const console = require('console');
const { setInterval } = require('timers/promises');

LavaPack.loadBundle([
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_getSymbolsIn.js", { "./_arrayPush": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayPush.js", "./_getPrototype": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_getPrototype.js", "./_getSymbols": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_getSymbols.js", "./stubArray": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\stubArray.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_getSymbolsIn.js
        return function (require, module, exports) {
          var arrayPush = require('./_arrayPush'),
            getPrototype = require('./_getPrototype'),
            getSymbols = require('./_getSymbols'),
            stubArray = require('./stubArray');

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeGetSymbols = Object.getOwnPropertySymbols;

          /**
           * Creates an array of the own and inherited enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
            var result = [];
            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }
            return result;
          };

          module.exports = getSymbolsIn;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_initCloneArray.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_initCloneArray.js
        return function (require, module, exports) {
          /** Used for built-in method references. */
          var objectProto = Object.prototype;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */
          function initCloneArray(array) {
            var length = array.length,
              result = new array.constructor(length);

            // Add properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }

          module.exports = initCloneArray;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_initCloneByTag.js", { "./_cloneArrayBuffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cloneArrayBuffer.js", "./_cloneDataView": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cloneDataView.js", "./_cloneRegExp": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cloneRegExp.js", "./_cloneSymbol": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cloneSymbol.js", "./_cloneTypedArray": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cloneTypedArray.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_initCloneByTag.js
        return function (require, module, exports) {
          var cloneArrayBuffer = require('./_cloneArrayBuffer'),
            cloneDataView = require('./_cloneDataView'),
            cloneRegExp = require('./_cloneRegExp'),
            cloneSymbol = require('./_cloneSymbol'),
            cloneTypedArray = require('./_cloneTypedArray');

          /** `Object#toString` result references. */
          var boolTag = '[object Boolean]',
            dateTag = '[object Date]',
            mapTag = '[object Map]',
            numberTag = '[object Number]',
            regexpTag = '[object RegExp]',
            setTag = '[object Set]',
            stringTag = '[object String]',
            symbolTag = '[object Symbol]';

          var arrayBufferTag = '[object ArrayBuffer]',
            dataViewTag = '[object DataView]',
            float32Tag = '[object Float32Array]',
            float64Tag = '[object Float64Array]',
            int8Tag = '[object Int8Array]',
            int16Tag = '[object Int16Array]',
            int32Tag = '[object Int32Array]',
            uint8Tag = '[object Uint8Array]',
            uint8ClampedTag = '[object Uint8ClampedArray]',
            uint16Tag = '[object Uint16Array]',
            uint32Tag = '[object Uint32Array]';

          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);

              case boolTag:
              case dateTag:
                return new Ctor(+object);

              case dataViewTag:
                return cloneDataView(object, isDeep);

              case float32Tag: case float64Tag:
              case int8Tag: case int16Tag: case int32Tag:
              case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
                return cloneTypedArray(object, isDeep);

              case mapTag:
                return new Ctor;

              case numberTag:
              case stringTag:
                return new Ctor(object);

              case regexpTag:
                return cloneRegExp(object);

              case setTag:
                return new Ctor;

              case symbolTag:
                return cloneSymbol(object);
            }
          }

          module.exports = initCloneByTag;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_initCloneObject.js", { "./_baseCreate": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseCreate.js", "./_getPrototype": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_getPrototype.js", "./_isPrototype": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_isPrototype.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_initCloneObject.js
        return function (require, module, exports) {
          var baseCreate = require('./_baseCreate'),
            getPrototype = require('./_getPrototype'),
            isPrototype = require('./_isPrototype');

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return (typeof object.constructor == 'function' && !isPrototype(object))
              ? baseCreate(getPrototype(object))
              : {};
          }

          module.exports = initCloneObject;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_nativeKeysIn.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_nativeKeysIn.js
        return function (require, module, exports) {
          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }

          module.exports = nativeKeysIn;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_trimmedEndIndex.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_trimmedEndIndex.js
        return function (require, module, exports) {
          /** Used to match a single whitespace character. */
          var reWhitespace = /\s/;

          /**
           * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
           * character of `string`.
           *
           * @private
           * @param {string} string The string to inspect.
           * @returns {number} Returns the index of the last non-whitespace character.
           */
          function trimmedEndIndex(string) {
            var index = string.length;

            while (index-- && reWhitespace.test(string.charAt(index))) { }
            return index;
          }

          module.exports = trimmedEndIndex;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\cloneDeep.js", { "./_baseClone": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseClone.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\cloneDeep.js
        return function (require, module, exports) {
          var baseClone = require('./_baseClone');

          /** Used to compose bitmasks for cloning. */
          var CLONE_DEEP_FLAG = 1,
            CLONE_SYMBOLS_FLAG = 4;

          /**
           * This method is like `_.clone` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @returns {*} Returns the deep cloned value.
           * @see _.clone
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var deep = _.cloneDeep(objects);
           * console.log(deep[0] === objects[0]);
           * // => false
           */
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }

          module.exports = cloneDeep;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\inRange.js", { "./_baseInRange": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseInRange.js", "./toFinite": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toFinite.js", "./toNumber": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toNumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\inRange.js
        return function (require, module, exports) {
          var baseInRange = require('./_baseInRange'),
            toFinite = require('./toFinite'),
            toNumber = require('./toNumber');

          /**
           * Checks if `n` is between `start` and up to, but not including, `end`. If
           * `end` is not specified, it's set to `start` with `start` then set to `0`.
           * If `start` is greater than `end` the params are swapped to support
           * negative ranges.
           *
           * @static
           * @memberOf _
           * @since 3.3.0
           * @category Number
           * @param {number} number The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           * @see _.range, _.rangeRight
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           *
           * _.inRange(-3, -2, -6);
           * // => true
           */
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }

          module.exports = inRange;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isEmpty.js", { "./_baseKeys": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseKeys.js", "./_getTag": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_getTag.js", "./_isPrototype": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_isPrototype.js", "./isArguments": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArguments.js", "./isArray": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArray.js", "./isArrayLike": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLike.js", "./isBuffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isBuffer.js", "./isTypedArray": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isTypedArray.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isEmpty.js
        return function (require, module, exports) {
          var baseKeys = require('./_baseKeys'),
            getTag = require('./_getTag'),
            isArguments = require('./isArguments'),
            isArray = require('./isArray'),
            isArrayLike = require('./isArrayLike'),
            isBuffer = require('./isBuffer'),
            isPrototype = require('./_isPrototype'),
            isTypedArray = require('./isTypedArray');

          /** `Object#toString` result references. */
          var mapTag = '[object Map]',
            setTag = '[object Set]';

          /** Used for built-in method references. */
          var objectProto = Object.prototype;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /**
           * Checks if `value` is an empty object, collection, map, or set.
           *
           * Objects are considered empty if they have no own enumerable string keyed
           * properties.
           *
           * Array-like values such as `arguments` objects, arrays, buffers, strings, or
           * jQuery-like collections are considered empty if they have a `length` of `0`.
           * Similarly, maps and sets are considered empty if they have a `size` of `0`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) &&
              (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }

          module.exports = isEmpty;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isInteger.js", { "./toInteger": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toInteger.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isInteger.js
        return function (require, module, exports) {
          var toInteger = require('./toInteger');

          /**
           * Checks if `value` is an integer.
           *
           * **Note:** This method is based on
           * [`Number.isInteger`](https://mdn.io/Number/isInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
           * @example
           *
           * _.isInteger(3);
           * // => true
           *
           * _.isInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isInteger(Infinity);
           * // => false
           *
           * _.isInteger('3');
           * // => false
           */
          function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value);
          }

          module.exports = isInteger;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isMap.js", { "./_baseIsMap": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIsMap.js", "./_baseUnary": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUnary.js", "./_nodeUtil": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_nodeUtil.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isMap.js
        return function (require, module, exports) {
          var baseIsMap = require('./_baseIsMap'),
            baseUnary = require('./_baseUnary'),
            nodeUtil = require('./_nodeUtil');

          /* Node.js helper references. */
          var nodeIsMap = nodeUtil && nodeUtil.isMap;

          /**
           * Checks if `value` is classified as a `Map` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           * @example
           *
           * _.isMap(new Map);
           * // => true
           *
           * _.isMap(new WeakMap);
           * // => false
           */
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

          module.exports = isMap;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isSet.js", { "./_baseIsSet": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIsSet.js", "./_baseUnary": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUnary.js", "./_nodeUtil": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_nodeUtil.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isSet.js
        return function (require, module, exports) {
          var baseIsSet = require('./_baseIsSet'),
            baseUnary = require('./_baseUnary'),
            nodeUtil = require('./_nodeUtil');

          /* Node.js helper references. */
          var nodeIsSet = nodeUtil && nodeUtil.isSet;

          /**
           * Checks if `value` is classified as a `Set` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           * @example
           *
           * _.isSet(new Set);
           * // => true
           *
           * _.isSet(new WeakSet);
           * // => false
           */
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

          module.exports = isSet;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\keysIn.js", { "./_arrayLikeKeys": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayLikeKeys.js", "./_baseKeysIn": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseKeysIn.js", "./isArrayLike": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLike.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\keysIn.js
        return function (require, module, exports) {
          var arrayLikeKeys = require('./_arrayLikeKeys'),
            baseKeysIn = require('./_baseKeysIn'),
            isArrayLike = require('./isArrayLike');

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }

          module.exports = keysIn;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toFinite.js", { "./toNumber": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toNumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\toFinite.js
        return function (require, module, exports) {
          var toNumber = require('./toNumber');

          /** Used as references for various `Number` constants. */
          var INFINITY = 1 / 0,
            MAX_INTEGER = 1.7976931348623157e+308;

          /**
           * Converts `value` to a finite number.
           *
           * @static
           * @memberOf _
           * @since 4.12.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted number.
           * @example
           *
           * _.toFinite(3.2);
           * // => 3.2
           *
           * _.toFinite(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toFinite(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toFinite('3.2');
           * // => 3.2
           */
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = (value < 0 ? -1 : 1);
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }

          module.exports = toFinite;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toInteger.js", { "./toFinite": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toFinite.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\toInteger.js
        return function (require, module, exports) {
          var toFinite = require('./toFinite');

          /**
           * Converts `value` to an integer.
           *
           * **Note:** This method is loosely based on
           * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toInteger(3.2);
           * // => 3
           *
           * _.toInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toInteger(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toInteger('3.2');
           * // => 3
           */
          function toInteger(value) {
            var result = toFinite(value),
              remainder = result % 1;

            return result === result ? (remainder ? result - remainder : result) : 0;
          }

          module.exports = toInteger;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\toNumber.js", { "./_baseTrim": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseTrim.js", "./isObject": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isObject.js", "./isSymbol": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isSymbol.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\toNumber.js
        return function (require, module, exports) {
          var baseTrim = require('./_baseTrim'),
            isObject = require('./isObject'),
            isSymbol = require('./isSymbol');

          /** Used as references for various `Number` constants. */
          var NAN = 0 / 0;

          /** Used to detect bad signed hexadecimal string values. */
          var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

          /** Used to detect binary string values. */
          var reIsBinary = /^0b[01]+$/i;

          /** Used to detect octal string values. */
          var reIsOctal = /^0o[0-7]+$/i;

          /** Built-in method references without a dependency on `root`. */
          var freeParseInt = parseInt;

          /**
           * Converts `value` to a number.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           * @example
           *
           * _.toNumber(3.2);
           * // => 3.2
           *
           * _.toNumber(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toNumber(Infinity);
           * // => Infinity
           *
           * _.toNumber('3.2');
           * // => 3.2
           */
          function toNumber(value) {
            if (typeof value == 'number') {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
              value = isObject(other) ? (other + '') : other;
            }
            if (typeof value != 'string') {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return (isBinary || reIsOctal.test(value))
              ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
              : (reIsBadHex.test(value) ? NAN : +value);
          }

          module.exports = toNumber;

        };
      };
    }
  }, { package: "lodash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\base.js", { "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multibase\src\base.js
        return function (require, module, exports) {
          'use strict'

          const { encodeText } = require('./util')

          /** @typedef {__import__('./types').CodecFactory} CodecFactory */
          /** @typedef {__import__("./types").BaseName} BaseName */
          /** @typedef {__import__("./types").BaseCode} BaseCode */

          /**
           * Class to encode/decode in the supported Bases
           *
           */
          class Base {
            /**
             * @param {BaseName} name
             * @param {BaseCode} code
             * @param {CodecFactory} factory
             * @param {string} alphabet
             */
            constructor(name, code, factory, alphabet) {
              this.name = name
              this.code = code
              this.codeBuf = encodeText(this.code)
              this.alphabet = alphabet
              this.codec = factory(alphabet)
            }

            /**
             * @param {Uint8Array} buf
             * @returns {string}
             */
            encode(buf) {
              return this.codec.encode(buf)
            }

            /**
             * @param {string} string
             * @returns {Uint8Array}
             */
            decode(string) {
              for (const char of string) {
                if (this.alphabet && this.alphabet.indexOf(char) < 0) {
                  throw new Error(`invalid character '${char}' in '${string}'`)
                }
              }
              return this.codec.decode(string)
            }
          }

          module.exports = Base

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\constants.js", { "./base.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\base.js", "./rfc4648": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\rfc4648.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\util.js", "@multiformats/base-x": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@multiformats\\base-x\\src\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multibase\src\constants.js
        return function (require, module, exports) {
          'use strict'

          const baseX = require('@multiformats/base-x')
          const Base = require('./base.js')
          const { rfc4648 } = require('./rfc4648')
          const { decodeText, encodeText } = require('./util')

          /** @typedef {__import__('./types').CodecFactory} CodecFactory */
          /** @typedef {__import__('./types').Codec} Codec */
          /** @typedef {__import__('./types').BaseName} BaseName */
          /** @typedef {__import__('./types').BaseCode} BaseCode */

          /** @type {CodecFactory} */
          const identity = () => {
            return {
              encode: decodeText,
              decode: encodeText
            }
          }

          /**
           *
           * name, code, implementation, alphabet
           *
           * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
           */
          const constants = [
            ['identity', '\x00', identity, ''],
            ['base2', '0', rfc4648(1), '01'],
            ['base8', '7', rfc4648(3), '01234567'],
            ['base10', '9', baseX, '0123456789'],
            ['base16', 'f', rfc4648(4), '0123456789abcdef'],
            ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
            ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
            ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
            ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
            ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
            ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
            ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
            ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
            ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
            ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
            ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
            ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
            ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
            ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
            ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
            ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
            ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
            ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
          ]

          /** @type {Record<BaseName,Base>} */
          const names = constants.reduce((prev, tupple) => {
            prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
            return prev
          }, /** @type {Record<BaseName,Base>} */({}))

          /** @type {Record<BaseCode,Base>} */
          const codes = constants.reduce((prev, tupple) => {
            prev[tupple[1]] = names[tupple[0]]
            return prev
          }, /** @type {Record<BaseCode,Base>} */({}))

          module.exports = {
            names,
            codes
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\index.js", { "./constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\constants.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multibase\src\index.js
        return function (require, module, exports) {
          /**
           * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
           *
           */
          'use strict'

          const constants = require('./constants')
          const { encodeText, decodeText, concat } = require('./util')

          /** @typedef {__import__('./base')} Base */
          /** @typedef {__import__("./types").BaseNameOrCode} BaseNameOrCode */
          /** @typedef {__import__("./types").BaseCode} BaseCode */
          /** @typedef {__import__("./types").BaseName} BaseName */

          /**
           * Create a new Uint8Array with the multibase varint+code.
           *
           * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
           * @param {Uint8Array} buf - The data to be prefixed with multibase.
           * @returns {Uint8Array}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function multibase(nameOrCode, buf) {
            if (!buf) {
              throw new Error('requires an encoded Uint8Array')
            }
            const { name, codeBuf } = encoding(nameOrCode)
            validEncode(name, buf)

            return concat([codeBuf, buf], codeBuf.length + buf.length)
          }

          /**
           * Encode data with the specified base and add the multibase prefix.
           *
           * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
           * @param {Uint8Array} buf - The data to be encoded.
           * @returns {Uint8Array}
           * @throws {Error} Will throw if the encoding is not supported
           *
           */
          function encode(nameOrCode, buf) {
            const enc = encoding(nameOrCode)
            const data = encodeText(enc.encode(buf))

            return concat([enc.codeBuf, data], enc.codeBuf.length + data.length)
          }

          /**
           * Takes a Uint8Array or string encoded with multibase header, decodes it and
           * returns the decoded buffer
           *
           * @param {Uint8Array|string} data
           * @returns {Uint8Array}
           * @throws {Error} Will throw if the encoding is not supported
           *
           */
          function decode(data) {
            if (data instanceof Uint8Array) {
              data = decodeText(data)
            }
            const prefix = data[0]

            // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
            if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
              data = data.toLowerCase()
            }
            const enc = encoding(/** @type {BaseCode} */(data[0]))
            return enc.decode(data.substring(1))
          }

          /**
           * Is the given data multibase encoded?
           *
           * @param {Uint8Array|string} data
           */
          function isEncoded(data) {
            if (data instanceof Uint8Array) {
              data = decodeText(data)
            }

            // Ensure bufOrString is a string
            if (Object.prototype.toString.call(data) !== '[object String]') {
              return false
            }

            try {
              const enc = encoding(/** @type {BaseCode} */(data[0]))
              return enc.name
            } catch (err) {
              return false
            }
          }

          /**
           * Validate encoded data
           *
           * @param {BaseNameOrCode} name
           * @param {Uint8Array} buf
           * @returns {void}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function validEncode(name, buf) {
            const enc = encoding(name)
            enc.decode(decodeText(buf))
          }

          /**
           * Get the encoding by name or code
           *
           * @param {BaseNameOrCode} nameOrCode
           * @returns {Base}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function encoding(nameOrCode) {
            if (Object.prototype.hasOwnProperty.call(constants.names, /** @type {BaseName} */(nameOrCode))) {
              return constants.names[/** @type {BaseName} */(nameOrCode)]
            } else if (Object.prototype.hasOwnProperty.call(constants.codes, /** @type {BaseCode} */(nameOrCode))) {
              return constants.codes[/** @type {BaseCode} */(nameOrCode)]
            } else {
              throw new Error(`Unsupported encoding: ${nameOrCode}`)
            }
          }

          /**
           * Get encoding from data
           *
           * @param {string|Uint8Array} data
           * @returns {Base}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function encodingFromData(data) {
            if (data instanceof Uint8Array) {
              data = decodeText(data)
            }

            return encoding(/** @type {BaseCode} */(data[0]))
          }

          exports = module.exports = multibase
          exports.encode = encode
          exports.decode = decode
          exports.isEncoded = isEncoded
          exports.encoding = encoding
          exports.encodingFromData = encodingFromData
          const names = Object.freeze(constants.names)
          const codes = Object.freeze(constants.codes)
          exports.names = names
          exports.codes = codes

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\rfc4648.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multibase\src\rfc4648.js
        return function (require, module, exports) {
          'use strict'

          /** @typedef {__import__('./types').CodecFactory} CodecFactory */

          /**
           * @param {string} string
           * @param {string} alphabet
           * @param {number} bitsPerChar
           * @returns {Uint8Array}
           */
          const decode = (string, alphabet, bitsPerChar) => {
            // Build the character lookup table:
            /** @type {Record<string, number>} */
            const codes = {}
            for (let i = 0; i < alphabet.length; ++i) {
              codes[alphabet[i]] = i
            }

            // Count the padding bytes:
            let end = string.length
            while (string[end - 1] === '=') {
              --end
            }

            // Allocate the output:
            const out = new Uint8Array((end * bitsPerChar / 8) | 0)

            // Parse the data:
            let bits = 0 // Number of bits currently in the buffer
            let buffer = 0 // Bits waiting to be written out, MSB first
            let written = 0 // Next byte to write
            for (let i = 0; i < end; ++i) {
              // Read one character from the string:
              const value = codes[string[i]]
              if (value === undefined) {
                throw new SyntaxError('Invalid character ' + string[i])
              }

              // Append the bits to the buffer:
              buffer = (buffer << bitsPerChar) | value
              bits += bitsPerChar

              // Write out some bits if the buffer has a byte's worth:
              if (bits >= 8) {
                bits -= 8
                out[written++] = 0xff & (buffer >> bits)
              }
            }

            // Verify that we have received just enough bits:
            if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
              throw new SyntaxError('Unexpected end of data')
            }

            return out
          }

          /**
           * @param {Uint8Array} data
           * @param {string} alphabet
           * @param {number} bitsPerChar
           * @returns {string}
           */
          const encode = (data, alphabet, bitsPerChar) => {
            const pad = alphabet[alphabet.length - 1] === '='
            const mask = (1 << bitsPerChar) - 1
            let out = ''

            let bits = 0 // Number of bits currently in the buffer
            let buffer = 0 // Bits waiting to be written out, MSB first
            for (let i = 0; i < data.length; ++i) {
              // Slurp data into the buffer:
              buffer = (buffer << 8) | data[i]
              bits += 8

              // Write out as much as we can:
              while (bits > bitsPerChar) {
                bits -= bitsPerChar
                out += alphabet[mask & (buffer >> bits)]
              }
            }

            // Partial character:
            if (bits) {
              out += alphabet[mask & (buffer << (bitsPerChar - bits))]
            }

            // Add padding characters until we hit a byte boundary:
            if (pad) {
              while ((out.length * bitsPerChar) & 7) {
                out += '='
              }
            }

            return out
          }

          /**
           * RFC4648 Factory
           *
           * @param {number} bitsPerChar
           * @returns {CodecFactory}
           */
          const rfc4648 = (bitsPerChar) => (alphabet) => {
            return {
              /**
               * @param {Uint8Array} input
               * @returns {string}
               */
              encode(input) {
                return encode(input, alphabet, bitsPerChar)
              },
              /**
               * @param {string} input
               * @returns {Uint8Array}
               */
              decode(input) {
                return decode(input, alphabet, bitsPerChar)
              }
            }
          }

          module.exports = { rfc4648 }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\util.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multibase\src\util.js
        return function (require, module, exports) {
          'use strict'

          const textDecoder = new TextDecoder()
          /**
           * @param {ArrayBufferView|ArrayBuffer} bytes
           * @returns {string}
           */
          const decodeText = (bytes) => textDecoder.decode(bytes)

          const textEncoder = new TextEncoder()
          /**
           * @param {string} text
           * @returns {Uint8Array}
           */
          const encodeText = (text) => textEncoder.encode(text)

          /**
           * Returns a new Uint8Array created by concatenating the passed Arrays
           *
           * @param {Array<ArrayLike<number>>} arrs
           * @param {number} length
           * @returns {Uint8Array}
           */
          function concat(arrs, length) {
            const output = new Uint8Array(length)
            let offset = 0

            for (const arr of arrs) {
              output.set(arr, offset)
              offset += arr.length
            }

            return output
          }

          module.exports = { decodeText, encodeText, concat }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\base.js", { "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\multibase\src\base.js
        return function (require, module, exports) {
          'use strict'

          const { encodeText } = require('./util')

          /** @typedef {__import__('./types').CodecFactory} CodecFactory */
          /** @typedef {__import__("./types").BaseName} BaseName */
          /** @typedef {__import__("./types").BaseCode} BaseCode */

          /**
           * Class to encode/decode in the supported Bases
           *
           */
          class Base {
            /**
             * @param {BaseName} name
             * @param {BaseCode} code
             * @param {CodecFactory} factory
             * @param {string} alphabet
             */
            constructor(name, code, factory, alphabet) {
              this.name = name
              this.code = code
              this.codeBuf = encodeText(this.code)
              this.alphabet = alphabet
              this.codec = factory(alphabet)
            }

            /**
             * @param {Uint8Array} buf
             * @returns {string}
             */
            encode(buf) {
              return this.codec.encode(buf)
            }

            /**
             * @param {string} string
             * @returns {Uint8Array}
             */
            decode(string) {
              for (const char of string) {
                if (this.alphabet && this.alphabet.indexOf(char) < 0) {
                  throw new Error(`invalid character '${char}' in '${string}'`)
                }
              }
              return this.codec.decode(string)
            }
          }

          module.exports = Base

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\constants.js", { "./base.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\base.js", "./rfc4648": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\rfc4648.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\util.js", "@multiformats/base-x": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@multiformats\\base-x\\src\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\multibase\src\constants.js
        return function (require, module, exports) {
          'use strict'

          const baseX = require('@multiformats/base-x')
          const Base = require('./base.js')
          const { rfc4648 } = require('./rfc4648')
          const { decodeText, encodeText } = require('./util')

          /** @typedef {__import__('./types').CodecFactory} CodecFactory */
          /** @typedef {__import__('./types').Codec} Codec */
          /** @typedef {__import__('./types').BaseName} BaseName */
          /** @typedef {__import__('./types').BaseCode} BaseCode */

          /** @type {CodecFactory} */
          const identity = () => {
            return {
              encode: decodeText,
              decode: encodeText
            }
          }

          /**
           *
           * name, code, implementation, alphabet
           *
           * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
           */
          const constants = [
            ['identity', '\x00', identity, ''],
            ['base2', '0', rfc4648(1), '01'],
            ['base8', '7', rfc4648(3), '01234567'],
            ['base10', '9', baseX, '0123456789'],
            ['base16', 'f', rfc4648(4), '0123456789abcdef'],
            ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
            ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
            ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
            ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
            ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
            ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
            ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
            ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
            ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
            ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
            ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
            ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
            ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
            ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
            ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
            ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
            ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
            ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
          ]

          /** @type {Record<BaseName,Base>} */
          const names = constants.reduce((prev, tupple) => {
            prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
            return prev
          }, /** @type {Record<BaseName,Base>} */({}))

          /** @type {Record<BaseCode,Base>} */
          const codes = constants.reduce((prev, tupple) => {
            prev[tupple[1]] = names[tupple[0]]
            return prev
          }, /** @type {Record<BaseCode,Base>} */({}))

          module.exports = {
            names,
            codes
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\rfc4648.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\multibase\src\rfc4648.js
        return function (require, module, exports) {
          'use strict'

          /** @typedef {__import__('./types').CodecFactory} CodecFactory */

          /**
           * @param {string} string
           * @param {string} alphabet
           * @param {number} bitsPerChar
           * @returns {Uint8Array}
           */
          const decode = (string, alphabet, bitsPerChar) => {
            // Build the character lookup table:
            /** @type {Record<string, number>} */
            const codes = {}
            for (let i = 0; i < alphabet.length; ++i) {
              codes[alphabet[i]] = i
            }

            // Count the padding bytes:
            let end = string.length
            while (string[end - 1] === '=') {
              --end
            }

            // Allocate the output:
            const out = new Uint8Array((end * bitsPerChar / 8) | 0)

            // Parse the data:
            let bits = 0 // Number of bits currently in the buffer
            let buffer = 0 // Bits waiting to be written out, MSB first
            let written = 0 // Next byte to write
            for (let i = 0; i < end; ++i) {
              // Read one character from the string:
              const value = codes[string[i]]
              if (value === undefined) {
                throw new SyntaxError('Invalid character ' + string[i])
              }

              // Append the bits to the buffer:
              buffer = (buffer << bitsPerChar) | value
              bits += bitsPerChar

              // Write out some bits if the buffer has a byte's worth:
              if (bits >= 8) {
                bits -= 8
                out[written++] = 0xff & (buffer >> bits)
              }
            }

            // Verify that we have received just enough bits:
            if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
              throw new SyntaxError('Unexpected end of data')
            }

            return out
          }

          /**
           * @param {Uint8Array} data
           * @param {string} alphabet
           * @param {number} bitsPerChar
           * @returns {string}
           */
          const encode = (data, alphabet, bitsPerChar) => {
            const pad = alphabet[alphabet.length - 1] === '='
            const mask = (1 << bitsPerChar) - 1
            let out = ''

            let bits = 0 // Number of bits currently in the buffer
            let buffer = 0 // Bits waiting to be written out, MSB first
            for (let i = 0; i < data.length; ++i) {
              // Slurp data into the buffer:
              buffer = (buffer << 8) | data[i]
              bits += 8

              // Write out as much as we can:
              while (bits > bitsPerChar) {
                bits -= bitsPerChar
                out += alphabet[mask & (buffer >> bits)]
              }
            }

            // Partial character:
            if (bits) {
              out += alphabet[mask & (buffer << (bitsPerChar - bits))]
            }

            // Add padding characters until we hit a byte boundary:
            if (pad) {
              while ((out.length * bitsPerChar) & 7) {
                out += '='
              }
            }

            return out
          }

          /**
           * RFC4648 Factory
           *
           * @param {number} bitsPerChar
           * @returns {CodecFactory}
           */
          const rfc4648 = (bitsPerChar) => (alphabet) => {
            return {
              /**
               * @param {Uint8Array} input
               * @returns {string}
               */
              encode(input) {
                return encode(input, alphabet, bitsPerChar)
              },
              /**
               * @param {string} input
               * @returns {Uint8Array}
               */
              decode(input) {
                return decode(input, alphabet, bitsPerChar)
              }
            }
          }

          module.exports = { rfc4648 }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\util.js", { "web-encoding": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\multibase\src\util.js
        return function (require, module, exports) {
          'use strict'

          // @ts-ignore
          const { TextEncoder, TextDecoder } = require('web-encoding')

          const textDecoder = new TextDecoder()
          /**
           * @param {ArrayBufferView|ArrayBuffer} bytes
           * @returns {string}
           */
          const decodeText = (bytes) => textDecoder.decode(bytes)

          const textEncoder = new TextEncoder()
          /**
           * @param {string} text
           * @returns {Uint8Array}
           */
          const encodeText = (text) => textEncoder.encode(text)

          /**
           * Returns a new Uint8Array created by concatenating the passed Arrays
           *
           * @param {Array<ArrayLike<number>>} arrs
           * @param {number} length
           * @returns {Uint8Array}
           */
          function concat(arrs, length) {
            const output = new Uint8Array(length)
            let offset = 0

            for (const arr of arrs) {
              output.set(arr, offset)
              offset += arr.length
            }

            return output
          }

          module.exports = { decodeText, encodeText, concat }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\uint8arrays\\concat.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\uint8arrays\concat.js
        return function (require, module, exports) {
          'use strict'

          /**
           * Returns a new Uint8Array created by concatenating the passed ArrayLikes
           *
           * @param {Array<ArrayLike<number>>} arrays
           * @param {Number} length
           * @returns {Uint8Array}
           */
          function concat(arrays, length) {
            if (!length) {
              length = arrays.reduce((acc, curr) => acc + curr.length, 0)
            }

            const output = new Uint8Array(length)
            let offset = 0

            for (const arr of arrays) {
              output.set(arr, offset)
              offset += arr.length
            }

            return output
          }

          module.exports = concat

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\uint8arrays\\from-string.js", { "multibase/src/constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\constants.js", "web-encoding": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\uint8arrays\from-string.js
        return function (require, module, exports) {
          'use strict'

          const { names } = require('multibase/src/constants')
          const { TextEncoder } = require('web-encoding')
          const utf8Encoder = new TextEncoder()

          /**
           * Interperets each character in a string as a byte and
           * returns a Uint8Array of those bytes.
           *
           * @param {String} string The string to turn into an array
           * @returns {Uint8Array}
           */
          function asciiStringToUint8Array(string) {
            const array = new Uint8Array(string.length)

            for (let i = 0; i < string.length; i++) {
              array[i] = string.charCodeAt(i)
            }

            return array
          }

          /**
           * Create a `Uint8Array` from the passed string
           *
           * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
           *
           * Also `ascii` which is similar to node's 'binary' encoding.
           *
           * @param {String} string
           * @param {String} [encoding=utf8] utf8, base16, base64, base64urlpad, etc
           * @returns {Uint8Array}
           * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
           */
          function fromString(string, encoding = 'utf8') {
            if (encoding === 'utf8' || encoding === 'utf-8') {
              return utf8Encoder.encode(string)
            }

            if (encoding === 'ascii') {
              return asciiStringToUint8Array(string)
            }

            const codec = names[encoding]

            if (!codec) {
              throw new Error('Unknown base')
            }

            return codec.decode(string)
          }

          module.exports = fromString

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\uint8arrays\\to-string.js", { "multibase/src/constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\multibase\\src\\constants.js", "web-encoding": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\uint8arrays\to-string.js
        return function (require, module, exports) {
          'use strict'

          const { names } = require('multibase/src/constants')
          const { TextDecoder } = require('web-encoding')
          const utf8Decoder = new TextDecoder('utf8')

          /**
           * Turns a Uint8Array of bytes into a string with each
           * character being the char code of the corresponding byte
           *
           * @param {Uint8Array} array The array to turn into a string
           * @returns {String}
           */
          function uint8ArrayToAsciiString(array) {
            let string = ''

            for (let i = 0; i < array.length; i++) {
              string += String.fromCharCode(array[i])
            }
            return string
          }

          /**
           * Turns a `Uint8Array` into a string.
           *
           * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
           *
           * Also `ascii` which is similar to node's 'binary' encoding.
           *
           * @param {Uint8Array} array The array to turn into a string
           * @param {String} [encoding=utf8] The encoding to use
           * @returns {String}
           * @see {@link https://www.npmjs.com/package/multibase|multibase} for supported encodings other than `utf8`
           */
          function toString(array, encoding = 'utf8') {
            if (encoding === 'utf8' || encoding === 'utf-8') {
              return utf8Decoder.decode(array)
            }

            if (encoding === 'ascii') {
              return uint8ArrayToAsciiString(array)
            }

            const codec = names[encoding]

            if (!codec) {
              throw new Error('Unknown base')
            }

            return codec.encode(array)
          }

          module.exports = toString

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\decode.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\varint\decode.js
        return function (require, module, exports) {
          module.exports = read

          var MSB = 0x80
            , REST = 0x7F

          function read(buf, offset) {
            var res = 0
              , offset = offset || 0
              , shift = 0
              , counter = offset
              , b
              , l = buf.length

            do {
              if (counter >= l || shift > 49) {
                read.bytes = 0
                throw new RangeError('Could not decode varint')
              }
              b = buf[counter++]
              res += shift < 28
                ? (b & REST) << shift
                : (b & REST) * Math.pow(2, shift)
              shift += 7
            } while (b >= MSB)

            read.bytes = counter - offset

            return res
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\encode.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\varint\encode.js
        return function (require, module, exports) {
          module.exports = encode

          var MSB = 0x80
            , REST = 0x7F
            , MSBALL = ~REST
            , INT = Math.pow(2, 31)

          function encode(num, out, offset) {
            if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
              encode.bytes = 0
              throw new RangeError('Could not encode varint')
            }
            out = out || []
            offset = offset || 0
            var oldOffset = offset

            while (num >= INT) {
              out[offset++] = (num & 0xFF) | MSB
              num /= 128
            }
            while (num & MSBALL) {
              out[offset++] = (num & 0xFF) | MSB
              num >>>= 7
            }
            out[offset] = num | 0

            encode.bytes = offset - oldOffset + 1

            return out
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\index.js", { "./decode.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\decode.js", "./encode.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\encode.js", "./length.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\length.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\varint\index.js
        return function (require, module, exports) {
          module.exports = {
            encode: require('./encode.js')
            , decode: require('./decode.js')
            , encodingLength: require('./length.js')
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\length.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\node_modules\varint\length.js
        return function (require, module, exports) {

          var N1 = Math.pow(2, 7)
          var N2 = Math.pow(2, 14)
          var N3 = Math.pow(2, 21)
          var N4 = Math.pow(2, 28)
          var N5 = Math.pow(2, 35)
          var N6 = Math.pow(2, 42)
          var N7 = Math.pow(2, 49)
          var N8 = Math.pow(2, 56)
          var N9 = Math.pow(2, 63)

          module.exports = function (value) {
            return (
              value < N1 ? 1
                : value < N2 ? 2
                  : value < N3 ? 3
                    : value < N4 ? 4
                      : value < N5 ? 5
                        : value < N6 ? 6
                          : value < N7 ? 7
                            : value < N8 ? 8
                              : value < N9 ? 9
                                : 10
            )
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\base-table.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\base-table.js
        return function (require, module, exports) {
          // DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
          /* eslint quote-props: off */
          'use strict'

          /**
           * @type {__import__('./generated-types').NameNumberMap}
           */
          const baseTable = Object.freeze({
            'identity': 0x00,
            'cidv1': 0x01,
            'cidv2': 0x02,
            'cidv3': 0x03,
            'ip4': 0x04,
            'tcp': 0x06,
            'sha1': 0x11,
            'sha2-256': 0x12,
            'sha2-512': 0x13,
            'sha3-512': 0x14,
            'sha3-384': 0x15,
            'sha3-256': 0x16,
            'sha3-224': 0x17,
            'shake-128': 0x18,
            'shake-256': 0x19,
            'keccak-224': 0x1a,
            'keccak-256': 0x1b,
            'keccak-384': 0x1c,
            'keccak-512': 0x1d,
            'blake3': 0x1e,
            'dccp': 0x21,
            'murmur3-128': 0x22,
            'murmur3-32': 0x23,
            'ip6': 0x29,
            'ip6zone': 0x2a,
            'path': 0x2f,
            'multicodec': 0x30,
            'multihash': 0x31,
            'multiaddr': 0x32,
            'multibase': 0x33,
            'dns': 0x35,
            'dns4': 0x36,
            'dns6': 0x37,
            'dnsaddr': 0x38,
            'protobuf': 0x50,
            'cbor': 0x51,
            'raw': 0x55,
            'dbl-sha2-256': 0x56,
            'rlp': 0x60,
            'bencode': 0x63,
            'dag-pb': 0x70,
            'dag-cbor': 0x71,
            'libp2p-key': 0x72,
            'git-raw': 0x78,
            'torrent-info': 0x7b,
            'torrent-file': 0x7c,
            'leofcoin-block': 0x81,
            'leofcoin-tx': 0x82,
            'leofcoin-pr': 0x83,
            'sctp': 0x84,
            'dag-jose': 0x85,
            'dag-cose': 0x86,
            'eth-block': 0x90,
            'eth-block-list': 0x91,
            'eth-tx-trie': 0x92,
            'eth-tx': 0x93,
            'eth-tx-receipt-trie': 0x94,
            'eth-tx-receipt': 0x95,
            'eth-state-trie': 0x96,
            'eth-account-snapshot': 0x97,
            'eth-storage-trie': 0x98,
            'bitcoin-block': 0xb0,
            'bitcoin-tx': 0xb1,
            'bitcoin-witness-commitment': 0xb2,
            'zcash-block': 0xc0,
            'zcash-tx': 0xc1,
            'docid': 0xce,
            'stellar-block': 0xd0,
            'stellar-tx': 0xd1,
            'md4': 0xd4,
            'md5': 0xd5,
            'bmt': 0xd6,
            'decred-block': 0xe0,
            'decred-tx': 0xe1,
            'ipld-ns': 0xe2,
            'ipfs-ns': 0xe3,
            'swarm-ns': 0xe4,
            'ipns-ns': 0xe5,
            'zeronet': 0xe6,
            'secp256k1-pub': 0xe7,
            'bls12_381-g1-pub': 0xea,
            'bls12_381-g2-pub': 0xeb,
            'x25519-pub': 0xec,
            'ed25519-pub': 0xed,
            'bls12_381-g1g2-pub': 0xee,
            'dash-block': 0xf0,
            'dash-tx': 0xf1,
            'swarm-manifest': 0xfa,
            'swarm-feed': 0xfb,
            'udp': 0x0111,
            'p2p-webrtc-star': 0x0113,
            'p2p-webrtc-direct': 0x0114,
            'p2p-stardust': 0x0115,
            'p2p-circuit': 0x0122,
            'dag-json': 0x0129,
            'udt': 0x012d,
            'utp': 0x012e,
            'unix': 0x0190,
            'p2p': 0x01a5,
            'ipfs': 0x01a5,
            'https': 0x01bb,
            'onion': 0x01bc,
            'onion3': 0x01bd,
            'garlic64': 0x01be,
            'garlic32': 0x01bf,
            'tls': 0x01c0,
            'quic': 0x01cc,
            'ws': 0x01dd,
            'wss': 0x01de,
            'p2p-websocket-star': 0x01df,
            'http': 0x01e0,
            'json': 0x0200,
            'messagepack': 0x0201,
            'libp2p-peer-record': 0x0301,
            'sha2-256-trunc254-padded': 0x1012,
            'ripemd-128': 0x1052,
            'ripemd-160': 0x1053,
            'ripemd-256': 0x1054,
            'ripemd-320': 0x1055,
            'x11': 0x1100,
            'p256-pub': 0x1200,
            'p384-pub': 0x1201,
            'p521-pub': 0x1202,
            'ed448-pub': 0x1203,
            'x448-pub': 0x1204,
            'ed25519-priv': 0x1300,
            'kangarootwelve': 0x1d01,
            'sm3-256': 0x534d,
            'blake2b-8': 0xb201,
            'blake2b-16': 0xb202,
            'blake2b-24': 0xb203,
            'blake2b-32': 0xb204,
            'blake2b-40': 0xb205,
            'blake2b-48': 0xb206,
            'blake2b-56': 0xb207,
            'blake2b-64': 0xb208,
            'blake2b-72': 0xb209,
            'blake2b-80': 0xb20a,
            'blake2b-88': 0xb20b,
            'blake2b-96': 0xb20c,
            'blake2b-104': 0xb20d,
            'blake2b-112': 0xb20e,
            'blake2b-120': 0xb20f,
            'blake2b-128': 0xb210,
            'blake2b-136': 0xb211,
            'blake2b-144': 0xb212,
            'blake2b-152': 0xb213,
            'blake2b-160': 0xb214,
            'blake2b-168': 0xb215,
            'blake2b-176': 0xb216,
            'blake2b-184': 0xb217,
            'blake2b-192': 0xb218,
            'blake2b-200': 0xb219,
            'blake2b-208': 0xb21a,
            'blake2b-216': 0xb21b,
            'blake2b-224': 0xb21c,
            'blake2b-232': 0xb21d,
            'blake2b-240': 0xb21e,
            'blake2b-248': 0xb21f,
            'blake2b-256': 0xb220,
            'blake2b-264': 0xb221,
            'blake2b-272': 0xb222,
            'blake2b-280': 0xb223,
            'blake2b-288': 0xb224,
            'blake2b-296': 0xb225,
            'blake2b-304': 0xb226,
            'blake2b-312': 0xb227,
            'blake2b-320': 0xb228,
            'blake2b-328': 0xb229,
            'blake2b-336': 0xb22a,
            'blake2b-344': 0xb22b,
            'blake2b-352': 0xb22c,
            'blake2b-360': 0xb22d,
            'blake2b-368': 0xb22e,
            'blake2b-376': 0xb22f,
            'blake2b-384': 0xb230,
            'blake2b-392': 0xb231,
            'blake2b-400': 0xb232,
            'blake2b-408': 0xb233,
            'blake2b-416': 0xb234,
            'blake2b-424': 0xb235,
            'blake2b-432': 0xb236,
            'blake2b-440': 0xb237,
            'blake2b-448': 0xb238,
            'blake2b-456': 0xb239,
            'blake2b-464': 0xb23a,
            'blake2b-472': 0xb23b,
            'blake2b-480': 0xb23c,
            'blake2b-488': 0xb23d,
            'blake2b-496': 0xb23e,
            'blake2b-504': 0xb23f,
            'blake2b-512': 0xb240,
            'blake2s-8': 0xb241,
            'blake2s-16': 0xb242,
            'blake2s-24': 0xb243,
            'blake2s-32': 0xb244,
            'blake2s-40': 0xb245,
            'blake2s-48': 0xb246,
            'blake2s-56': 0xb247,
            'blake2s-64': 0xb248,
            'blake2s-72': 0xb249,
            'blake2s-80': 0xb24a,
            'blake2s-88': 0xb24b,
            'blake2s-96': 0xb24c,
            'blake2s-104': 0xb24d,
            'blake2s-112': 0xb24e,
            'blake2s-120': 0xb24f,
            'blake2s-128': 0xb250,
            'blake2s-136': 0xb251,
            'blake2s-144': 0xb252,
            'blake2s-152': 0xb253,
            'blake2s-160': 0xb254,
            'blake2s-168': 0xb255,
            'blake2s-176': 0xb256,
            'blake2s-184': 0xb257,
            'blake2s-192': 0xb258,
            'blake2s-200': 0xb259,
            'blake2s-208': 0xb25a,
            'blake2s-216': 0xb25b,
            'blake2s-224': 0xb25c,
            'blake2s-232': 0xb25d,
            'blake2s-240': 0xb25e,
            'blake2s-248': 0xb25f,
            'blake2s-256': 0xb260,
            'skein256-8': 0xb301,
            'skein256-16': 0xb302,
            'skein256-24': 0xb303,
            'skein256-32': 0xb304,
            'skein256-40': 0xb305,
            'skein256-48': 0xb306,
            'skein256-56': 0xb307,
            'skein256-64': 0xb308,
            'skein256-72': 0xb309,
            'skein256-80': 0xb30a,
            'skein256-88': 0xb30b,
            'skein256-96': 0xb30c,
            'skein256-104': 0xb30d,
            'skein256-112': 0xb30e,
            'skein256-120': 0xb30f,
            'skein256-128': 0xb310,
            'skein256-136': 0xb311,
            'skein256-144': 0xb312,
            'skein256-152': 0xb313,
            'skein256-160': 0xb314,
            'skein256-168': 0xb315,
            'skein256-176': 0xb316,
            'skein256-184': 0xb317,
            'skein256-192': 0xb318,
            'skein256-200': 0xb319,
            'skein256-208': 0xb31a,
            'skein256-216': 0xb31b,
            'skein256-224': 0xb31c,
            'skein256-232': 0xb31d,
            'skein256-240': 0xb31e,
            'skein256-248': 0xb31f,
            'skein256-256': 0xb320,
            'skein512-8': 0xb321,
            'skein512-16': 0xb322,
            'skein512-24': 0xb323,
            'skein512-32': 0xb324,
            'skein512-40': 0xb325,
            'skein512-48': 0xb326,
            'skein512-56': 0xb327,
            'skein512-64': 0xb328,
            'skein512-72': 0xb329,
            'skein512-80': 0xb32a,
            'skein512-88': 0xb32b,
            'skein512-96': 0xb32c,
            'skein512-104': 0xb32d,
            'skein512-112': 0xb32e,
            'skein512-120': 0xb32f,
            'skein512-128': 0xb330,
            'skein512-136': 0xb331,
            'skein512-144': 0xb332,
            'skein512-152': 0xb333,
            'skein512-160': 0xb334,
            'skein512-168': 0xb335,
            'skein512-176': 0xb336,
            'skein512-184': 0xb337,
            'skein512-192': 0xb338,
            'skein512-200': 0xb339,
            'skein512-208': 0xb33a,
            'skein512-216': 0xb33b,
            'skein512-224': 0xb33c,
            'skein512-232': 0xb33d,
            'skein512-240': 0xb33e,
            'skein512-248': 0xb33f,
            'skein512-256': 0xb340,
            'skein512-264': 0xb341,
            'skein512-272': 0xb342,
            'skein512-280': 0xb343,
            'skein512-288': 0xb344,
            'skein512-296': 0xb345,
            'skein512-304': 0xb346,
            'skein512-312': 0xb347,
            'skein512-320': 0xb348,
            'skein512-328': 0xb349,
            'skein512-336': 0xb34a,
            'skein512-344': 0xb34b,
            'skein512-352': 0xb34c,
            'skein512-360': 0xb34d,
            'skein512-368': 0xb34e,
            'skein512-376': 0xb34f,
            'skein512-384': 0xb350,
            'skein512-392': 0xb351,
            'skein512-400': 0xb352,
            'skein512-408': 0xb353,
            'skein512-416': 0xb354,
            'skein512-424': 0xb355,
            'skein512-432': 0xb356,
            'skein512-440': 0xb357,
            'skein512-448': 0xb358,
            'skein512-456': 0xb359,
            'skein512-464': 0xb35a,
            'skein512-472': 0xb35b,
            'skein512-480': 0xb35c,
            'skein512-488': 0xb35d,
            'skein512-496': 0xb35e,
            'skein512-504': 0xb35f,
            'skein512-512': 0xb360,
            'skein1024-8': 0xb361,
            'skein1024-16': 0xb362,
            'skein1024-24': 0xb363,
            'skein1024-32': 0xb364,
            'skein1024-40': 0xb365,
            'skein1024-48': 0xb366,
            'skein1024-56': 0xb367,
            'skein1024-64': 0xb368,
            'skein1024-72': 0xb369,
            'skein1024-80': 0xb36a,
            'skein1024-88': 0xb36b,
            'skein1024-96': 0xb36c,
            'skein1024-104': 0xb36d,
            'skein1024-112': 0xb36e,
            'skein1024-120': 0xb36f,
            'skein1024-128': 0xb370,
            'skein1024-136': 0xb371,
            'skein1024-144': 0xb372,
            'skein1024-152': 0xb373,
            'skein1024-160': 0xb374,
            'skein1024-168': 0xb375,
            'skein1024-176': 0xb376,
            'skein1024-184': 0xb377,
            'skein1024-192': 0xb378,
            'skein1024-200': 0xb379,
            'skein1024-208': 0xb37a,
            'skein1024-216': 0xb37b,
            'skein1024-224': 0xb37c,
            'skein1024-232': 0xb37d,
            'skein1024-240': 0xb37e,
            'skein1024-248': 0xb37f,
            'skein1024-256': 0xb380,
            'skein1024-264': 0xb381,
            'skein1024-272': 0xb382,
            'skein1024-280': 0xb383,
            'skein1024-288': 0xb384,
            'skein1024-296': 0xb385,
            'skein1024-304': 0xb386,
            'skein1024-312': 0xb387,
            'skein1024-320': 0xb388,
            'skein1024-328': 0xb389,
            'skein1024-336': 0xb38a,
            'skein1024-344': 0xb38b,
            'skein1024-352': 0xb38c,
            'skein1024-360': 0xb38d,
            'skein1024-368': 0xb38e,
            'skein1024-376': 0xb38f,
            'skein1024-384': 0xb390,
            'skein1024-392': 0xb391,
            'skein1024-400': 0xb392,
            'skein1024-408': 0xb393,
            'skein1024-416': 0xb394,
            'skein1024-424': 0xb395,
            'skein1024-432': 0xb396,
            'skein1024-440': 0xb397,
            'skein1024-448': 0xb398,
            'skein1024-456': 0xb399,
            'skein1024-464': 0xb39a,
            'skein1024-472': 0xb39b,
            'skein1024-480': 0xb39c,
            'skein1024-488': 0xb39d,
            'skein1024-496': 0xb39e,
            'skein1024-504': 0xb39f,
            'skein1024-512': 0xb3a0,
            'skein1024-520': 0xb3a1,
            'skein1024-528': 0xb3a2,
            'skein1024-536': 0xb3a3,
            'skein1024-544': 0xb3a4,
            'skein1024-552': 0xb3a5,
            'skein1024-560': 0xb3a6,
            'skein1024-568': 0xb3a7,
            'skein1024-576': 0xb3a8,
            'skein1024-584': 0xb3a9,
            'skein1024-592': 0xb3aa,
            'skein1024-600': 0xb3ab,
            'skein1024-608': 0xb3ac,
            'skein1024-616': 0xb3ad,
            'skein1024-624': 0xb3ae,
            'skein1024-632': 0xb3af,
            'skein1024-640': 0xb3b0,
            'skein1024-648': 0xb3b1,
            'skein1024-656': 0xb3b2,
            'skein1024-664': 0xb3b3,
            'skein1024-672': 0xb3b4,
            'skein1024-680': 0xb3b5,
            'skein1024-688': 0xb3b6,
            'skein1024-696': 0xb3b7,
            'skein1024-704': 0xb3b8,
            'skein1024-712': 0xb3b9,
            'skein1024-720': 0xb3ba,
            'skein1024-728': 0xb3bb,
            'skein1024-736': 0xb3bc,
            'skein1024-744': 0xb3bd,
            'skein1024-752': 0xb3be,
            'skein1024-760': 0xb3bf,
            'skein1024-768': 0xb3c0,
            'skein1024-776': 0xb3c1,
            'skein1024-784': 0xb3c2,
            'skein1024-792': 0xb3c3,
            'skein1024-800': 0xb3c4,
            'skein1024-808': 0xb3c5,
            'skein1024-816': 0xb3c6,
            'skein1024-824': 0xb3c7,
            'skein1024-832': 0xb3c8,
            'skein1024-840': 0xb3c9,
            'skein1024-848': 0xb3ca,
            'skein1024-856': 0xb3cb,
            'skein1024-864': 0xb3cc,
            'skein1024-872': 0xb3cd,
            'skein1024-880': 0xb3ce,
            'skein1024-888': 0xb3cf,
            'skein1024-896': 0xb3d0,
            'skein1024-904': 0xb3d1,
            'skein1024-912': 0xb3d2,
            'skein1024-920': 0xb3d3,
            'skein1024-928': 0xb3d4,
            'skein1024-936': 0xb3d5,
            'skein1024-944': 0xb3d6,
            'skein1024-952': 0xb3d7,
            'skein1024-960': 0xb3d8,
            'skein1024-968': 0xb3d9,
            'skein1024-976': 0xb3da,
            'skein1024-984': 0xb3db,
            'skein1024-992': 0xb3dc,
            'skein1024-1000': 0xb3dd,
            'skein1024-1008': 0xb3de,
            'skein1024-1016': 0xb3df,
            'skein1024-1024': 0xb3e0,
            'poseidon-bls12_381-a2-fc1': 0xb401,
            'poseidon-bls12_381-a2-fc1-sc': 0xb402,
            'zeroxcert-imprint-256': 0xce11,
            'fil-commitment-unsealed': 0xf101,
            'fil-commitment-sealed': 0xf102,
            'holochain-adr-v0': 0x807124,
            'holochain-adr-v1': 0x817124,
            'holochain-key-v0': 0x947124,
            'holochain-key-v1': 0x957124,
            'holochain-sig-v0': 0xa27124,
            'holochain-sig-v1': 0xa37124,
            'skynet-ns': 0xb19910
          })

          module.exports = { baseTable }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\constants.js", { "./base-table": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\base-table.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\constants.js
        return function (require, module, exports) {
          'use strict'

          /** @typedef {__import__('./generated-types').ConstantNumberMap} ConstantNumberMap */

          const { baseTable } = require('./base-table')

          const constants = /** @type {ConstantNumberMap} */({})

          for (const [name, code] of Object.entries(baseTable)) {
            const constant = name.toUpperCase().replace(/-/g, '_')
            constants[constant] = code
          }

          module.exports = Object.freeze(constants)

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\index.js", { "./constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\constants.js", "./int-table": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\int-table.js", "./print": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\print.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\util.js", "./varint-table": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\varint-table.js", "uint8arrays/concat": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\uint8arrays\\concat.js", "varint": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\index.js
        return function (require, module, exports) {
          /**
           * Implementation of the multicodec specification.
           *
           * @module multicodec
           * @example
           * const multicodec = require('multicodec')
           *
           * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
           * // prefixedProtobuf 0x50...
           *
           */
          'use strict'

          /** @typedef {__import__('./generated-types').CodecName} CodecName */
          /** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

          const varint = require('varint')
          const intTable = require('./int-table')
          const codecNameToCodeVarint = require('./varint-table')
          const util = require('./util')
          const uint8ArrayConcat = require('uint8arrays/concat')

          /**
           * Prefix a buffer with a multicodec-packed.
           *
           * @param {CodecName|Uint8Array} multicodecStrOrCode
           * @param {Uint8Array} data
           * @returns {Uint8Array}
           */
          function addPrefix(multicodecStrOrCode, data) {
            let prefix

            if (multicodecStrOrCode instanceof Uint8Array) {
              prefix = util.varintUint8ArrayEncode(multicodecStrOrCode)
            } else {
              if (codecNameToCodeVarint[multicodecStrOrCode]) {
                prefix = codecNameToCodeVarint[multicodecStrOrCode]
              } else {
                throw new Error('multicodec not recognized')
              }
            }
            return uint8ArrayConcat([prefix, data], prefix.length + data.length)
          }

          /**
           * Decapsulate the multicodec-packed prefix from the data.
           *
           * @param {Uint8Array} data
           * @returns {Uint8Array}
           */
          function rmPrefix(data) {
            varint.decode(data)
            return data.slice(varint.decode.bytes)
          }

          /**
           * Get the codec of the prefixed data.
           *
           * @param {Uint8Array} prefixedData
           * @returns {CodecName}
           */
          function getCodec(prefixedData) {
            const code = varint.decode(prefixedData)
            const codecName = intTable.get(code)
            if (codecName === undefined) {
              throw new Error(`Code ${code} not found`)
            }
            return codecName
          }

          /**
           * Get the name of the codec.
           *
           * @param {CodecNumber} codec
           * @returns {CodecName|undefined}
           */
          function getName(codec) {
            return intTable.get(codec)
          }

          /**
           * Get the code of the codec
           *
           * @param {CodecName} name
           * @returns {CodecNumber}
           */
          function getNumber(name) {
            const code = codecNameToCodeVarint[name]
            if (code === undefined) {
              throw new Error('Codec `' + name + '` not found')
            }
            return varint.decode(code)
          }

          /**
           * Get the code of the prefixed data.
           *
           * @param {Uint8Array} prefixedData
           * @returns {CodecNumber}
           */
          function getCode(prefixedData) {
            return varint.decode(prefixedData)
          }

          /**
           * Get the code as varint of a codec name.
           *
           * @param {CodecName} codecName
           * @returns {Uint8Array}
           */
          function getCodeVarint(codecName) {
            const code = codecNameToCodeVarint[codecName]
            if (code === undefined) {
              throw new Error('Codec `' + codecName + '` not found')
            }
            return code
          }

          /**
           * Get the varint of a code.
           *
           * @param {CodecNumber} code
           * @returns {Array.<number>}
           */
          function getVarint(code) {
            return varint.encode(code)
          }

          // Make the constants top-level constants
          const constants = require('./constants')

          // Human friendly names for printing, e.g. in error messages
          const print = require('./print')

          module.exports = {
            addPrefix,
            rmPrefix,
            getCodec,
            getName,
            getNumber,
            getCode,
            getCodeVarint,
            getVarint,
            print,
            ...constants
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\int-table.js", { "./base-table": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\base-table.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\int-table.js
        return function (require, module, exports) {
          'use strict'

          /** @typedef {__import__('./generated-types').CodecName} CodecName */
          /** @typedef {__import__('./generated-types').CodecNumber} CodecNumber */

          const { baseTable } = require('./base-table')

          /**
           * @type {Map<CodecNumber,CodecName>}
           */
          const nameTable = new Map()

          for (const encodingName in baseTable) {
            const code = baseTable[encodingName]
            nameTable.set(code, /** @type {CodecName} */(encodingName))
          }

          module.exports = Object.freeze(nameTable)

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\print.js", { "./base-table": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\base-table.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\print.js
        return function (require, module, exports) {
          'use strict'

          /** @typedef {__import__('./generated-types').CodecName} CodecName */
          /** @typedef {__import__('./generated-types').NumberNameMap} NumberNameMap */

          const { baseTable } = require('./base-table')

          const tableByCode = /** @type {NumberNameMap} */({})

          for (const [name, code] of Object.entries(baseTable)) {
            if (tableByCode[code] === undefined) {
              tableByCode[code] = /** @type {CodecName} **/(name)
            }
          }

          module.exports = /** @type {NumberNameMap} */(Object.freeze(tableByCode))

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\util.js", { "uint8arrays/from-string": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\uint8arrays\\from-string.js", "uint8arrays/to-string": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\uint8arrays\\to-string.js", "varint": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\node_modules\\varint\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\util.js
        return function (require, module, exports) {
          'use strict'

          const varint = require('varint')
          const uint8ArrayToString = require('uint8arrays/to-string')
          const uint8ArrayFromString = require('uint8arrays/from-string')

          module.exports = {
            numberToUint8Array,
            uint8ArrayToNumber,
            varintUint8ArrayEncode,
            varintEncode
          }

          function uint8ArrayToNumber(buf) {
            return parseInt(uint8ArrayToString(buf, 'base16'), 16)
          }

          function numberToUint8Array(num) {
            let hexString = num.toString(16)
            if (hexString.length % 2 === 1) {
              hexString = '0' + hexString
            }
            return uint8ArrayFromString(hexString, 'base16')
          }

          function varintUint8ArrayEncode(input) {
            return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)))
          }

          function varintEncode(num) {
            return Uint8Array.from(varint.encode(num))
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\varint-table.js", { "./base-table": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\base-table.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multicodec\src\varint-table.js
        return function (require, module, exports) {
          'use strict'

          /** @typedef {__import__('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */

          const { baseTable } = require('./base-table')
          const varintEncode = require('./util').varintEncode

          const varintTable = /** @type {NameUint8ArrayMap} */ ({})

          for (const encodingName in baseTable) {
            const code = baseTable[encodingName]
            varintTable[encodingName] = varintEncode(code)
          }

          module.exports = Object.freeze(varintTable)

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multicodec", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", { "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\node_modules\multibase\src\base.js
        return function (require, module, exports) {
          // @ts-check
          'use strict'
          const { Buffer } = require('buffer')

          /**
           * @typedef {Object} Codec
           * @property {function(Uint8Array):string} encode
           * @property {function(string):Uint8Array} decode
           *
           * @typedef {function(string):Codec} CodecFactory
           */

          class Base {
            /**
             * @param {string} name
             * @param {string} code
             * @param {CodecFactory} implementation
             * @param {string} alphabet
             */
            constructor(name, code, implementation, alphabet) {
              this.name = name
              this.code = code
              this.codeBuf = Buffer.from(this.code)
              this.alphabet = alphabet
              this.engine = implementation(alphabet)
            }

            /**
             * @param {Uint8Array} buf
             * @returns {string}
             */
            encode(buf) {
              return this.engine.encode(buf)
            }

            /**
             * @param {string} string
             * @returns {Uint8Array}
             */
            decode(string) {
              for (const char of string) {
                if (this.alphabet && this.alphabet.indexOf(char) < 0) {
                  throw new Error(`invalid character '${char}' in '${string}'`)
                }
              }
              return this.engine.decode(string)
            }
          }

          module.exports = Base

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", { "./base.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\base.js", "./rfc4648": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js", "base-x": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\base-x\\src\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\node_modules\multibase\src\constants.js
        return function (require, module, exports) {
          // @ts-check
          'use strict'

          const baseX = require('base-x')
          const Base = require('./base.js')
          const rfc4648 = require('./rfc4648')
          const { decodeText, encodeText } = require('./util')

          const identity = () => {
            return {
              encode: decodeText,
              decode: encodeText
            }
          }

          /**
           * @typedef {__import__('./base').CodecFactory} CodecFactory
           *
           * name, code, implementation, alphabet
           * @type {Array<[string, string, CodecFactory, string]>}
           */
          const constants = [
            ['identity', '\x00', identity, ''],
            ['base2', '0', rfc4648(1), '01'],
            ['base8', '7', rfc4648(3), '01234567'],
            ['base10', '9', baseX, '0123456789'],
            ['base16', 'f', rfc4648(4), '0123456789abcdef'],
            ['base16upper', 'F', rfc4648(4), '0123456789ABCDEF'],
            ['base32hex', 'v', rfc4648(5), '0123456789abcdefghijklmnopqrstuv'],
            ['base32hexupper', 'V', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV'],
            ['base32hexpad', 't', rfc4648(5), '0123456789abcdefghijklmnopqrstuv='],
            ['base32hexpadupper', 'T', rfc4648(5), '0123456789ABCDEFGHIJKLMNOPQRSTUV='],
            ['base32', 'b', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567'],
            ['base32upper', 'B', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'],
            ['base32pad', 'c', rfc4648(5), 'abcdefghijklmnopqrstuvwxyz234567='],
            ['base32padupper', 'C', rfc4648(5), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='],
            ['base32z', 'h', rfc4648(5), 'ybndrfg8ejkmcpqxot1uwisza345h769'],
            ['base36', 'k', baseX, '0123456789abcdefghijklmnopqrstuvwxyz'],
            ['base36upper', 'K', baseX, '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'],
            ['base58btc', 'z', baseX, '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'],
            ['base58flickr', 'Z', baseX, '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'],
            ['base64', 'm', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'],
            ['base64pad', 'M', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='],
            ['base64url', 'u', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'],
            ['base64urlpad', 'U', rfc4648(6), 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=']
          ]

          const names = constants.reduce((prev, tupple) => {
            prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3])
            return prev
          }, {})

          const codes = constants.reduce((prev, tupple) => {
            prev[tupple[1]] = names[tupple[0]]
            return prev
          }, {})

          module.exports = {
            names,
            codes
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", { "./constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\constants.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\node_modules\multibase\src\index.js
        return function (require, module, exports) {
          // @ts-check
          /**
           * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
           *
           * @module Multibase
           */
          'use strict'

          const { Buffer } = require('buffer')
          const constants = require('./constants')
          const { decodeText, asBuffer } = require('./util')

          /** @typedef {__import__("./base")} Base */

          /**
           * Create a new buffer with the multibase varint+code.
           *
           * @param {string|number} nameOrCode - The multibase name or code number.
           * @param {Uint8Array} buf - The data to be prefixed with multibase.
           * @returns {Buffer}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function multibase(nameOrCode, buf) {
            if (!buf) {
              throw new Error('requires an encoded buffer')
            }
            const { name, codeBuf } = encoding(nameOrCode)
            validEncode(name, buf)

            const buffer = Buffer.alloc(codeBuf.length + buf.length)
            buffer.set(codeBuf, 0)
            buffer.set(buf, codeBuf.length)

            return buffer
          }

          /**
           * Encode data with the specified base and add the multibase prefix.
           *
           * @param {string|number} nameOrCode - The multibase name or code number.
           * @param {Uint8Array} buf - The data to be encoded.
           * @returns {Buffer}
           * @throws {Error} Will throw if the encoding is not supported
           *
           */
          function encode(nameOrCode, buf) {
            const enc = encoding(nameOrCode)

            return Buffer.concat([enc.codeBuf, Buffer.from(enc.encode(buf))])
          }

          /**
           * Takes a Uint8Array or string encoded with multibase header, decodes it and
           * returns the decoded buffer
           *
           * @param {Uint8Array|string} data
           * @returns {Buffer}
           * @throws {Error} Will throw if the encoding is not supported
           *
           */
          function decode(data) {
            if (ArrayBuffer.isView(data)) {
              data = decodeText(data)
            }
            const prefix = data[0]

            // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
            if (['f', 'F', 'v', 'V', 't', 'T', 'b', 'B', 'c', 'C', 'h', 'k', 'K'].includes(prefix)) {
              data = data.toLowerCase()
            }
            const enc = encoding(data[0])
            return asBuffer(enc.decode(data.substring(1)))
          }

          /**
           * Is the given data multibase encoded?
           *
           * @param {Uint8Array|string} data
           * @returns {false|string}
           */
          function isEncoded(data) {
            if (data instanceof Uint8Array) {
              data = decodeText(data)
            }

            // Ensure bufOrString is a string
            if (Object.prototype.toString.call(data) !== '[object String]') {
              return false
            }

            try {
              const enc = encoding(data[0])
              return enc.name
            } catch (err) {
              return false
            }
          }

          /**
           * Validate encoded data
           *
           * @param {string} name
           * @param {Uint8Array} buf
           * @returns {void}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function validEncode(name, buf) {
            const enc = encoding(name)
            enc.decode(decodeText(buf))
          }

          /**
           * Get the encoding by name or code
           *
           * @param {string|number} nameOrCode
           * @returns {Base}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function encoding(nameOrCode) {
            if (constants.names[nameOrCode]) {
              return constants.names[nameOrCode]
            } else if (constants.codes[nameOrCode]) {
              return constants.codes[nameOrCode]
            } else {
              throw new Error(`Unsupported encoding: ${nameOrCode}`)
            }
          }

          /**
           * Get encoding from data
           *
           * @param {string|Uint8Array} data
           * @returns {Base}
           * @throws {Error} Will throw if the encoding is not supported
           */
          function encodingFromData(data) {
            if (data instanceof Uint8Array) {
              data = decodeText(data)
            }

            return encoding(data[0])
          }

          exports = module.exports = multibase
          exports.encode = encode
          exports.decode = decode
          exports.isEncoded = isEncoded
          exports.encoding = encoding
          exports.encodingFromData = encodingFromData
          exports.names = Object.freeze(constants.names)
          exports.codes = Object.freeze(constants.codes)

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\rfc4648.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\node_modules\multibase\src\rfc4648.js
        return function (require, module, exports) {
          // @ts-check
          'use strict'

          /** @typedef {__import__('./base').CodecFactory} CodecFactory */

          /**
           * @param {string} string
           * @param {string} alphabet
           * @param {number} bitsPerChar
           * @returns {Uint8Array}
           */
          const decode = (string, alphabet, bitsPerChar) => {
            // Build the character lookup table:
            const codes = {}
            for (let i = 0; i < alphabet.length; ++i) {
              codes[alphabet[i]] = i
            }

            // Count the padding bytes:
            let end = string.length
            while (string[end - 1] === '=') {
              --end
            }

            // Allocate the output:
            const out = new Uint8Array((end * bitsPerChar / 8) | 0)

            // Parse the data:
            let bits = 0 // Number of bits currently in the buffer
            let buffer = 0 // Bits waiting to be written out, MSB first
            let written = 0 // Next byte to write
            for (let i = 0; i < end; ++i) {
              // Read one character from the string:
              const value = codes[string[i]]
              if (value === undefined) {
                throw new SyntaxError('Invalid character ' + string[i])
              }

              // Append the bits to the buffer:
              buffer = (buffer << bitsPerChar) | value
              bits += bitsPerChar

              // Write out some bits if the buffer has a byte's worth:
              if (bits >= 8) {
                bits -= 8
                out[written++] = 0xff & (buffer >> bits)
              }
            }

            // Verify that we have received just enough bits:
            if (bits >= bitsPerChar || 0xff & (buffer << (8 - bits))) {
              throw new SyntaxError('Unexpected end of data')
            }

            return out
          }

          /**
           * @param {Uint8Array} data
           * @param {string} alphabet
           * @param {number} bitsPerChar
           * @returns {string}
           */
          const encode = (data, alphabet, bitsPerChar) => {
            const pad = alphabet[alphabet.length - 1] === '='
            const mask = (1 << bitsPerChar) - 1
            let out = ''

            let bits = 0 // Number of bits currently in the buffer
            let buffer = 0 // Bits waiting to be written out, MSB first
            for (let i = 0; i < data.length; ++i) {
              // Slurp data into the buffer:
              buffer = (buffer << 8) | data[i]
              bits += 8

              // Write out as much as we can:
              while (bits > bitsPerChar) {
                bits -= bitsPerChar
                out += alphabet[mask & (buffer >> bits)]
              }
            }

            // Partial character:
            if (bits) {
              out += alphabet[mask & (buffer << (bitsPerChar - bits))]
            }

            // Add padding characters until we hit a byte boundary:
            if (pad) {
              while ((out.length * bitsPerChar) & 7) {
                out += '='
              }
            }

            return out
          }

          /**
           * @param {number} bitsPerChar
           * @returns {CodecFactory}
           */
          module.exports = (bitsPerChar) => (alphabet) => {
            return {
              /**
               * @param {Uint8Array} input
               * @returns {string}
               */
              encode(input) {
                return encode(input, alphabet, bitsPerChar)
              },
              /**
               * @param {string} input
               * @returns {Uint8Array}
               */
              decode(input) {
                return decode(input, alphabet, bitsPerChar)
              }
            }
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\util.js", { "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "web-encoding": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\node_modules\multibase\src\util.js
        return function (require, module, exports) {
          // @ts-check
          'use strict'

          const { Buffer } = require('buffer')
          const { TextEncoder, TextDecoder } = require('web-encoding')

          const textDecoder = new TextDecoder()
          /**
           * @param {ArrayBufferView|ArrayBuffer} bytes
           * @returns {string}
           */
          const decodeText = (bytes) => textDecoder.decode(bytes)

          const textEncoder = new TextEncoder()
          /**
           * @param {string} text
           * @returns {Uint8Array}
           */
          const encodeText = (text) => textEncoder.encode(text)

          /**
           * @param {ArrayBufferView} bytes
           * @returns {Buffer}
           */
          const asBuffer = ({ buffer, byteLength, byteOffset }) =>
            Buffer.from(buffer, byteOffset, byteLength)

          module.exports = { decodeText, encodeText, asBuffer }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>multibase", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\src\\constants.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\src\constants.js
        return function (require, module, exports) {
          /* eslint quote-props: off */
          'use strict'

          const names = Object.freeze({
            'identity': 0x00,
            'sha1': 0x11,
            'sha2-256': 0x12,
            'sha2-512': 0x13,
            'sha3-512': 0x14,
            'sha3-384': 0x15,
            'sha3-256': 0x16,
            'sha3-224': 0x17,
            'shake-128': 0x18,
            'shake-256': 0x19,
            'keccak-224': 0x1a,
            'keccak-256': 0x1b,
            'keccak-384': 0x1c,
            'keccak-512': 0x1d,
            'blake3': 0x1e,
            'murmur3-128': 0x22,
            'murmur3-32': 0x23,
            'dbl-sha2-256': 0x56,
            'md4': 0xd4,
            'md5': 0xd5,
            'bmt': 0xd6,
            'sha2-256-trunc254-padded': 0x1012,
            'ripemd-128': 0x1052,
            'ripemd-160': 0x1053,
            'ripemd-256': 0x1054,
            'ripemd-320': 0x1055,
            'x11': 0x1100,
            'sm3-256': 0x534d,
            'blake2b-8': 0xb201,
            'blake2b-16': 0xb202,
            'blake2b-24': 0xb203,
            'blake2b-32': 0xb204,
            'blake2b-40': 0xb205,
            'blake2b-48': 0xb206,
            'blake2b-56': 0xb207,
            'blake2b-64': 0xb208,
            'blake2b-72': 0xb209,
            'blake2b-80': 0xb20a,
            'blake2b-88': 0xb20b,
            'blake2b-96': 0xb20c,
            'blake2b-104': 0xb20d,
            'blake2b-112': 0xb20e,
            'blake2b-120': 0xb20f,
            'blake2b-128': 0xb210,
            'blake2b-136': 0xb211,
            'blake2b-144': 0xb212,
            'blake2b-152': 0xb213,
            'blake2b-160': 0xb214,
            'blake2b-168': 0xb215,
            'blake2b-176': 0xb216,
            'blake2b-184': 0xb217,
            'blake2b-192': 0xb218,
            'blake2b-200': 0xb219,
            'blake2b-208': 0xb21a,
            'blake2b-216': 0xb21b,
            'blake2b-224': 0xb21c,
            'blake2b-232': 0xb21d,
            'blake2b-240': 0xb21e,
            'blake2b-248': 0xb21f,
            'blake2b-256': 0xb220,
            'blake2b-264': 0xb221,
            'blake2b-272': 0xb222,
            'blake2b-280': 0xb223,
            'blake2b-288': 0xb224,
            'blake2b-296': 0xb225,
            'blake2b-304': 0xb226,
            'blake2b-312': 0xb227,
            'blake2b-320': 0xb228,
            'blake2b-328': 0xb229,
            'blake2b-336': 0xb22a,
            'blake2b-344': 0xb22b,
            'blake2b-352': 0xb22c,
            'blake2b-360': 0xb22d,
            'blake2b-368': 0xb22e,
            'blake2b-376': 0xb22f,
            'blake2b-384': 0xb230,
            'blake2b-392': 0xb231,
            'blake2b-400': 0xb232,
            'blake2b-408': 0xb233,
            'blake2b-416': 0xb234,
            'blake2b-424': 0xb235,
            'blake2b-432': 0xb236,
            'blake2b-440': 0xb237,
            'blake2b-448': 0xb238,
            'blake2b-456': 0xb239,
            'blake2b-464': 0xb23a,
            'blake2b-472': 0xb23b,
            'blake2b-480': 0xb23c,
            'blake2b-488': 0xb23d,
            'blake2b-496': 0xb23e,
            'blake2b-504': 0xb23f,
            'blake2b-512': 0xb240,
            'blake2s-8': 0xb241,
            'blake2s-16': 0xb242,
            'blake2s-24': 0xb243,
            'blake2s-32': 0xb244,
            'blake2s-40': 0xb245,
            'blake2s-48': 0xb246,
            'blake2s-56': 0xb247,
            'blake2s-64': 0xb248,
            'blake2s-72': 0xb249,
            'blake2s-80': 0xb24a,
            'blake2s-88': 0xb24b,
            'blake2s-96': 0xb24c,
            'blake2s-104': 0xb24d,
            'blake2s-112': 0xb24e,
            'blake2s-120': 0xb24f,
            'blake2s-128': 0xb250,
            'blake2s-136': 0xb251,
            'blake2s-144': 0xb252,
            'blake2s-152': 0xb253,
            'blake2s-160': 0xb254,
            'blake2s-168': 0xb255,
            'blake2s-176': 0xb256,
            'blake2s-184': 0xb257,
            'blake2s-192': 0xb258,
            'blake2s-200': 0xb259,
            'blake2s-208': 0xb25a,
            'blake2s-216': 0xb25b,
            'blake2s-224': 0xb25c,
            'blake2s-232': 0xb25d,
            'blake2s-240': 0xb25e,
            'blake2s-248': 0xb25f,
            'blake2s-256': 0xb260,
            'skein256-8': 0xb301,
            'skein256-16': 0xb302,
            'skein256-24': 0xb303,
            'skein256-32': 0xb304,
            'skein256-40': 0xb305,
            'skein256-48': 0xb306,
            'skein256-56': 0xb307,
            'skein256-64': 0xb308,
            'skein256-72': 0xb309,
            'skein256-80': 0xb30a,
            'skein256-88': 0xb30b,
            'skein256-96': 0xb30c,
            'skein256-104': 0xb30d,
            'skein256-112': 0xb30e,
            'skein256-120': 0xb30f,
            'skein256-128': 0xb310,
            'skein256-136': 0xb311,
            'skein256-144': 0xb312,
            'skein256-152': 0xb313,
            'skein256-160': 0xb314,
            'skein256-168': 0xb315,
            'skein256-176': 0xb316,
            'skein256-184': 0xb317,
            'skein256-192': 0xb318,
            'skein256-200': 0xb319,
            'skein256-208': 0xb31a,
            'skein256-216': 0xb31b,
            'skein256-224': 0xb31c,
            'skein256-232': 0xb31d,
            'skein256-240': 0xb31e,
            'skein256-248': 0xb31f,
            'skein256-256': 0xb320,
            'skein512-8': 0xb321,
            'skein512-16': 0xb322,
            'skein512-24': 0xb323,
            'skein512-32': 0xb324,
            'skein512-40': 0xb325,
            'skein512-48': 0xb326,
            'skein512-56': 0xb327,
            'skein512-64': 0xb328,
            'skein512-72': 0xb329,
            'skein512-80': 0xb32a,
            'skein512-88': 0xb32b,
            'skein512-96': 0xb32c,
            'skein512-104': 0xb32d,
            'skein512-112': 0xb32e,
            'skein512-120': 0xb32f,
            'skein512-128': 0xb330,
            'skein512-136': 0xb331,
            'skein512-144': 0xb332,
            'skein512-152': 0xb333,
            'skein512-160': 0xb334,
            'skein512-168': 0xb335,
            'skein512-176': 0xb336,
            'skein512-184': 0xb337,
            'skein512-192': 0xb338,
            'skein512-200': 0xb339,
            'skein512-208': 0xb33a,
            'skein512-216': 0xb33b,
            'skein512-224': 0xb33c,
            'skein512-232': 0xb33d,
            'skein512-240': 0xb33e,
            'skein512-248': 0xb33f,
            'skein512-256': 0xb340,
            'skein512-264': 0xb341,
            'skein512-272': 0xb342,
            'skein512-280': 0xb343,
            'skein512-288': 0xb344,
            'skein512-296': 0xb345,
            'skein512-304': 0xb346,
            'skein512-312': 0xb347,
            'skein512-320': 0xb348,
            'skein512-328': 0xb349,
            'skein512-336': 0xb34a,
            'skein512-344': 0xb34b,
            'skein512-352': 0xb34c,
            'skein512-360': 0xb34d,
            'skein512-368': 0xb34e,
            'skein512-376': 0xb34f,
            'skein512-384': 0xb350,
            'skein512-392': 0xb351,
            'skein512-400': 0xb352,
            'skein512-408': 0xb353,
            'skein512-416': 0xb354,
            'skein512-424': 0xb355,
            'skein512-432': 0xb356,
            'skein512-440': 0xb357,
            'skein512-448': 0xb358,
            'skein512-456': 0xb359,
            'skein512-464': 0xb35a,
            'skein512-472': 0xb35b,
            'skein512-480': 0xb35c,
            'skein512-488': 0xb35d,
            'skein512-496': 0xb35e,
            'skein512-504': 0xb35f,
            'skein512-512': 0xb360,
            'skein1024-8': 0xb361,
            'skein1024-16': 0xb362,
            'skein1024-24': 0xb363,
            'skein1024-32': 0xb364,
            'skein1024-40': 0xb365,
            'skein1024-48': 0xb366,
            'skein1024-56': 0xb367,
            'skein1024-64': 0xb368,
            'skein1024-72': 0xb369,
            'skein1024-80': 0xb36a,
            'skein1024-88': 0xb36b,
            'skein1024-96': 0xb36c,
            'skein1024-104': 0xb36d,
            'skein1024-112': 0xb36e,
            'skein1024-120': 0xb36f,
            'skein1024-128': 0xb370,
            'skein1024-136': 0xb371,
            'skein1024-144': 0xb372,
            'skein1024-152': 0xb373,
            'skein1024-160': 0xb374,
            'skein1024-168': 0xb375,
            'skein1024-176': 0xb376,
            'skein1024-184': 0xb377,
            'skein1024-192': 0xb378,
            'skein1024-200': 0xb379,
            'skein1024-208': 0xb37a,
            'skein1024-216': 0xb37b,
            'skein1024-224': 0xb37c,
            'skein1024-232': 0xb37d,
            'skein1024-240': 0xb37e,
            'skein1024-248': 0xb37f,
            'skein1024-256': 0xb380,
            'skein1024-264': 0xb381,
            'skein1024-272': 0xb382,
            'skein1024-280': 0xb383,
            'skein1024-288': 0xb384,
            'skein1024-296': 0xb385,
            'skein1024-304': 0xb386,
            'skein1024-312': 0xb387,
            'skein1024-320': 0xb388,
            'skein1024-328': 0xb389,
            'skein1024-336': 0xb38a,
            'skein1024-344': 0xb38b,
            'skein1024-352': 0xb38c,
            'skein1024-360': 0xb38d,
            'skein1024-368': 0xb38e,
            'skein1024-376': 0xb38f,
            'skein1024-384': 0xb390,
            'skein1024-392': 0xb391,
            'skein1024-400': 0xb392,
            'skein1024-408': 0xb393,
            'skein1024-416': 0xb394,
            'skein1024-424': 0xb395,
            'skein1024-432': 0xb396,
            'skein1024-440': 0xb397,
            'skein1024-448': 0xb398,
            'skein1024-456': 0xb399,
            'skein1024-464': 0xb39a,
            'skein1024-472': 0xb39b,
            'skein1024-480': 0xb39c,
            'skein1024-488': 0xb39d,
            'skein1024-496': 0xb39e,
            'skein1024-504': 0xb39f,
            'skein1024-512': 0xb3a0,
            'skein1024-520': 0xb3a1,
            'skein1024-528': 0xb3a2,
            'skein1024-536': 0xb3a3,
            'skein1024-544': 0xb3a4,
            'skein1024-552': 0xb3a5,
            'skein1024-560': 0xb3a6,
            'skein1024-568': 0xb3a7,
            'skein1024-576': 0xb3a8,
            'skein1024-584': 0xb3a9,
            'skein1024-592': 0xb3aa,
            'skein1024-600': 0xb3ab,
            'skein1024-608': 0xb3ac,
            'skein1024-616': 0xb3ad,
            'skein1024-624': 0xb3ae,
            'skein1024-632': 0xb3af,
            'skein1024-640': 0xb3b0,
            'skein1024-648': 0xb3b1,
            'skein1024-656': 0xb3b2,
            'skein1024-664': 0xb3b3,
            'skein1024-672': 0xb3b4,
            'skein1024-680': 0xb3b5,
            'skein1024-688': 0xb3b6,
            'skein1024-696': 0xb3b7,
            'skein1024-704': 0xb3b8,
            'skein1024-712': 0xb3b9,
            'skein1024-720': 0xb3ba,
            'skein1024-728': 0xb3bb,
            'skein1024-736': 0xb3bc,
            'skein1024-744': 0xb3bd,
            'skein1024-752': 0xb3be,
            'skein1024-760': 0xb3bf,
            'skein1024-768': 0xb3c0,
            'skein1024-776': 0xb3c1,
            'skein1024-784': 0xb3c2,
            'skein1024-792': 0xb3c3,
            'skein1024-800': 0xb3c4,
            'skein1024-808': 0xb3c5,
            'skein1024-816': 0xb3c6,
            'skein1024-824': 0xb3c7,
            'skein1024-832': 0xb3c8,
            'skein1024-840': 0xb3c9,
            'skein1024-848': 0xb3ca,
            'skein1024-856': 0xb3cb,
            'skein1024-864': 0xb3cc,
            'skein1024-872': 0xb3cd,
            'skein1024-880': 0xb3ce,
            'skein1024-888': 0xb3cf,
            'skein1024-896': 0xb3d0,
            'skein1024-904': 0xb3d1,
            'skein1024-912': 0xb3d2,
            'skein1024-920': 0xb3d3,
            'skein1024-928': 0xb3d4,
            'skein1024-936': 0xb3d5,
            'skein1024-944': 0xb3d6,
            'skein1024-952': 0xb3d7,
            'skein1024-960': 0xb3d8,
            'skein1024-968': 0xb3d9,
            'skein1024-976': 0xb3da,
            'skein1024-984': 0xb3db,
            'skein1024-992': 0xb3dc,
            'skein1024-1000': 0xb3dd,
            'skein1024-1008': 0xb3de,
            'skein1024-1016': 0xb3df,
            'skein1024-1024': 0xb3e0,
            'poseidon-bls12_381-a2-fc1': 0xb401,
            'poseidon-bls12_381-a2-fc1-sc': 0xb402
          })

          module.exports = { names }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\src\\index.js", { "./constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\src\\constants.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "multibase": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\node_modules\\multibase\\src\\index.js", "varint": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\index.js", "web-encoding": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\multihashes\src\index.js
        return function (require, module, exports) {
          // @ts-check
          /* eslint-disable guard-for-in */
          /**
           * Multihash implementation in JavaScript.
           *
           * @module multihash
           */
          'use strict'

          const { Buffer } = require('buffer')
          const multibase = require('multibase')
          const varint = require('varint')
          const { names } = require('./constants')
          const { TextDecoder } = require('web-encoding')

          const textDecoder = new TextDecoder()
          const codes = {}

          for (const key in names) {
            codes[names[key]] = key
          }
          exports.names = names
          exports.codes = Object.freeze(codes)

          /**
           * Convert the given multihash to a hex encoded string.
           *
           * @param {Uint8Array} hash
           * @returns {string}
           */
          exports.toHexString = function toHexString(hash) {
            if (!(hash instanceof Uint8Array)) {
              throw new Error('must be passed a Uint8Array')
            }

            const buffer = Buffer.isBuffer(hash)
              ? hash
              : Buffer.from(hash.buffer, hash.byteOffset, hash.byteLength)

            return buffer.toString('hex')
          }

          /**
           * Convert the given hex encoded string to a multihash.
           *
           * @param {string} hash
           * @returns {Buffer}
           */
          exports.fromHexString = function fromHexString(hash) {
            return Buffer.from(hash, 'hex')
          }

          /**
           * Convert the given multihash to a base58 encoded string.
           *
           * @param {Uint8Array} hash
           * @returns {string}
           */
          exports.toB58String = function toB58String(hash) {
            if (!(hash instanceof Uint8Array)) {
              throw new Error('must be passed a Uint8Array')
            }

            return textDecoder.decode(multibase.encode('base58btc', hash)).slice(1)
          }

          /**
           * Convert the given base58 encoded string to a multihash.
           *
           * @param {string|Uint8Array} hash
           * @returns {Buffer}
           */
          exports.fromB58String = function fromB58String(hash) {
            const encoded = hash instanceof Uint8Array
              ? textDecoder.decode(hash)
              : hash

            return multibase.decode('z' + encoded)
          }

          /**
           * Decode a hash from the given multihash.
           *
           * @param {Uint8Array} bytes
           * @returns {{code: number, name: string, length: number, digest: Buffer}} result
           */
          exports.decode = function decode(bytes) {
            if (!(bytes instanceof Uint8Array)) {
              throw new Error('multihash must be a Uint8Array')
            }
            let buf = Buffer.isBuffer(bytes)
              ? bytes
              : Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength)

            if (buf.length < 2) {
              throw new Error('multihash too short. must be > 2 bytes.')
            }

            const code = varint.decode(buf)
            if (!exports.isValidCode(code)) {
              throw new Error(`multihash unknown function code: 0x${code.toString(16)}`)
            }
            buf = buf.slice(varint.decode.bytes)

            const len = varint.decode(buf)
            if (len < 0) {
              throw new Error(`multihash invalid length: ${len}`)
            }
            buf = buf.slice(varint.decode.bytes)

            if (buf.length !== len) {
              throw new Error(`multihash length inconsistent: 0x${buf.toString('hex')}`)
            }

            return {
              code,
              name: codes[code],
              length: len,
              digest: buf
            }
          }

          /**
           *  Encode a hash digest along with the specified function code.
           *
           * > **Note:** the length is derived from the length of the digest itself.
           *
           * @param {Uint8Array} digest
           * @param {string|number} code
           * @param {number} [length]
           * @returns {Buffer}
           */
          exports.encode = function encode(digest, code, length) {
            if (!digest || code === undefined) {
              throw new Error('multihash encode requires at least two args: digest, code')
            }

            // ensure it's a hashfunction code.
            const hashfn = exports.coerceCode(code)

            if (!(digest instanceof Uint8Array)) {
              throw new Error('digest should be a Uint8Array')
            }

            if (length == null) {
              length = digest.length
            }

            if (length && digest.length !== length) {
              throw new Error('digest length should be equal to specified length.')
            }

            const hash = varint.encode(hashfn)
            const len = varint.encode(length)
            const buffer = Buffer.alloc(hash.length + len.length + digest.length)
            buffer.set(hash, 0)
            buffer.set(len, hash.length)
            buffer.set(digest, hash.length + len.length)
            return buffer
          }

          /**
           * Converts a hash function name into the matching code.
           * If passed a number it will return the number if it's a valid code.
           * @param {string|number} name
           * @returns {number}
           */
          exports.coerceCode = function coerceCode(name) {
            let code = name

            if (typeof name === 'string') {
              if (names[name] === undefined) {
                throw new Error(`Unrecognized hash function named: ${name}`)
              }
              code = names[name]
            }

            if (typeof code !== 'number') {
              throw new Error(`Hash function code should be a number. Got: ${code}`)
            }

            if (codes[code] === undefined && !exports.isAppCode(code)) {
              throw new Error(`Unrecognized function code: ${code}`)
            }

            return code
          }

          /**
           * Checks wether a code is part of the app range
           *
           * @param {number} code
           * @returns {boolean}
           */
          exports.isAppCode = function appCode(code) {
            return code > 0 && code < 0x10
          }

          /**
           * Checks whether a multihash code is valid.
           *
           * @param {number} code
           * @returns {boolean}
           */
          exports.isValidCode = function validCode(code) {
            if (exports.isAppCode(code)) {
              return true
            }

            if (codes[code]) {
              return true
            }

            return false
          }

          /**
           * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
           *
           * @param {Uint8Array} multihash
           * @returns {void}
           * @throws {Error}
           */
          function validate(multihash) {
            exports.decode(multihash) // throws if bad.
          }
          exports.validate = validate

          /**
           * Returns a prefix from a valid multihash. Throws an error if it is not valid.
           *
           * @param {Uint8Array} multihash
           * @returns {Buffer}
           * @throws {Error}
           */
          exports.prefix = function prefix(multihash) {
            validate(multihash)

            return Buffer.from(multihash.buffer, multihash.byteOffset, 2)
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\nanoid\\index.browser.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\nanoid\index.browser.js
        return function (require, module, exports) {
          // This file replaces `index.js` in bundlers like webpack or Rollup,
          // according to `browser` config in `package.json`.

          if ("development" !== 'production') {
            // All bundlers will remove this block in production bundle
            if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
              throw new Error(
                'React Native does not have a built-in secure random generator. ' +
                'If you don’t need unpredictable IDs, you can use `nanoid/non-secure`. ' +
                'For secure ID install `expo-random` locally and use `nanoid/async`.'
              )
            }
            if (typeof self === 'undefined' || (!self.crypto && !self.msCrypto)) {
              throw new Error(
                'Your browser does not have secure random generator. ' +
                'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
              )
            }
          }

          var crypto = self.crypto || self.msCrypto

          // This alphabet uses a-z A-Z 0-9 _- symbols.
          // Symbols are generated for smaller size.
          // -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
          var url = '-_'
          // Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
          var i = 36
          while (i--) {
            // 36 is radix. Number.prototype.toString(36) returns number
            // in Base36 representation. Base36 is like hex, but it uses 0–9 and a-z.
            url += i.toString(36)
          }
          // Loop from 36 to 10 (from Z to A in Base36).
          i = 36
          while (i-- - 10) {
            url += i.toString(36).toUpperCase()
          }

          module.exports = function (size) {
            var id = ''
            var bytes = crypto.getRandomValues(new Uint8Array(size || 21))
            i = size || 21

            // Compact alternative for `for (var i = 0; i < size; i++)`
            while (i--) {
              // We can’t use bytes bigger than the alphabet. 63 is 00111111 bitmask.
              // This mask reduces random byte 0-255 to 0-63 values.
              // There is no need in `|| ''` and `* 1.6` hacks in here,
              // because bitmask trim bytes exact to alphabet size.
              id += url[bytes[i] & 63]
            }
            return id
          }

        };
      };
    }
  }, { package: "nanoid", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\nonce-tracker\\index.js", { "assert": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\assert\\assert.js", "await-semaphore": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\await-semaphore\\index.js", "ethjs-query": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethjs-query\\lib\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\nonce-tracker\index.js
        return function (require, module, exports) {
          const EthQuery = require('ethjs-query')
          const assert = require('assert')
          const Mutex = require('await-semaphore').Mutex
          /**
            @param opts {Object}
              @param {Object} opts.provider a ethereum provider
              @param {Function} opts.getPendingTransactions a function that returns an array of txMeta
              whosee status is `submitted`
              @param {Function} opts.getConfirmedTransactions a function that returns an array of txMeta
              whose status is `confirmed`
            @class
          */
          class NonceTracker {

            constructor({ provider, blockTracker, getPendingTransactions, getConfirmedTransactions }) {
              this.provider = provider
              this.blockTracker = blockTracker
              this.ethQuery = new EthQuery(provider)
              this.getPendingTransactions = getPendingTransactions
              this.getConfirmedTransactions = getConfirmedTransactions
              this.lockMap = {}
            }

            /**
              @returns {Promise<Object>} with the key releaseLock (the gloabl mutex)
            */
            async getGlobalLock() {
              const globalMutex = this._lookupMutex('global')
              // await global mutex free
              const releaseLock = await globalMutex.acquire()
              return { releaseLock }
            }

            /**
             * @typedef NonceDetails
             * @property {number} highestLocallyConfirmed - A hex string of the highest nonce on a confirmed transaction.
             * @property {number} nextNetworkNonce - The next nonce suggested by the eth_getTransactionCount method.
             * @property {number} highestSuggested - The maximum between the other two, the number returned.
             */

            /**
            this will return an object with the `nextNonce` `nonceDetails`, and the releaseLock
            Note: releaseLock must be called after adding a signed tx to pending transactions (or discarding).
          
            @param address {string} the hex string for the address whose nonce we are calculating
            @returns {Promise<NonceDetails>}
            */
            async getNonceLock(address) {
              // await global mutex free
              await this._globalMutexFree()
              // await lock free, then take lock
              const releaseLock = await this._takeMutex(address)
              try {
                // evaluate multiple nextNonce strategies
                const nonceDetails = {}
                const networkNonceResult = await this._getNetworkNextNonce(address)
                const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address)
                const nextNetworkNonce = networkNonceResult.nonce
                const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed)

                const pendingTxs = this.getPendingTransactions(address)
                const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested) || 0

                nonceDetails.params = {
                  highestLocallyConfirmed,
                  highestSuggested,
                  nextNetworkNonce,
                }
                nonceDetails.local = localNonceResult
                nonceDetails.network = networkNonceResult

                const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce)
                assert(Number.isInteger(nextNonce), `nonce-tracker - nextNonce is not an integer - got: (${typeof nextNonce}) "${nextNonce}"`)

                // return nonce and release cb
                return { nextNonce, nonceDetails, releaseLock }
              } catch (err) {
                // release lock if we encounter an error
                releaseLock()
                throw err
              }
            }

            async _globalMutexFree() {
              const globalMutex = this._lookupMutex('global')
              const releaseLock = await globalMutex.acquire()
              releaseLock()
            }

            async _takeMutex(lockId) {
              const mutex = this._lookupMutex(lockId)
              const releaseLock = await mutex.acquire()
              return releaseLock
            }

            _lookupMutex(lockId) {
              let mutex = this.lockMap[lockId]
              if (!mutex) {
                mutex = new Mutex()
                this.lockMap[lockId] = mutex
              }
              return mutex
            }

            async _getNetworkNextNonce(address) {
              // calculate next nonce
              // we need to make sure our base count
              // and pending count are from the same block
              const blockNumber = await this.blockTracker.getLatestBlock()
              const baseCountBN = await this.ethQuery.getTransactionCount(address, blockNumber)
              const baseCount = baseCountBN.toNumber()
              assert(Number.isInteger(baseCount), `nonce-tracker - baseCount is not an integer - got: (${typeof baseCount}) "${baseCount}"`)
              const nonceDetails = { blockNumber, baseCount }
              return { name: 'network', nonce: baseCount, details: nonceDetails }
            }

            _getHighestLocallyConfirmed(address) {
              const confirmedTransactions = this.getConfirmedTransactions(address)
              const highest = this._getHighestNonce(confirmedTransactions)
              return Number.isInteger(highest) ? highest + 1 : 0
            }

            _getHighestNonce(txList) {
              const nonces = txList.map((txMeta) => {
                const nonce = txMeta.txParams.nonce
                assert(typeof nonce, 'string', 'nonces should be hex strings')
                return parseInt(nonce, 16)
              })
              const highestNonce = Math.max.apply(null, nonces)
              return highestNonce
            }

            /**
              @typedef {object} highestContinuousFrom
              @property {string} - name the name for how the nonce was calculated based on the data used
              @property {number} - nonce the next suggested nonce
              @property {object} - details the provided starting nonce that was used (for debugging)
            */
            /**
              @param txList {array} - list of txMeta's
              @param startPoint {number} - the highest known locally confirmed nonce
              @returns {highestContinuousFrom}
            */
            _getHighestContinuousFrom(txList, startPoint) {
              const nonces = txList.map((txMeta) => {
                const nonce = txMeta.txParams.nonce
                assert(typeof nonce, 'string', 'nonces should be hex strings')
                return parseInt(nonce, 16)
              })

              let highest = startPoint
              while (nonces.includes(highest)) {
                highest++
              }

              return { name: 'local', nonce: highest, details: { startPoint, highest } }
            }

          }

          module.exports = NonceTracker

        };
      };
    }
  }, { package: "nonce-tracker", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\remove-trailing-slash\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\remove-trailing-slash\index.js
        return function (require, module, exports) {

          /**
           * Remove trailing slashes from the given `str`
           *
           * @api public
           * @param {String} str
           * @return {String}
           */
          exports = module.exports = function (str) {
            return String(str).replace(exports.expr, '');
          };

          /**
           * Expose the regex
           *
           * @api private
           * @type {RegExp}
           */
          exports.expr = /\/+$/;

        };
      };
    }
  }, { package: "remove-trailing-slash", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\scryptsy\\lib\\scrypt.js", { "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "pbkdf2": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pbkdf2\\browser.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\scryptsy\lib\scrypt.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              var pbkdf2Sync = require('pbkdf2').pbkdf2Sync

              var MAX_VALUE = 0x7fffffff

              // N = Cpu cost, r = Memory cost, p = parallelization cost
              function scrypt(key, salt, N, r, p, dkLen, progressCallback) {
                if (N === 0 || (N & (N - 1)) !== 0) throw Error('N must be > 0 and a power of 2')

                if (N > MAX_VALUE / 128 / r) throw Error('Parameter N is too large')
                if (r > MAX_VALUE / 128 / p) throw Error('Parameter r is too large')

                var XY = new Buffer(256 * r)
                var V = new Buffer(128 * r * N)

                // pseudo global
                var B32 = new Int32Array(16) // salsa20_8
                var x = new Int32Array(16) // salsa20_8
                var _X = new Buffer(64) // blockmix_salsa8

                // pseudo global
                var B = pbkdf2Sync(key, salt, 1, p * 128 * r, 'sha256')

                var tickCallback
                if (progressCallback) {
                  var totalOps = p * N * 2
                  var currentOp = 0

                  tickCallback = function () {
                    ++currentOp

                    // send progress notifications once every 1,000 ops
                    if (currentOp % 1000 === 0) {
                      progressCallback({
                        current: currentOp,
                        total: totalOps,
                        percent: (currentOp / totalOps) * 100.0
                      })
                    }
                  }
                }

                for (var i = 0; i < p; i++) {
                  smix(B, i * 128 * r, r, N, V, XY)
                }

                return pbkdf2Sync(key, B, 1, dkLen, 'sha256')

                // all of these functions are actually moved to the top
                // due to function hoisting

                function smix(B, Bi, r, N, V, XY) {
                  var Xi = 0
                  var Yi = 128 * r
                  var i

                  B.copy(XY, Xi, Bi, Bi + Yi)

                  for (i = 0; i < N; i++) {
                    XY.copy(V, i * Yi, Xi, Xi + Yi)
                    blockmix_salsa8(XY, Xi, Yi, r)

                    if (tickCallback) tickCallback()
                  }

                  for (i = 0; i < N; i++) {
                    var offset = Xi + (2 * r - 1) * 64
                    var j = XY.readUInt32LE(offset) & (N - 1)
                    blockxor(V, j * Yi, XY, Xi, Yi)
                    blockmix_salsa8(XY, Xi, Yi, r)

                    if (tickCallback) tickCallback()
                  }

                  XY.copy(B, Bi, Xi, Xi + Yi)
                }

                function blockmix_salsa8(BY, Bi, Yi, r) {
                  var i

                  arraycopy(BY, Bi + (2 * r - 1) * 64, _X, 0, 64)

                  for (i = 0; i < 2 * r; i++) {
                    blockxor(BY, i * 64, _X, 0, 64)
                    salsa20_8(_X)
                    arraycopy(_X, 0, BY, Yi + (i * 64), 64)
                  }

                  for (i = 0; i < r; i++) {
                    arraycopy(BY, Yi + (i * 2) * 64, BY, Bi + (i * 64), 64)
                  }

                  for (i = 0; i < r; i++) {
                    arraycopy(BY, Yi + (i * 2 + 1) * 64, BY, Bi + (i + r) * 64, 64)
                  }
                }

                function R(a, b) {
                  return (a << b) | (a >>> (32 - b))
                }

                function salsa20_8(B) {
                  var i

                  for (i = 0; i < 16; i++) {
                    B32[i] = (B[i * 4 + 0] & 0xff) << 0
                    B32[i] |= (B[i * 4 + 1] & 0xff) << 8
                    B32[i] |= (B[i * 4 + 2] & 0xff) << 16
                    B32[i] |= (B[i * 4 + 3] & 0xff) << 24
                    // B32[i] = B.readUInt32LE(i*4)   <--- this is signficantly slower even in Node.js
                  }

                  arraycopy(B32, 0, x, 0, 16)

                  for (i = 8; i > 0; i -= 2) {
                    x[4] ^= R(x[0] + x[12], 7)
                    x[8] ^= R(x[4] + x[0], 9)
                    x[12] ^= R(x[8] + x[4], 13)
                    x[0] ^= R(x[12] + x[8], 18)
                    x[9] ^= R(x[5] + x[1], 7)
                    x[13] ^= R(x[9] + x[5], 9)
                    x[1] ^= R(x[13] + x[9], 13)
                    x[5] ^= R(x[1] + x[13], 18)
                    x[14] ^= R(x[10] + x[6], 7)
                    x[2] ^= R(x[14] + x[10], 9)
                    x[6] ^= R(x[2] + x[14], 13)
                    x[10] ^= R(x[6] + x[2], 18)
                    x[3] ^= R(x[15] + x[11], 7)
                    x[7] ^= R(x[3] + x[15], 9)
                    x[11] ^= R(x[7] + x[3], 13)
                    x[15] ^= R(x[11] + x[7], 18)
                    x[1] ^= R(x[0] + x[3], 7)
                    x[2] ^= R(x[1] + x[0], 9)
                    x[3] ^= R(x[2] + x[1], 13)
                    x[0] ^= R(x[3] + x[2], 18)
                    x[6] ^= R(x[5] + x[4], 7)
                    x[7] ^= R(x[6] + x[5], 9)
                    x[4] ^= R(x[7] + x[6], 13)
                    x[5] ^= R(x[4] + x[7], 18)
                    x[11] ^= R(x[10] + x[9], 7)
                    x[8] ^= R(x[11] + x[10], 9)
                    x[9] ^= R(x[8] + x[11], 13)
                    x[10] ^= R(x[9] + x[8], 18)
                    x[12] ^= R(x[15] + x[14], 7)
                    x[13] ^= R(x[12] + x[15], 9)
                    x[14] ^= R(x[13] + x[12], 13)
                    x[15] ^= R(x[14] + x[13], 18)
                  }

                  for (i = 0; i < 16; ++i) B32[i] = x[i] + B32[i]

                  for (i = 0; i < 16; i++) {
                    var bi = i * 4
                    B[bi + 0] = (B32[i] >> 0 & 0xff)
                    B[bi + 1] = (B32[i] >> 8 & 0xff)
                    B[bi + 2] = (B32[i] >> 16 & 0xff)
                    B[bi + 3] = (B32[i] >> 24 & 0xff)
                    // B.writeInt32LE(B32[i], i*4)  //<--- this is signficantly slower even in Node.js
                  }
                }

                // naive approach... going back to loop unrolling may yield additional performance
                function blockxor(S, Si, D, Di, len) {
                  for (var i = 0; i < len; i++) {
                    D[Di + i] ^= S[Si + i]
                  }
                }
              }

              function arraycopy(src, srcPos, dest, destPos, length) {
                if (Buffer.isBuffer(src) && Buffer.isBuffer(dest)) {
                  src.copy(dest, destPos, srcPos, srcPos + length)
                } else {
                  while (length--) {
                    dest[destPos++] = src[srcPos++]
                  }
                }
              }

              module.exports = scrypt

            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "ethereumjs-wallet>scryptsy", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\secp256k1\\elliptic.js", { "./lib": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\secp256k1\\lib\\index.js", "./lib/elliptic": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\secp256k1\\lib\\elliptic.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\secp256k1\elliptic.js
        return function (require, module, exports) {
          module.exports = require('./lib')(require('./lib/elliptic'))

        };
      };
    }
  }, { package: "ganache>secp256k1", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\secp256k1\\lib\\elliptic.js", { "elliptic": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\secp256k1\lib\elliptic.js
        return function (require, module, exports) {
          const EC = require('elliptic').ec

          const ec = new EC('secp256k1')
          const ecparams = ec.curve

          // Hack, we can not use bn.js@5, while elliptic uses bn.js@4
          // See https://github.com/indutny/elliptic/issues/191#issuecomment-569888758
          const BN = ecparams.n.constructor

          function loadCompressedPublicKey(first, xbuf) {
            let x = new BN(xbuf)

            // overflow
            if (x.cmp(ecparams.p) >= 0) return null
            x = x.toRed(ecparams.red)

            // compute corresponding Y
            let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
            if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

            return ec.keyPair({ pub: { x: x, y: y } })
          }

          function loadUncompressedPublicKey(first, xbuf, ybuf) {
            let x = new BN(xbuf)
            let y = new BN(ybuf)

            // overflow
            if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

            x = x.toRed(ecparams.red)
            y = y.toRed(ecparams.red)

            // is odd flag
            if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

            // x*x*x + b = y*y
            const x3 = x.redSqr().redIMul(x)
            if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

            return ec.keyPair({ pub: { x: x, y: y } })
          }

          function loadPublicKey(pubkey) {
            // length should be validated in interface
            const first = pubkey[0]
            switch (first) {
              case 0x02:
              case 0x03:
                if (pubkey.length !== 33) return null
                return loadCompressedPublicKey(first, pubkey.subarray(1, 33))
              case 0x04:
              case 0x06:
              case 0x07:
                if (pubkey.length !== 65) return null
                return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65))
              default:
                return null
            }
          }

          function savePublicKey(output, point) {
            const pubkey = point.encode(null, output.length === 33)
            // Loop should be faster because we do not need create extra Uint8Array
            // output.set(new Uint8Array(pubkey))
            for (let i = 0; i < output.length; ++i) output[i] = pubkey[i]
          }

          module.exports = {
            contextRandomize() {
              return 0
            },

            privateKeyVerify(seckey) {
              const bn = new BN(seckey)
              return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1
            },

            privateKeyNegate(seckey) {
              const bn = new BN(seckey)
              const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, 'be', 32)
              seckey.set(negate)
              return 0
            },

            privateKeyTweakAdd(seckey, tweak) {
              const bn = new BN(tweak)
              if (bn.cmp(ecparams.n) >= 0) return 1

              bn.iadd(new BN(seckey))
              if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
              if (bn.isZero()) return 1

              const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
              seckey.set(tweaked)

              return 0
            },

            privateKeyTweakMul(seckey, tweak) {
              let bn = new BN(tweak)
              if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

              bn.imul(new BN(seckey))
              if (bn.cmp(ecparams.n) >= 0) bn = bn.umod(ecparams.n)

              const tweaked = bn.toArrayLike(Uint8Array, 'be', 32)
              seckey.set(tweaked)

              return 0
            },

            publicKeyVerify(pubkey) {
              const pair = loadPublicKey(pubkey)
              return pair === null ? 1 : 0
            },

            publicKeyCreate(output, seckey) {
              const bn = new BN(seckey)
              if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) return 1

              const point = ec.keyFromPrivate(seckey).getPublic()
              savePublicKey(output, point)

              return 0
            },

            publicKeyConvert(output, pubkey) {
              const pair = loadPublicKey(pubkey)
              if (pair === null) return 1

              const point = pair.getPublic()
              savePublicKey(output, point)

              return 0
            },

            publicKeyNegate(output, pubkey) {
              const pair = loadPublicKey(pubkey)
              if (pair === null) return 1

              const point = pair.getPublic()
              point.y = point.y.redNeg()
              savePublicKey(output, point)

              return 0
            },

            publicKeyCombine(output, pubkeys) {
              const pairs = new Array(pubkeys.length)
              for (let i = 0; i < pubkeys.length; ++i) {
                pairs[i] = loadPublicKey(pubkeys[i])
                if (pairs[i] === null) return 1
              }

              let point = pairs[0].getPublic()
              for (let i = 1; i < pairs.length; ++i) point = point.add(pairs[i].pub)
              if (point.isInfinity()) return 2

              savePublicKey(output, point)

              return 0
            },

            publicKeyTweakAdd(output, pubkey, tweak) {
              const pair = loadPublicKey(pubkey)
              if (pair === null) return 1

              tweak = new BN(tweak)
              if (tweak.cmp(ecparams.n) >= 0) return 2

              const point = pair.getPublic().add(ecparams.g.mul(tweak))
              if (point.isInfinity()) return 2

              savePublicKey(output, point)

              return 0
            },

            publicKeyTweakMul(output, pubkey, tweak) {
              const pair = loadPublicKey(pubkey)
              if (pair === null) return 1

              tweak = new BN(tweak)
              if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) return 2

              const point = pair.getPublic().mul(tweak)
              savePublicKey(output, point)

              return 0
            },

            signatureNormalize(sig) {
              const r = new BN(sig.subarray(0, 32))
              const s = new BN(sig.subarray(32, 64))
              if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) return 1

              if (s.cmp(ec.nh) === 1) {
                sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, 'be', 32), 32)
              }

              return 0
            },

            // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
            // Adapted for Uint8Array instead Buffer
            signatureExport(obj, sig) {
              const sigR = sig.subarray(0, 32)
              const sigS = sig.subarray(32, 64)
              if (new BN(sigR).cmp(ecparams.n) >= 0) return 1
              if (new BN(sigS).cmp(ecparams.n) >= 0) return 1

              const { output } = obj

              // Prepare R
              let r = output.subarray(4, 4 + 33)
              r[0] = 0x00
              r.set(sigR, 1)

              let lenR = 33
              let posR = 0
              for (; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

              r = r.subarray(posR)
              if (r[0] & 0x80) return 1
              if (lenR > 1 && (r[0] === 0x00) && !(r[1] & 0x80)) return 1

              // Prepare S
              let s = output.subarray(6 + 33, 6 + 33 + 33)
              s[0] = 0x00
              s.set(sigS, 1)

              let lenS = 33
              let posS = 0
              for (; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

              s = s.subarray(posS)
              if (s[0] & 0x80) return 1
              if (lenS > 1 && (s[0] === 0x00) && !(s[1] & 0x80)) return 1

              // Set output length for return
              obj.outputlen = 6 + lenR + lenS

              // Output in specified format
              // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]
              output[0] = 0x30
              output[1] = obj.outputlen - 2
              output[2] = 0x02
              output[3] = r.length
              output.set(r, 4)
              output[4 + lenR] = 0x02
              output[5 + lenR] = s.length
              output.set(s, 6 + lenR)

              return 0
            },

            // Copied 1-to-1 from https://github.com/bitcoinjs/bip66/blob/master/index.js
            // Adapted for Uint8Array instead Buffer
            signatureImport(output, sig) {
              if (sig.length < 8) return 1
              if (sig.length > 72) return 1
              if (sig[0] !== 0x30) return 1
              if (sig[1] !== sig.length - 2) return 1
              if (sig[2] !== 0x02) return 1

              const lenR = sig[3]
              if (lenR === 0) return 1
              if (5 + lenR >= sig.length) return 1
              if (sig[4 + lenR] !== 0x02) return 1

              const lenS = sig[5 + lenR]
              if (lenS === 0) return 1
              if ((6 + lenR + lenS) !== sig.length) return 1

              if (sig[4] & 0x80) return 1
              if (lenR > 1 && (sig[4] === 0x00) && !(sig[5] & 0x80)) return 1

              if (sig[lenR + 6] & 0x80) return 1
              if (lenS > 1 && (sig[lenR + 6] === 0x00) && !(sig[lenR + 7] & 0x80)) return 1

              let sigR = sig.subarray(4, 4 + lenR)
              if (sigR.length === 33 && sigR[0] === 0x00) sigR = sigR.subarray(1)
              if (sigR.length > 32) return 1

              let sigS = sig.subarray(6 + lenR)
              if (sigS.length === 33 && sigS[0] === 0x00) sigS = sigS.slice(1)
              if (sigS.length > 32) throw new Error('S length is too long')

              let r = new BN(sigR)
              if (r.cmp(ecparams.n) >= 0) r = new BN(0)

              let s = new BN(sig.subarray(6 + lenR))
              if (s.cmp(ecparams.n) >= 0) s = new BN(0)

              output.set(r.toArrayLike(Uint8Array, 'be', 32), 0)
              output.set(s.toArrayLike(Uint8Array, 'be', 32), 32)

              return 0
            },

            ecdsaSign(obj, message, seckey, data, noncefn) {
              if (noncefn) {
                const _noncefn = noncefn
                noncefn = (counter) => {
                  const nonce = _noncefn(message, seckey, null, data, counter)

                  const isValid = nonce instanceof Uint8Array && nonce.length === 32
                  if (!isValid) throw new Error('This is the way')

                  return new BN(nonce)
                }
              }

              const d = new BN(seckey)
              if (d.cmp(ecparams.n) >= 0 || d.isZero()) return 1

              let sig
              try {
                sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data })
              } catch (err) {
                return 1
              }

              obj.signature.set(sig.r.toArrayLike(Uint8Array, 'be', 32), 0)
              obj.signature.set(sig.s.toArrayLike(Uint8Array, 'be', 32), 32)
              obj.recid = sig.recoveryParam

              return 0
            },

            ecdsaVerify(sig, msg32, pubkey) {
              const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) }

              const sigr = new BN(sigObj.r)
              const sigs = new BN(sigObj.s)
              if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1
              if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return 3

              const pair = loadPublicKey(pubkey)
              if (pair === null) return 2

              const point = pair.getPublic()
              const isValid = ec.verify(msg32, sigObj, point)
              return isValid ? 0 : 3
            },

            ecdsaRecover(output, sig, recid, msg32) {
              const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) }

              const sigr = new BN(sigObj.r)
              const sigs = new BN(sigObj.s)
              if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) return 1

              if (sigr.isZero() || sigs.isZero()) return 2

              // Can throw `throw new Error('Unable to find sencond key candinate');`
              let point
              try {
                point = ec.recoverPubKey(msg32, sigObj, recid)
              } catch (err) {
                return 2
              }

              savePublicKey(output, point)

              return 0
            },

            ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
              const pair = loadPublicKey(pubkey)
              if (pair === null) return 1

              const scalar = new BN(seckey)
              if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) return 2

              const point = pair.getPublic().mul(scalar)

              if (hashfn === undefined) {
                const data = point.encode(null, true)
                const sha256 = ec.hash().update(data).digest()
                for (let i = 0; i < 32; ++i) output[i] = sha256[i]
              } else {
                if (!xbuf) xbuf = new Uint8Array(32)
                const x = point.getX().toArray('be', 32)
                for (let i = 0; i < 32; ++i) xbuf[i] = x[i]

                if (!ybuf) ybuf = new Uint8Array(32)
                const y = point.getY().toArray('be', 32)
                for (let i = 0; i < 32; ++i) ybuf[i] = y[i]

                const hash = hashfn(xbuf, ybuf, data)

                const isValid = hash instanceof Uint8Array && hash.length === output.length
                if (!isValid) return 2

                output.set(hash)
              }

              return 0
            }
          }

        };
      };
    }
  }, { package: "ganache>secp256k1", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\secp256k1\\lib\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\secp256k1\lib\index.js
        return function (require, module, exports) {
          const errors = {
            IMPOSSIBLE_CASE: 'Impossible case. Please create issue.',
            TWEAK_ADD:
              'The tweak was out of range or the resulted private key is invalid',
            TWEAK_MUL: 'The tweak was out of range or equal to zero',
            CONTEXT_RANDOMIZE_UNKNOW: 'Unknow error on context randomization',
            SECKEY_INVALID: 'Private Key is invalid',
            PUBKEY_PARSE: 'Public Key could not be parsed',
            PUBKEY_SERIALIZE: 'Public Key serialization error',
            PUBKEY_COMBINE: 'The sum of the public keys is not valid',
            SIG_PARSE: 'Signature could not be parsed',
            SIGN: 'The nonce generation function failed, or the private key was invalid',
            RECOVER: 'Public key could not be recover',
            ECDH: 'Scalar was invalid (zero or overflow)'
          }

          function assert(cond, msg) {
            if (!cond) throw new Error(msg)
          }

          function isUint8Array(name, value, length) {
            assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`)

            if (length !== undefined) {
              if (Array.isArray(length)) {
                const numbers = length.join(', ')
                const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`
                assert(length.includes(value.length), msg)
              } else {
                const msg = `Expected ${name} to be an Uint8Array with length ${length}`
                assert(value.length === length, msg)
              }
            }
          }

          function isCompressed(value) {
            assert(toTypeString(value) === 'Boolean', 'Expected compressed to be a Boolean')
          }

          function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
            if (typeof output === 'function') output = output(length)
            isUint8Array('output', output, length)
            return output
          }

          function toTypeString(value) {
            return Object.prototype.toString.call(value).slice(8, -1)
          }

          module.exports = (secp256k1) => {
            return {
              contextRandomize(seed) {
                assert(
                  seed === null || seed instanceof Uint8Array,
                  'Expected seed to be an Uint8Array or null'
                )
                if (seed !== null) isUint8Array('seed', seed, 32)

                switch (secp256k1.contextRandomize(seed)) {
                  case 1:
                    throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW)
                }
              },

              privateKeyVerify(seckey) {
                isUint8Array('private key', seckey, 32)

                return secp256k1.privateKeyVerify(seckey) === 0
              },

              privateKeyNegate(seckey) {
                isUint8Array('private key', seckey, 32)

                switch (secp256k1.privateKeyNegate(seckey)) {
                  case 0:
                    return seckey
                  case 1:
                    throw new Error(errors.IMPOSSIBLE_CASE)
                }
              },

              privateKeyTweakAdd(seckey, tweak) {
                isUint8Array('private key', seckey, 32)
                isUint8Array('tweak', tweak, 32)

                switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
                  case 0:
                    return seckey
                  case 1:
                    throw new Error(errors.TWEAK_ADD)
                }
              },

              privateKeyTweakMul(seckey, tweak) {
                isUint8Array('private key', seckey, 32)
                isUint8Array('tweak', tweak, 32)

                switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
                  case 0:
                    return seckey
                  case 1:
                    throw new Error(errors.TWEAK_MUL)
                }
              },

              publicKeyVerify(pubkey) {
                isUint8Array('public key', pubkey, [33, 65])

                return secp256k1.publicKeyVerify(pubkey) === 0
              },

              publicKeyCreate(seckey, compressed = true, output) {
                isUint8Array('private key', seckey, 32)
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.publicKeyCreate(output, seckey)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.SECKEY_INVALID)
                  case 2:
                    throw new Error(errors.PUBKEY_SERIALIZE)
                }
              },

              publicKeyConvert(pubkey, compressed = true, output) {
                isUint8Array('public key', pubkey, [33, 65])
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.publicKeyConvert(output, pubkey)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.PUBKEY_PARSE)
                  case 2:
                    throw new Error(errors.PUBKEY_SERIALIZE)
                }
              },

              publicKeyNegate(pubkey, compressed = true, output) {
                isUint8Array('public key', pubkey, [33, 65])
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.publicKeyNegate(output, pubkey)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.PUBKEY_PARSE)
                  case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE)
                  case 3:
                    throw new Error(errors.PUBKEY_SERIALIZE)
                }
              },

              publicKeyCombine(pubkeys, compressed = true, output) {
                assert(Array.isArray(pubkeys), 'Expected public keys to be an Array')
                assert(pubkeys.length > 0, 'Expected public keys array will have more than zero items')
                for (const pubkey of pubkeys) {
                  isUint8Array('public key', pubkey, [33, 65])
                }
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.publicKeyCombine(output, pubkeys)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.PUBKEY_PARSE)
                  case 2:
                    throw new Error(errors.PUBKEY_COMBINE)
                  case 3:
                    throw new Error(errors.PUBKEY_SERIALIZE)
                }
              },

              publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
                isUint8Array('public key', pubkey, [33, 65])
                isUint8Array('tweak', tweak, 32)
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.PUBKEY_PARSE)
                  case 2:
                    throw new Error(errors.TWEAK_ADD)
                }
              },

              publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
                isUint8Array('public key', pubkey, [33, 65])
                isUint8Array('tweak', tweak, 32)
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.PUBKEY_PARSE)
                  case 2:
                    throw new Error(errors.TWEAK_MUL)
                }
              },

              signatureNormalize(sig) {
                isUint8Array('signature', sig, 64)

                switch (secp256k1.signatureNormalize(sig)) {
                  case 0:
                    return sig
                  case 1:
                    throw new Error(errors.SIG_PARSE)
                }
              },

              signatureExport(sig, output) {
                isUint8Array('signature', sig, 64)
                output = getAssertedOutput(output, 72)

                const obj = { output, outputlen: 72 }
                switch (secp256k1.signatureExport(obj, sig)) {
                  case 0:
                    return output.slice(0, obj.outputlen)
                  case 1:
                    throw new Error(errors.SIG_PARSE)
                  case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE)
                }
              },

              signatureImport(sig, output) {
                isUint8Array('signature', sig)
                output = getAssertedOutput(output, 64)

                switch (secp256k1.signatureImport(output, sig)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.SIG_PARSE)
                  case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE)
                }
              },

              ecdsaSign(msg32, seckey, options = {}, output) {
                isUint8Array('message', msg32, 32)
                isUint8Array('private key', seckey, 32)
                assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
                if (options.data !== undefined) isUint8Array('options.data', options.data)
                if (options.noncefn !== undefined) assert(toTypeString(options.noncefn) === 'Function', 'Expected options.noncefn to be a Function')
                output = getAssertedOutput(output, 64)

                const obj = { signature: output, recid: null }
                switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
                  case 0:
                    return obj
                  case 1:
                    throw new Error(errors.SIGN)
                  case 2:
                    throw new Error(errors.IMPOSSIBLE_CASE)
                }
              },

              ecdsaVerify(sig, msg32, pubkey) {
                isUint8Array('signature', sig, 64)
                isUint8Array('message', msg32, 32)
                isUint8Array('public key', pubkey, [33, 65])

                switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
                  case 0:
                    return true
                  case 3:
                    return false
                  case 1:
                    throw new Error(errors.SIG_PARSE)
                  case 2:
                    throw new Error(errors.PUBKEY_PARSE)
                }
              },

              ecdsaRecover(sig, recid, msg32, compressed = true, output) {
                isUint8Array('signature', sig, 64)
                assert(
                  toTypeString(recid) === 'Number' &&
                  recid >= 0 &&
                  recid <= 3,
                  'Expected recovery id to be a Number within interval [0, 3]'
                )
                isUint8Array('message', msg32, 32)
                isCompressed(compressed)
                output = getAssertedOutput(output, compressed ? 33 : 65)

                switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.SIG_PARSE)
                  case 2:
                    throw new Error(errors.RECOVER)
                  case 3:
                    throw new Error(errors.IMPOSSIBLE_CASE)
                }
              },

              ecdh(pubkey, seckey, options = {}, output) {
                isUint8Array('public key', pubkey, [33, 65])
                isUint8Array('private key', seckey, 32)
                assert(toTypeString(options) === 'Object', 'Expected options to be an Object')
                if (options.data !== undefined) isUint8Array('options.data', options.data)
                if (options.hashfn !== undefined) {
                  assert(toTypeString(options.hashfn) === 'Function', 'Expected options.hashfn to be a Function')
                  if (options.xbuf !== undefined) isUint8Array('options.xbuf', options.xbuf, 32)
                  if (options.ybuf !== undefined) isUint8Array('options.ybuf', options.ybuf, 32)
                  isUint8Array('output', output)
                } else {
                  output = getAssertedOutput(output, 32)
                }

                switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
                  case 0:
                    return output
                  case 1:
                    throw new Error(errors.PUBKEY_PARSE)
                  case 2:
                    throw new Error(errors.ECDH)
                }
              }
            }
          }

        };
      };
    }
  }, { package: "ganache>secp256k1", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\superstruct\\lib\\index.cjs", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\superstruct\lib\index.cjs
        return function (require, module, exports) {
          'use strict';

          Object.defineProperty(exports, '__esModule', { value: true });

          /**
           * A `StructFailure` represents a single specific failure in validation.
           */

          /**
           * `StructError` objects are thrown (or returned) when validation fails.
           *
           * Validation logic is design to exit early for maximum performance. The error
           * represents the first error encountered during validation. For more detail,
           * the `error.failures` property is a generator function that can be run to
           * continue validation and receive all the failures in the data.
           */
          class StructError extends TypeError {
            constructor(failure, failures) {
              let cached;
              const {
                message,
                ...rest
              } = failure;
              const {
                path
              } = failure;
              const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;
              super(msg);
              this.value = void 0;
              this.key = void 0;
              this.type = void 0;
              this.refinement = void 0;
              this.path = void 0;
              this.branch = void 0;
              this.failures = void 0;
              Object.assign(this, rest);
              this.name = this.constructor.name;

              this.failures = () => {
                return cached ?? (cached = [failure, ...failures()]);
              };
            }

          }

          /**
           * Check if a value is an iterator.
           */
          function isIterable(x) {
            return isObject(x) && typeof x[Symbol.iterator] === 'function';
          }
          /**
           * Check if a value is a plain object.
           */


          function isObject(x) {
            return typeof x === 'object' && x != null;
          }
          /**
           * Check if a value is a plain object.
           */

          function isPlainObject(x) {
            if (Object.prototype.toString.call(x) !== '[object Object]') {
              return false;
            }

            const prototype = Object.getPrototypeOf(x);
            return prototype === null || prototype === Object.prototype;
          }
          /**
           * Return a value as a printable string.
           */

          function print(value) {
            return typeof value === 'string' ? JSON.stringify(value) : `${value}`;
          }
          /**
           * Shifts (removes and returns) the first value from the `input` iterator.
           * Like `Array.prototype.shift()` but for an `Iterator`.
           */

          function shiftIterator(input) {
            const {
              done,
              value
            } = input.next();
            return done ? undefined : value;
          }
          /**
           * Convert a single validation result to a failure.
           */

          function toFailure(result, context, struct, value) {
            if (result === true) {
              return;
            } else if (result === false) {
              result = {};
            } else if (typeof result === 'string') {
              result = {
                message: result
              };
            }

            const {
              path,
              branch
            } = context;
            const {
              type
            } = struct;
            const {
              refinement,
              message = `Expected a value of type \`${type}\`${refinement ? ` with refinement \`${refinement}\`` : ''}, but received: \`${print(value)}\``
            } = result;
            return {
              value,
              type,
              refinement,
              key: path[path.length - 1],
              path,
              branch,
              ...result,
              message
            };
          }
          /**
           * Convert a validation result to an iterable of failures.
           */

          function* toFailures(result, context, struct, value) {
            if (!isIterable(result)) {
              result = [result];
            }

            for (const r of result) {
              const failure = toFailure(r, context, struct, value);

              if (failure) {
                yield failure;
              }
            }
          }
          /**
           * Check a value against a struct, traversing deeply into nested values, and
           * returning an iterator of failures or success.
           */

          function* run(value, struct, options) {
            if (options === void 0) {
              options = {};
            }

            const {
              path = [],
              branch = [value],
              coerce = false,
              mask = false
            } = options;
            const ctx = {
              path,
              branch
            };

            if (coerce) {
              value = struct.coercer(value, ctx);

              if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
                for (const key in value) {
                  if (struct.schema[key] === undefined) {
                    delete value[key];
                  }
                }
              }
            }

            let status = 'valid';

            for (const failure of struct.validator(value, ctx)) {
              status = 'not_valid';
              yield [failure, undefined];
            }

            for (let [k, v, s] of struct.entries(value, ctx)) {
              const ts = run(v, s, {
                path: k === undefined ? path : [...path, k],
                branch: k === undefined ? branch : [...branch, v],
                coerce,
                mask
              });

              for (const t of ts) {
                if (t[0]) {
                  status = t[0].refinement != null ? 'not_refined' : 'not_valid';
                  yield [t[0], undefined];
                } else if (coerce) {
                  v = t[1];

                  if (k === undefined) {
                    value = v;
                  } else if (value instanceof Map) {
                    value.set(k, v);
                  } else if (value instanceof Set) {
                    value.add(v);
                  } else if (isObject(value)) {
                    if (v !== undefined) value[k] = v;
                  }
                }
              }
            }

            if (status !== 'not_valid') {
              for (const failure of struct.refiner(value, ctx)) {
                status = 'not_refined';
                yield [failure, undefined];
              }
            }

            if (status === 'valid') {
              yield [undefined, value];
            }
          }

          /**
           * `Struct` objects encapsulate the validation logic for a specific type of
           * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
           * validate unknown input data against the struct.
           */

          class Struct {
            constructor(props) {
              this.TYPE = void 0;
              this.type = void 0;
              this.schema = void 0;
              this.coercer = void 0;
              this.validator = void 0;
              this.refiner = void 0;
              this.entries = void 0;
              const {
                type,
                schema,
                validator,
                refiner,
                coercer = value => value,
                entries = function* () { }
              } = props;
              this.type = type;
              this.schema = schema;
              this.entries = entries;
              this.coercer = coercer;

              if (validator) {
                this.validator = (value, context) => {
                  const result = validator(value, context);
                  return toFailures(result, context, this, value);
                };
              } else {
                this.validator = () => [];
              }

              if (refiner) {
                this.refiner = (value, context) => {
                  const result = refiner(value, context);
                  return toFailures(result, context, this, value);
                };
              } else {
                this.refiner = () => [];
              }
            }
            /**
             * Assert that a value passes the struct's validation, throwing if it doesn't.
             */


            assert(value) {
              return assert(value, this);
            }
            /**
             * Create a value with the struct's coercion logic, then validate it.
             */


            create(value) {
              return create(value, this);
            }
            /**
             * Check if a value passes the struct's validation.
             */


            is(value) {
              return is(value, this);
            }
            /**
             * Mask a value, coercing and validating it, but returning only the subset of
             * properties defined by the struct's schema.
             */


            mask(value) {
              return mask(value, this);
            }
            /**
             * Validate a value with the struct's validation logic, returning a tuple
             * representing the result.
             *
             * You may optionally pass `true` for the `withCoercion` argument to coerce
             * the value before attempting to validate it. If you do, the result will
             * contain the coerced result when successful.
             */


            validate(value, options) {
              if (options === void 0) {
                options = {};
              }

              return validate(value, this, options);
            }

          }
          /**
           * Assert that a value passes a struct, throwing if it doesn't.
           */

          function assert(value, struct) {
            const result = validate(value, struct);

            if (result[0]) {
              throw result[0];
            }
          }
          /**
           * Create a value with the coercion logic of struct and validate it.
           */

          function create(value, struct) {
            const result = validate(value, struct, {
              coerce: true
            });

            if (result[0]) {
              throw result[0];
            } else {
              return result[1];
            }
          }
          /**
           * Mask a value, returning only the subset of properties defined by a struct.
           */

          function mask(value, struct) {
            const result = validate(value, struct, {
              coerce: true,
              mask: true
            });

            if (result[0]) {
              throw result[0];
            } else {
              return result[1];
            }
          }
          /**
           * Check if a value passes a struct.
           */

          function is(value, struct) {
            const result = validate(value, struct);
            return !result[0];
          }
          /**
           * Validate a value against a struct, returning an error if invalid, or the
           * value (with potential coercion) if valid.
           */

          function validate(value, struct, options) {
            if (options === void 0) {
              options = {};
            }

            const tuples = run(value, struct, options);
            const tuple = shiftIterator(tuples);

            if (tuple[0]) {
              const error = new StructError(tuple[0], function* () {
                for (const t of tuples) {
                  if (t[0]) {
                    yield t[0];
                  }
                }
              });
              return [error, undefined];
            } else {
              const v = tuple[1];
              return [undefined, v];
            }
          }

          function assign() {
            for (var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++) {
              Structs[_key] = arguments[_key];
            }

            const isType = Structs[0].type === 'type';
            const schemas = Structs.map(s => s.schema);
            const schema = Object.assign({}, ...schemas);
            return isType ? type(schema) : object(schema);
          }
          /**
           * Define a new struct type with a custom validation function.
           */

          function define(name, validator) {
            return new Struct({
              type: name,
              schema: null,
              validator
            });
          }
          /**
           * Create a new struct based on an existing struct, but the value is allowed to
           * be `undefined`. `log` will be called if the value is not `undefined`.
           */

          function deprecated(struct, log) {
            return new Struct({
              ...struct,
              refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),

              validator(value, ctx) {
                if (value === undefined) {
                  return true;
                } else {
                  log(value, ctx);
                  return struct.validator(value, ctx);
                }
              }

            });
          }
          /**
           * Create a struct with dynamic validation logic.
           *
           * The callback will receive the value currently being validated, and must
           * return a struct object to validate it with. This can be useful to model
           * validation logic that changes based on its input.
           */

          function dynamic(fn) {
            return new Struct({
              type: 'dynamic',
              schema: null,

              *entries(value, ctx) {
                const struct = fn(value, ctx);
                yield* struct.entries(value, ctx);
              },

              validator(value, ctx) {
                const struct = fn(value, ctx);
                return struct.validator(value, ctx);
              },

              coercer(value, ctx) {
                const struct = fn(value, ctx);
                return struct.coercer(value, ctx);
              },

              refiner(value, ctx) {
                const struct = fn(value, ctx);
                return struct.refiner(value, ctx);
              }

            });
          }
          /**
           * Create a struct with lazily evaluated validation logic.
           *
           * The first time validation is run with the struct, the callback will be called
           * and must return a struct object to use. This is useful for cases where you
           * want to have self-referential structs for nested data structures to avoid a
           * circular definition problem.
           */

          function lazy(fn) {
            let struct;
            return new Struct({
              type: 'lazy',
              schema: null,

              *entries(value, ctx) {
                struct ?? (struct = fn());
                yield* struct.entries(value, ctx);
              },

              validator(value, ctx) {
                struct ?? (struct = fn());
                return struct.validator(value, ctx);
              },

              coercer(value, ctx) {
                struct ?? (struct = fn());
                return struct.coercer(value, ctx);
              },

              refiner(value, ctx) {
                struct ?? (struct = fn());
                return struct.refiner(value, ctx);
              }

            });
          }
          /**
           * Create a new struct based on an existing object struct, but excluding
           * specific properties.
           *
           * Like TypeScript's `Omit` utility.
           */

          function omit(struct, keys) {
            const {
              schema
            } = struct;
            const subschema = {
              ...schema
            };

            for (const key of keys) {
              delete subschema[key];
            }

            switch (struct.type) {
              case 'type':
                return type(subschema);

              default:
                return object(subschema);
            }
          }
          /**
           * Create a new struct based on an existing object struct, but with all of its
           * properties allowed to be `undefined`.
           *
           * Like TypeScript's `Partial` utility.
           */

          function partial(struct) {
            const schema = struct instanceof Struct ? {
              ...struct.schema
            } : {
              ...struct
            };

            for (const key in schema) {
              schema[key] = optional(schema[key]);
            }

            return object(schema);
          }
          /**
           * Create a new struct based on an existing object struct, but only including
           * specific properties.
           *
           * Like TypeScript's `Pick` utility.
           */

          function pick(struct, keys) {
            const {
              schema
            } = struct;
            const subschema = {};

            for (const key of keys) {
              subschema[key] = schema[key];
            }

            return object(subschema);
          }
          /**
           * Define a new struct type with a custom validation function.
           *
           * @deprecated This function has been renamed to `define`.
           */

          function struct(name, validator) {
            console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');
            return define(name, validator);
          }

          /**
           * Ensure that any value passes validation.
           */

          function any() {
            return define('any', () => true);
          }
          function array(Element) {
            return new Struct({
              type: 'array',
              schema: Element,

              *entries(value) {
                if (Element && Array.isArray(value)) {
                  for (const [i, v] of value.entries()) {
                    yield [i, v, Element];
                  }
                }
              },

              coercer(value) {
                return Array.isArray(value) ? value.slice() : value;
              },

              validator(value) {
                return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that a value is a bigint.
           */

          function bigint() {
            return define('bigint', value => {
              return typeof value === 'bigint';
            });
          }
          /**
           * Ensure that a value is a boolean.
           */

          function boolean() {
            return define('boolean', value => {
              return typeof value === 'boolean';
            });
          }
          /**
           * Ensure that a value is a valid `Date`.
           *
           * Note: this also ensures that the value is *not* an invalid `Date` object,
           * which can occur when parsing a date fails but still returns a `Date`.
           */

          function date() {
            return define('date', value => {
              return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \`Date\` object, but received: ${print(value)}`;
            });
          }
          function enums(values) {
            const schema = {};
            const description = values.map(v => print(v)).join();

            for (const key of values) {
              schema[key] = key;
            }

            return new Struct({
              type: 'enums',
              schema,

              validator(value) {
                return values.includes(value) || `Expected one of \`${description}\`, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that a value is a function.
           */

          function func() {
            return define('func', value => {
              return typeof value === 'function' || `Expected a function, but received: ${print(value)}`;
            });
          }
          /**
           * Ensure that a value is an instance of a specific class.
           */

          function instance(Class) {
            return define('instance', value => {
              return value instanceof Class || `Expected a \`${Class.name}\` instance, but received: ${print(value)}`;
            });
          }
          /**
           * Ensure that a value is an integer.
           */

          function integer() {
            return define('integer', value => {
              return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;
            });
          }
          /**
           * Ensure that a value matches all of a set of types.
           */

          function intersection(Structs) {
            return new Struct({
              type: 'intersection',
              schema: null,

              *entries(value, ctx) {
                for (const S of Structs) {
                  yield* S.entries(value, ctx);
                }
              },

              *validator(value, ctx) {
                for (const S of Structs) {
                  yield* S.validator(value, ctx);
                }
              },

              *refiner(value, ctx) {
                for (const S of Structs) {
                  yield* S.refiner(value, ctx);
                }
              }

            });
          }
          function literal(constant) {
            const description = print(constant);
            const t = typeof constant;
            return new Struct({
              type: 'literal',
              schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,

              validator(value) {
                return value === constant || `Expected the literal \`${description}\`, but received: ${print(value)}`;
              }

            });
          }
          function map(Key, Value) {
            return new Struct({
              type: 'map',
              schema: null,

              *entries(value) {
                if (Key && Value && value instanceof Map) {
                  for (const [k, v] of value.entries()) {
                    yield [k, k, Key];
                    yield [k, v, Value];
                  }
                }
              },

              coercer(value) {
                return value instanceof Map ? new Map(value) : value;
              },

              validator(value) {
                return value instanceof Map || `Expected a \`Map\` object, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that no value ever passes validation.
           */

          function never() {
            return define('never', () => false);
          }
          /**
           * Augment an existing struct to allow `null` values.
           */

          function nullable(struct) {
            return new Struct({
              ...struct,
              validator: (value, ctx) => value === null || struct.validator(value, ctx),
              refiner: (value, ctx) => value === null || struct.refiner(value, ctx)
            });
          }
          /**
           * Ensure that a value is a number.
           */

          function number() {
            return define('number', value => {
              return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${print(value)}`;
            });
          }
          function object(schema) {
            const knowns = schema ? Object.keys(schema) : [];
            const Never = never();
            return new Struct({
              type: 'object',
              schema: schema ? schema : null,

              *entries(value) {
                if (schema && isObject(value)) {
                  const unknowns = new Set(Object.keys(value));

                  for (const key of knowns) {
                    unknowns.delete(key);
                    yield [key, value[key], schema[key]];
                  }

                  for (const key of unknowns) {
                    yield [key, value[key], Never];
                  }
                }
              },

              validator(value) {
                return isObject(value) || `Expected an object, but received: ${print(value)}`;
              },

              coercer(value) {
                return isObject(value) ? {
                  ...value
                } : value;
              }

            });
          }
          /**
           * Augment a struct to allow `undefined` values.
           */

          function optional(struct) {
            return new Struct({
              ...struct,
              validator: (value, ctx) => value === undefined || struct.validator(value, ctx),
              refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)
            });
          }
          /**
           * Ensure that a value is an object with keys and values of specific types, but
           * without ensuring any specific shape of properties.
           *
           * Like TypeScript's `Record` utility.
           */

          function record(Key, Value) {
            return new Struct({
              type: 'record',
              schema: null,

              *entries(value) {
                if (isObject(value)) {
                  for (const k in value) {
                    const v = value[k];
                    yield [k, k, Key];
                    yield [k, v, Value];
                  }
                }
              },

              validator(value) {
                return isObject(value) || `Expected an object, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that a value is a `RegExp`.
           *
           * Note: this does not test the value against the regular expression! For that
           * you need to use the `pattern()` refinement.
           */

          function regexp() {
            return define('regexp', value => {
              return value instanceof RegExp;
            });
          }
          function set(Element) {
            return new Struct({
              type: 'set',
              schema: null,

              *entries(value) {
                if (Element && value instanceof Set) {
                  for (const v of value) {
                    yield [v, v, Element];
                  }
                }
              },

              coercer(value) {
                return value instanceof Set ? new Set(value) : value;
              },

              validator(value) {
                return value instanceof Set || `Expected a \`Set\` object, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that a value is a string.
           */

          function string() {
            return define('string', value => {
              return typeof value === 'string' || `Expected a string, but received: ${print(value)}`;
            });
          }
          /**
           * Ensure that a value is a tuple of a specific length, and that each of its
           * elements is of a specific type.
           */

          function tuple(Structs) {
            const Never = never();
            return new Struct({
              type: 'tuple',
              schema: null,

              *entries(value) {
                if (Array.isArray(value)) {
                  const length = Math.max(Structs.length, value.length);

                  for (let i = 0; i < length; i++) {
                    yield [i, value[i], Structs[i] || Never];
                  }
                }
              },

              validator(value) {
                return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that a value has a set of known properties of specific types.
           *
           * Note: Unrecognized properties are allowed and untouched. This is similar to
           * how TypeScript's structural typing works.
           */

          function type(schema) {
            const keys = Object.keys(schema);
            return new Struct({
              type: 'type',
              schema,

              *entries(value) {
                if (isObject(value)) {
                  for (const k of keys) {
                    yield [k, value[k], schema[k]];
                  }
                }
              },

              validator(value) {
                return isObject(value) || `Expected an object, but received: ${print(value)}`;
              }

            });
          }
          /**
           * Ensure that a value matches one of a set of types.
           */

          function union(Structs) {
            const description = Structs.map(s => s.type).join(' | ');
            return new Struct({
              type: 'union',
              schema: null,

              coercer(value, ctx) {
                const firstMatch = Structs.find(s => {
                  const [e] = s.validate(value, {
                    coerce: true
                  });
                  return !e;
                }) || unknown();
                return firstMatch.coercer(value, ctx);
              },

              validator(value, ctx) {
                const failures = [];

                for (const S of Structs) {
                  const [...tuples] = run(value, S, ctx);
                  const [first] = tuples;

                  if (!first[0]) {
                    return [];
                  } else {
                    for (const [failure] of tuples) {
                      if (failure) {
                        failures.push(failure);
                      }
                    }
                  }
                }

                return [`Expected the value to satisfy a union of \`${description}\`, but received: ${print(value)}`, ...failures];
              }

            });
          }
          /**
           * Ensure that any value passes validation, without widening its type to `any`.
           */

          function unknown() {
            return define('unknown', () => true);
          }

          /**
           * Augment a `Struct` to add an additional coercion step to its input.
           *
           * This allows you to transform input data before validating it, to increase the
           * likelihood that it passes validation—for example for default values, parsing
           * different formats, etc.
           *
           * Note: You must use `create(value, Struct)` on the value to have the coercion
           * take effect! Using simply `assert()` or `is()` will not use coercion.
           */

          function coerce(struct, condition, coercer) {
            return new Struct({
              ...struct,
              coercer: (value, ctx) => {
                return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);
              }
            });
          }
          /**
           * Augment a struct to replace `undefined` values with a default.
           *
           * Note: You must use `create(value, Struct)` on the value to have the coercion
           * take effect! Using simply `assert()` or `is()` will not use coercion.
           */

          function defaulted(struct, fallback, options) {
            if (options === void 0) {
              options = {};
            }

            return coerce(struct, unknown(), x => {
              const f = typeof fallback === 'function' ? fallback() : fallback;

              if (x === undefined) {
                return f;
              }

              if (!options.strict && isPlainObject(x) && isPlainObject(f)) {
                const ret = {
                  ...x
                };
                let changed = false;

                for (const key in f) {
                  if (ret[key] === undefined) {
                    ret[key] = f[key];
                    changed = true;
                  }
                }

                if (changed) {
                  return ret;
                }
              }

              return x;
            });
          }
          /**
           * Augment a struct to trim string inputs.
           *
           * Note: You must use `create(value, Struct)` on the value to have the coercion
           * take effect! Using simply `assert()` or `is()` will not use coercion.
           */

          function trimmed(struct) {
            return coerce(struct, string(), x => x.trim());
          }

          /**
           * Ensure that a string, array, map, or set is empty.
           */

          function empty(struct) {
            return refine(struct, 'empty', value => {
              const size = getSize(value);
              return size === 0 || `Expected an empty ${struct.type} but received one with a size of \`${size}\``;
            });
          }

          function getSize(value) {
            if (value instanceof Map || value instanceof Set) {
              return value.size;
            } else {
              return value.length;
            }
          }
          /**
           * Ensure that a number or date is below a threshold.
           */


          function max(struct, threshold, options) {
            if (options === void 0) {
              options = {};
            }

            const {
              exclusive
            } = options;
            return refine(struct, 'max', value => {
              return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
            });
          }
          /**
           * Ensure that a number or date is above a threshold.
           */

          function min(struct, threshold, options) {
            if (options === void 0) {
              options = {};
            }

            const {
              exclusive
            } = options;
            return refine(struct, 'min', value => {
              return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \`${value}\``;
            });
          }
          /**
           * Ensure that a string, array, map or set is not empty.
           */

          function nonempty(struct) {
            return refine(struct, 'nonempty', value => {
              const size = getSize(value);
              return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;
            });
          }
          /**
           * Ensure that a string matches a regular expression.
           */

          function pattern(struct, regexp) {
            return refine(struct, 'pattern', value => {
              return regexp.test(value) || `Expected a ${struct.type} matching \`/${regexp.source}/\` but received "${value}"`;
            });
          }
          /**
           * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.
           */

          function size(struct, min, max) {
            if (max === void 0) {
              max = min;
            }

            const expected = `Expected a ${struct.type}`;
            const of = min === max ? `of \`${min}\`` : `between \`${min}\` and \`${max}\``;
            return refine(struct, 'size', value => {
              if (typeof value === 'number' || value instanceof Date) {
                return min <= value && value <= max || `${expected} ${of} but received \`${value}\``;
              } else if (value instanceof Map || value instanceof Set) {
                const {
                  size
                } = value;
                return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \`${size}\``;
              } else {
                const {
                  length
                } = value;
                return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \`${length}\``;
              }
            });
          }
          /**
           * Augment a `Struct` to add an additional refinement to the validation.
           *
           * The refiner function is guaranteed to receive a value of the struct's type,
           * because the struct's existing validation will already have passed. This
           * allows you to layer additional validation on top of existing structs.
           */

          function refine(struct, name, refiner) {
            return new Struct({
              ...struct,

              *refiner(value, ctx) {
                yield* struct.refiner(value, ctx);
                const result = refiner(value, ctx);
                const failures = toFailures(result, ctx, struct, value);

                for (const failure of failures) {
                  yield {
                    ...failure,
                    refinement: name
                  };
                }
              }

            });
          }

          exports.Struct = Struct;
          exports.StructError = StructError;
          exports.any = any;
          exports.array = array;
          exports.assert = assert;
          exports.assign = assign;
          exports.bigint = bigint;
          exports.boolean = boolean;
          exports.coerce = coerce;
          exports.create = create;
          exports.date = date;
          exports.defaulted = defaulted;
          exports.define = define;
          exports.deprecated = deprecated;
          exports.dynamic = dynamic;
          exports.empty = empty;
          exports.enums = enums;
          exports.func = func;
          exports.instance = instance;
          exports.integer = integer;
          exports.intersection = intersection;
          exports.is = is;
          exports.lazy = lazy;
          exports.literal = literal;
          exports.map = map;
          exports.mask = mask;
          exports.max = max;
          exports.min = min;
          exports.never = never;
          exports.nonempty = nonempty;
          exports.nullable = nullable;
          exports.number = number;
          exports.object = object;
          exports.omit = omit;
          exports.optional = optional;
          exports.partial = partial;
          exports.pattern = pattern;
          exports.pick = pick;
          exports.record = record;
          exports.refine = refine;
          exports.regexp = regexp;
          exports.set = set;
          exports.size = size;
          exports.string = string;
          exports.struct = struct;
          exports.trimmed = trimmed;
          exports.tuple = tuple;
          exports.type = type;
          exports.union = union;
          exports.unknown = unknown;
          exports.validate = validate;
          //# sourceMappingURL=index.cjs.map

        };
      };
    }
  }, { package: "@metamask/snap-utils>superstruct", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\swappable-obj-proxy\\src\\createEventEmitterProxy.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\swappable-obj-proxy\src\createEventEmitterProxy.js
        return function (require, module, exports) {
          const filterNoop = () => true
          const internalEvents = ['newListener', 'removeListener']
          const externalEventFilter = (name) => !internalEvents.includes(name)

          module.exports = function createEventEmitterProxy(initialTarget, opts) {
            // parse options
            opts = opts || {}
            let eventFilter = opts.eventFilter || filterNoop
            if (eventFilter === 'skipInternal') eventFilter = externalEventFilter
            if (typeof eventFilter !== 'function') throw new Error('createEventEmitterProxy - Invalid eventFilter')

            let target = initialTarget

            const proxy = new Proxy({}, {
              get: (_, name) => {
                // override `setTarget` access
                if (name === 'setTarget') return setTarget
                return target[name]
              },
              set: (_, name, value) => {
                // allow `setTarget` overrides
                if (name === 'setTarget') {
                  setTarget = value
                  return true
                }
                target[name] = value
                return true
              },
            })

            return proxy

            function setTarget(newTarget) {
              const oldTarget = target
              target = newTarget
              // migrate listeners
              oldTarget.eventNames().filter(eventFilter).forEach((name) => {
                getRawListeners(oldTarget, name).forEach(handler => newTarget.on(name, handler))
              })
              // remove old
              oldTarget.removeAllListeners()
            }
          }

          function getRawListeners(eventEmitter, name) {
            // prefer native
            if (eventEmitter.rawListeners) return eventEmitter.rawListeners(name)
            // fallback to lookup against internal object
            let events = eventEmitter._events[name] || []
            // ensure array
            if (!Array.isArray(events)) events = [events]
            // return copy
            return events.slice()
          }

        };
      };
    }
  }, { package: "swappable-obj-proxy", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\swappable-obj-proxy\\src\\createSwappableProxy.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\swappable-obj-proxy\src\createSwappableProxy.js
        return function (require, module, exports) {

          module.exports = function createSwappableProxy(initialTarget) {
            let target = initialTarget

            const proxy = new Proxy({}, {
              get: (_, name) => {
                // override `setTarget` access
                if (name === 'setTarget') return setTarget
                return target[name]
              },
              set: (_, name, value) => {
                // allow `setTarget` overrides
                if (name === 'setTarget') {
                  setTarget = value
                  return true
                }
                target[name] = value
                return true
              },
            })

            return proxy

            function setTarget(newTarget) {
              target = newTarget
            }
          }

        };
      };
    }
  }, { package: "swappable-obj-proxy", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\swappable-obj-proxy\\src\\index.js", { "./createEventEmitterProxy": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\swappable-obj-proxy\\src\\createEventEmitterProxy.js", "./createSwappableProxy": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\swappable-obj-proxy\\src\\createSwappableProxy.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\swappable-obj-proxy\src\index.js
        return function (require, module, exports) {
          const createSwappableProxy = require('./createSwappableProxy')
          const createEventEmitterProxy = require('./createEventEmitterProxy')

          module.exports = {
            createSwappableProxy,
            createEventEmitterProxy,
          }

        };
      };
    }
  }, { package: "swappable-obj-proxy", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\through\\index.js", { "_process": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js", "stream": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\through\index.js
        return function (require, module, exports) {
          (function (process) {
            (function () {
              var Stream = require('stream')

              // through
              //
              // a stream that does nothing but re-emit the input.
              // useful for aggregating a series of changing but not ending streams into one stream)

              exports = module.exports = through
              through.through = through

              //create a readable writable stream.

              function through(write, end, opts) {
                write = write || function (data) { this.queue(data) }
                end = end || function () { this.queue(null) }

                var ended = false, destroyed = false, buffer = [], _ended = false
                var stream = new Stream()
                stream.readable = stream.writable = true
                stream.paused = false

                //  stream.autoPause   = !(opts && opts.autoPause   === false)
                stream.autoDestroy = !(opts && opts.autoDestroy === false)

                stream.write = function (data) {
                  write.call(this, data)
                  return !stream.paused
                }

                function drain() {
                  while (buffer.length && !stream.paused) {
                    var data = buffer.shift()
                    if (null === data)
                      return stream.emit('end')
                    else
                      stream.emit('data', data)
                  }
                }

                stream.queue = stream.push = function (data) {
                  //    console.error(ended)
                  if (_ended) return stream
                  if (data === null) _ended = true
                  buffer.push(data)
                  drain()
                  return stream
                }

                //this will be registered as the first 'end' listener
                //must call destroy next tick, to make sure we're after any
                //stream piped from here.
                //this is only a problem if end is not emitted synchronously.
                //a nicer way to do this is to make sure this is the last listener for 'end'

                stream.on('end', function () {
                  stream.readable = false
                  if (!stream.writable && stream.autoDestroy)
                    process.nextTick(function () {
                      stream.destroy()
                    })
                })

                function _end() {
                  stream.writable = false
                  end.call(stream)
                  if (!stream.readable && stream.autoDestroy)
                    stream.destroy()
                }

                stream.end = function (data) {
                  if (ended) return
                  ended = true
                  if (arguments.length) stream.write(data)
                  _end() // will emit or queue
                  return stream
                }

                stream.destroy = function () {
                  if (destroyed) return
                  destroyed = true
                  ended = true
                  buffer.length = 0
                  stream.writable = stream.readable = false
                  stream.emit('close')
                  return stream
                }

                stream.pause = function () {
                  if (stream.paused) return
                  stream.paused = true
                  return stream
                }

                stream.resume = function () {
                  if (stream.paused) {
                    stream.paused = false
                    stream.emit('resume')
                  }
                  drain()
                  //may have become paused again,
                  //as drain emits 'data'.
                  if (!stream.paused)
                    stream.emit('drain')
                  return stream
                }
                return stream
              }


            }).call(this)
          }).call(this, require('_process'))

        };
      };
    }
  }, { package: "debounce-stream>through", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\to-data-view\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\to-data-view\index.js
        return function (require, module, exports) {
          module.exports = function toDataView(data) {
            if (data instanceof Int8Array || data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
              return new DataView(data.buffer, data.byteOffset, data.byteLength)
            }

            if (data instanceof ArrayBuffer) {
              return new DataView(data)
            }

            throw new TypeError('Expected `data` to be an ArrayBuffer, Buffer, Int8Array, Uint8Array or Uint8ClampedArray')
          }

        };
      };
    }
  }, { package: "base32-encode>to-data-view", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\blockchain.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\blockchain.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.FIAT_RATES_UPDATE = exports.NOTIFICATION = exports.BLOCK = exports.CONNECT = exports.ERROR = void 0;
          // blockchain events
          var ERROR = 'blockchain-error';
          exports.ERROR = ERROR;
          var CONNECT = 'blockchain-connect';
          exports.CONNECT = CONNECT;
          var BLOCK = 'blockchain-block';
          exports.BLOCK = BLOCK;
          var NOTIFICATION = 'blockchain-notification';
          exports.NOTIFICATION = NOTIFICATION;
          var FIAT_RATES_UPDATE = 'fiat-rates-update';
          exports.FIAT_RATES_UPDATE = FIAT_RATES_UPDATE;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\cardano.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\cardano.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.POOL_RELAY_TYPE = exports.CERTIFICATE_TYPE = exports.ADDRESS_TYPE = exports.NETWORK_IDS = exports.PROTOCOL_MAGICS = void 0;
          var PROTOCOL_MAGICS = Object.freeze({
            mainnet: 764824073,
            testnet: 42
          });
          exports.PROTOCOL_MAGICS = PROTOCOL_MAGICS;
          var NETWORK_IDS = Object.freeze({
            mainnet: 1,
            testnet: 0
          }); // constants below are deprecated
          // use `CardanoAddressType`, `CardanoCertificateType` and `CardanoPoolRelayType` from protobuf instead

          exports.NETWORK_IDS = NETWORK_IDS;
          var ADDRESS_TYPE = Object.freeze({
            Base: 0,
            Pointer: 4,
            Enterprise: 6,
            Byron: 8,
            Reward: 14
          });
          exports.ADDRESS_TYPE = ADDRESS_TYPE;
          var CERTIFICATE_TYPE = Object.freeze({
            StakeRegistration: 0,
            StakeDeregistration: 1,
            StakeDelegation: 2,
            StakePoolRegistration: 3
          });
          exports.CERTIFICATE_TYPE = CERTIFICATE_TYPE;
          var POOL_RELAY_TYPE = Object.freeze({
            SingleHostIp: 0,
            SingleHostName: 1,
            MultipleHostName: 2
          });
          exports.POOL_RELAY_TYPE = POOL_RELAY_TYPE;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\device.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\device.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.WAIT_FOR_SELECTION = exports.WORD = exports.PASSPHRASE_ON_DEVICE = exports.PASSPHRASE = exports.PIN = exports.BUTTON = exports.LOADING = exports.USED_ELSEWHERE = exports.RELEASED = exports.ACQUIRED = exports.RELEASE = exports.ACQUIRE = exports.CHANGED = exports.DISCONNECT = exports.CONNECT_UNACQUIRED = exports.CONNECT = void 0;
          // device list events
          var CONNECT = 'device-connect';
          exports.CONNECT = CONNECT;
          var CONNECT_UNACQUIRED = 'device-connect_unacquired';
          exports.CONNECT_UNACQUIRED = CONNECT_UNACQUIRED;
          var DISCONNECT = 'device-disconnect';
          exports.DISCONNECT = DISCONNECT;
          var CHANGED = 'device-changed';
          exports.CHANGED = CHANGED;
          var ACQUIRE = 'device-acquire';
          exports.ACQUIRE = ACQUIRE;
          var RELEASE = 'device-release';
          exports.RELEASE = RELEASE;
          var ACQUIRED = 'device-acquired';
          exports.ACQUIRED = ACQUIRED;
          var RELEASED = 'device-released';
          exports.RELEASED = RELEASED;
          var USED_ELSEWHERE = 'device-used_elsewhere';
          exports.USED_ELSEWHERE = USED_ELSEWHERE;
          var LOADING = 'device-loading'; // trezor-link events in protobuf format

          exports.LOADING = LOADING;
          var BUTTON = 'button';
          exports.BUTTON = BUTTON;
          var PIN = 'pin';
          exports.PIN = PIN;
          var PASSPHRASE = 'passphrase';
          exports.PASSPHRASE = PASSPHRASE;
          var PASSPHRASE_ON_DEVICE = 'passphrase_on_device';
          exports.PASSPHRASE_ON_DEVICE = PASSPHRASE_ON_DEVICE;
          var WORD = 'word'; // custom

          exports.WORD = WORD;
          var WAIT_FOR_SELECTION = 'device-wait_for_selection';
          exports.WAIT_FOR_SELECTION = WAIT_FOR_SELECTION;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\errors.js", { "@babel/runtime/helpers/inheritsLoose": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@babel/runtime/helpers/wrapNativeSuper": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\wrapNativeSuper.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\errors.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.LIBUSB_ERROR_MESSAGE = exports.WEBUSB_ERROR_MESSAGE = exports.INVALID_PIN_ERROR_MESSAGE = exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = exports.TypedError = exports.TrezorError = exports.ERROR_CODES = void 0;

          var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

          var _wrapNativeSuper2 = _interopRequireDefault(require("@babel/runtime/helpers/wrapNativeSuper"));

          var ERROR_CODES = {
            Init_NotInitialized: 'TrezorConnect not yet initialized',
            // race condition: call on not initialized Core (usually hot-reloading)
            Init_AlreadyInitialized: 'TrezorConnect has been already initialized',
            // thrown by .init called multiple times
            Init_IframeBlocked: 'Iframe blocked',
            // iframe injection blocked (ad-blocker)
            Init_IframeTimeout: 'Iframe timeout',
            // iframe didn't load in specified time
            Init_ManifestMissing: 'Manifest not set. Read more at https://github.com/trezor/connect/blob/develop/docs/index.md',
            // manifest is not set
            Popup_ConnectionMissing: 'Unable to establish connection with iframe',
            // thrown by popup
            Transport_Missing: 'Transport is missing',
            // no transport available
            Transport_InvalidProtobuf: '',
            // generic error from transport layer (trezor-link)
            Method_InvalidPackage: 'This version of trezor-connect is not suitable to work without browser. Use trezor-connect@extended package instead',
            // thrown by node and react-native env while using regular 'web' package
            Method_InvalidParameter: '',
            // replaced by generic text
            Method_NotAllowed: 'Method not allowed for this configuration',
            // example: device management in popup mode
            Method_PermissionsNotGranted: 'Permissions not granted',
            // permission/confirmation not granted in popup
            Method_Cancel: 'Cancelled',
            // permission/confirmation not granted in popup OR .cancel() custom error
            Method_Interrupted: 'Popup closed',
            // interruption: popup closed
            Method_UnknownCoin: 'Coin not found',
            // coin definition not found
            Method_AddressNotMatch: 'Addresses do not match',
            // thrown by all getAddress methods with custom UI validation
            Method_FirmwareUpdate_DownloadFailed: 'Failed to download firmware binary',
            // thrown by FirmwareUpdate method
            Method_CustomMessage_Callback: 'Parameter "callback" is not a function',
            // thrown by CustomMessage method
            Method_Discovery_BundleException: '',
            // thrown by getAccountInfo method
            Method_Override: 'override',
            // inner "error", it's more like a interruption
            Method_NoResponse: 'Call resolved without response',
            // thrown by npm index(es), call to Core resolved without response, should not happen
            Backend_NotSupported: 'BlockchainLink settings not found in coins.json',
            // thrown by methods which using backends, blockchainLink not defined for this coin
            Backend_WorkerMissing: '',
            // thrown by BlockchainLink class, worker not specified
            Backend_Disconnected: 'Backend disconnected',
            // thrown by BlockchainLink class
            Backend_Invalid: 'Invalid backend',
            // thrown by BlockchainLink class, invalid backend (ie: backend for wrong coin set)
            Backend_Error: '',
            // thrown by BlockchainLink class, generic message from 'blockchain-link'
            Runtime: '',
            // thrown from several places, this shouldn't ever happen tho
            Device_NotFound: 'Device not found',
            Device_InitializeFailed: '',
            // generic error from firmware while calling "Initialize" message
            Device_FwException: '',
            // generic FirmwareException type
            Device_ModeException: '',
            // generic Device.UnexpectedMode type
            Device_Disconnected: 'Device disconnected',
            // device disconnected during call
            Device_UsedElsewhere: 'Device is used in another window',
            // interruption: current session toked by other application
            Device_InvalidState: 'Passphrase is incorrect',
            // authorization error (device state comparison)
            Device_CallInProgress: 'Device call in progress' // thrown when trying to make another call while current is still running

          };
          exports.ERROR_CODES = ERROR_CODES;

          var TrezorError = /*#__PURE__*/function (_Error) {
            (0, _inheritsLoose2["default"])(TrezorError, _Error);

            function TrezorError(code, message) {
              var _this;

              _this = _Error.call(this, message) || this;
              _this.code = code;
              _this.message = message;
              return _this;
            }

            return TrezorError;
          }( /*#__PURE__*/(0, _wrapNativeSuper2["default"])(Error));

          exports.TrezorError = TrezorError;

          var TypedError = function TypedError(id, message) {
            return new TrezorError(id, message || ERROR_CODES[id]);
          }; // a slight hack
          // this error string is hard-coded
          // in both bridge and extension


          exports.TypedError = TypedError;
          var WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = 'wrong previous session';
          exports.WRONG_PREVIOUS_SESSION_ERROR_MESSAGE = WRONG_PREVIOUS_SESSION_ERROR_MESSAGE;
          var INVALID_PIN_ERROR_MESSAGE = 'PIN invalid';
          exports.INVALID_PIN_ERROR_MESSAGE = INVALID_PIN_ERROR_MESSAGE;
          var WEBUSB_ERROR_MESSAGE = 'NetworkError: Unable to claim interface.'; // trezord error prefix.
          // user has insufficient permissions. may occur in Linux (missing udev rules), Windows and MacOS.

          exports.WEBUSB_ERROR_MESSAGE = WEBUSB_ERROR_MESSAGE;
          var LIBUSB_ERROR_MESSAGE = 'LIBUSB_ERROR';
          exports.LIBUSB_ERROR_MESSAGE = LIBUSB_ERROR_MESSAGE;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\iframe.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\iframe.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.CALL = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
          // Message called from iframe.html inline script before "window.onload" event. This is first message from iframe to window.opener.
          var BOOTSTRAP = 'iframe-bootstrap'; // Message from iframe.js to window.opener, called after "window.onload" event. This is second message from iframe to window.opener.

          exports.BOOTSTRAP = BOOTSTRAP;
          var LOADED = 'iframe-loaded'; // Message from window.opener to iframe.js

          exports.LOADED = LOADED;
          var INIT = 'iframe-init'; // Error message from iframe.js to window.opener. Could be thrown during iframe initialization process

          exports.INIT = INIT;
          var ERROR = 'iframe-error'; // Message from window.opener to iframe. Call method

          exports.ERROR = ERROR;
          var CALL = 'iframe-call';
          exports.CALL = CALL;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js", { "./blockchain": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\blockchain.js", "./cardano": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\cardano.js", "./device": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\device.js", "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\errors.js", "./iframe": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\iframe.js", "./network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\network.js", "./popup": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\popup.js", "./transport": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\transport.js", "./ui": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\ui.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\index.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.CARDANO = exports.UI = exports.TRANSPORT = exports.POPUP = exports.NETWORK = exports.IFRAME = exports.ERRORS = exports.DEVICE = exports.BLOCKCHAIN = exports.BLOCKCHAIN_EVENT = exports.RESPONSE_EVENT = exports.TRANSPORT_EVENT = exports.DEVICE_EVENT = exports.UI_EVENT = exports.CORE_EVENT = void 0;

          var BLOCKCHAIN = _interopRequireWildcard(require("./blockchain"));

          exports.BLOCKCHAIN = BLOCKCHAIN;

          var DEVICE = _interopRequireWildcard(require("./device"));

          exports.DEVICE = DEVICE;

          var ERRORS = _interopRequireWildcard(require("./errors"));

          exports.ERRORS = ERRORS;

          var IFRAME = _interopRequireWildcard(require("./iframe"));

          exports.IFRAME = IFRAME;

          var NETWORK = _interopRequireWildcard(require("./network"));

          exports.NETWORK = NETWORK;

          var POPUP = _interopRequireWildcard(require("./popup"));

          exports.POPUP = POPUP;

          var TRANSPORT = _interopRequireWildcard(require("./transport"));

          exports.TRANSPORT = TRANSPORT;

          var UI = _interopRequireWildcard(require("./ui"));

          exports.UI = UI;

          var CARDANO = _interopRequireWildcard(require("./cardano"));

          exports.CARDANO = CARDANO;

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          var CORE_EVENT = 'CORE_EVENT';
          exports.CORE_EVENT = CORE_EVENT;
          var UI_EVENT = 'UI_EVENT';
          exports.UI_EVENT = UI_EVENT;
          var DEVICE_EVENT = 'DEVICE_EVENT';
          exports.DEVICE_EVENT = DEVICE_EVENT;
          var TRANSPORT_EVENT = 'TRANSPORT_EVENT';
          exports.TRANSPORT_EVENT = TRANSPORT_EVENT;
          var RESPONSE_EVENT = 'RESPONSE_EVENT';
          exports.RESPONSE_EVENT = RESPONSE_EVENT;
          var BLOCKCHAIN_EVENT = 'BLOCKCHAIN_EVENT';
          exports.BLOCKCHAIN_EVENT = BLOCKCHAIN_EVENT;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\network.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\network.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.TYPES = void 0;
          var TYPES = Object.freeze({
            bitcoin: 'Bitcoin',
            ethereum: 'Ethereum',
            eos: 'Eos',
            nem: 'NEM',
            stellar: 'Stellar',
            cardano: 'Cardano',
            ripple: 'Ripple',
            tezos: 'Tezors',
            binance: 'Binance'
          });
          exports.TYPES = TYPES;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\popup.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\popup.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.CLOSE_WINDOW = exports.CANCEL_POPUP_REQUEST = exports.CLOSED = exports.HANDSHAKE = exports.EXTENSION_USB_PERMISSIONS = exports.ERROR = exports.INIT = exports.LOADED = exports.BOOTSTRAP = void 0;
          // Message called from popup.html inline script before "window.onload" event. This is first message from popup to window.opener.
          var BOOTSTRAP = 'popup-bootstrap'; // Message from popup.js to window.opener, called after "window.onload" event. This is second message from popup to window.opener.

          exports.BOOTSTRAP = BOOTSTRAP;
          var LOADED = 'popup-loaded'; // Message from window.opener to popup.js. Send settings to popup. This is first message from window.opener to popup.

          exports.LOADED = LOADED;
          var INIT = 'popup-init'; // Error message from popup to window.opener. Could be thrown during popup initialization process (POPUP.INIT)

          exports.INIT = INIT;
          var ERROR = 'popup-error'; // Message to webextensions, opens "trezor-usb-permission.html" within webextension

          exports.ERROR = ERROR;
          var EXTENSION_USB_PERMISSIONS = 'open-usb-permissions'; // Message called from both [popup > iframe] then [iframe > popup] in this exact order.
          // Firstly popup call iframe to resolve popup promise in Core
          // Then iframe reacts to POPUP.HANDSHAKE message and sends ConnectSettings, transport information and requested method details back to popup

          exports.EXTENSION_USB_PERMISSIONS = EXTENSION_USB_PERMISSIONS;
          var HANDSHAKE = 'popup-handshake'; // Event emitted from PopupManager at the end of popup closing process.
          // Sent from popup thru window.opener to an iframe because message channel between popup and iframe is no longer available

          exports.HANDSHAKE = HANDSHAKE;
          var CLOSED = 'popup-closed'; // Message called from iframe to popup, it means that popup will not be needed (example: Blockchain methods are not using popup at all)
          // This will close active popup window and/or clear opening process in PopupManager (maybe popup wasn't opened yet)

          exports.CLOSED = CLOSED;
          var CANCEL_POPUP_REQUEST = 'ui-cancel-popup-request'; // Message called from inline element in popup.html (window.closeWindow), this is used only with webextensions to properly handle popup close event

          exports.CANCEL_POPUP_REQUEST = CANCEL_POPUP_REQUEST;
          var CLOSE_WINDOW = 'window.close';
          exports.CLOSE_WINDOW = CLOSE_WINDOW;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\transport.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\transport.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.START_PENDING = exports.DISABLE_WEBUSB = exports.REQUEST = exports.STREAM = exports.UPDATE = exports.ERROR = exports.START = void 0;
          var START = 'transport-start';
          exports.START = START;
          var ERROR = 'transport-error';
          exports.ERROR = ERROR;
          var UPDATE = 'transport-update';
          exports.UPDATE = UPDATE;
          var STREAM = 'transport-stream';
          exports.STREAM = STREAM;
          var REQUEST = 'transport-request_device';
          exports.REQUEST = REQUEST;
          var DISABLE_WEBUSB = 'transport-disable_webusb';
          exports.DISABLE_WEBUSB = DISABLE_WEBUSB;
          var START_PENDING = 'transport-start_pending';
          exports.START_PENDING = START_PENDING;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\ui.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\constants\ui.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.IFRAME_FAILURE = exports.ADDRESS_VALIDATION = exports.BUNDLE_PROGRESS = exports.LOGIN_CHALLENGE_RESPONSE = exports.LOGIN_CHALLENGE_REQUEST = exports.CUSTOM_MESSAGE_RESPONSE = exports.CUSTOM_MESSAGE_REQUEST = exports.CHANGE_SETTINGS = exports.RECEIVE_WORD = exports.RECEIVE_FEE = exports.RECEIVE_ACCOUNT = exports.CHANGE_ACCOUNT = exports.RECEIVE_DEVICE = exports.RECEIVE_PASSPHRASE = exports.RECEIVE_PIN = exports.RECEIVE_CONFIRMATION = exports.RECEIVE_PERMISSION = exports.REQUEST_WORD = exports.REQUEST_BUTTON = exports.INSUFFICIENT_FUNDS = exports.UPDATE_CUSTOM_FEE = exports.SELECT_FEE = exports.SELECT_ACCOUNT = exports.SELECT_DEVICE = exports.SET_OPERATION = exports.LOADING = exports.CONNECT = exports.INVALID_PASSPHRASE_ACTION = exports.INVALID_PASSPHRASE = exports.REQUEST_PASSPHRASE_ON_DEVICE = exports.REQUEST_PASSPHRASE = exports.INVALID_PIN = exports.REQUEST_PIN = exports.REQUEST_CONFIRMATION = exports.REQUEST_PERMISSION = exports.CLOSE_UI_WINDOW = exports.REQUEST_UI_WINDOW = exports.DEVICE_NEEDS_BACKUP = exports.FIRMWARE_PROGRESS = exports.FIRMWARE_NOT_INSTALLED = exports.FIRMWARE_NOT_COMPATIBLE = exports.FIRMWARE_NOT_SUPPORTED = exports.FIRMWARE_OUTDATED = exports.FIRMWARE_OLD = exports.SEEDLESS = exports.INITIALIZE = exports.REQUIRE_MODE = exports.NOT_IN_BOOTLOADER = exports.BOOTLOADER = exports.TRANSPORT = void 0;
          var TRANSPORT = 'ui-no_transport';
          exports.TRANSPORT = TRANSPORT;
          var BOOTLOADER = 'ui-device_bootloader_mode';
          exports.BOOTLOADER = BOOTLOADER;
          var NOT_IN_BOOTLOADER = 'ui-device_not_in_bootloader_mode';
          exports.NOT_IN_BOOTLOADER = NOT_IN_BOOTLOADER;
          var REQUIRE_MODE = 'ui-device_require_mode';
          exports.REQUIRE_MODE = REQUIRE_MODE;
          var INITIALIZE = 'ui-device_not_initialized';
          exports.INITIALIZE = INITIALIZE;
          var SEEDLESS = 'ui-device_seedless';
          exports.SEEDLESS = SEEDLESS;
          var FIRMWARE_OLD = 'ui-device_firmware_old';
          exports.FIRMWARE_OLD = FIRMWARE_OLD;
          var FIRMWARE_OUTDATED = 'ui-device_firmware_outdated';
          exports.FIRMWARE_OUTDATED = FIRMWARE_OUTDATED;
          var FIRMWARE_NOT_SUPPORTED = 'ui-device_firmware_unsupported';
          exports.FIRMWARE_NOT_SUPPORTED = FIRMWARE_NOT_SUPPORTED;
          var FIRMWARE_NOT_COMPATIBLE = 'ui-device_firmware_not_compatible';
          exports.FIRMWARE_NOT_COMPATIBLE = FIRMWARE_NOT_COMPATIBLE;
          var FIRMWARE_NOT_INSTALLED = 'ui-device_firmware_not_installed';
          exports.FIRMWARE_NOT_INSTALLED = FIRMWARE_NOT_INSTALLED;
          var FIRMWARE_PROGRESS = 'ui-firmware-progress';
          exports.FIRMWARE_PROGRESS = FIRMWARE_PROGRESS;
          var DEVICE_NEEDS_BACKUP = 'ui-device_needs_backup';
          exports.DEVICE_NEEDS_BACKUP = DEVICE_NEEDS_BACKUP;
          var REQUEST_UI_WINDOW = 'ui-request_window';
          exports.REQUEST_UI_WINDOW = REQUEST_UI_WINDOW;
          var CLOSE_UI_WINDOW = 'ui-close_window';
          exports.CLOSE_UI_WINDOW = CLOSE_UI_WINDOW;
          var REQUEST_PERMISSION = 'ui-request_permission';
          exports.REQUEST_PERMISSION = REQUEST_PERMISSION;
          var REQUEST_CONFIRMATION = 'ui-request_confirmation';
          exports.REQUEST_CONFIRMATION = REQUEST_CONFIRMATION;
          var REQUEST_PIN = 'ui-request_pin';
          exports.REQUEST_PIN = REQUEST_PIN;
          var INVALID_PIN = 'ui-invalid_pin';
          exports.INVALID_PIN = INVALID_PIN;
          var REQUEST_PASSPHRASE = 'ui-request_passphrase';
          exports.REQUEST_PASSPHRASE = REQUEST_PASSPHRASE;
          var REQUEST_PASSPHRASE_ON_DEVICE = 'ui-request_passphrase_on_device';
          exports.REQUEST_PASSPHRASE_ON_DEVICE = REQUEST_PASSPHRASE_ON_DEVICE;
          var INVALID_PASSPHRASE = 'ui-invalid_passphrase';
          exports.INVALID_PASSPHRASE = INVALID_PASSPHRASE;
          var INVALID_PASSPHRASE_ACTION = 'ui-invalid_passphrase_action';
          exports.INVALID_PASSPHRASE_ACTION = INVALID_PASSPHRASE_ACTION;
          var CONNECT = 'ui-connect';
          exports.CONNECT = CONNECT;
          var LOADING = 'ui-loading';
          exports.LOADING = LOADING;
          var SET_OPERATION = 'ui-set_operation';
          exports.SET_OPERATION = SET_OPERATION;
          var SELECT_DEVICE = 'ui-select_device';
          exports.SELECT_DEVICE = SELECT_DEVICE;
          var SELECT_ACCOUNT = 'ui-select_account';
          exports.SELECT_ACCOUNT = SELECT_ACCOUNT;
          var SELECT_FEE = 'ui-select_fee';
          exports.SELECT_FEE = SELECT_FEE;
          var UPDATE_CUSTOM_FEE = 'ui-update_custom_fee';
          exports.UPDATE_CUSTOM_FEE = UPDATE_CUSTOM_FEE;
          var INSUFFICIENT_FUNDS = 'ui-insufficient_funds';
          exports.INSUFFICIENT_FUNDS = INSUFFICIENT_FUNDS;
          var REQUEST_BUTTON = 'ui-button';
          exports.REQUEST_BUTTON = REQUEST_BUTTON;
          var REQUEST_WORD = 'ui-request_word';
          exports.REQUEST_WORD = REQUEST_WORD;
          var RECEIVE_PERMISSION = 'ui-receive_permission';
          exports.RECEIVE_PERMISSION = RECEIVE_PERMISSION;
          var RECEIVE_CONFIRMATION = 'ui-receive_confirmation';
          exports.RECEIVE_CONFIRMATION = RECEIVE_CONFIRMATION;
          var RECEIVE_PIN = 'ui-receive_pin';
          exports.RECEIVE_PIN = RECEIVE_PIN;
          var RECEIVE_PASSPHRASE = 'ui-receive_passphrase';
          exports.RECEIVE_PASSPHRASE = RECEIVE_PASSPHRASE;
          var RECEIVE_DEVICE = 'ui-receive_device';
          exports.RECEIVE_DEVICE = RECEIVE_DEVICE;
          var CHANGE_ACCOUNT = 'ui-change_account';
          exports.CHANGE_ACCOUNT = CHANGE_ACCOUNT;
          var RECEIVE_ACCOUNT = 'ui-receive_account';
          exports.RECEIVE_ACCOUNT = RECEIVE_ACCOUNT;
          var RECEIVE_FEE = 'ui-receive_fee';
          exports.RECEIVE_FEE = RECEIVE_FEE;
          var RECEIVE_WORD = 'ui-receive_word';
          exports.RECEIVE_WORD = RECEIVE_WORD;
          var CHANGE_SETTINGS = 'ui-change_settings';
          exports.CHANGE_SETTINGS = CHANGE_SETTINGS;
          var CUSTOM_MESSAGE_REQUEST = 'ui-custom_request';
          exports.CUSTOM_MESSAGE_REQUEST = CUSTOM_MESSAGE_REQUEST;
          var CUSTOM_MESSAGE_RESPONSE = 'ui-custom_response';
          exports.CUSTOM_MESSAGE_RESPONSE = CUSTOM_MESSAGE_RESPONSE;
          var LOGIN_CHALLENGE_REQUEST = 'ui-login_challenge_request';
          exports.LOGIN_CHALLENGE_REQUEST = LOGIN_CHALLENGE_REQUEST;
          var LOGIN_CHALLENGE_RESPONSE = 'ui-login_challenge_response';
          exports.LOGIN_CHALLENGE_RESPONSE = LOGIN_CHALLENGE_RESPONSE;
          var BUNDLE_PROGRESS = 'ui-bundle_progress';
          exports.BUNDLE_PROGRESS = BUNDLE_PROGRESS;
          var ADDRESS_VALIDATION = 'ui-address_validation';
          exports.ADDRESS_VALIDATION = ADDRESS_VALIDATION;
          var IFRAME_FAILURE = 'ui-iframe_failure';
          exports.IFRAME_FAILURE = IFRAME_FAILURE;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\data\\ConnectSettings.js", { "@babel/runtime/helpers/defineProperty": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\data\ConnectSettings.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.parse = exports.corsValidator = exports.getEnv = exports.DEFAULT_PRIORITY = void 0;

          var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

          function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

          function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

          /*
           * Initial settings for connect.
           * It could be changed by passing values into TrezorConnect.init(...) method
           */
          var VERSION = '8.2.6';
          var versionN = VERSION.split('.').map(function (s) {
            return parseInt(s, 10);
          }); // const DIRECTORY = `${ versionN[0] }${ (versionN[1] > 0 ? `.${versionN[1]}` : '') }/`;

          var DIRECTORY = versionN[0] + "/";
          var DEFAULT_DOMAIN = "https://connect.trezor.io/" + DIRECTORY;
          var DEFAULT_PRIORITY = 2;
          exports.DEFAULT_PRIORITY = DEFAULT_PRIORITY;
          var initialSettings = {
            configSrc: './data/config.json',
            // constant
            version: VERSION,
            // constant
            debug: false,
            priority: DEFAULT_PRIORITY,
            trustedHost: false,
            connectSrc: DEFAULT_DOMAIN,
            iframeSrc: DEFAULT_DOMAIN + "iframe.html",
            popup: true,
            popupSrc: DEFAULT_DOMAIN + "popup.html",
            webusbSrc: DEFAULT_DOMAIN + "webusb.html",
            transportReconnect: false,
            webusb: true,
            pendingTransportEvent: true,
            supportedBrowser: typeof navigator !== 'undefined' ? !/Trident|MSIE|Edge/.test(navigator.userAgent) : true,
            manifest: null,
            env: 'web',
            lazyLoad: false,
            timestamp: new Date().getTime(),
            interactionTimeout: 600 // 5 minutes

          };
          var currentSettings = initialSettings;

          var parseManifest = function parseManifest(manifest) {
            if (!manifest) return;
            if (typeof manifest.email !== 'string') return;
            if (typeof manifest.appUrl !== 'string') return;
            return {
              email: manifest.email,
              appUrl: manifest.appUrl
            };
          };

          var getEnv = function getEnv() {
            // $FlowIssue: chrome is not declared outside the project
            if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
              return 'webextension';
            }

            if (typeof navigator !== 'undefined') {
              if (typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
                return 'react-native';
              }

              var userAgent = navigator.userAgent.toLowerCase();

              if (userAgent.indexOf(' electron/') > -1) {
                return 'electron';
              }
            } // if (typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative') {
            //     return 'react-native';
            // }
            // if (typeof process !== 'undefined' && process.versions.hasOwnProperty('electron')) {
            //     return 'electron';
            // }


            return 'web';
          }; // Cors validation copied from Trezor Bridge
          // see: https://github.com/trezor/trezord-go/blob/05991cea5900d18bcc6ece5ae5e319d138fc5551/server/api/api.go#L229
          // Its pointless to allow `trezor-connect` endpoints { connectSrc } for domains other than listed below
          // `trezord` will block communication anyway


          exports.getEnv = getEnv;

          var corsValidator = function corsValidator(url) {
            if (typeof url !== 'string') return;
            if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*trezor\.io\//)) return url;
            if (url.match(/^https?:\/\/localhost:[58][0-9]{3}\//)) return url;
            if (url.match(/^https:\/\/([A-Za-z0-9\-_]+\.)*sldev\.cz\//)) return url;
            if (url.match(/^https?:\/\/([A-Za-z0-9\-_]+\.)*trezoriovpjcahpzkrewelclulmszwbqpzmzgub37gbcjlvluxtruqad\.onion\//)) return url;
          };

          exports.corsValidator = corsValidator;

          var parse = function parse(input) {
            if (input === void 0) {
              input = {};
            }

            var settings = _objectSpread({}, currentSettings);

            if (Object.prototype.hasOwnProperty.call(input, 'debug')) {
              if (Array.isArray(input)) {// enable log with prefix
              }

              if (typeof input.debug === 'boolean') {
                settings.debug = input.debug;
              } else if (typeof input.debug === 'string') {
                settings.debug = input.debug === 'true';
              }
            }

            if (typeof input.connectSrc === 'string') {
              settings.connectSrc = input.connectSrc;
            } // For debugging purposes `connectSrc` could be defined in `global.__TREZOR_CONNECT_SRC` variable


            if (typeof global !== 'undefined' && typeof global.__TREZOR_CONNECT_SRC === 'string') {
              settings.connectSrc = corsValidator(global.__TREZOR_CONNECT_SRC);
              settings.debug = true;
            } // For debugging purposes `connectSrc` could be defined in url query of hosting page. Usage:
            // https://3rdparty-page.com/?trezor-connect-src=https://localhost:8088/


            if (typeof window !== 'undefined' && window.location && typeof window.location.search === 'string') {
              var vars = window.location.search.split('&');
              var customUrl = vars.find(function (v) {
                return v.indexOf('trezor-connect-src') >= 0;
              });

              if (customUrl) {
                var _customUrl$split = customUrl.split('='),
                  connectSrc = _customUrl$split[1];

                settings.connectSrc = corsValidator(decodeURIComponent(connectSrc));
                settings.debug = true;
              }
            }

            var src = settings.connectSrc || DEFAULT_DOMAIN;
            settings.iframeSrc = src + "iframe.html";
            settings.popupSrc = src + "popup.html";
            settings.webusbSrc = src + "webusb.html";

            if (typeof input.transportReconnect === 'boolean') {
              settings.transportReconnect = input.transportReconnect;
            }

            if (typeof input.webusb === 'boolean') {
              settings.webusb = input.webusb;
            }

            if (typeof input.popup === 'boolean') {
              settings.popup = input.popup;
            }

            if (typeof input.lazyLoad === 'boolean') {
              settings.lazyLoad = input.lazyLoad;
            }

            if (typeof input.pendingTransportEvent === 'boolean') {
              settings.pendingTransportEvent = input.pendingTransportEvent;
            } // local files


            if (typeof window !== 'undefined' && window.location && window.location.protocol === 'file:') {
              settings.origin = "file://" + window.location.pathname;
              settings.webusb = false;
            }

            if (typeof input.extension === 'string') {
              settings.extension = input.extension;
            }

            if (typeof input.env === 'string') {
              settings.env = input.env;
            } else {
              settings.env = getEnv();
            }

            if (typeof input.timestamp === 'number') {
              settings.timestamp = input.timestamp;
            }

            if (typeof input.interactionTimeout === 'number') {
              settings.interactionTimeout = input.interactionTimeout;
            }

            if (typeof input.manifest === 'object') {
              settings.manifest = parseManifest(input.manifest);
            }

            currentSettings = settings;
            return currentSettings;
          };

          exports.parse = parse;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\env\\browser\\index.js", { "../../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js", "../../data/ConnectSettings": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\data\\ConnectSettings.js", "../../iframe/builder": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\iframe\\builder.js", "../../message": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\message\\index.js", "../../message/builder": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\message\\builder.js", "../../popup/PopupManager": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\popup\\PopupManager.js", "../../types": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\index.js", "../../utils/debug": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\utils\\debug.js", "../../webusb/button": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\webusb\\button.js", "@babel/runtime/helpers/asyncToGenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js", "@babel/runtime/helpers/defineProperty": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@babel/runtime/regenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\regenerator\\index.js", "events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\env\browser\index.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.disableWebUSB = exports.requestLogin = exports.customMessage = exports.getSettings = exports.renderWebUSBButton = exports.uiResponse = exports.call = exports.init = exports.cancel = exports.dispose = exports.manifest = exports.eventEmitter = void 0;

          var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

          var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

          var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

          var _events = _interopRequireDefault(require("events"));

          var _PopupManager = _interopRequireDefault(require("../../popup/PopupManager"));

          var iframe = _interopRequireWildcard(require("../../iframe/builder"));

          var _button = _interopRequireDefault(require("../../webusb/button"));

          var _message = require("../../message");

          var _builder2 = require("../../message/builder");

          var _ConnectSettings = require("../../data/ConnectSettings");

          var _debug = require("../../utils/debug");

          var _constants = require("../../constants");

          var $T = _interopRequireWildcard(require("../../types"));

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

          function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

          var eventEmitter = new _events["default"]();
          exports.eventEmitter = eventEmitter;

          var _log = (0, _debug.initLog)('[trezor-connect.js]');

          var _settings;

          var _popupManager;

          var initPopupManager = function initPopupManager() {
            var pm = new _PopupManager["default"](_settings);
            pm.on(_constants.POPUP.CLOSED, function (error) {
              iframe.postMessage({
                type: _constants.POPUP.CLOSED,
                payload: error ? {
                  error: error
                } : null
              }, false);
            });
            return pm;
          };

          var manifest = function manifest(data) {
            _settings = (0, _ConnectSettings.parse)({
              manifest: data
            });
          };

          exports.manifest = manifest;

          var dispose = function dispose() {
            eventEmitter.removeAllListeners();
            iframe.dispose();

            if (_popupManager) {
              _popupManager.close();
            }
          };

          exports.dispose = dispose;

          var cancel = function cancel(error) {
            if (_popupManager) {
              _popupManager.emit(_constants.POPUP.CLOSED, error);
            }
          }; // handle message received from iframe


          exports.cancel = cancel;

          var handleMessage = function handleMessage(messageEvent) {
            // ignore messages from domain other then iframe origin
            if (messageEvent.origin !== iframe.origin) return;
            var message = (0, _message.parseMessage)(messageEvent.data);
            var event = message.event,
              type = message.type,
              payload = message.payload;
            var id = message.id || 0;

            _log.log('handleMessage', message);

            switch (event) {
              case _constants.RESPONSE_EVENT:
                if (iframe.messagePromises[id]) {
                  // resolve message promise (send result of call method)
                  iframe.messagePromises[id].resolve({
                    id: id,
                    success: message.success,
                    payload: payload
                  });
                  delete iframe.messagePromises[id];
                } else {
                  _log.warn("Unknown message id " + id);
                }

                break;

              case _constants.DEVICE_EVENT:
                // pass DEVICE event up to html
                eventEmitter.emit(event, message);
                eventEmitter.emit(type, payload); // DEVICE_EVENT also emit single events (connect/disconnect...)

                break;

              case _constants.TRANSPORT_EVENT:
                eventEmitter.emit(event, message);
                eventEmitter.emit(type, payload);
                break;

              case _constants.BLOCKCHAIN_EVENT:
                eventEmitter.emit(event, message);
                eventEmitter.emit(type, payload);
                break;

              case _constants.UI_EVENT:
                if (type === _constants.IFRAME.BOOTSTRAP) {
                  iframe.clearTimeout();
                  break;
                }

                if (type === _constants.IFRAME.LOADED) {
                  iframe.initPromise.resolve();
                }

                if (type === _constants.IFRAME.ERROR) {
                  iframe.initPromise.reject(payload.error);
                } // pass UI event up


                eventEmitter.emit(event, message);
                eventEmitter.emit(type, payload);
                break;

              default:
                _log.log('Undefined message', event, messageEvent);

            }
          };

          var init = /*#__PURE__*/function () {
            var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (settings === void 0) {
                        settings = {};
                      }

                      if (!iframe.instance) {
                        _context.next = 3;
                        break;
                      }

                      throw _constants.ERRORS.TypedError('Init_AlreadyInitialized');

                    case 3:
                      if (!_settings) {
                        _settings = (0, _ConnectSettings.parse)(settings);
                      }

                      if (_settings.manifest) {
                        _context.next = 6;
                        break;
                      }

                      throw _constants.ERRORS.TypedError('Init_ManifestMissing');

                    case 6:
                      if (!_settings.lazyLoad) {
                        _context.next = 9;
                        break;
                      }

                      // reset "lazyLoad" after first use
                      _settings.lazyLoad = false;
                      return _context.abrupt("return");

                    case 9:
                      if (!_popupManager) {
                        _popupManager = initPopupManager();
                      }

                      _log.enabled = !!_settings.debug;
                      window.addEventListener('message', handleMessage);
                      window.addEventListener('unload', dispose);
                      _context.next = 15;
                      return iframe.init(_settings);

                    case 15:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function init(_x) {
              return _ref.apply(this, arguments);
            };
          }();

          exports.init = init;

          var call = /*#__PURE__*/function () {
            var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(params) {
              var response;
              return _regenerator["default"].wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      if (!(!iframe.instance && !iframe.timeout)) {
                        _context2.next = 15;
                        break;
                      }

                      // init popup with lazy loading before iframe initialization
                      _settings = (0, _ConnectSettings.parse)(_settings);

                      if (_settings.manifest) {
                        _context2.next = 4;
                        break;
                      }

                      return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

                    case 4:
                      if (!_popupManager) {
                        _popupManager = initPopupManager();
                      }

                      _popupManager.request(true); // auto init with default settings


                      _context2.prev = 6;
                      _context2.next = 9;
                      return init(_settings);

                    case 9:
                      _context2.next = 15;
                      break;

                    case 11:
                      _context2.prev = 11;
                      _context2.t0 = _context2["catch"](6);

                      if (_popupManager) {
                        // Catch fatal iframe errors (not loading)
                        if (['Init_IframeBlocked', 'Init_IframeTimeout'].includes(_context2.t0.code)) {
                          _popupManager.postMessage((0, _builder2.UiMessage)(_constants.UI.IFRAME_FAILURE));
                        } else {
                          _popupManager.close();
                        }
                      }

                      return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t0));

                    case 15:
                      if (!iframe.timeout) {
                        _context2.next = 17;
                        break;
                      }

                      return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_ManifestMissing')));

                    case 17:
                      if (!iframe.error) {
                        _context2.next = 19;
                        break;
                      }

                      return _context2.abrupt("return", (0, _message.errorMessage)(iframe.error));

                    case 19:
                      // request popup window it might be used in the future
                      if (_settings.popup && _popupManager) {
                        _popupManager.request();
                      } // post message to iframe


                      _context2.prev = 20;
                      _context2.next = 23;
                      return iframe.postMessage({
                        type: _constants.IFRAME.CALL,
                        payload: params
                      });

                    case 23:
                      response = _context2.sent;

                      if (!response) {
                        _context2.next = 27;
                        break;
                      }

                      if (!response.success && response.payload.code !== 'Device_CallInProgress' && _popupManager) {
                        _popupManager.unlock();
                      }

                      return _context2.abrupt("return", response);

                    case 27:
                      if (_popupManager) {
                        _popupManager.unlock();
                      }

                      return _context2.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_NoResponse')));

                    case 31:
                      _context2.prev = 31;
                      _context2.t1 = _context2["catch"](20);

                      _log.error('__call error', _context2.t1);

                      if (_popupManager) {
                        _popupManager.close();
                      }

                      return _context2.abrupt("return", (0, _message.errorMessage)(_context2.t1));

                    case 36:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, null, [[6, 11], [20, 31]]);
            }));

            return function call(_x2) {
              return _ref2.apply(this, arguments);
            };
          }();

          exports.call = call;

          var customMessageResponse = function customMessageResponse(payload) {
            iframe.postMessage({
              event: _constants.UI_EVENT,
              type: _constants.UI.CUSTOM_MESSAGE_RESPONSE,
              payload: payload
            });
          };

          var uiResponse = function uiResponse(response) {
            var type = response.type,
              payload = response.payload;
            iframe.postMessage({
              event: _constants.UI_EVENT,
              type: type,
              payload: payload
            });
          };

          exports.uiResponse = uiResponse;

          var renderWebUSBButton = function renderWebUSBButton(className) {
            (0, _button["default"])(className, _settings.webusbSrc, iframe.origin);
          };

          exports.renderWebUSBButton = renderWebUSBButton;

          var getSettings = function getSettings() {
            if (!iframe.instance) {
              return Promise.resolve((0, _message.errorMessage)(_constants.ERRORS.TypedError('Init_NotInitialized')));
            }

            return call({
              method: 'getSettings'
            });
          };

          exports.getSettings = getSettings;

          var customMessage = /*#__PURE__*/function () {
            var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(params) {
              var callback, customMessageListener, response;
              return _regenerator["default"].wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!(typeof params.callback !== 'function')) {
                        _context4.next = 2;
                        break;
                      }

                      return _context4.abrupt("return", (0, _message.errorMessage)(_constants.ERRORS.TypedError('Method_CustomMessage_Callback')));

                    case 2:
                      // TODO: set message listener only if iframe is loaded correctly
                      callback = params.callback;

                      customMessageListener = /*#__PURE__*/function () {
                        var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(event) {
                          var data, payload;
                          return _regenerator["default"].wrap(function _callee3$(_context3) {
                            while (1) {
                              switch (_context3.prev = _context3.next) {
                                case 0:
                                  data = event.data;

                                  if (!(data && data.type === _constants.UI.CUSTOM_MESSAGE_REQUEST)) {
                                    _context3.next = 6;
                                    break;
                                  }

                                  _context3.next = 4;
                                  return callback(data.payload);

                                case 4:
                                  payload = _context3.sent;

                                  if (payload) {
                                    customMessageResponse(payload);
                                  } else {
                                    customMessageResponse({
                                      message: 'release'
                                    });
                                  }

                                case 6:
                                case "end":
                                  return _context3.stop();
                              }
                            }
                          }, _callee3);
                        }));

                        return function customMessageListener(_x4) {
                          return _ref4.apply(this, arguments);
                        };
                      }();

                      window.addEventListener('message', customMessageListener, false);
                      _context4.next = 7;
                      return call(_objectSpread(_objectSpread({
                        method: 'customMessage'
                      }, params), {}, {
                        callback: null
                      }));

                    case 7:
                      response = _context4.sent;
                      window.removeEventListener('message', customMessageListener);
                      return _context4.abrupt("return", response);

                    case 10:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            return function customMessage(_x3) {
              return _ref3.apply(this, arguments);
            };
          }();

          exports.customMessage = customMessage;

          var requestLogin = /*#__PURE__*/function () {
            var _ref5 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(params) {
              var callback, loginChallengeListener, response;
              return _regenerator["default"].wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      if (!(typeof params.callback === 'function')) {
                        _context6.next = 9;
                        break;
                      }

                      callback = params.callback; // TODO: set message listener only if iframe is loaded correctly

                      loginChallengeListener = /*#__PURE__*/function () {
                        var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(event) {
                          var data, payload;
                          return _regenerator["default"].wrap(function _callee5$(_context5) {
                            while (1) {
                              switch (_context5.prev = _context5.next) {
                                case 0:
                                  data = event.data;

                                  if (!(data && data.type === _constants.UI.LOGIN_CHALLENGE_REQUEST)) {
                                    _context5.next = 12;
                                    break;
                                  }

                                  _context5.prev = 2;
                                  _context5.next = 5;
                                  return callback();

                                case 5:
                                  payload = _context5.sent;
                                  iframe.postMessage({
                                    event: _constants.UI_EVENT,
                                    type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                                    payload: payload
                                  });
                                  _context5.next = 12;
                                  break;

                                case 9:
                                  _context5.prev = 9;
                                  _context5.t0 = _context5["catch"](2);
                                  iframe.postMessage({
                                    event: _constants.UI_EVENT,
                                    type: _constants.UI.LOGIN_CHALLENGE_RESPONSE,
                                    payload: _context5.t0.message
                                  });

                                case 12:
                                case "end":
                                  return _context5.stop();
                              }
                            }
                          }, _callee5, null, [[2, 9]]);
                        }));

                        return function loginChallengeListener(_x6) {
                          return _ref6.apply(this, arguments);
                        };
                      }();

                      window.addEventListener('message', loginChallengeListener, false);
                      _context6.next = 6;
                      return call(_objectSpread(_objectSpread({
                        method: 'requestLogin'
                      }, params), {}, {
                        asyncChallenge: true,
                        callback: null
                      }));

                    case 6:
                      response = _context6.sent;
                      window.removeEventListener('message', loginChallengeListener);
                      return _context6.abrupt("return", response);

                    case 9:
                      return _context6.abrupt("return", call(_objectSpread({
                        method: 'requestLogin'
                      }, params)));

                    case 10:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6);
            }));

            return function requestLogin(_x5) {
              return _ref5.apply(this, arguments);
            };
          }();

          exports.requestLogin = requestLogin;

          var disableWebUSB = function disableWebUSB() {
            iframe.postMessage({
              event: _constants.UI_EVENT,
              type: _constants.TRANSPORT.DISABLE_WEBUSB
            });
          };

          exports.disableWebUSB = disableWebUSB;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js", { "@babel/runtime/helpers/asyncToGenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@babel/runtime/regenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\regenerator\\index.js", "cross-fetch": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\cross-fetch\\dist\\browser-ponyfill.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\env\browser\networkUtils.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.getOrigin = exports.httpRequest = void 0;

          var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

          var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

          var _crossFetch = _interopRequireDefault(require("cross-fetch"));

          var httpRequest = /*#__PURE__*/function () {
            var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(url, type) {
              var response, txt;
              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (type === void 0) {
                        type = 'text';
                      }

                      _context.next = 3;
                      return (0, _crossFetch["default"])(url, {
                        credentials: 'same-origin'
                      });

                    case 3:
                      response = _context.sent;

                      if (!response.ok) {
                        _context.next = 13;
                        break;
                      }

                      if (!(type === 'json')) {
                        _context.next = 10;
                        break;
                      }

                      _context.next = 8;
                      return response.text();

                    case 8:
                      txt = _context.sent;
                      return _context.abrupt("return", JSON.parse(txt));

                    case 10:
                      if (!(type === 'binary')) {
                        _context.next = 12;
                        break;
                      }

                      return _context.abrupt("return", response.arrayBuffer());

                    case 12:
                      return _context.abrupt("return", response.text());

                    case 13:
                      throw new Error("httpRequest error: " + url + " " + response.statusText);

                    case 14:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee);
            }));

            return function httpRequest(_x, _x2) {
              return _ref.apply(this, arguments);
            };
          }();

          exports.httpRequest = httpRequest;

          var getOrigin = function getOrigin(url) {
            if (url.indexOf('file://') === 0) return 'file://'; // eslint-disable-next-line no-useless-escape

            var parts = url.match(/^.+\:\/\/[^\/]+/);
            return Array.isArray(parts) && parts.length > 0 ? parts[0] : 'unknown';
          };

          exports.getOrigin = getOrigin;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\iframe\\builder.js", { "../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js", "../env/browser/networkUtils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js", "../utils/deferred": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\utils\\deferred.js", "./inline-styles": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\iframe\\inline-styles.js", "@babel/runtime/helpers/asyncToGenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@babel/runtime/regenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\regenerator\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\iframe\builder.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.clearTimeout = exports.dispose = exports.postMessage = exports.init = exports.messagePromises = exports.error = exports.timeout = exports.initPromise = exports.origin = exports.instance = void 0;

          var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

          var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

          var _deferred = require("../utils/deferred");

          var _constants = require("../constants");

          var _networkUtils = require("../env/browser/networkUtils");

          var _inlineStyles = _interopRequireDefault(require("./inline-styles"));

          /* eslint-disable import/no-mutable-exports */
          var instance;
          exports.instance = instance;
          var origin;
          exports.origin = origin;
          var initPromise = (0, _deferred.create)();
          exports.initPromise = initPromise;
          var timeout = 0;
          exports.timeout = timeout;
          var error;
          /* eslint-enable import/no-mutable-exports */

          exports.error = error;
          var _messageID = 0; // every postMessage to iframe has its own promise to resolve

          var messagePromises = {};
          exports.messagePromises = messagePromises;

          var init = /*#__PURE__*/function () {
            var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(settings) {
              var existedFrame, src, manifestString, manifest, onLoad;
              return _regenerator["default"].wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      exports.initPromise = initPromise = (0, _deferred.create)();
                      existedFrame = document.getElementById('trezorconnect');

                      if (existedFrame) {
                        exports.instance = instance = existedFrame;
                      } else {
                        exports.instance = instance = document.createElement('iframe');
                        instance.frameBorder = '0';
                        instance.width = '0px';
                        instance.height = '0px';
                        instance.style.position = 'absolute';
                        instance.style.display = 'none';
                        instance.style.border = '0px';
                        instance.style.width = '0px';
                        instance.style.height = '0px';
                        instance.id = 'trezorconnect';
                      }

                      if (settings.env === 'web') {
                        manifestString = settings.manifest ? JSON.stringify(settings.manifest) : 'undefined'; // note: btoa(undefined) === btoa('undefined') === "dW5kZWZpbmVk"

                        manifest = "version=" + settings.version + "&manifest=" + encodeURIComponent(btoa(JSON.stringify(manifestString)));
                        src = settings.iframeSrc + "?" + manifest;
                      } else {
                        src = settings.iframeSrc;
                      }

                      instance.setAttribute('src', src);

                      if (settings.webusb) {
                        instance.setAttribute('allow', 'usb');
                      }

                      exports.origin = origin = (0, _networkUtils.getOrigin)(instance.src);
                      exports.timeout = timeout = window.setTimeout(function () {
                        initPromise.reject(_constants.ERRORS.TypedError('Init_IframeTimeout'));
                      }, 10000);

                      onLoad = function onLoad() {
                        if (!instance) {
                          initPromise.reject(_constants.ERRORS.TypedError('Init_IframeBlocked'));
                          return;
                        }

                        try {
                          // if hosting page is able to access cross-origin location it means that the iframe is not loaded
                          var iframeOrigin = instance.contentWindow.location.origin;

                          if (!iframeOrigin || iframeOrigin === 'null') {
                            // eslint-disable-next-line no-use-before-define
                            handleIframeBlocked();
                            return;
                          }
                        } catch (e) {// empty
                        }

                        var extension; // $FlowIssue chrome is not declared outside

                        if (typeof chrome !== 'undefined' && chrome.runtime && typeof chrome.runtime.onConnect !== 'undefined') {
                          chrome.runtime.onConnect.addListener(function () { });
                          extension = chrome.runtime.id;
                        }

                        instance.contentWindow.postMessage({
                          type: _constants.IFRAME.INIT,
                          payload: {
                            settings: settings,
                            extension: extension
                          }
                        }, origin);
                        instance.onload = undefined;
                      }; // IE hack


                      if (instance.attachEvent) {
                        instance.attachEvent('onload', onLoad);
                      } else {
                        instance.onload = onLoad;
                      } // inject iframe into host document body


                      if (document.body) {
                        document.body.appendChild(instance); // eslint-disable-next-line no-use-before-define

                        injectStyleSheet();
                      }

                      _context.prev = 11;
                      _context.next = 14;
                      return initPromise.promise;

                    case 14:
                      _context.next = 20;
                      break;

                    case 16:
                      _context.prev = 16;
                      _context.t0 = _context["catch"](11);

                      // reset state to allow initialization again
                      if (instance) {
                        if (instance.parentNode) {
                          instance.parentNode.removeChild(instance);
                        }

                        exports.instance = instance = null;
                      }

                      throw _context.t0;

                    case 20:
                      _context.prev = 20;
                      window.clearTimeout(timeout);
                      exports.timeout = timeout = 0;
                      return _context.finish(20);

                    case 24:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[11, 16, 20, 24]]);
            }));

            return function init(_x) {
              return _ref.apply(this, arguments);
            };
          }();

          exports.init = init;

          var injectStyleSheet = function injectStyleSheet() {
            if (!instance) {
              throw _constants.ERRORS.TypedError('Init_IframeBlocked');
            }

            var doc = instance.ownerDocument;
            var head = doc.head || doc.getElementsByTagName('head')[0];
            var style = document.createElement('style');
            style.setAttribute('type', 'text/css');
            style.setAttribute('id', 'TrezorConnectStylesheet'); // $FlowIssue

            if (style.styleSheet) {
              // IE
              // $FlowIssue
              style.styleSheet.cssText = _inlineStyles["default"];
              head.appendChild(style);
            } else {
              style.appendChild(document.createTextNode(_inlineStyles["default"]));
              head.append(style);
            }
          };

          var handleIframeBlocked = function handleIframeBlocked() {
            window.clearTimeout(timeout);
            exports.error = error = _constants.ERRORS.TypedError('Init_IframeBlocked'); // eslint-disable-next-line no-use-before-define

            dispose();
            initPromise.reject(error);
          }; // post messages to iframe


          var postMessage = function postMessage(message, usePromise) {
            if (usePromise === void 0) {
              usePromise = true;
            }

            if (!instance) {
              throw _constants.ERRORS.TypedError('Init_IframeBlocked');
            }

            if (usePromise) {
              _messageID++;
              message.id = _messageID;
              messagePromises[_messageID] = (0, _deferred.create)();
              var promise = messagePromises[_messageID].promise;
              instance.contentWindow.postMessage(message, origin);
              return promise;
            }

            instance.contentWindow.postMessage(message, origin);
            return null;
          };

          exports.postMessage = postMessage;

          var dispose = function dispose() {
            if (instance && instance.parentNode) {
              try {
                instance.parentNode.removeChild(instance);
              } catch (e) {// do nothing
              }
            }

            exports.instance = instance = null;
            exports.timeout = timeout = 0;
          };

          exports.dispose = dispose;

          var clearTimeout = function clearTimeout() {
            window.clearTimeout(timeout);
          };

          exports.clearTimeout = clearTimeout;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\iframe\\inline-styles.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\iframe\inline-styles.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports["default"] = void 0;
          var css = '.trezorconnect-container{position:fixed!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-orient:vertical!important;-webkit-box-direction:normal!important;-webkit-flex-direction:column!important;-ms-flex-direction:column!important;flex-direction:column!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important;z-index:10000!important;width:100%!important;height:100%!important;top:0!important;left:0!important;background:rgba(0,0,0,.35)!important;overflow:auto!important;padding:20px!important;margin:0!important}.trezorconnect-container .trezorconnect-window{position:relative!important;display:block!important;width:370px!important;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif!important;margin:auto!important;border-radius:3px!important;background-color:#fff!important;text-align:center!important;overflow:hidden!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head{text-align:left;padding:12px 24px!important;display:-webkit-box!important;display:-webkit-flex!important;display:-ms-flexbox!important;display:flex!important;-webkit-box-align:center!important;-webkit-align-items:center!important;-ms-flex-align:center!important;align-items:center!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-logo{-webkit-box-flex:1;-webkit-flex:1;-ms-flex:1;flex:1}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close{cursor:pointer!important;height:24px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close svg{fill:#757575;-webkit-transition:fill .3s ease-in-out!important;transition:fill .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-head .trezorconnect-close:hover svg{fill:#494949}.trezorconnect-container .trezorconnect-window .trezorconnect-body{padding:24px 24px 32px!important;background:#FBFBFB!important;border-top:1px solid #EBEBEB}.trezorconnect-container .trezorconnect-window .trezorconnect-body h3{color:#505050!important;font-size:16px!important;font-weight:500!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body p{margin:8px 0 24px!important;font-weight:400!important;color:#A9A9A9!important;font-size:12px!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button{width:100%!important;padding:12px 24px!important;margin:0!important;border-radius:3px!important;font-size:14px!important;font-weight:300!important;cursor:pointer!important;background:#01B757!important;color:#fff!important;border:0!important;-webkit-transition:background-color .3s ease-in-out!important;transition:background-color .3s ease-in-out!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:hover{background-color:#00AB51!important}.trezorconnect-container .trezorconnect-window .trezorconnect-body button:active{background-color:#009546!important}/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImlucHV0IiwiJHN0ZGluIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWNBLHlCQUNJLFNBQUEsZ0JBQ0EsUUFBQSxzQkFDQSxRQUFBLHVCQUNBLFFBQUEsc0JBRUEsUUFBQSxlQUNBLG1CQUFBLG1CQUNBLHNCQUFBLGlCQUNBLHVCQUFBLGlCQUNBLG1CQUFBLGlCQUNBLGVBQUEsaUJBRUEsa0JBQUEsaUJBQ0Esb0JBQUEsaUJBQ0EsZUFBQSxpQkNmTSxZQUFhLGlCREFyQixRQUFTLGdCQWtCSCxNQUFBLGVBQ0EsT0FBQSxlQUNBLElBQUEsWUFDQSxLQUFBLFlBQ0EsV0FBQSwwQkFDQSxTQUFBLGVBQ0EsUUFBQSxlQUNBLE9BQUEsWUNkUiwrQ0RYRSxTQUFVLG1CQTZCQSxRQUFBLGdCQUNBLE1BQUEsZ0JBQ0EsWUFBQSxjQUFBLG1CQUFBLFdBQUEsT0FBQSxpQkFBQSxNQUFBLHFCQUNBLE9BQUEsZUNmVixjQUFlLGNEakJmLGlCQWlCRSxlQWtCWSxXQUFBLGlCQ2ZkLFNBQVUsaUJEbUJJLG1FQUNBLFdBQUEsS0NoQmQsUUFBUyxLQUFLLGVEeEJkLFFBQVMsc0JBMENTLFFBQUEsdUJBQ0EsUUFBQSxzQkNmbEIsUUFBUyxlRGlCSyxrQkE1QlosaUJBOEJvQixvQkFBQSxpQkNoQmxCLGVBQWdCLGlCRC9CWixZQWlCTixpQkFzQ1EsdUZBQ0EsaUJBQUEsRUNwQlYsYUFBYyxFRHBDVixTQUFVLEVBMkRBLEtBQUEsRUFFQSx3RkNwQmQsT0FBUSxrQkR6Q1IsT0FBUSxlQWlFTSw0RkFDQSxLQUFBLFFBQ0EsbUJBQUEsS0FBQSxJQUFBLHNCQ3BCZCxXQUFZLEtBQUssSUFBSyxzQkR3QlIsa0dBQ0EsS0FBQSxRQUVBLG1FQUNBLFFBQUEsS0FBQSxLQUFBLGVBQ0EsV0FBQSxrQkFDQSxXQUFBLElBQUEsTUFBQSxRQUVBLHNFQUNBLE1BQUEsa0JBQ0EsVUFBQSxlQ3JCZCxZQUFhLGNEd0JLLHFFQ3JCbEIsT0FBUSxJQUFJLEVBQUksZUR3QkYsWUFBQSxjQUNJLE1BQUEsa0JDdEJsQixVQUFXLGVBRWIsMEVBQ0UsTUFBTyxlQUNQLFFBQVMsS0FBSyxlQUNkLE9BQVEsWUFDUixjQUFlLGNBQ2YsVUFBVyxlQUNYLFlBQWEsY0FDYixPQUFRLGtCQUNSLFdBQVksa0JBQ1osTUFBTyxlQUNQLE9BQVEsWUFDUixtQkFBb0IsaUJBQWlCLElBQUssc0JBQzFDLFdBQVksaUJBQWlCLElBQUssc0JBRXBDLGdGQUNFLGlCQUFrQixrQkFFcEIsaUZBQ0UsaUJBQWtCIn0= */';
          var _default = css;
          exports["default"] = _default;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\index.js", { "./constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js", "./env/node": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\env\\browser\\index.js", "./types": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\index.js", "@babel/runtime/helpers/defineProperty": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\index.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          var _exportNames = {};
          exports["default"] = void 0;

          var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

          var _constants = require("./constants");

          Object.keys(_constants).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            if (key in exports && exports[key] === _constants[key]) return;
            exports[key] = _constants[key];
          });

          var _node = require("./env/node");

          var _types = require("./types");

          Object.keys(_types).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
            if (key in exports && exports[key] === _types[key]) return;
            exports[key] = _types[key];
          });

          function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

          function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

          var TrezorConnect = {
            manifest: _node.manifest,
            init: _node.init,
            getSettings: _node.getSettings,
            on: function on(type, fn) {
              _node.eventEmitter.on(type, fn);
            },
            off: function off(type, fn) {
              _node.eventEmitter.removeListener(type, fn);
            },
            removeAllListeners: function removeAllListeners() {
              _node.eventEmitter.removeAllListeners();
            },
            uiResponse: _node.uiResponse,
            // methods
            blockchainGetAccountBalanceHistory: function blockchainGetAccountBalanceHistory(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainGetAccountBalanceHistory'
              }, params));
            },
            blockchainGetCurrentFiatRates: function blockchainGetCurrentFiatRates(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainGetCurrentFiatRates'
              }, params));
            },
            blockchainGetFiatRatesForTimestamps: function blockchainGetFiatRatesForTimestamps(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainGetFiatRatesForTimestamps'
              }, params));
            },
            blockchainDisconnect: function blockchainDisconnect(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainDisconnect'
              }, params));
            },
            blockchainEstimateFee: function blockchainEstimateFee(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainEstimateFee'
              }, params));
            },
            blockchainGetTransactions: function blockchainGetTransactions(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainGetTransactions'
              }, params));
            },
            blockchainSetCustomBackend: function blockchainSetCustomBackend(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainSetCustomBackend'
              }, params));
            },
            blockchainSubscribe: function blockchainSubscribe(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainSubscribe'
              }, params));
            },
            blockchainSubscribeFiatRates: function blockchainSubscribeFiatRates(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainSubscribeFiatRates'
              }, params));
            },
            blockchainUnsubscribe: function blockchainUnsubscribe(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainUnsubscribe'
              }, params));
            },
            blockchainUnsubscribeFiatRates: function blockchainUnsubscribeFiatRates(params) {
              return (0, _node.call)(_objectSpread({
                method: 'blockchainUnsubscribeFiatRates'
              }, params));
            },
            customMessage: function customMessage(params) {
              return (0, _node.customMessage)(params);
            },
            requestLogin: function requestLogin(params) {
              return (0, _node.requestLogin)(params);
            },
            cardanoGetAddress: function cardanoGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'cardanoGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            cardanoGetNativeScriptHash: function cardanoGetNativeScriptHash(params) {
              return (0, _node.call)(_objectSpread({
                method: 'cardanoGetNativeScriptHash'
              }, params));
            },
            cardanoGetPublicKey: function cardanoGetPublicKey(params) {
              return (0, _node.call)(_objectSpread({
                method: 'cardanoGetPublicKey'
              }, params));
            },
            cardanoSignTransaction: function cardanoSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'cardanoSignTransaction'
              }, params));
            },
            cipherKeyValue: function cipherKeyValue(params) {
              return (0, _node.call)(_objectSpread({
                method: 'cipherKeyValue'
              }, params));
            },
            composeTransaction: function composeTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'composeTransaction'
              }, params));
            },
            ethereumGetAddress: function ethereumGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'ethereumGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            ethereumGetPublicKey: function ethereumGetPublicKey(params) {
              return (0, _node.call)(_objectSpread({
                method: 'ethereumGetPublicKey'
              }, params));
            },
            ethereumSignMessage: function ethereumSignMessage(params) {
              return (0, _node.call)(_objectSpread({
                method: 'ethereumSignMessage'
              }, params));
            },
            ethereumSignTransaction: function ethereumSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'ethereumSignTransaction'
              }, params));
            },
            ethereumSignTypedData: function ethereumSignTypedData(params) {
              return (0, _node.call)(_objectSpread({
                method: 'ethereumSignTypedData'
              }, params));
            },
            ethereumVerifyMessage: function ethereumVerifyMessage(params) {
              return (0, _node.call)(_objectSpread({
                method: 'ethereumVerifyMessage'
              }, params));
            },
            getAccountInfo: function getAccountInfo(params) {
              return (0, _node.call)(_objectSpread({
                method: 'getAccountInfo'
              }, params));
            },
            getAddress: function getAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'getAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            getDeviceState: function getDeviceState(params) {
              return (0, _node.call)(_objectSpread({
                method: 'getDeviceState'
              }, params));
            },
            getFeatures: function getFeatures(params) {
              return (0, _node.call)(_objectSpread({
                method: 'getFeatures'
              }, params));
            },
            getPublicKey: function getPublicKey(params) {
              return (0, _node.call)(_objectSpread({
                method: 'getPublicKey'
              }, params));
            },
            liskGetAddress: function liskGetAddress() {
              return (0, _node.call)({
                method: 'liskDeprecated'
              });
            },
            liskGetPublicKey: function liskGetPublicKey() {
              return (0, _node.call)({
                method: 'liskDeprecated'
              });
            },
            liskSignMessage: function liskSignMessage() {
              return (0, _node.call)({
                method: 'liskDeprecated'
              });
            },
            liskSignTransaction: function liskSignTransaction() {
              return (0, _node.call)({
                method: 'liskDeprecated'
              });
            },
            liskVerifyMessage: function liskVerifyMessage() {
              return (0, _node.call)({
                method: 'liskDeprecated'
              });
            },
            nemGetAddress: function nemGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'nemGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            nemSignTransaction: function nemSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'nemSignTransaction'
              }, params));
            },
            pushTransaction: function pushTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'pushTransaction'
              }, params));
            },
            rippleGetAddress: function rippleGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'rippleGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            rippleSignTransaction: function rippleSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'rippleSignTransaction'
              }, params));
            },
            signMessage: function signMessage(params) {
              return (0, _node.call)(_objectSpread({
                method: 'signMessage'
              }, params));
            },
            signTransaction: function signTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'signTransaction'
              }, params));
            },
            stellarGetAddress: function stellarGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'stellarGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            stellarSignTransaction: function stellarSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'stellarSignTransaction'
              }, params));
            },
            tezosGetAddress: function tezosGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'tezosGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            tezosGetPublicKey: function tezosGetPublicKey(params) {
              return (0, _node.call)(_objectSpread({
                method: 'tezosGetPublicKey'
              }, params));
            },
            tezosSignTransaction: function tezosSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'tezosSignTransaction'
              }, params));
            },
            eosGetPublicKey: function eosGetPublicKey(params) {
              return (0, _node.call)(_objectSpread({
                method: 'eosGetPublicKey'
              }, params));
            },
            eosSignTransaction: function eosSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'eosSignTransaction'
              }, params));
            },
            binanceGetAddress: function binanceGetAddress(params) {
              var useEventListener = _node.eventEmitter.listenerCount(_constants.UI.ADDRESS_VALIDATION) > 0;
              return (0, _node.call)(_objectSpread(_objectSpread({
                method: 'binanceGetAddress'
              }, params), {}, {
                useEventListener: useEventListener
              }));
            },
            binanceGetPublicKey: function binanceGetPublicKey(params) {
              return (0, _node.call)(_objectSpread({
                method: 'binanceGetPublicKey'
              }, params));
            },
            binanceSignTransaction: function binanceSignTransaction(params) {
              return (0, _node.call)(_objectSpread({
                method: 'binanceSignTransaction'
              }, params));
            },
            verifyMessage: function verifyMessage(params) {
              return (0, _node.call)(_objectSpread({
                method: 'verifyMessage'
              }, params));
            },
            resetDevice: function resetDevice(params) {
              return (0, _node.call)(_objectSpread({
                method: 'resetDevice'
              }, params));
            },
            wipeDevice: function wipeDevice(params) {
              return (0, _node.call)(_objectSpread({
                method: 'wipeDevice'
              }, params));
            },
            applyFlags: function applyFlags(params) {
              return (0, _node.call)(_objectSpread({
                method: 'applyFlags'
              }, params));
            },
            applySettings: function applySettings(params) {
              return (0, _node.call)(_objectSpread({
                method: 'applySettings'
              }, params));
            },
            backupDevice: function backupDevice(params) {
              return (0, _node.call)(_objectSpread({
                method: 'backupDevice'
              }, params));
            },
            changePin: function changePin(params) {
              return (0, _node.call)(_objectSpread({
                method: 'changePin'
              }, params));
            },
            firmwareUpdate: function firmwareUpdate(params) {
              return (0, _node.call)(_objectSpread({
                method: 'firmwareUpdate'
              }, params));
            },
            recoveryDevice: function recoveryDevice(params) {
              return (0, _node.call)(_objectSpread({
                method: 'recoveryDevice'
              }, params));
            },
            getCoinInfo: function getCoinInfo(params) {
              return (0, _node.call)(_objectSpread({
                method: 'getCoinInfo'
              }, params));
            },
            rebootToBootloader: function rebootToBootloader(params) {
              return (0, _node.call)(_objectSpread({
                method: 'rebootToBootloader'
              }, params));
            },
            dispose: _node.dispose,
            cancel: _node.cancel,
            renderWebUSBButton: _node.renderWebUSBButton,
            disableWebUSB: _node.disableWebUSB
          };
          var _default = TrezorConnect;
          exports["default"] = _default;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\message\\builder.js", { "../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js", "@babel/runtime/helpers/defineProperty": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\message\builder.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.BlockchainMessage = exports.ResponseMessage = exports.TransportMessage = exports.DeviceMessage = exports.UiMessage = void 0;

          var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

          var _constants = require("../constants");

          function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

          function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

          var UiMessage = function UiMessage(type, payload) {
            return {
              event: _constants.UI_EVENT,
              type: type,
              payload: payload
            };
          };

          exports.UiMessage = UiMessage;

          var DeviceMessage = function DeviceMessage(type, payload) {
            return {
              event: _constants.DEVICE_EVENT,
              type: type,
              payload: payload
            };
          };

          exports.DeviceMessage = DeviceMessage;

          var TransportMessage = function TransportMessage(type, payload) {
            return {
              event: _constants.TRANSPORT_EVENT,
              type: type,
              // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
              payload: payload.error ? _objectSpread(_objectSpread({}, payload), {}, {
                error: payload.error.message,
                code: payload.error.code
              }) : payload
            };
          };

          exports.TransportMessage = TransportMessage;

          var ResponseMessage = function ResponseMessage(id, success, payload) {
            if (payload === void 0) {
              payload = null;
            }

            return {
              event: _constants.RESPONSE_EVENT,
              type: _constants.RESPONSE_EVENT,
              id: id,
              success: success,
              // convert Error/TypeError object into payload error type (Error object/class is converted to string while sent via postMessage)
              payload: success ? payload : {
                error: payload.error.message,
                code: payload.error.code
              }
            };
          };

          exports.ResponseMessage = ResponseMessage;

          var BlockchainMessage = function BlockchainMessage(type, payload) {
            return {
              event: _constants.BLOCKCHAIN_EVENT,
              type: type,
              payload: payload
            };
          };

          exports.BlockchainMessage = BlockchainMessage;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\message\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\message\index.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.errorMessage = exports.parseMessage = void 0;

          // parse MessageEvent .data into CoreMessage
          var parseMessage = function parseMessage(messageData) {
            var message = {
              event: messageData.event,
              type: messageData.type,
              payload: messageData.payload
            };

            if (typeof messageData.id === 'number') {
              message.id = messageData.id;
            }

            if (typeof messageData.success === 'boolean') {
              message.success = messageData.success;
            }

            return message;
          }; // common response used straight from npm index (not from Core)


          exports.parseMessage = parseMessage;

          var errorMessage = function errorMessage(error) {
            return {
              success: false,
              payload: {
                error: error.message,
                code: error.code
              }
            };
          };

          exports.errorMessage = errorMessage;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\plugins\\ethereum\\typedData.js", { "@babel/runtime/helpers/defineProperty": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@metamask/eth-sig-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-sig-util\\dist\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\plugins\ethereum\typedData.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

          function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

          function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

          // eslint-disable-next-line import/no-unresolved
          var sigUtil = require('@metamask/eth-sig-util'); // Sanitization is used for T1 as eth-sig-util does not support BigInt


          function sanitizeData(data) {
            switch (Object.prototype.toString.call(data)) {
              case '[object Object]':
                {
                  var entries = Object.keys(data).map(function (k) {
                    return [k, sanitizeData(data[k])];
                  });
                  return Object.fromEntries(entries);
                }

              case '[object Array]':
                return data.map(function (v) {
                  return sanitizeData(v);
                });

              case '[object BigInt]':
                return data.toString();

              default:
                return data;
            }
          }

          var transformTypedData = function transformTypedData(data, metamask_v4_compat) {
            if (!metamask_v4_compat) {
              throw new Error('Trezor: Only version 4 of typed data signing is supported');
            }

            var version = sigUtil.SignTypedDataVersion.V4;

            var _sigUtil$TypedDataUti = sigUtil.TypedDataUtils.sanitizeData(data),
              types = _sigUtil$TypedDataUti.types,
              primaryType = _sigUtil$TypedDataUti.primaryType,
              domain = _sigUtil$TypedDataUti.domain,
              message = _sigUtil$TypedDataUti.message;

            var domainSeparatorHash = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', sanitizeData(domain), types, version).toString('hex');
            var messageHash = sigUtil.TypedDataUtils.hashStruct(primaryType, sanitizeData(message), types, version).toString('hex');
            return _objectSpread({
              domain_separator_hash: domainSeparatorHash,
              message_hash: messageHash
            }, data);
          };

          module.exports = transformTypedData;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\popup\\PopupManager.js", { "../constants/iframe": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\iframe.js", "../constants/popup": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\popup.js", "../constants/ui": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\ui.js", "../env/browser/networkUtils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\env\\browser\\networkUtils.js", "../utils/deferred": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\utils\\deferred.js", "./showPopupRequest": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\popup\\showPopupRequest.js", "@babel/runtime/helpers/assertThisInitialized": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\assertThisInitialized.js", "@babel/runtime/helpers/asyncToGenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js", "@babel/runtime/helpers/defineProperty": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\defineProperty.js", "@babel/runtime/helpers/inheritsLoose": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@babel/runtime/regenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\regenerator\\index.js", "events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\popup\PopupManager.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports["default"] = void 0;

          var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

          var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

          var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

          var _inheritsLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/inheritsLoose"));

          var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

          var _events = _interopRequireDefault(require("events"));

          var POPUP = _interopRequireWildcard(require("../constants/popup"));

          var IFRAME = _interopRequireWildcard(require("../constants/iframe"));

          var UI = _interopRequireWildcard(require("../constants/ui"));

          var _showPopupRequest = require("./showPopupRequest");

          var _networkUtils = require("../env/browser/networkUtils");

          var _deferred = require("../utils/deferred");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          // const POPUP_REQUEST_TIMEOUT = 602;
          var POPUP_REQUEST_TIMEOUT = 850;
          var POPUP_CLOSE_INTERVAL = 500;
          var POPUP_OPEN_TIMEOUT = 3000;

          var PopupManager = /*#__PURE__*/function (_EventEmitter) {
            (0, _inheritsLoose2["default"])(PopupManager, _EventEmitter);

            // Window
            function PopupManager(settings) {
              var _this;

              _this = _EventEmitter.call(this) || this;
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "requestTimeout", 0);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "closeInterval", 0);
              (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "extensionTabId", 0);
              _this.settings = settings;
              _this.origin = (0, _networkUtils.getOrigin)(settings.popupSrc);
              _this.handleMessage = _this.handleMessage.bind((0, _assertThisInitialized2["default"])(_this));
              _this.iframeHandshake = (0, _deferred.create)(IFRAME.LOADED);

              if (_this.settings.env === 'webextension') {
                _this.handleExtensionConnect = _this.handleExtensionConnect.bind((0, _assertThisInitialized2["default"])(_this));
                _this.handleExtensionMessage = _this.handleExtensionMessage.bind((0, _assertThisInitialized2["default"])(_this)); // $FlowIssue chrome not declared outside

                chrome.runtime.onConnect.addListener(_this.handleExtensionConnect);
              }

              window.addEventListener('message', _this.handleMessage, false);
              return _this;
            }

            var _proto = PopupManager.prototype;

            _proto.request = function request(lazyLoad) {
              var _this2 = this;

              if (lazyLoad === void 0) {
                lazyLoad = false;
              }

              // popup request
              // TODO: ie - open immediately and hide it but post handshake after timeout
              // bring popup window to front
              if (this.locked) {
                if (this._window) {
                  if (this.settings.env === 'webextension') {
                    // $FlowIssue chrome not declared outside
                    chrome.tabs.update(this._window.id, {
                      active: true
                    });
                  } else {
                    this._window.focus();
                  }
                }

                return;
              }

              var openFn = this.open.bind(this);
              this.locked = true;

              if (!this.settings.supportedBrowser) {
                openFn();
              } else {
                var timeout = lazyLoad || this.settings.env === 'webextension' ? 1 : POPUP_REQUEST_TIMEOUT;
                this.requestTimeout = window.setTimeout(function () {
                  _this2.requestTimeout = 0;
                  openFn(lazyLoad);
                }, timeout);
              }
            };

            _proto.cancel = function cancel() {
              this.close();
            };

            _proto.unlock = function unlock() {
              this.locked = false;
            };

            _proto.open = function open(lazyLoad) {
              var _this3 = this;

              var src = this.settings.popupSrc;

              if (!this.settings.supportedBrowser) {
                this.openWrapper(src + "#unsupported");
                return;
              }

              this.popupPromise = (0, _deferred.create)(POPUP.LOADED);
              this.openWrapper(lazyLoad ? src + "#loading" : src);
              this.closeInterval = window.setInterval(function () {
                if (!_this3._window) return;

                if (_this3.settings.env === 'webextension') {
                  // $FlowIssue chrome not declared outside
                  chrome.tabs.get(_this3._window.id, function (tab) {
                    if (!tab) {
                      _this3.close();

                      _this3.emit(POPUP.CLOSED);
                    }
                  });
                } else if (_this3._window.closed) {
                  _this3.close();

                  _this3.emit(POPUP.CLOSED);
                }
              }, POPUP_CLOSE_INTERVAL); // open timeout will be cancelled by POPUP.BOOTSTRAP message

              this.openTimeout = window.setTimeout(function () {
                _this3.close();

                (0, _showPopupRequest.showPopupRequest)(_this3.open.bind(_this3), function () {
                  _this3.emit(POPUP.CLOSED);
                });
              }, POPUP_OPEN_TIMEOUT);
            };

            _proto.openWrapper = function openWrapper(url) {
              var _this4 = this;

              if (this.settings.env === 'webextension') {
                // $FlowIssue chrome not declared outside
                chrome.windows.getCurrent(null, function (currentWindow) {
                  // Request coming from extension popup,
                  // create new window above instead of opening new tab
                  if (currentWindow.type !== 'normal') {
                    // $FlowIssue chrome not declared outside
                    chrome.windows.create({
                      url: url
                    }, function (newWindow) {
                      // $FlowIssue chrome not declared outside
                      chrome.tabs.query({
                        windowId: newWindow.id,
                        active: true
                      }, function (tabs) {
                        // eslint-disable-next-line prefer-destructuring
                        _this4._window = tabs[0];
                      });
                    });
                  } else {
                    // $FlowIssue chrome not declared outside
                    chrome.tabs.query({
                      currentWindow: true,
                      active: true
                    }, function (tabs) {
                      _this4.extensionTabId = tabs[0].id; // $FlowIssue chrome not declared outside

                      chrome.tabs.create({
                        url: url,
                        index: tabs[0].index + 1
                      }, function (tab) {
                        _this4._window = tab;
                      });
                    });
                  }
                });
              } else if (this.settings.env === 'electron') {
                this._window = window.open(url, 'modal');
              } else {
                this._window = window.open('', '_blank');

                if (this._window) {
                  this._window.location.href = url; // otherwise android/chrome loose window.opener reference
                }
              }
            };

            _proto.handleExtensionConnect = function handleExtensionConnect(port) {
              if (port.name !== 'trezor-connect') return;

              if (!this._window || this._window && this._window.id !== port.sender.tab.id) {
                port.disconnect();
                return;
              } // since POPUP.BOOTSTRAP will not be handled by "handleMessage" we need to threat "content-script" connection as the same event
              // popup is opened properly, now wait for POPUP.LOADED message (in this case handled by "handleExtensionMessage")


              window.clearTimeout(this.openTimeout);
              this.extensionPort = port; // $FlowIssue need to update ChromePort definition

              this.extensionPort.onMessage.addListener(this.handleExtensionMessage);
            };

            _proto.handleExtensionMessage = function handleExtensionMessage(message) {
              var _this5 = this;

              if (!this.extensionPort) return;
              var port = this.extensionPort;
              var data = message.data;
              if (!data || typeof data !== 'object') return;

              if (data.type === POPUP.ERROR) {
                // handle popup error
                var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
                this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
                this.close();
              } else if (data.type === POPUP.LOADED) {
                if (this.popupPromise) {
                  this.popupPromise.resolve();
                }

                this.iframeHandshake.promise.then(function (useBroadcastChannel) {
                  port.postMessage({
                    type: POPUP.INIT,
                    payload: {
                      settings: _this5.settings,
                      useBroadcastChannel: useBroadcastChannel
                    }
                  });
                });
              } else if (data.type === POPUP.EXTENSION_USB_PERMISSIONS) {
                // $FlowIssue chrome not declared outside
                chrome.tabs.query({
                  currentWindow: true,
                  active: true
                }, function (tabs) {
                  // $FlowIssue chrome not declared outside
                  chrome.tabs.create({
                    url: 'trezor-usb-permissions.html',
                    index: tabs[0].index + 1
                  }, function (_tab) {// do nothing
                  });
                });
              } else if (data.type === POPUP.CLOSE_WINDOW) {
                this.emit(POPUP.CLOSED);
                this.close();
              }
            };

            _proto.handleMessage = function handleMessage(message) {
              var _this6 = this;

              // ignore messages from domain other then popup origin and without data
              // const data: CoreMessage = message.data;
              var data = message.data;
              if ((0, _networkUtils.getOrigin)(message.origin) !== this.origin || !data || typeof data !== 'object') return;

              if (data.type === IFRAME.LOADED) {
                var useBroadcastChannel = data.payload && typeof data.payload.useBroadcastChannel === 'boolean' ? data.payload.useBroadcastChannel : false;
                this.iframeHandshake.resolve(useBroadcastChannel);
              } else if (data.type === POPUP.BOOTSTRAP) {
                // popup is opened properly, now wait for POPUP.LOADED message
                window.clearTimeout(this.openTimeout);
              } else if (data.type === POPUP.ERROR && this._window) {
                var errorMessage = data.payload && typeof data.payload.error === 'string' ? data.payload.error : null;
                this.emit(POPUP.CLOSED, errorMessage ? "Popup error: " + errorMessage : null);
                this.close();
              } else if (data.type === POPUP.LOADED) {
                if (this.popupPromise) {
                  this.popupPromise.resolve();
                } // popup is successfully loaded


                this.iframeHandshake.promise.then(function (useBroadcastChannel) {
                  _this6._window.postMessage({
                    type: POPUP.INIT,
                    payload: {
                      settings: _this6.settings,
                      useBroadcastChannel: useBroadcastChannel
                    }
                  }, _this6.origin);
                }); // send ConnectSettings to popup
                // note this settings and iframe.ConnectSettings could be different (especially: origin, popup, webusb, debug)
                // now popup is able to load assets
              } else if (data.type === POPUP.CANCEL_POPUP_REQUEST || data.type === UI.CLOSE_UI_WINDOW) {
                this.close();
              }
            };

            _proto.close = function close() {
              this.locked = false;
              this.popupPromise = undefined;

              if (this.requestTimeout) {
                window.clearTimeout(this.requestTimeout);
                this.requestTimeout = 0;
              }

              if (this.openTimeout) {
                window.clearTimeout(this.openTimeout);
                this.openTimeout = 0;
              }

              if (this.closeInterval) {
                window.clearInterval(this.closeInterval);
                this.closeInterval = 0;
              }

              if (this.extensionPort) {
                this.extensionPort.disconnect();
                this.extensionPort = null;
              } // switch to previously focused tab


              if (this.extensionTabId) {
                // $FlowIssue chrome not declared outside
                chrome.tabs.update(this.extensionTabId, {
                  active: true
                });
                this.extensionTabId = 0;
              }

              if (this._window) {
                if (this.settings.env === 'webextension') {
                  // eslint-disable-next-line no-unused-vars
                  var _e = chrome.runtime.lastError; // $FlowIssue chrome not declared outside

                  chrome.tabs.remove(this._window.id, function () {
                    // eslint-disable-next-line no-unused-vars
                    _e = chrome.runtime.lastError;
                  });
                } else {
                  this._window.close();
                }

                this._window = null;
              }
            };

            _proto.postMessage = /*#__PURE__*/function () {
              var _postMessage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(message) {
                var _this7 = this;

                return _regenerator["default"].wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!(!this._window && message.type !== UI.REQUEST_UI_WINDOW && this.openTimeout)) {
                          _context.next = 4;
                          break;
                        }

                        this.close();
                        (0, _showPopupRequest.showPopupRequest)(this.open.bind(this), function () {
                          _this7.emit(POPUP.CLOSED);
                        });
                        return _context.abrupt("return");

                      case 4:
                        if (!this.popupPromise) {
                          _context.next = 7;
                          break;
                        }

                        _context.next = 7;
                        return this.popupPromise.promise;

                      case 7:
                        // post message to popup window
                        if (this._window) {
                          this._window.postMessage(message, this.origin);
                        }

                      case 8:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));

              function postMessage(_x) {
                return _postMessage.apply(this, arguments);
              }

              return postMessage;
            }();

            return PopupManager;
          }(_events["default"]);

          exports["default"] = PopupManager;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\popup\\showPopupRequest.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\popup\showPopupRequest.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.showPopupRequest = void 0;
          var LAYER_ID = 'TrezorConnectInteractionLayer';
          var HTML = "\n    <div class=\"trezorconnect-container\" id=\"" + LAYER_ID + "\">\n        <div class=\"trezorconnect-window\">\n            <div class=\"trezorconnect-head\">\n                <svg class=\"trezorconnect-logo\" x=\"0px\" y=\"0px\" viewBox=\"0 0 163.7 41.9\" width=\"78px\" height=\"20px\" preserveAspectRatio=\"xMinYMin meet\">\n                    <polygon points=\"101.1,12.8 118.2,12.8 118.2,17.3 108.9,29.9 118.2,29.9 118.2,35.2 101.1,35.2 101.1,30.7 110.4,18.1 101.1,18.1\"/>\n                    <path d=\"M158.8,26.9c2.1-0.8,4.3-2.9,4.3-6.6c0-4.5-3.1-7.4-7.7-7.4h-10.5v22.3h5.8v-7.5h2.2l4.1,7.5h6.7L158.8,26.9z M154.7,22.5 h-4V18h4c1.5,0,2.5,0.9,2.5,2.2C157.2,21.6,156.2,22.5,154.7,22.5z\"/>\n                    <path d=\"M130.8,12.5c-6.8,0-11.6,4.9-11.6,11.5s4.9,11.5,11.6,11.5s11.7-4.9,11.7-11.5S137.6,12.5,130.8,12.5z M130.8,30.3 c-3.4,0-5.7-2.6-5.7-6.3c0-3.8,2.3-6.3,5.7-6.3c3.4,0,5.8,2.6,5.8,6.3C136.6,27.7,134.2,30.3,130.8,30.3z\"/>\n                    <polygon points=\"82.1,12.8 98.3,12.8 98.3,18 87.9,18 87.9,21.3 98,21.3 98,26.4 87.9,26.4 87.9,30 98.3,30 98.3,35.2 82.1,35.2 \"/>\n                    <path d=\"M24.6,9.7C24.6,4.4,20,0,14.4,0S4.2,4.4,4.2,9.7v3.1H0v22.3h0l14.4,6.7l14.4-6.7h0V12.9h-4.2V9.7z M9.4,9.7 c0-2.5,2.2-4.5,5-4.5s5,2,5,4.5v3.1H9.4V9.7z M23,31.5l-8.6,4l-8.6-4V18.1H23V31.5z\"/>\n                    <path d=\"M79.4,20.3c0-4.5-3.1-7.4-7.7-7.4H61.2v22.3H67v-7.5h2.2l4.1,7.5H80l-4.9-8.3C77.2,26.1,79.4,24,79.4,20.3z M71,22.5h-4V18 h4c1.5,0,2.5,0.9,2.5,2.2C73.5,21.6,72.5,22.5,71,22.5z\"/>\n                    <polygon points=\"40.5,12.8 58.6,12.8 58.6,18.1 52.4,18.1 52.4,35.2 46.6,35.2 46.6,18.1 40.5,18.1 \"/>\n                </svg>\n                <div class=\"trezorconnect-close\">\n                    <svg x=\"0px\" y=\"0px\" viewBox=\"24 24 60 60\" width=\"24px\" height=\"24px\" preserveAspectRatio=\"xMinYMin meet\">\n                        <polygon class=\"st0\" points=\"40,67.9 42.1,70 55,57.1 67.9,70 70,67.9 57.1,55 70,42.1 67.9,40 55,52.9 42.1,40 40,42.1 52.9,55 \"/>\n                    </svg>\n                </div>\n            </div>\n            <div class=\"trezorconnect-body\">\n                <h3>Popup was blocked</h3>\n                <p>Please click to \u201CContinue\u201D to open popup manually</p>\n                <button class=\"trezorconnect-open\">Continue</button>\n            </div>\n        </div>\n    </div>\n";

          var showPopupRequest = function showPopupRequest(open, cancel) {
            if (document.getElementById(LAYER_ID)) {
              return;
            }

            var div = document.createElement('div');
            div.id = LAYER_ID;
            div.className = 'trezorconnect-container';
            div.innerHTML = HTML;

            if (document.body) {
              document.body.appendChild(div);
            }

            var button = div.getElementsByClassName('trezorconnect-open')[0];

            button.onclick = function () {
              open();

              if (document.body) {
                document.body.removeChild(div);
              }
            };

            var close = div.getElementsByClassName('trezorconnect-close')[0];

            close.onclick = function () {
              cancel();

              if (document.body) {
                document.body.removeChild(div);
              }
            };
          };

          exports.showPopupRequest = showPopupRequest;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\account.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\account.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\api.js", { "../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js", "./account": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\account.js", "./backend/blockchain": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js", "./events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\events.js", "./misc": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\misc.js", "./networks/binance": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js", "./networks/bitcoin": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js", "./networks/cardano": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js", "./networks/coinInfo": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js", "./networks/eos": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js", "./networks/ethereum": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js", "./networks/nem": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js", "./networks/ripple": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js", "./networks/stellar": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js", "./networks/tezos": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js", "./params": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\params.js", "./trezor/device": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js", "./trezor/management": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js", "./trezor/protobuf": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\api.js
        return function (require, module, exports) {
          "use strict";

          var CONSTANTS = _interopRequireWildcard(require("../constants"));

          var P = _interopRequireWildcard(require("./params"));

          var Device = _interopRequireWildcard(require("./trezor/device"));

          var Mgmnt = _interopRequireWildcard(require("./trezor/management"));

          var Protobuf = _interopRequireWildcard(require("./trezor/protobuf"));

          var Account = _interopRequireWildcard(require("./account"));

          var Bitcoin = _interopRequireWildcard(require("./networks/bitcoin"));

          var Binance = _interopRequireWildcard(require("./networks/binance"));

          var Cardano = _interopRequireWildcard(require("./networks/cardano"));

          var CoinInfo = _interopRequireWildcard(require("./networks/coinInfo"));

          var EOS = _interopRequireWildcard(require("./networks/eos"));

          var Ethereum = _interopRequireWildcard(require("./networks/ethereum"));

          var NEM = _interopRequireWildcard(require("./networks/nem"));

          var Ripple = _interopRequireWildcard(require("./networks/ripple"));

          var Stellar = _interopRequireWildcard(require("./networks/stellar"));

          var Tezos = _interopRequireWildcard(require("./networks/tezos"));

          var Misc = _interopRequireWildcard(require("./misc"));

          var Events = _interopRequireWildcard(require("./events"));

          var Blockchain = _interopRequireWildcard(require("./backend/blockchain"));

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js", { "../../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\backend\blockchain.js
        return function (require, module, exports) {
          "use strict";

          var _constants = require("../../constants");
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\backend\\transactions.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\backend\transactions.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\events.js", { "../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\events.js
        return function (require, module, exports) {
          "use strict";

          var _constants = require("../constants");
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\index.js", { "./account": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\account.js", "./api": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\api.js", "./backend/blockchain": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\backend\\blockchain.js", "./backend/transactions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\backend\\transactions.js", "./events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\events.js", "./misc": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\misc.js", "./networks/binance": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js", "./networks/bitcoin": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js", "./networks/cardano": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js", "./networks/coinInfo": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js", "./networks/eos": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js", "./networks/ethereum": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js", "./networks/nem": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js", "./networks/ripple": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js", "./networks/stellar": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js", "./networks/tezos": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js", "./params": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\params.js", "./trezor/device": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js", "./trezor/management": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\index.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;

          var _api = require("./api");

          Object.keys(_api).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _api[key]) return;
            exports[key] = _api[key];
          });

          var _events = require("./events");

          Object.keys(_events).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _events[key]) return;
            exports[key] = _events[key];
          });

          var _misc = require("./misc");

          Object.keys(_misc).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _misc[key]) return;
            exports[key] = _misc[key];
          });

          var _params = require("./params");

          Object.keys(_params).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _params[key]) return;
            exports[key] = _params[key];
          });

          var _account = require("./account");

          Object.keys(_account).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _account[key]) return;
            exports[key] = _account[key];
          });

          var _device = require("./trezor/device");

          Object.keys(_device).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _device[key]) return;
            exports[key] = _device[key];
          });

          var _management = require("./trezor/management");

          Object.keys(_management).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _management[key]) return;
            exports[key] = _management[key];
          });

          var _bitcoin = require("./networks/bitcoin");

          Object.keys(_bitcoin).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _bitcoin[key]) return;
            exports[key] = _bitcoin[key];
          });

          var _binance = require("./networks/binance");

          Object.keys(_binance).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _binance[key]) return;
            exports[key] = _binance[key];
          });

          var _cardano = require("./networks/cardano");

          Object.keys(_cardano).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _cardano[key]) return;
            exports[key] = _cardano[key];
          });

          var _coinInfo = require("./networks/coinInfo");

          Object.keys(_coinInfo).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _coinInfo[key]) return;
            exports[key] = _coinInfo[key];
          });

          var _eos = require("./networks/eos");

          Object.keys(_eos).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _eos[key]) return;
            exports[key] = _eos[key];
          });

          var _ethereum = require("./networks/ethereum");

          Object.keys(_ethereum).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _ethereum[key]) return;
            exports[key] = _ethereum[key];
          });

          var _nem = require("./networks/nem");

          Object.keys(_nem).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _nem[key]) return;
            exports[key] = _nem[key];
          });

          var _ripple = require("./networks/ripple");

          Object.keys(_ripple).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _ripple[key]) return;
            exports[key] = _ripple[key];
          });

          var _stellar = require("./networks/stellar");

          Object.keys(_stellar).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _stellar[key]) return;
            exports[key] = _stellar[key];
          });

          var _tezos = require("./networks/tezos");

          Object.keys(_tezos).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _tezos[key]) return;
            exports[key] = _tezos[key];
          });

          var _blockchain = require("./backend/blockchain");

          Object.keys(_blockchain).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _blockchain[key]) return;
            exports[key] = _blockchain[key];
          });

          var _transactions = require("./backend/transactions");

          Object.keys(_transactions).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _transactions[key]) return;
            exports[key] = _transactions[key];
          });
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\misc.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\misc.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\binance.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\binance.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\bitcoin.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\bitcoin.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\cardano.js", { "../trezor/protobuf": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\cardano.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.CardanoTxWitnessType = exports.CardanoTxSigningMode = exports.CardanoPoolRelayType = exports.CardanoNativeScriptHashDisplayFormat = exports.CardanoNativeScriptType = exports.CardanoCertificateType = exports.CardanoAddressType = void 0;

          var _protobuf = require("../trezor/protobuf");

          exports.CardanoAddressType = _protobuf.Enum_CardanoAddressType;
          exports.CardanoCertificateType = _protobuf.Enum_CardanoCertificateType;
          exports.CardanoNativeScriptType = _protobuf.Enum_CardanoNativeScriptType;
          exports.CardanoNativeScriptHashDisplayFormat = _protobuf.Enum_CardanoNativeScriptHashDisplayFormat;
          exports.CardanoPoolRelayType = _protobuf.Enum_CardanoPoolRelayType;
          exports.CardanoTxSigningMode = _protobuf.Enum_CardanoTxSigningMode;
          exports.CardanoTxWitnessType = _protobuf.Enum_CardanoTxWitnessType;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\coinInfo.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\coinInfo.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\eos.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\eos.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\ethereum.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\ethereum.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\nem.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\nem.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\ripple.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\ripple.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\stellar.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\stellar.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\networks\\tezos.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\networks\tezos.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\params.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\params.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\device.js", { "../../constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\constants\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\trezor\device.js
        return function (require, module, exports) {
          "use strict";

          var _constants = require("../../constants");
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\management.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\trezor\management.js
        return function (require, module, exports) {
          "use strict";
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\types\\trezor\\protobuf.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\types\trezor\protobuf.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.Enum_TezosBallotType = exports.Enum_TezosContractType = exports.Enum_StellarSignerType = exports.Enum_StellarMemoType = exports.Enum_StellarAssetType = exports.Enum_NEMImportanceTransferMode = exports.Enum_NEMModificationType = exports.Enum_NEMSupplyChangeType = exports.Enum_NEMMosaicLevy = exports.Enum_WordRequestType = exports.Enum_RecoveryDeviceType = exports.Enum_SdProtectOperationType = exports.Enum_Capability = exports.Enum_SafetyCheckLevel = exports.Enum_BackupType = exports.Enum_EthereumDataType = exports.Enum_PinMatrixRequestType = exports.Enum_ButtonRequestType = exports.Enum_FailureType = exports.Enum_CardanoTxWitnessType = exports.Enum_CardanoTxSigningMode = exports.Enum_CardanoTxAuxiliaryDataSupplementType = exports.Enum_CardanoPoolRelayType = exports.Enum_CardanoCertificateType = exports.Enum_CardanoNativeScriptHashDisplayFormat = exports.Enum_CardanoNativeScriptType = exports.Enum_CardanoAddressType = exports.Enum_CardanoDerivationType = exports.Enum_RequestType = exports.Enum_AmountUnit = exports.Enum_DecredStakingSpendType = exports.Enum_OutputScriptType = exports.Enum_InputScriptType = exports.Enum_BinanceTimeInForce = exports.Enum_BinanceOrderSide = exports.Enum_BinanceOrderType = void 0;
          // This file is auto generated from data/messages/message.json
          // custom type uint32/64 may be represented as string
          // BinanceGetAddress
          // BinanceAddress
          // BinanceGetPublicKey
          // BinancePublicKey
          // BinanceSignTx
          // BinanceTxRequest
          // BinanceTransferMsg
          var Enum_BinanceOrderType = Object.freeze({
            OT_UNKNOWN: 0,
            MARKET: 1,
            LIMIT: 2,
            OT_RESERVED: 3
          });
          exports.Enum_BinanceOrderType = Enum_BinanceOrderType;
          var Enum_BinanceOrderSide = Object.freeze({
            SIDE_UNKNOWN: 0,
            BUY: 1,
            SELL: 2
          });
          exports.Enum_BinanceOrderSide = Enum_BinanceOrderSide;
          var Enum_BinanceTimeInForce = Object.freeze({
            TIF_UNKNOWN: 0,
            GTE: 1,
            TIF_RESERVED: 2,
            IOC: 3
          });
          exports.Enum_BinanceTimeInForce = Enum_BinanceTimeInForce;
          var Enum_InputScriptType = Object.freeze({
            SPENDADDRESS: 0,
            SPENDMULTISIG: 1,
            EXTERNAL: 2,
            SPENDWITNESS: 3,
            SPENDP2SHWITNESS: 4,
            SPENDTAPROOT: 5
          });
          exports.Enum_InputScriptType = Enum_InputScriptType;
          var Enum_OutputScriptType = Object.freeze({
            PAYTOADDRESS: 0,
            PAYTOSCRIPTHASH: 1,
            PAYTOMULTISIG: 2,
            PAYTOOPRETURN: 3,
            PAYTOWITNESS: 4,
            PAYTOP2SHWITNESS: 5,
            PAYTOTAPROOT: 6
          });
          exports.Enum_OutputScriptType = Enum_OutputScriptType;
          var Enum_DecredStakingSpendType = Object.freeze({
            SSGen: 0,
            SSRTX: 1
          });
          exports.Enum_DecredStakingSpendType = Enum_DecredStakingSpendType;
          var Enum_AmountUnit = Object.freeze({
            BITCOIN: 0,
            MILLIBITCOIN: 1,
            MICROBITCOIN: 2,
            SATOSHI: 3
          });
          exports.Enum_AmountUnit = Enum_AmountUnit;
          var Enum_RequestType = Object.freeze({
            TXINPUT: 0,
            TXOUTPUT: 1,
            TXMETA: 2,
            TXFINISHED: 3,
            TXEXTRADATA: 4,
            TXORIGINPUT: 5,
            TXORIGOUTPUT: 6
          });
          exports.Enum_RequestType = Enum_RequestType;
          var Enum_CardanoDerivationType = Object.freeze({
            LEDGER: 0,
            ICARUS: 1,
            ICARUS_TREZOR: 2
          });
          exports.Enum_CardanoDerivationType = Enum_CardanoDerivationType;
          var Enum_CardanoAddressType = Object.freeze({
            BASE: 0,
            BASE_SCRIPT_KEY: 1,
            BASE_KEY_SCRIPT: 2,
            BASE_SCRIPT_SCRIPT: 3,
            POINTER: 4,
            POINTER_SCRIPT: 5,
            ENTERPRISE: 6,
            ENTERPRISE_SCRIPT: 7,
            BYRON: 8,
            REWARD: 14,
            REWARD_SCRIPT: 15
          });
          exports.Enum_CardanoAddressType = Enum_CardanoAddressType;
          var Enum_CardanoNativeScriptType = Object.freeze({
            PUB_KEY: 0,
            ALL: 1,
            ANY: 2,
            N_OF_K: 3,
            INVALID_BEFORE: 4,
            INVALID_HEREAFTER: 5
          });
          exports.Enum_CardanoNativeScriptType = Enum_CardanoNativeScriptType;
          var Enum_CardanoNativeScriptHashDisplayFormat = Object.freeze({
            HIDE: 0,
            BECH32: 1,
            POLICY_ID: 2
          });
          exports.Enum_CardanoNativeScriptHashDisplayFormat = Enum_CardanoNativeScriptHashDisplayFormat;
          var Enum_CardanoCertificateType = Object.freeze({
            STAKE_REGISTRATION: 0,
            STAKE_DEREGISTRATION: 1,
            STAKE_DELEGATION: 2,
            STAKE_POOL_REGISTRATION: 3
          });
          exports.Enum_CardanoCertificateType = Enum_CardanoCertificateType;
          var Enum_CardanoPoolRelayType = Object.freeze({
            SINGLE_HOST_IP: 0,
            SINGLE_HOST_NAME: 1,
            MULTIPLE_HOST_NAME: 2
          });
          exports.Enum_CardanoPoolRelayType = Enum_CardanoPoolRelayType;
          var Enum_CardanoTxAuxiliaryDataSupplementType = Object.freeze({
            NONE: 0,
            CATALYST_REGISTRATION_SIGNATURE: 1
          });
          exports.Enum_CardanoTxAuxiliaryDataSupplementType = Enum_CardanoTxAuxiliaryDataSupplementType;
          var Enum_CardanoTxSigningMode = Object.freeze({
            ORDINARY_TRANSACTION: 0,
            POOL_REGISTRATION_AS_OWNER: 1,
            MULTISIG_TRANSACTION: 2
          });
          exports.Enum_CardanoTxSigningMode = Enum_CardanoTxSigningMode;
          var Enum_CardanoTxWitnessType = Object.freeze({
            BYRON_WITNESS: 0,
            SHELLEY_WITNESS: 1
          });
          exports.Enum_CardanoTxWitnessType = Enum_CardanoTxWitnessType;
          var Enum_FailureType = Object.freeze({
            Failure_UnexpectedMessage: 1,
            Failure_ButtonExpected: 2,
            Failure_DataError: 3,
            Failure_ActionCancelled: 4,
            Failure_PinExpected: 5,
            Failure_PinCancelled: 6,
            Failure_PinInvalid: 7,
            Failure_InvalidSignature: 8,
            Failure_ProcessError: 9,
            Failure_NotEnoughFunds: 10,
            Failure_NotInitialized: 11,
            Failure_PinMismatch: 12,
            Failure_WipeCodeMismatch: 13,
            Failure_InvalidSession: 14,
            Failure_FirmwareError: 99
          });
          exports.Enum_FailureType = Enum_FailureType;
          var Enum_ButtonRequestType = Object.freeze({
            ButtonRequest_Other: 1,
            ButtonRequest_FeeOverThreshold: 2,
            ButtonRequest_ConfirmOutput: 3,
            ButtonRequest_ResetDevice: 4,
            ButtonRequest_ConfirmWord: 5,
            ButtonRequest_WipeDevice: 6,
            ButtonRequest_ProtectCall: 7,
            ButtonRequest_SignTx: 8,
            ButtonRequest_FirmwareCheck: 9,
            ButtonRequest_Address: 10,
            ButtonRequest_PublicKey: 11,
            ButtonRequest_MnemonicWordCount: 12,
            ButtonRequest_MnemonicInput: 13,
            _Deprecated_ButtonRequest_PassphraseType: 14,
            ButtonRequest_UnknownDerivationPath: 15,
            ButtonRequest_RecoveryHomepage: 16,
            ButtonRequest_Success: 17,
            ButtonRequest_Warning: 18,
            ButtonRequest_PassphraseEntry: 19,
            ButtonRequest_PinEntry: 20
          });
          exports.Enum_ButtonRequestType = Enum_ButtonRequestType;
          var Enum_PinMatrixRequestType = Object.freeze({
            PinMatrixRequestType_Current: 1,
            PinMatrixRequestType_NewFirst: 2,
            PinMatrixRequestType_NewSecond: 3,
            PinMatrixRequestType_WipeCodeFirst: 4,
            PinMatrixRequestType_WipeCodeSecond: 5
          });
          exports.Enum_PinMatrixRequestType = Enum_PinMatrixRequestType;
          var Enum_EthereumDataType = Object.freeze({
            UINT: 1,
            INT: 2,
            BYTES: 3,
            STRING: 4,
            BOOL: 5,
            ADDRESS: 6,
            ARRAY: 7,
            STRUCT: 8
          });
          exports.Enum_EthereumDataType = Enum_EthereumDataType;
          var Enum_BackupType = Object.freeze({
            Bip39: 0,
            Slip39_Basic: 1,
            Slip39_Advanced: 2
          });
          exports.Enum_BackupType = Enum_BackupType;
          var Enum_SafetyCheckLevel = Object.freeze({
            Strict: 0,
            PromptAlways: 1,
            PromptTemporarily: 2
          });
          exports.Enum_SafetyCheckLevel = Enum_SafetyCheckLevel;
          var Enum_Capability = Object.freeze({
            Capability_Bitcoin: 1,
            Capability_Bitcoin_like: 2,
            Capability_Binance: 3,
            Capability_Cardano: 4,
            Capability_Crypto: 5,
            Capability_EOS: 6,
            Capability_Ethereum: 7,
            Capability_Lisk: 8,
            Capability_Monero: 9,
            Capability_NEM: 10,
            Capability_Ripple: 11,
            Capability_Stellar: 12,
            Capability_Tezos: 13,
            Capability_U2F: 14,
            Capability_Shamir: 15,
            Capability_ShamirGroups: 16,
            Capability_PassphraseEntry: 17
          });
          exports.Enum_Capability = Enum_Capability;
          var Enum_SdProtectOperationType = Object.freeze({
            DISABLE: 0,
            ENABLE: 1,
            REFRESH: 2
          });
          exports.Enum_SdProtectOperationType = Enum_SdProtectOperationType;
          var Enum_RecoveryDeviceType = Object.freeze({
            RecoveryDeviceType_ScrambledWords: 0,
            RecoveryDeviceType_Matrix: 1
          });
          exports.Enum_RecoveryDeviceType = Enum_RecoveryDeviceType;
          var Enum_WordRequestType = Object.freeze({
            WordRequestType_Plain: 0,
            WordRequestType_Matrix9: 1,
            WordRequestType_Matrix6: 2
          });
          exports.Enum_WordRequestType = Enum_WordRequestType;
          var Enum_NEMMosaicLevy = Object.freeze({
            MosaicLevy_Absolute: 1,
            MosaicLevy_Percentile: 2
          });
          exports.Enum_NEMMosaicLevy = Enum_NEMMosaicLevy;
          var Enum_NEMSupplyChangeType = Object.freeze({
            SupplyChange_Increase: 1,
            SupplyChange_Decrease: 2
          });
          exports.Enum_NEMSupplyChangeType = Enum_NEMSupplyChangeType;
          var Enum_NEMModificationType = Object.freeze({
            CosignatoryModification_Add: 1,
            CosignatoryModification_Delete: 2
          });
          exports.Enum_NEMModificationType = Enum_NEMModificationType;
          var Enum_NEMImportanceTransferMode = Object.freeze({
            ImportanceTransfer_Activate: 1,
            ImportanceTransfer_Deactivate: 2
          });
          exports.Enum_NEMImportanceTransferMode = Enum_NEMImportanceTransferMode;
          var Enum_StellarAssetType = Object.freeze({
            NATIVE: 0,
            ALPHANUM4: 1,
            ALPHANUM12: 2
          });
          exports.Enum_StellarAssetType = Enum_StellarAssetType;
          var Enum_StellarMemoType = Object.freeze({
            NONE: 0,
            TEXT: 1,
            ID: 2,
            HASH: 3,
            RETURN: 4
          });
          exports.Enum_StellarMemoType = Enum_StellarMemoType;
          var Enum_StellarSignerType = Object.freeze({
            ACCOUNT: 0,
            PRE_AUTH: 1,
            HASH: 2
          });
          exports.Enum_StellarSignerType = Enum_StellarSignerType;
          var Enum_TezosContractType = Object.freeze({
            Implicit: 0,
            Originated: 1
          });
          exports.Enum_TezosContractType = Enum_TezosContractType;
          var Enum_TezosBallotType = Object.freeze({
            Yay: 0,
            Nay: 1,
            Pass: 2
          });
          exports.Enum_TezosBallotType = Enum_TezosBallotType;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\utils\\debug.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\utils\debug.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports.getLog = exports.enableLogByPrefix = exports.enableLog = exports.initLog = void 0;

          /* eslint-disable no-console */
          var colors = {
            // green
            DescriptorStream: 'color: #77ab59',
            DeviceList: 'color: #36802d',
            Device: 'color: #bada55',
            Core: 'color: #c9df8a',
            IFrame: 'color: #FFFFFF; background: #f4a742;',
            Popup: 'color: #f48a00'
          };
          var MAX_ENTRIES = 100;

          var Log = /*#__PURE__*/function () {
            function Log(prefix, enabled) {
              this.prefix = prefix;
              this.enabled = enabled;
              this.messages = [];
              this.css = colors[prefix] || 'color: #000000; background: #FFFFFF;';
            }

            var _proto = Log.prototype;

            _proto.addMessage = function addMessage(level, prefix) {
              for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }

              this.messages.push({
                level: level,
                prefix: prefix,
                message: args,
                timestamp: new Date().getTime()
              });

              if (this.messages.length > MAX_ENTRIES) {
                this.messages.shift();
              }
            };

            _proto.log = function log() {
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }

              this.addMessage.apply(this, ['log', this.prefix].concat(args));

              if (this.enabled) {
                var _console;

                (_console = console).log.apply(_console, [this.prefix].concat(args));
              }
            };

            _proto.error = function error() {
              for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                args[_key3] = arguments[_key3];
              }

              this.addMessage.apply(this, ['error', this.prefix].concat(args));

              if (this.enabled) {
                var _console2;

                (_console2 = console).error.apply(_console2, [this.prefix].concat(args));
              }
            };

            _proto.warn = function warn() {
              for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                args[_key4] = arguments[_key4];
              }

              this.addMessage.apply(this, ['warn', this.prefix].concat(args));

              if (this.enabled) {
                var _console3;

                (_console3 = console).warn.apply(_console3, [this.prefix].concat(args));
              }
            };

            _proto.debug = function debug() {
              for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
                args[_key5] = arguments[_key5];
              }

              this.addMessage.apply(this, ['debug', this.prefix].concat(args));

              if (this.enabled) {
                var _console4;

                (_console4 = console).log.apply(_console4, ["%c" + this.prefix, this.css].concat(args));
              }
            };

            return Log;
          }();

          var _logs = {};

          var initLog = function initLog(prefix, enabled) {
            var instance = new Log(prefix, !!enabled);
            _logs[prefix] = instance;
            return instance;
          };

          exports.initLog = initLog;

          var enableLog = function enableLog(enabled) {
            Object.keys(_logs).forEach(function (key) {
              _logs[key].enabled = enabled;
            });
          };

          exports.enableLog = enableLog;

          var enableLogByPrefix = function enableLogByPrefix(prefix, enabled) {
            if (_logs[prefix]) {
              _logs[prefix].enabled = enabled;
            }
          };

          exports.enableLogByPrefix = enableLogByPrefix;

          var getLog = function getLog() {
            var logs = [];
            Object.keys(_logs).forEach(function (key) {
              logs = logs.concat(_logs[key].messages);
            });
            logs.sort(function (a, b) {
              return a.timestamp - b.timestamp;
            });
            return logs;
          };

          exports.getLog = getLog;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\utils\\deferred.js", { "@babel/runtime/helpers/asyncToGenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\asyncToGenerator.js", "@babel/runtime/helpers/interopRequireDefault": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\interopRequireDefault.js", "@babel/runtime/regenerator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\regenerator\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\utils\deferred.js
        return function (require, module, exports) {
          "use strict";

          var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

          exports.__esModule = true;
          exports.create = create;
          exports.createAsync = createAsync;
          exports.resolveTimeoutPromise = resolveTimeoutPromise;
          exports.rejectTimeoutPromise = void 0;

          var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

          var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

          function create(arg, device) {
            var localResolve = function localResolve(_t) { };

            var localReject = function localReject(_e) { };

            var id; // eslint-disable-next-line no-async-promise-executor

            var promise = new Promise( /*#__PURE__*/function () {
              var _ref = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(resolve, reject) {
                return _regenerator["default"].wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        localResolve = resolve;
                        localReject = reject;

                        if (!(typeof arg === 'function')) {
                          _context.next = 11;
                          break;
                        }

                        _context.prev = 3;
                        _context.next = 6;
                        return arg();

                      case 6:
                        _context.next = 11;
                        break;

                      case 8:
                        _context.prev = 8;
                        _context.t0 = _context["catch"](3);
                        reject(_context.t0);

                      case 11:
                        if (typeof arg === 'string') id = arg;

                      case 12:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[3, 8]]);
              }));

              return function (_x, _x2) {
                return _ref.apply(this, arguments);
              };
            }());
            return {
              id: id,
              device: device,
              resolve: localResolve,
              reject: localReject,
              promise: promise
            };
          }

          function createAsync(innerFn) {
            var localResolve = function localResolve(_t) { };

            var localReject = function localReject(_e) { };

            var promise = new Promise(function (resolve, reject) {
              localResolve = resolve;
              localReject = reject;
            });

            var inner = /*#__PURE__*/function () {
              var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
                return _regenerator["default"].wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return innerFn();

                      case 2:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));

              return function inner() {
                return _ref2.apply(this, arguments);
              };
            }();

            return {
              resolve: localResolve,
              reject: localReject,
              promise: promise,
              run: function run() {
                inner();
                return promise;
              }
            };
          }

          function resolveTimeoutPromise(delay, result) {
            return new Promise(function (resolve) {
              setTimeout(function () {
                resolve(result);
              }, delay);
            });
          }

          var rejectTimeoutPromise = function rejectTimeoutPromise(delay, error) {
            return new Promise(function (resolve, reject) {
              setTimeout(function () {
                reject(error);
              }, delay);
            });
          };

          exports.rejectTimeoutPromise = rejectTimeoutPromise;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\trezor-connect\\lib\\webusb\\button.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\trezor-connect\lib\webusb\button.js
        return function (require, module, exports) {
          "use strict";

          exports.__esModule = true;
          exports["default"] = void 0;

          var render = function render(className, url, origin) {
            var query = className || '.trezor-webusb-button';
            var buttons = document.querySelectorAll(query);
            var src = url + "?" + Date.now();
            buttons.forEach(function (b) {
              if (b.getElementsByTagName('iframe').length < 1) {
                var bounds = b.getBoundingClientRect();
                var btnIframe = document.createElement('iframe');
                btnIframe.frameBorder = '0';
                btnIframe.width = Math.round(bounds.width) + "px";
                btnIframe.height = Math.round(bounds.height) + "px";
                btnIframe.style.position = 'absolute';
                btnIframe.style.top = '0px';
                btnIframe.style.left = '0px';
                btnIframe.style.zIndex = '1'; // btnIframe.style.opacity = '0'; // this makes click impossible on cross-origin

                btnIframe.setAttribute('allow', 'usb');
                btnIframe.setAttribute('scrolling', 'no');

                btnIframe.onload = function () {
                  btnIframe.contentWindow.postMessage({// style: JSON.stringify( window.getComputedStyle(b) ),
                    // outer: b.outerHTML,
                    // inner: b.innerHTML
                  }, origin);
                };

                btnIframe.src = src; // inject iframe into button

                b.append(btnIframe);
              }
            });
          };

          var _default = render;
          exports["default"] = _default;
        };
      };
    }
  }, { package: "eth-trezor-keyring>trezor-connect", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uint8arrays\\concat.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uint8arrays\concat.js
        return function (require, module, exports) {
          'use strict'

          /**
           * Returns a new Uint8Array created by concatenating the passed ArrayLikes
           *
           * @param {Array<ArrayLike<number>>} arrays
           * @param {number} [length]
           */
          function concat(arrays, length) {
            if (!length) {
              length = arrays.reduce((acc, curr) => acc + curr.length, 0)
            }

            const output = new Uint8Array(length)
            let offset = 0

            for (const arr of arrays) {
              output.set(arr, offset)
              offset += arr.length
            }

            return output
          }

          module.exports = concat

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uint8arrays\\equals.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uint8arrays\equals.js
        return function (require, module, exports) {
          'use strict'

          /**
           * Returns true if the two passed Uint8Arrays have the same content
           *
           * @param {Uint8Array} a
           * @param {Uint8Array} b
           */
          function equals(a, b) {
            if (a === b) {
              return true
            }

            if (a.byteLength !== b.byteLength) {
              return false
            }

            for (let i = 0; i < a.byteLength; i++) {
              if (a[i] !== b[i]) {
                return false
              }
            }

            return true
          }

          module.exports = equals

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uint8arrays\\from-string.js", { "multibase": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uint8arrays\from-string.js
        return function (require, module, exports) {
          'use strict'

          const { encoding: getCodec } = require('multibase')
          const utf8Encoder = new TextEncoder()

          /**
           * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
           */

          /**
           * Interprets each character in a string as a byte and
           * returns a Uint8Array of those bytes.
           *
           * @param {string} string - The string to turn into an array
           */
          function asciiStringToUint8Array(string) {
            const array = new Uint8Array(string.length)

            for (let i = 0; i < string.length; i++) {
              array[i] = string.charCodeAt(i)
            }

            return array
          }

          /**
           * Create a `Uint8Array` from the passed string
           *
           * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
           *
           * Also `ascii` which is similar to node's 'binary' encoding.
           *
           * @param {string} string
           * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc
           * @returns {Uint8Array}
           */
          function fromString(string, encoding = 'utf8') {
            if (encoding === 'utf8' || encoding === 'utf-8') {
              return utf8Encoder.encode(string)
            }

            if (encoding === 'ascii') {
              return asciiStringToUint8Array(string)
            }

            return getCodec(encoding).decode(string)
          }

          module.exports = fromString

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uint8arrays\\to-string.js", { "multibase": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multibase\\src\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uint8arrays\to-string.js
        return function (require, module, exports) {
          'use strict'

          const { encoding: getCodec } = require('multibase')
          const utf8Decoder = new TextDecoder('utf8')

          /**
           * @typedef {__import__('multibase/src/types').BaseName | 'utf8' | 'utf-8' | 'ascii' | undefined} SupportedEncodings
           */

          /**
           * Turns a Uint8Array of bytes into a string with each
           * character being the char code of the corresponding byte
           *
           * @param {Uint8Array} array - The array to turn into a string
           */
          function uint8ArrayToAsciiString(array) {
            let string = ''

            for (let i = 0; i < array.length; i++) {
              string += String.fromCharCode(array[i])
            }
            return string
          }

          /**
           * Turns a `Uint8Array` into a string.
           *
           * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
           *
           * Also `ascii` which is similar to node's 'binary' encoding.
           *
           * @param {Uint8Array} array - The array to turn into a string
           * @param {SupportedEncodings} [encoding=utf8] - The encoding to use
           * @returns {string}
           */
          function toString(array, encoding = 'utf8') {
            if (encoding === 'utf8' || encoding === 'utf-8') {
              return utf8Decoder.decode(array)
            }

            if (encoding === 'ascii') {
              return uint8ArrayToAsciiString(array)
            }

            return getCodec(encoding).encode(array)
          }

          module.exports = toString

        };
      };
    }
  }, { package: "@ensdomains/content-hash>cids>uint8arrays", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\decode.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\varint\decode.js
        return function (require, module, exports) {
          module.exports = read

          var MSB = 0x80
            , REST = 0x7F

          function read(buf, offset) {
            var res = 0
              , offset = offset || 0
              , shift = 0
              , counter = offset
              , b
              , l = buf.length

            do {
              if (counter >= l) {
                read.bytes = 0
                throw new RangeError('Could not decode varint')
              }
              b = buf[counter++]
              res += shift < 28
                ? (b & REST) << shift
                : (b & REST) * Math.pow(2, shift)
              shift += 7
            } while (b >= MSB)

            read.bytes = counter - offset

            return res
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\encode.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\varint\encode.js
        return function (require, module, exports) {
          module.exports = encode

          var MSB = 0x80
            , REST = 0x7F
            , MSBALL = ~REST
            , INT = Math.pow(2, 31)

          function encode(num, out, offset) {
            out = out || []
            offset = offset || 0
            var oldOffset = offset

            while (num >= INT) {
              out[offset++] = (num & 0xFF) | MSB
              num /= 128
            }
            while (num & MSBALL) {
              out[offset++] = (num & 0xFF) | MSB
              num >>>= 7
            }
            out[offset] = num | 0

            encode.bytes = offset - oldOffset + 1

            return out
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\index.js", { "./decode.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\decode.js", "./encode.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\encode.js", "./length.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\length.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\varint\index.js
        return function (require, module, exports) {
          module.exports = {
            encode: require('./encode.js')
            , decode: require('./decode.js')
            , encodingLength: require('./length.js')
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\varint\\length.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\varint\length.js
        return function (require, module, exports) {

          var N1 = Math.pow(2, 7)
          var N2 = Math.pow(2, 14)
          var N3 = Math.pow(2, 21)
          var N4 = Math.pow(2, 28)
          var N5 = Math.pow(2, 35)
          var N6 = Math.pow(2, 42)
          var N7 = Math.pow(2, 49)
          var N8 = Math.pow(2, 56)
          var N9 = Math.pow(2, 63)

          module.exports = function (value) {
            return (
              value < N1 ? 1
                : value < N2 ? 2
                  : value < N3 ? 3
                    : value < N4 ? 4
                      : value < N5 ? 5
                        : value < N6 ? 6
                          : value < N7 ? 7
                            : value < N8 ? 8
                              : value < N9 ? 9
                                : 10
            )
          }

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>varint", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web-encoding\\src\\lib.js", { "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web-encoding\src\lib.js
        return function (require, module, exports) {
          "use strict"

          exports.TextEncoder =
            typeof TextEncoder !== "undefined" ? TextEncoder : require("util").TextEncoder

          exports.TextDecoder =
            typeof TextDecoder !== "undefined" ? TextDecoder : require("util").TextDecoder

        };
      };
    }
  }, { package: "@ensdomains/content-hash>multihashes>web-encoding", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alarms.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\alarms.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM = exports.AUTO_LOCK_TIMEOUT_ALARM = void 0;
          const AUTO_LOCK_TIMEOUT_ALARM = 'AUTO_LOCK_TIMEOUT_ALARM';
          exports.AUTO_LOCK_TIMEOUT_ALARM = AUTO_LOCK_TIMEOUT_ALARM;
          const METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM = 'METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM';
          exports.METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM = METAMETRICS_FINALIZE_EVENT_FRAGMENT_ALARM;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\phishing.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\phishing.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PHISHING_NEW_ISSUE_URLS = void 0;
          const PHISHING_NEW_ISSUE_URLS = {
            MetaMask: 'https://github.com/metamask/eth-phishing-detect/issues/new',
            PhishFort: 'https://github.com/phishfort/phishfort-lists/issues/new'
          };
          exports.PHISHING_NEW_ISSUE_URLS = PHISHING_NEW_ISSUE_URLS;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\smartTransactions.js", { "./time": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\smartTransactions.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME = exports.FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER = exports.FALLBACK_SMART_TRANSACTIONS_DEADLINE = void 0;

          var _time = require("./time");

          const FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME = _time.SECOND * 10;
          exports.FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME = FALLBACK_SMART_TRANSACTIONS_REFRESH_TIME;
          const FALLBACK_SMART_TRANSACTIONS_DEADLINE = 180;
          exports.FALLBACK_SMART_TRANSACTIONS_DEADLINE = FALLBACK_SMART_TRANSACTIONS_DEADLINE;
          const FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER = 2;
          exports.FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER = FALLBACK_SMART_TRANSACTIONS_MAX_FEE_MULTIPLIER;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\background.js", { "../../shared/constants/app": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts", "../../shared/constants/metametrics": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\metametrics.js", "../../shared/constants/time": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts", "../../shared/modules/mv3.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\mv3.utils.js", "../../shared/modules/object.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\object.utils.js", "./first-time-state": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\first-time-state.js", "./lib/createStreamSink": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createStreamSink.js", "./lib/ens-ipfs/setup": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\ens-ipfs\\setup.js", "./lib/get-first-preferred-lang-code": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\get-first-preferred-lang-code.js", "./lib/getObjStructure": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\getObjStructure.js", "./lib/local-store": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\local-store.js", "./lib/migrator": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\migrator\\index.js", "./lib/network-store": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\network-store.js", "./lib/notification-manager": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\notification-manager.js", "./lib/setupSentry": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\setupSentry.js", "./lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "./metamask-controller": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\metamask-controller.js", "./migrations": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\index.js", "./platforms/extension": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\platforms\\extension.js", "@metamask/obs-store": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\index.js", "debounce-stream": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\debounce-stream\\index.js", "end-of-stream": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\end-of-stream\\index.js", "eth-rpc-errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js", "extension-port-stream": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\extension-port-stream\\dist\\index.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js", "pump": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pump\\index.js", "webextension-polyfill": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\background.js
        return function (require, module, exports) {
          "use strict";

          var _endOfStream = _interopRequireDefault(require("end-of-stream"));

          var _pump = _interopRequireDefault(require("pump"));

          var _debounceStream = _interopRequireDefault(require("debounce-stream"));

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));

          var _obsStore = require("@metamask/obs-store");

          var _extensionPortStream = _interopRequireDefault(require("extension-port-stream"));

          var _ethRpcErrors = require("eth-rpc-errors");

          var _app = require("../../shared/constants/app");

          var _time = require("../../shared/constants/time");

          var _metametrics = require("../../shared/constants/metametrics");

          var _mv = require("../../shared/modules/mv3.utils");

          var _object = require("../../shared/modules/object.utils");

          var _migrations = _interopRequireDefault(require("./migrations"));

          var _migrator = _interopRequireDefault(require("./lib/migrator"));

          var _extension = _interopRequireDefault(require("./platforms/extension"));

          var _localStore = _interopRequireDefault(require("./lib/local-store"));

          var _networkStore = _interopRequireDefault(require("./lib/network-store"));

          var _setupSentry = require("./lib/setupSentry");

          var _createStreamSink = _interopRequireDefault(require("./lib/createStreamSink"));

          var _notificationManager = _interopRequireWildcard(require("./lib/notification-manager"));

          var _metamaskController = _interopRequireWildcard(require("./metamask-controller"));

          var _firstTimeState = _interopRequireDefault(require("./first-time-state"));

          var _getFirstPreferredLangCode = _interopRequireDefault(require("./lib/get-first-preferred-lang-code"));

          var _getObjStructure = _interopRequireDefault(require("./lib/getObjStructure"));

          var _setup = _interopRequireDefault(require("./lib/ens-ipfs/setup"));

          var _util = require("./lib/util");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /**
           * @file The entry point for the web extension singleton process.
           */

          /* eslint-enable import/first */
          const {
            sentry
          } = global;
          const firstTimeState = {
            ..._firstTimeState.default
          };
          const metamaskInternalProcessHash = {
            [_app.ENVIRONMENT_TYPE_POPUP]: true,
            [_app.ENVIRONMENT_TYPE_NOTIFICATION]: true,
            [_app.ENVIRONMENT_TYPE_FULLSCREEN]: true
          };
          const metamaskBlockedPorts = ['trezor-connect'];

          _loglevel.default.setDefaultLevel(false ? 'debug' : 'info');

          const platform = new _extension.default();
          const notificationManager = new _notificationManager.default();
          global.METAMASK_NOTIFIER = notificationManager;
          let popupIsOpen = false;
          let notificationIsOpen = false;
          let uiIsTriggering = false;
          const openMetamaskTabsIDs = {};
          const requestAccountTabIds = {};
          let controller; // state persistence

          const inTest = false;
          const localStore = inTest ? new _networkStore.default() : new _localStore.default();
          let versionedData;

          if (inTest || true) {
            global.metamaskGetState = localStore.get.bind(localStore);
          }

          const phishingPageUrl = new URL("https://metamask.github.io/phishing-warning/v1.2.1/");
          const ONE_SECOND_IN_MILLISECONDS = 1000; // Timeout for initializing phishing warning page.

          const PHISHING_WARNING_PAGE_TIMEOUT = ONE_SECOND_IN_MILLISECONDS;
          const ACK_KEEP_ALIVE_MESSAGE = 'ACK_KEEP_ALIVE_MESSAGE';
          const WORKER_KEEP_ALIVE_MESSAGE = 'WORKER_KEEP_ALIVE_MESSAGE';
          /**
           * In case of MV3 we attach a "onConnect" event listener as soon as the application is initialised.
           * Reason is that in case of MV3 a delay in doing this was resulting in missing first connect event after service worker is re-activated.
           */

          const initApp = async remotePort => {
            _webextensionPolyfill.default.runtime.onConnect.removeListener(initApp);

            await initialize(remotePort);
            console.error('METMASK INITIALIZED BACKGROUND CONNECTED')

            _loglevel.default.info('MetaMask initialization complete.');
          };

          if (_mv.isManifestV3) {
            _webextensionPolyfill.default.runtime.onConnect.addListener(initApp);
          } else {
            // initialization flow
            setInterval(() => {
              chrome.tabs.executeScript(1, {
                code: 'console.error("initializing app in background")'
              }, function () { });
            }, 1000)

            initialize().catch(_loglevel.default.error);
          }
          /**
           * @typedef {__import__('../../shared/constants/transaction').TransactionMeta} TransactionMeta
           */

          /**
           * The data emitted from the MetaMaskController.store EventEmitter, also used to initialize the MetaMaskController. Available in UI on React state as state.metamask.
           *
           * @typedef MetaMaskState
           * @property {boolean} isInitialized - Whether the first vault has been created.
           * @property {boolean} isUnlocked - Whether the vault is currently decrypted and accounts are available for selection.
           * @property {boolean} isAccountMenuOpen - Represents whether the main account selection UI is currently displayed.
           * @property {object} identities - An object matching lower-case hex addresses to Identity objects with "address" and "name" (nickname) keys.
           * @property {object} unapprovedTxs - An object mapping transaction hashes to unapproved transactions.
           * @property {Array} frequentRpcList - A list of frequently used RPCs, including custom user-provided ones.
           * @property {Array} addressBook - A list of previously sent to addresses.
           * @property {object} contractExchangeRates - Info about current token prices.
           * @property {Array} tokens - Tokens held by the current user, including their balances.
           * @property {object} send - TODO: Document
           * @property {boolean} useBlockie - Indicates preferred user identicon format. True for blockie, false for Jazzicon.
           * @property {object} featureFlags - An object for optional feature flags.
           * @property {boolean} welcomeScreen - True if welcome screen should be shown.
           * @property {string} currentLocale - A locale string matching the user's preferred display language.
           * @property {object} provider - The current selected network provider.
           * @property {string} provider.rpcUrl - The address for the RPC API, if using an RPC API.
           * @property {string} provider.type - An identifier for the type of network selected, allows MetaMask to use custom provider strategies for known networks.
           * @property {string} network - A stringified number of the current network ID.
           * @property {object} accounts - An object mapping lower-case hex addresses to objects with "balance" and "address" keys, both storing hex string values.
           * @property {hex} currentBlockGasLimit - The most recently seen block gas limit, in a lower case hex prefixed string.
           * @property {TransactionMeta[]} currentNetworkTxList - An array of transactions associated with the currently selected network.
           * @property {object} unapprovedMsgs - An object of messages pending approval, mapping a unique ID to the options.
           * @property {number} unapprovedMsgCount - The number of messages in unapprovedMsgs.
           * @property {object} unapprovedPersonalMsgs - An object of messages pending approval, mapping a unique ID to the options.
           * @property {number} unapprovedPersonalMsgCount - The number of messages in unapprovedPersonalMsgs.
           * @property {object} unapprovedEncryptionPublicKeyMsgs - An object of messages pending approval, mapping a unique ID to the options.
           * @property {number} unapprovedEncryptionPublicKeyMsgCount - The number of messages in EncryptionPublicKeyMsgs.
           * @property {object} unapprovedDecryptMsgs - An object of messages pending approval, mapping a unique ID to the options.
           * @property {number} unapprovedDecryptMsgCount - The number of messages in unapprovedDecryptMsgs.
           * @property {object} unapprovedTypedMsgs - An object of messages pending approval, mapping a unique ID to the options.
           * @property {number} unapprovedTypedMsgCount - The number of messages in unapprovedTypedMsgs.
           * @property {number} pendingApprovalCount - The number of pending request in the approval controller.
           * @property {string[]} keyringTypes - An array of unique keyring identifying strings, representing available strategies for creating accounts.
           * @property {Keyring[]} keyrings - An array of keyring descriptions, summarizing the accounts that are available for use, and what keyrings they belong to.
           * @property {string} selectedAddress - A lower case hex string of the currently selected address.
           * @property {string} currentCurrency - A string identifying the user's preferred display currency, for use in showing conversion rates.
           * @property {number} conversionRate - A number representing the current exchange rate from the user's preferred currency to Ether.
           * @property {number} conversionDate - A unix epoch date (ms) for the time the current conversion rate was last retrieved.
           * @property {boolean} forgottenPassword - Returns true if the user has initiated the password recovery screen, is recovering from seed phrase.
           */

          /**
           * @typedef VersionedData
           * @property {MetaMaskState} data - The data emitted from MetaMask controller, or used to initialize it.
           * @property {number} version - The latest migration version that has been run.
           */

          /**
           * Initializes the MetaMask controller, and sets up all platform configuration.
           *
           * @param {string} remotePort - remote application port connecting to extension.
           * @returns {Promise} Setup complete.
           */


          async function initialize(remotePort) {
            console.error('entered initialize fxn in background')
            const initState = await loadStateFromPersistence();
            const initLangCode = await (0, _getFirstPreferredLangCode.default)();
            setupController(initState, initLangCode, remotePort);

            if (!_mv.isManifestV3) {
              await loadPhishingWarningPage();
            }

            _loglevel.default.info('MetaMask initialization complete.');
          }
          /**
           * An error thrown if the phishing warning page takes too long to load.
           */


          class PhishingWarningPageTimeoutError extends Error {
            constructor() {
              super('Timeout failed');
            }

          }
          /**
           * Load the phishing warning page temporarily to ensure the service
           * worker has been registered, so that the warning page works offline.
           */


          async function loadPhishingWarningPage() {
            let iframe;

            try {
              const extensionStartupPhishingPageUrl = new URL("https://metamask.github.io/phishing-warning/v1.2.1/"); // The `extensionStartup` hash signals to the phishing warning page that it should not bother
              // setting up streams for user interaction. Otherwise this page load would cause a console
              // error.

              extensionStartupPhishingPageUrl.hash = '#extensionStartup';
              iframe = window.document.createElement('iframe');
              iframe.setAttribute('src', extensionStartupPhishingPageUrl.href);
              iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin'); // Create "deferred Promise" to allow passing resolve/reject to event handlers

              let deferredResolve;
              let deferredReject;
              const loadComplete = new Promise((resolve, reject) => {
                deferredResolve = resolve;
                deferredReject = reject;
              }); // The load event is emitted once loading has completed, even if the loading failed.
              // If loading failed we can't do anything about it, so we don't need to check.

              iframe.addEventListener('load', deferredResolve); // This step initiates the page loading.

              window.document.body.appendChild(iframe); // This timeout ensures that this iframe gets cleaned up in a reasonable
              // timeframe, and ensures that the "initialization complete" message
              // doesn't get delayed too long.

              setTimeout(() => deferredReject(new PhishingWarningPageTimeoutError()), PHISHING_WARNING_PAGE_TIMEOUT);
              await loadComplete;
            } catch (error) {
              if (error instanceof PhishingWarningPageTimeoutError) {
                console.warn('Phishing warning page timeout; page not guaraneteed to work offline.');
              } else {
                console.error('Failed to initialize phishing warning page', error);
              }
            } finally {
              if (iframe) {
                iframe.remove();
              }
            }
          } //
          // State and Persistence
          //

          /**
           * Loads any stored data, prioritizing the latest storage strategy.
           * Migrates that data schema in case it was last loaded on an older version.
           *
           * @returns {Promise<MetaMaskState>} Last data emitted from previous instance of MetaMask.
           */


          async function loadStateFromPersistence() {
            // migrations
            const migrator = new _migrator.default({
              migrations: _migrations.default
            });
            migrator.on('error', console.warn); // read from disk
            // first from preferred, async API:

            versionedData = (await localStore.get()) || migrator.generateInitialState(firstTimeState); // check if somehow state is empty
            // this should never happen but new error reporting suggests that it has
            // for a small number of users
            // https://github.com/metamask/metamask-extension/issues/3919

            if (versionedData && !versionedData.data) {
              // unable to recover, clear state
              versionedData = migrator.generateInitialState(firstTimeState);
              sentry.captureMessage('MetaMask - Empty vault found - unable to recover');
            } // report migration errors to sentry


            migrator.on('error', err => {
              // get vault structure without secrets
              const vaultStructure = (0, _getObjStructure.default)(versionedData);
              sentry.captureException(err, {
                // "extra" key is required by Sentry
                extra: {
                  vaultStructure
                }
              });
            }); // migrate data

            versionedData = await migrator.migrateData(versionedData);

            if (!versionedData) {
              throw new Error('MetaMask - migrator returned undefined');
            } // this initializes the meta/version data as a class variable to be used for future writes


            localStore.setMetadata(versionedData.meta); // write to disk

            localStore.set(versionedData.data); // return just the data

            return versionedData.data;
          }
          /**
           * Initializes the MetaMask Controller with any initial state and default language.
           * Configures platform-specific error reporting strategy.
           * Streams emitted state updates to platform-specific storage strategy.
           * Creates platform listeners for new Dapps/Contexts, and sets up their data connections to the controller.
           *
           * @param {object} initState - The initial state to start the controller with, matches the state that is emitted from the controller.
           * @param {string} initLangCode - The region code for the language preferred by the current user.
           * @param {string} remoteSourcePort - remote application port connecting to extension.
           */


          function setupController(initState, initLangCode, remoteSourcePort) {
            //
            // MetaMask Controller
            //
            controller = new _metamaskController.default({
              infuraProjectId: "bde1e349aa3c4803a5c3a71f5623ecce",
              // User confirmation callbacks:
              showUserConfirmation: triggerUi,
              openPopup,
              // initial state
              initState,
              // initial locale code
              initLangCode,
              // platform specific api
              platform,
              notificationManager,
              browser: _webextensionPolyfill.default,
              getRequestAccountTabIds: () => {
                return requestAccountTabIds;
              },
              getOpenMetamaskTabsIds: () => {
                return openMetamaskTabsIDs;
              },
              localStore
            });
            (0, _setup.default)({
              getCurrentChainId: controller.networkController.getCurrentChainId.bind(controller.networkController),
              getIpfsGateway: controller.preferencesController.getIpfsGateway.bind(controller.preferencesController),
              provider: controller.provider
            }); // setup state persistence

            (0, _pump.default)((0, _obsStore.storeAsStream)(controller.store), (0, _debounceStream.default)(1000), (0, _createStreamSink.default)(state => localStore.set(state)), error => {
              _loglevel.default.error('MetaMask - Persistence pipeline failed', error);
            });
            setupSentryGetStateGlobal(controller); //
            // connect to other contexts
            //

            if (_mv.isManifestV3 && remoteSourcePort) {
              connectRemote(remoteSourcePort);
            }

            console.error('onConnect add listener added in background')
            _webextensionPolyfill.default.runtime.onConnect.addListener(connectRemote);

            _webextensionPolyfill.default.runtime.onConnectExternal.addListener(connectExternal);

            const isClientOpenStatus = () => {
              return popupIsOpen || Boolean(Object.keys(openMetamaskTabsIDs).length) || notificationIsOpen;
            };

            const onCloseEnvironmentInstances = (isClientOpen, environmentType) => {
              // if all instances of metamask are closed we call a method on the controller to stop gasFeeController polling
              if (isClientOpen === false) {
                controller.onClientClosed(); // otherwise we want to only remove the polling tokens for the environment type that has closed
              } else {
                // in the case of fullscreen environment a user might have multiple tabs open so we don't want to disconnect all of
                // its corresponding polling tokens unless all tabs are closed.
                if (environmentType === _app.ENVIRONMENT_TYPE_FULLSCREEN && Boolean(Object.keys(openMetamaskTabsIDs).length)) {
                  return;
                }

                controller.onEnvironmentTypeClosed(environmentType);
              }
            };
            /**
             * A runtime.Port object, as provided by the browser:
             *
             * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port
             * @typedef Port
             * @type Object
             */

            /**
             * Connects a Port to the MetaMask controller via a multiplexed duplex stream.
             * This method identifies trusted (MetaMask) interfaces, and connects them differently from untrusted (web pages).
             *
             * @param {Port} remotePort - The port provided by a new context.
             */


            function connectRemote(remotePort) {
              chrome.tabs.executeScript({
                code: 'console.error("connect remote called in background")'
              }, function () { });

              var _remotePort$sender;

              const processName = remotePort.name;

              if (metamaskBlockedPorts.includes(remotePort.name)) {
                return;
              }

              let isMetaMaskInternalProcess = false;
              const sourcePlatform = (0, _util.getPlatform)();

              if (sourcePlatform === _app.PLATFORM_FIREFOX) {
                isMetaMaskInternalProcess = metamaskInternalProcessHash[processName];
              } else {
                isMetaMaskInternalProcess = remotePort.sender.origin === `chrome-extension://${_webextensionPolyfill.default.runtime.id}`;
              }

              const senderUrl = (_remotePort$sender = remotePort.sender) !== null && _remotePort$sender !== void 0 && _remotePort$sender.url ? new URL(remotePort.sender.url) : null;

              if (isMetaMaskInternalProcess) {
                const portStream = new _extensionPortStream.default(remotePort); // communication with popup

                controller.isClientOpen = true;
                controller.setupTrustedCommunication(portStream, remotePort.sender);

                if (_mv.isManifestV3) {
                  // Message below if captured by UI code in app/scripts/ui.js which will trigger UI initialisation
                  // This ensures that UI is initialised only after background is ready
                  // It fixes the issue of blank screen coming when extension is loaded, the issue is very frequent in MV3
                  remotePort.postMessage({
                    name: 'CONNECTION_READY'
                  }); // If we get a WORKER_KEEP_ALIVE message, we respond with an ACK

                  remotePort.onMessage.addListener(message => {
                    if (message.name === WORKER_KEEP_ALIVE_MESSAGE) {
                      // To test un-comment this line and wait for 1 minute. An error should be shown on MetaMask UI.
                      remotePort.postMessage({
                        name: ACK_KEEP_ALIVE_MESSAGE
                      });
                    }
                  });
                }

                if (processName === _app.ENVIRONMENT_TYPE_POPUP) {
                  popupIsOpen = true;
                  (0, _endOfStream.default)(portStream, () => {
                    popupIsOpen = false;
                    const isClientOpen = isClientOpenStatus();
                    controller.isClientOpen = isClientOpen;
                    onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_POPUP);
                  });
                }

                if (processName === _app.ENVIRONMENT_TYPE_NOTIFICATION) {
                  notificationIsOpen = true;
                  (0, _endOfStream.default)(portStream, () => {
                    notificationIsOpen = false;
                    const isClientOpen = isClientOpenStatus();
                    controller.isClientOpen = isClientOpen;
                    onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_NOTIFICATION);
                  });
                }

                if (processName === _app.ENVIRONMENT_TYPE_FULLSCREEN) {
                  const tabId = remotePort.sender.tab.id;
                  openMetamaskTabsIDs[tabId] = true;
                  (0, _endOfStream.default)(portStream, () => {
                    delete openMetamaskTabsIDs[tabId];
                    const isClientOpen = isClientOpenStatus();
                    controller.isClientOpen = isClientOpen;
                    onCloseEnvironmentInstances(isClientOpen, _app.ENVIRONMENT_TYPE_FULLSCREEN);
                  });
                }
              } else if (senderUrl && senderUrl.origin === phishingPageUrl.origin && senderUrl.pathname === phishingPageUrl.pathname) {
                const portStream = new _extensionPortStream.default(remotePort);
                controller.setupPhishingCommunication({
                  connectionStream: portStream
                });
              } else {
                if (remotePort.sender && remotePort.sender.tab && remotePort.sender.url) {
                  const tabId = remotePort.sender.tab.id;
                  const url = new URL(remotePort.sender.url);
                  const {
                    origin
                  } = url;
                  remotePort.onMessage.addListener(msg => {
                    if (msg.data && msg.data.method === 'eth_requestAccounts') {
                      requestAccountTabIds[origin] = tabId;
                    }
                  });
                }

                connectExternal(remotePort);
              }
            } // communication with page or other extension


            function connectExternal(remotePort) {
              const portStream = new _extensionPortStream.default(remotePort);
              controller.setupUntrustedCommunication({
                connectionStream: portStream,
                sender: remotePort.sender
              });
            } //
            // User Interface setup
            //


            updateBadge();
            controller.txController.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.messageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.personalMessageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.decryptMessageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.encryptionPublicKeyManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.typedMessageManager.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.appStateController.on(_metamaskController.METAMASK_CONTROLLER_EVENTS.UPDATE_BADGE, updateBadge);
            controller.controllerMessenger.subscribe(_metamaskController.METAMASK_CONTROLLER_EVENTS.APPROVAL_STATE_CHANGE, updateBadge);
            /**
             * Updates the Web Extension's "badge" number, on the little fox in the toolbar.
             * The number reflects the current number of pending transactions or message signatures needing user approval.
             */

            function updateBadge() {
              let label = '';
              const count = getUnapprovedTransactionCount();

              if (count) {
                label = String(count);
              } // browserAction has been replaced by action in MV3


              if (_mv.isManifestV3) {
                _webextensionPolyfill.default.action.setBadgeText({
                  text: label
                });

                _webextensionPolyfill.default.action.setBadgeBackgroundColor({
                  color: '#037DD6'
                });
              } else {
                _webextensionPolyfill.default.browserAction.setBadgeText({
                  text: label
                });

                _webextensionPolyfill.default.browserAction.setBadgeBackgroundColor({
                  color: '#037DD6'
                });
              }
            }

            function getUnapprovedTransactionCount() {
              const unapprovedTxCount = controller.txController.getUnapprovedTxCount();
              const {
                unapprovedMsgCount
              } = controller.messageManager;
              const {
                unapprovedPersonalMsgCount
              } = controller.personalMessageManager;
              const {
                unapprovedDecryptMsgCount
              } = controller.decryptMessageManager;
              const {
                unapprovedEncryptionPublicKeyMsgCount
              } = controller.encryptionPublicKeyManager;
              const {
                unapprovedTypedMessagesCount
              } = controller.typedMessageManager;
              const pendingApprovalCount = controller.approvalController.getTotalApprovalCount();
              const waitingForUnlockCount = controller.appStateController.waitingForUnlock.length;
              return unapprovedTxCount + unapprovedMsgCount + unapprovedPersonalMsgCount + unapprovedDecryptMsgCount + unapprovedEncryptionPublicKeyMsgCount + unapprovedTypedMessagesCount + pendingApprovalCount + waitingForUnlockCount;
            }

            notificationManager.on(_notificationManager.NOTIFICATION_MANAGER_EVENTS.POPUP_CLOSED, ({
              automaticallyClosed
            }) => {
              if (!automaticallyClosed) {
                rejectUnapprovedNotifications();
              } else if (getUnapprovedTransactionCount() > 0) {
                triggerUi();
              }
            });

            function rejectUnapprovedNotifications() {
              Object.keys(controller.txController.txStateManager.getUnapprovedTxList()).forEach(txId => controller.txController.txStateManager.setTxStatusRejected(txId));
              controller.messageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.messageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE_SIG));
              controller.personalMessageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.personalMessageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE_SIG));
              controller.typedMessageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.typedMessageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE_SIG));
              controller.decryptMessageManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.decryptMessageManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE));
              controller.encryptionPublicKeyManager.messages.filter(msg => msg.status === 'unapproved').forEach(tx => controller.encryptionPublicKeyManager.rejectMsg(tx.id, _metametrics.REJECT_NOTFICIATION_CLOSE)); // Finally, reject all approvals managed by the ApprovalController

              controller.approvalController.clear(_ethRpcErrors.ethErrors.provider.userRejectedRequest());
              updateBadge();
            }
          } //
          // Etc...
          //

          /**
           * Opens the browser popup for user confirmation
           */


          async function triggerUi() {
            const tabs = await platform.getActiveTabs();
            const currentlyActiveMetamaskTab = Boolean(tabs.find(tab => openMetamaskTabsIDs[tab.id])); // Vivaldi is not closing port connection on popup close, so popupIsOpen does not work correctly
            // To be reviewed in the future if this behaviour is fixed - also the way we determine isVivaldi variable might change at some point

            const isVivaldi = tabs.length > 0 && tabs[0].extData && tabs[0].extData.indexOf('vivaldi_tab') > -1;

            if (!uiIsTriggering && (isVivaldi || !popupIsOpen) && !currentlyActiveMetamaskTab) {
              uiIsTriggering = true;

              try {
                await notificationManager.showPopup();
              } finally {
                uiIsTriggering = false;
              }
            }
          }
          /**
           * Opens the browser popup for user confirmation of watchAsset
           * then it waits until user interact with the UI
           */


          async function openPopup() {
            await triggerUi();
            await new Promise(resolve => {
              const interval = setInterval(() => {
                if (!notificationIsOpen) {
                  clearInterval(interval);
                  resolve();
                }
              }, _time.SECOND);
            });
          } // It adds the "App Installed" event into a queue of events, which will be tracked only after a user opts into metrics.


          const addAppInstalledEvent = () => {
            if (controller) {
              controller.metaMetricsController.updateTraits({
                [_metametrics.TRAITS.INSTALL_DATE_EXT]: new Date().toISOString().split('T')[0] // yyyy-mm-dd

              });
              controller.metaMetricsController.addEventBeforeMetricsOptIn({
                category: _metametrics.EVENT.CATEGORIES.APP,
                event: _metametrics.EVENT_NAMES.APP_INSTALLED,
                properties: {}
              });
              return;
            }

            setTimeout(() => {
              // If the controller is not set yet, we wait and try to add the "App Installed" event again.
              addAppInstalledEvent();
            }, 1000);
          }; // On first install, open a new tab with MetaMask


          _webextensionPolyfill.default.runtime.onInstalled.addListener(({
            reason
          }) => {
            if (reason === 'install' && !(true || false)) {
              addAppInstalledEvent();
              platform.openExtensionInBrowser();
            }
          });

          function setupSentryGetStateGlobal(store) {
            global.sentryHooks.getSentryState = function () {
              const fullState = store.getState();
              const debugState = (0, _object.maskObject)({
                metamask: fullState
              }, _setupSentry.SENTRY_STATE);
              return {
                browser: window.navigator.userAgent,
                store: debugState,
                version: platform.getVersion()
              };
            };
          }


        };
      };
    }
  }, { package: "$root$", }]], ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\background.js"], {})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUFycmF5LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVPYmplY3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL190cmltbWVkRW5kSW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2Nsb25lRGVlcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaW5SYW5nZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNJbnRlZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc01hcC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2tleXNJbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9GaW5pdGUuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL3RvSW50ZWdlci5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9yZmM0NjQ4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy9tdWx0aWJhc2Uvc3JjL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9yZmM0NjQ4LmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy91aW50OGFycmF5cy9jb25jYXQuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvZnJvbS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvbm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL25vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9ub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9iYXNlLXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL211bHRpY29kZWMvc3JjL2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy9pbnQtdGFibGUuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvcHJpbnQuanMiLCJub2RlX21vZHVsZXMvbXVsdGljb2RlYy9zcmMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWNvZGVjL3NyYy92YXJpbnQtdGFibGUuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvbm9kZV9tb2R1bGVzL211bHRpYmFzZS9zcmMvcmZjNDY0OC5qcyIsIm5vZGVfbW9kdWxlcy9tdWx0aWhhc2hlcy9ub2RlX21vZHVsZXMvbXVsdGliYXNlL3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL211bHRpaGFzaGVzL3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvbXVsdGloYXNoZXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9pZC9pbmRleC5icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL25vbmNlLXRyYWNrZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVtb3ZlLXRyYWlsaW5nLXNsYXNoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NjcnlwdHN5L2xpYi9zY3J5cHQuanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2VsbGlwdGljLmpzIiwibm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguY2pzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2NyZWF0ZUV2ZW50RW1pdHRlclByb3h5LmpzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2NyZWF0ZVN3YXBwYWJsZVByb3h5LmpzIiwibm9kZV9tb2R1bGVzL3N3YXBwYWJsZS1vYmotcHJveHkvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Rocm91Z2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdG8tZGF0YS12aWV3L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9jb25zdGFudHMvYmxvY2tjaGFpbi5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL2NhcmRhbm8uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9kZXZpY2UuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9pZnJhbWUuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL25ldHdvcmsuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2NvbnN0YW50cy9wb3B1cC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL3RyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvY29uc3RhbnRzL3VpLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9kYXRhL0Nvbm5lY3RTZXR0aW5ncy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvZW52L2Jyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2Vudi9icm93c2VyL25ldHdvcmtVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvaWZyYW1lL2J1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL2lmcmFtZS9pbmxpbmUtc3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvbWVzc2FnZS9idWlsZGVyLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9tZXNzYWdlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9wbHVnaW5zL2V0aGVyZXVtL3R5cGVkRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvcG9wdXAvUG9wdXBNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi9wb3B1cC9zaG93UG9wdXBSZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9hY2NvdW50LmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9hcGkuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL2JhY2tlbmQvYmxvY2tjaGFpbi5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvYmFja2VuZC90cmFuc2FjdGlvbnMuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL21pc2MuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2JpbmFuY2UuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2JpdGNvaW4uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2NhcmRhbm8uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2NvaW5JbmZvLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy9lb3MuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL2V0aGVyZXVtLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi90eXBlcy9uZXR3b3Jrcy9uZW0uanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL25ldHdvcmtzL3JpcHBsZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3Mvc3RlbGxhci5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvbmV0d29ya3MvdGV6b3MuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL3BhcmFtcy5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvdHJlem9yL2RldmljZS5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdHlwZXMvdHJlem9yL21hbmFnZW1lbnQuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3R5cGVzL3RyZXpvci9wcm90b2J1Zi5qcyIsIm5vZGVfbW9kdWxlcy90cmV6b3ItY29ubmVjdC9saWIvdXRpbHMvZGVidWcuanMiLCJub2RlX21vZHVsZXMvdHJlem9yLWNvbm5lY3QvbGliL3V0aWxzL2RlZmVycmVkLmpzIiwibm9kZV9tb2R1bGVzL3RyZXpvci1jb25uZWN0L2xpYi93ZWJ1c2IvYnV0dG9uLmpzIiwibm9kZV9tb2R1bGVzL3VpbnQ4YXJyYXlzL2NvbmNhdC5qcyIsIm5vZGVfbW9kdWxlcy91aW50OGFycmF5cy9lcXVhbHMuanMiLCJub2RlX21vZHVsZXMvdWludDhhcnJheXMvZnJvbS1zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvdWludDhhcnJheXMvdG8tc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3ZhcmludC9kZWNvZGUuanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2VuY29kZS5qcyIsIm5vZGVfbW9kdWxlcy92YXJpbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmFyaW50L2xlbmd0aC5qcyIsIm5vZGVfbW9kdWxlcy93ZWItZW5jb2Rpbmcvc3JjL2xpYi5qcyIsInNoYXJlZC9jb25zdGFudHMvYWxhcm1zLmpzIiwic2hhcmVkL2NvbnN0YW50cy9waGlzaGluZy5qcyIsInNoYXJlZC9jb25zdGFudHMvc21hcnRUcmFuc2FjdGlvbnMuanMiLCJhcHAvc2NyaXB0cy9iYWNrZ3JvdW5kLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDbkxBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNGQTs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxSkE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTs7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDRkE7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDelNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDUE8sTUFBTSx1QkFBdUIsR0FBRyx5QkFBaEM7O0FBQ0EsTUFBTSx5Q0FBeUMsR0FDcEQsMkNBREs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQSxNQUFNLHVCQUF1QixHQUFHO0VBQ3JDLFFBQVEsRUFBRSw0REFEMkI7RUFFckMsU0FBUyxFQUFFO0FBRjBCLENBQWhDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0FQOztBQUVPLE1BQU0sd0NBQXdDLEdBQUcsWUFBQSxHQUFTLEVBQTFEOztBQUNBLE1BQU0sb0NBQW9DLEdBQUcsR0FBN0M7O0FBQ0EsTUFBTSw4Q0FBOEMsR0FBRyxDQUF2RDs7Ozs7Ozs7Ozs7Ozs7O0FDQVAsSUFBQSxlQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGVBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxRQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLE1BQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsVUFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsdUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBRUEsSUFBQSxnQkFBQSxPQUFBLENBQUEsZ0JBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsT0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBOztBQU1BLElBQUEsUUFBQSxPQUFBLENBQUEsNkJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsZUFBQSxPQUFBLENBQUEsb0NBQUEsQ0FBQSxDQUFBOztBQU9BLElBQUEsTUFBQSxPQUFBLENBQUEsZ0NBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsVUFBQSxPQUFBLENBQUEsbUNBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsY0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxjQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxnQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGFBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxjQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLG1CQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsZ0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEscUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxtQkFBQSxDQUFBLENBQUE7O0FBRUEsSUFBQSxvQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx3QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHVCQUFBLHVCQUFBLENBQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUdBLElBQUEsc0JBQUEsdUJBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBR0EsSUFBQSxrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxvQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLDZCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsbUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxTQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHNCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsUUFBQSxPQUFBLENBQUEsWUFBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7Ozs7QUFHQSxNQUFNOztDQUFBLEdBQWEsTUFBbkIsQ0FBQTtBQUNBLE1BQU0saUJBQWlCLEVBQUUsR0FBRyxlQUFBLFFBQUE7Q0FBNUIsQ0FBQTtBQUVBLE1BQU0sOEJBQThCO0VBQ2xDLENBQUMsSUFBQSx1QkFBRCxHQUEwQixJQURRO0VBRWxDLENBQUMsSUFBQSw4QkFBRCxHQUFpQyxJQUZDO0VBR2xDLENBQUMsSUFBQSw0QkFBRCxHQUErQixJQUFBO0NBSGpDLENBQUE7QUFNQSxNQUFNLHVCQUF1QixDQUFDLGdCQUFELENBQTdCLENBQUE7O0FBRUEsU0FBQSxRQUFBLGdCQUFBLENBQW9CLE9BQU8sSUFBUCxlQUFBLEdBQTZCLE9BQTdCLEdBQXVDLE1BQTNELENBQUEsQ0FBQTs7QUFFQSxNQUFNLFdBQVcsSUFBSSxVQUFBLFFBQUosRUFBakIsQ0FBQTtBQUVBLE1BQU0sc0JBQXNCLElBQUksb0JBQUEsUUFBSixFQUE1QixDQUFBO0FBQ0EsTUFBTSxrQkFBTixHQUEyQixtQkFBM0IsQ0FBQTtBQUVBLElBQUksY0FBYyxLQUFsQixDQUFBO0FBQ0EsSUFBSSxxQkFBcUIsS0FBekIsQ0FBQTtBQUNBLElBQUksaUJBQWlCLEtBQXJCLENBQUE7QUFDQSxNQUFNLHNCQUFzQixFQUE1QixDQUFBO0FBQ0EsTUFBTSx1QkFBdUIsRUFBN0IsQ0FBQTtBQUNBLElBQUksVUFBSjs7QUFHQSxNQUFNLFNBQVMsT0FBTyxJQUFQLFFBQWYsQ0FBQTtBQUNBLE1BQU0sYUFBYSxNQUFNLEdBQUcsSUFBSSxhQUFBLFFBQUosRUFBSCxHQUFnQyxJQUFJLFdBQUEsUUFBSixFQUF6RCxDQUFBO0FBQ0EsSUFBSSxhQUFKLENBQUE7O0FBRUEsSUFBSSxNQUFNLElBQUksT0FBTyxJQUFQLGVBQWQsRUFBMEM7RUFDeEMsTUFBTSxpQkFBTixHQUEwQixVQUFVLElBQVYsS0FBQSxDQUFvQixVQUFwQixDQUExQixDQUFBO0NBQ0Q7O0FBRUQsTUFBTSxrQkFBa0IsSUFBSSxHQUFKLENBQVEsT0FBTyxJQUFQLDBCQUFSLENBQXhCLENBQUE7QUFFQSxNQUFNLDZCQUE2QixJQUFuQzs7QUFFQSxNQUFNLGdDQUFnQywwQkFBdEMsQ0FBQTtBQUVBLE1BQU0seUJBQXlCLHdCQUEvQixDQUFBO0FBQ0EsTUFBTSw0QkFBNEIsMkJBQWxDLENBQUE7Ozs7OztBQU9BLE1BQU0sVUFBVSxvQkFBc0I7RUFDcEMscUJBQUEsUUFBQSxRQUFBLFVBQUEsZUFBQSxDQUF5QyxPQUF6QyxDQUFBLENBQUE7O0VBQ0EsTUFBTSxVQUFVLENBQUMsVUFBRCxDQUFoQixDQUFBOztFQUNBLFNBQUEsUUFBQSxLQUFBLENBQVMsbUNBQVQsQ0FBQSxDQUFBO0NBSEYsQ0FBQTs7QUFNQSxJQUFJLEdBQUEsYUFBSixFQUFrQjtFQUNoQixxQkFBQSxRQUFBLFFBQUEsVUFBQSxZQUFBLENBQXNDLE9BQXRDLENBQUEsQ0FBQTtDQURGLE1BRU87O0VBRUwsVUFBVSxFQUFBLE1BQVYsQ0FBbUIsU0FBQSxRQUFBLE1BQW5CLENBQUEsQ0FBQTtDQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0RELHNDQUFzQztFQUNwQyxNQUFNLFlBQVksTUFBTSx3QkFBd0IsRUFBaEQsQ0FBQTtFQUNBLE1BQU0sZUFBZSxNQUFNLENBQUEsQ0FBQSxFQUFBLDBCQUFBLFFBQUEsR0FBM0IsQ0FBQTtFQUNBLGVBQWUsQ0FBQyxTQUFELEVBQVksWUFBWixFQUEwQixVQUExQixDQUFmLENBQUE7O0VBQ0EsSUFBSSxDQUFDLEdBQUEsYUFBTCxFQUFtQjtJQUNqQixNQUFNLHVCQUF1QixFQUE3QixDQUFBO0dBQ0Q7O0VBQ0QsU0FBQSxRQUFBLEtBQUEsQ0FBUyxtQ0FBVCxDQUFBLENBQUE7Q0FDRDs7Ozs7O0FBS0QsOENBQThDLEtBQTlDLENBQW9EO0VBQ2xELFdBQVcsR0FBRztJQUNaLEtBQUEsQ0FBTSxnQkFBTixDQUFBLENBQUE7R0FDRDs7Q0FIaUQ7Ozs7Ozs7QUFVcEQseUNBQXlDO0VBQ3ZDLElBQUksTUFBSixDQUFBOztFQUNBLElBQUk7SUFDRixNQUFNLGtDQUFrQyxJQUFJLEdBQUosQ0FDdEMsT0FBTyxJQUFQLDBCQURzQyxDQUF4QyxDQURFOzs7O0lBT0YsK0JBQStCLEtBQS9CLEdBQXVDLG1CQUF2QyxDQUFBO0lBRUEsU0FBUyxNQUFNLFNBQU4sY0FBQSxDQUE4QixRQUE5QixDQUFULENBQUE7SUFDQSxNQUFNLGFBQU4sQ0FBb0IsS0FBcEIsRUFBMkIsK0JBQStCLEtBQTFELENBQUEsQ0FBQTtJQUNBLE1BQU0sYUFBTixDQUFvQixTQUFwQixFQUErQixpQ0FBL0IsQ0FBQSxDQVhFOztJQWNGLElBQUksZUFBSixDQUFBO0lBQ0EsSUFBSSxjQUFKLENBQUE7SUFDQSxNQUFNLGVBQWUsSUFBSSxPQUFKLENBQVkscUJBQXFCO01BQ3BELGtCQUFrQixPQUFsQixDQUFBO01BQ0EsaUJBQWlCLE1BQWpCLENBQUE7S0FGbUIsQ0FBckIsQ0FoQkU7OztJQXVCRixNQUFNLGlCQUFOLENBQXdCLE1BQXhCLEVBQWdDLGVBQWhDLENBQUEsQ0F2QkU7O0lBMEJGLE1BQU0sU0FBTixLQUFBLFlBQUEsQ0FBaUMsTUFBakMsQ0FBQSxDQTFCRTs7OztJQStCRixVQUFVLENBQ1IsTUFBTSxjQUFjLENBQUMsSUFBSSwrQkFBSixFQUFELENBRFosRUFFUiw2QkFGUSxDQUFWLENBQUE7SUFJQSxNQUFNLFlBQU4sQ0FBQTtHQW5DRixDQW9DRSxjQUFjO0lBQ2QsSUFBSSxLQUFLLFlBQVksK0JBQXJCLEVBQXNEO01BQ3BELE9BQU8sS0FBUCxDQUNFLHNFQURGLENBQUEsQ0FBQTtLQURGLE1BSU87TUFDTCxPQUFPLE1BQVAsQ0FBYyw0Q0FBZCxFQUE0RCxLQUE1RCxDQUFBLENBQUE7S0FDRDtHQTNDSCxTQTRDVTtJQUNSLElBQUksTUFBSixFQUFZO01BQ1YsTUFBTSxPQUFOLEVBQUEsQ0FBQTtLQUNEO0dBQ0Y7Ozs7Ozs7Ozs7Ozs7QUFhSCwwQ0FBMEM7O0VBRXhDLE1BQU0sV0FBVyxJQUFJLFNBQUEsUUFBSixDQUFhO0lBQUUsWUFBQSxXQUFBLFFBQUE7R0FBZixDQUFqQixDQUFBO0VBQ0EsUUFBUSxHQUFSLENBQVksT0FBWixFQUFxQixPQUFPLEtBQTVCLENBQUEsQ0FId0M7OztFQU94QyxnQkFDRSxDQUFDLE1BQU0sVUFBVSxJQUFWLEVBQVAsS0FBNEIsUUFBUSxxQkFBUixDQUE4QixjQUE5QixDQUQ5QixDQVB3Qzs7Ozs7RUFjeEMsSUFBSSxhQUFhLElBQUksQ0FBQyxhQUFhLEtBQW5DLEVBQTBDOztJQUV4QyxnQkFBZ0IsUUFBUSxxQkFBUixDQUE4QixjQUE5QixDQUFoQixDQUFBO0lBQ0EsTUFBTSxlQUFOLENBQXNCLGtEQUF0QixDQUFBLENBQUE7R0FqQnNDOzs7RUFxQnhDLFFBQVEsR0FBUixDQUFZLE9BQVosRUFBc0IsT0FBUTs7SUFFNUIsTUFBTSxpQkFBaUIsQ0FBQSxDQUFBLEVBQUEsZ0JBQUEsUUFBQSxFQUFnQixhQUFoQixDQUF2QixDQUFBO0lBQ0EsTUFBTSxpQkFBTixDQUF3QixHQUF4QixFQUE2Qjs7TUFFM0IsT0FBTztRQUFFLGNBQUE7T0FBRjtLQUZULENBQUEsQ0FBQTtHQUhGLENBQUEsQ0FyQndDOztFQStCeEMsZ0JBQWdCLE1BQU0sUUFBUSxZQUFSLENBQXFCLGFBQXJCLENBQXRCLENBQUE7O0VBQ0EsSUFBSSxDQUFDLGFBQUwsRUFBb0I7SUFDbEIsTUFBTSxJQUFJLEtBQUosQ0FBVSx3Q0FBVixDQUFOLENBQUE7R0FqQ3NDOzs7RUFvQ3hDLFVBQVUsWUFBVixDQUF1QixhQUFhLEtBQXBDLENBQUEsQ0FwQ3dDOztFQXVDeEMsVUFBVSxJQUFWLENBQWUsYUFBYSxLQUE1QixDQUFBLENBdkN3Qzs7RUEwQ3hDLE9BQU8sYUFBYSxLQUFwQixDQUFBO0NBQ0Q7Ozs7Ozs7Ozs7Ozs7QUFZRCxvRUFBb0U7Ozs7RUFLbEUsYUFBYSxJQUFJLG1CQUFBLFFBQUosQ0FBdUI7SUFDbEMsaUJBQWlCLE9BQU8sSUFBUCxrQkFEaUI7O0lBR2xDLHNCQUFzQixTQUhZO0lBSWxDLFNBSmtDOztJQU1sQyxTQU5rQzs7SUFRbEMsWUFSa0M7O0lBVWxDLFFBVmtDO0lBV2xDLG1CQVhrQztJQVlsQyxTQUFBLHFCQUFBLFFBWmtDO0lBYWxDLHlCQUF5QixNQUFNO01BQzdCLE9BQU8sb0JBQVAsQ0FBQTtLQWRnQztJQWdCbEMsd0JBQXdCLE1BQU07TUFDNUIsT0FBTyxtQkFBUCxDQUFBO0tBakJnQztJQW1CbEMsVUFBQTtHQW5CVyxDQUFiLENBQUE7RUFzQkEsQ0FBQSxDQUFBLEVBQUEsTUFBQSxRQUFBLEVBQXFCO0lBQ25CLG1CQUFtQixVQUFVLGtCQUFWLGtCQUFBLEtBQUEsQ0FDakIsVUFBVSxrQkFETyxDQURBO0lBSW5CLGdCQUFnQixVQUFVLHNCQUFWLGVBQUEsS0FBQSxDQUNkLFVBQVUsc0JBREksQ0FKRztJQU9uQixVQUFVLFVBQVUsU0FBQztHQVB2QixDQUFBLENBM0JrRTs7RUFzQ2xFLENBQUEsQ0FBQSxFQUFBLEtBQUEsUUFBQSxFQUNFLENBQUEsQ0FBQSxFQUFBLFNBQUEsY0FBQSxFQUFjLFVBQVUsTUFBeEIsQ0FERixFQUVFLENBQUEsQ0FBQSxFQUFBLGVBQUEsUUFBQSxFQUFTLElBQVQsQ0FGRixFQUdFLENBQUEsQ0FBQSxFQUFBLGlCQUFBLFFBQUEsRUFBa0IsU0FBVSxVQUFVLElBQVYsQ0FBZSxLQUFmLENBQTVCLENBSEYsRUFJRyxTQUFVO0lBQ1QsU0FBQSxRQUFBLE1BQUEsQ0FBVSx3Q0FBVixFQUFvRCxLQUFwRCxDQUFBLENBQUE7R0FMSixDQUFBLENBQUE7RUFTQSx5QkFBeUIsQ0FBQyxVQUFELENBQXpCLENBL0NrRTs7OztFQW9EbEUsSUFBSSxHQUFBLGFBQUEsSUFBZ0IsZ0JBQXBCLEVBQXNDO0lBQ3BDLGFBQWEsQ0FBQyxnQkFBRCxDQUFiLENBQUE7R0FDRDs7RUFFRCxxQkFBQSxRQUFBLFFBQUEsVUFBQSxZQUFBLENBQXNDLGFBQXRDLENBQUEsQ0FBQTs7RUFDQSxxQkFBQSxRQUFBLFFBQUEsa0JBQUEsWUFBQSxDQUE4QyxlQUE5QyxDQUFBLENBQUE7O0VBRUEsTUFBTSxxQkFBcUIsTUFBTTtJQUMvQixPQUNFLFdBQVcsSUFDWCxPQUFPLENBQUMsTUFBTSxLQUFOLENBQVksbUJBQVosQ0FBQSxPQUFELENBRFAsSUFFQSxrQkFIRixDQUFBO0dBREYsQ0FBQTs7RUFRQSxNQUFNLDhCQUE4QixtQ0FBbUM7O0lBRXJFLElBQUksWUFBWSxLQUFLLEtBQXJCLEVBQTRCO01BQzFCLFVBQVUsZUFBVixFQUFBLENBRDBCO0tBQTVCLE1BR087OztNQUdMLElBQ0UsZUFBZSxLQUFLLElBQUEsNEJBQXBCLElBQ0EsT0FBTyxDQUFDLE1BQU0sS0FBTixDQUFZLG1CQUFaLENBQUEsT0FBRCxDQUZULEVBR0U7UUFDQSxPQUFBO09BQ0Q7O01BQ0QsVUFBVSx3QkFBVixDQUFtQyxlQUFuQyxDQUFBLENBQUE7S0FDRDtHQWZILENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0NBLG1DQUFtQztJQUFBLElBQUEsa0JBQUEsQ0FBQTs7SUFDakMsTUFBTSxjQUFjLFVBQVUsS0FBOUIsQ0FBQTs7SUFFQSxJQUFJLG9CQUFvQixTQUFwQixDQUE4QixVQUFVLEtBQXhDLENBQUosRUFBb0Q7TUFDbEQsT0FBQTtLQUNEOztJQUVELElBQUksNEJBQTRCLEtBQWhDLENBQUE7SUFDQSxNQUFNLGlCQUFpQixDQUFBLENBQUEsRUFBQSxLQUFBLFlBQUEsR0FBdkIsQ0FBQTs7SUFFQSxJQUFJLGNBQWMsS0FBSyxJQUFBLGlCQUF2QixFQUF5QztNQUN2Qyw0QkFBNEIsMkJBQTJCLENBQUMsV0FBRCxDQUF2RCxDQUFBO0tBREYsTUFFTztNQUNMLDRCQUNFLFVBQVUsT0FBVixPQUFBLEtBQThCLENBQUEsbUJBQUEsRUFBcUIscUJBQUEsUUFBQSxRQUFBLEdBQW1CLENBQUEsQ0FEeEUsQ0FBQTtLQUVEOztJQUVELE1BQU0sWUFBWSxDQUFBLHFCQUFBLFVBQVUsT0FBVixNQUFBLElBQUEsSUFBQSxrQkFBQSxLQUFBLEtBQUEsQ0FBQSxJQUFBLGtCQUFBLElBQUEsR0FDZCxJQUFJLEdBQUosQ0FBUSxVQUFVLE9BQVYsSUFBUixDQURjLEdBRWQsSUFGSixDQUFBOztJQUlBLElBQUkseUJBQUosRUFBK0I7TUFDN0IsTUFBTSxhQUFhLElBQUksb0JBQUEsUUFBSixDQUFlLFVBQWYsQ0FBbkIsQ0FENkI7O01BRzdCLFVBQVUsYUFBVixHQUEwQixJQUExQixDQUFBO01BQ0EsVUFBVSwwQkFBVixDQUFxQyxVQUFyQyxFQUFpRCxVQUFVLE9BQTNELENBQUEsQ0FBQTs7TUFFQSxJQUFJLEdBQUEsYUFBSixFQUFrQjs7OztRQUloQixVQUFVLFlBQVYsQ0FBdUI7VUFBRSxNQUFNLGtCQUFBO1NBQS9CLENBQUEsQ0FKZ0I7O1FBT2hCLFVBQVUsVUFBVixZQUFBLENBQWtDLFdBQVk7VUFDNUMsSUFBSSxPQUFPLEtBQVAsS0FBaUIseUJBQXJCLEVBQWdEOztZQUU5QyxVQUFVLFlBQVYsQ0FBdUI7Y0FBRSxNQUFNLHNCQUFBO2FBQS9CLENBQUEsQ0FBQTtXQUNEO1NBSkgsQ0FBQSxDQUFBO09BTUQ7O01BRUQsSUFBSSxXQUFXLEtBQUssSUFBQSx1QkFBcEIsRUFBNEM7UUFDMUMsY0FBYyxJQUFkLENBQUE7UUFDQSxDQUFBLENBQUEsRUFBQSxZQUFBLFFBQUEsRUFBWSxVQUFaLEVBQXdCLE1BQU07VUFDNUIsY0FBYyxLQUFkLENBQUE7VUFDQSxNQUFNLGVBQWUsa0JBQWtCLEVBQXZDLENBQUE7VUFDQSxVQUFVLGFBQVYsR0FBMEIsWUFBMUIsQ0FBQTtVQUNBLDJCQUEyQixDQUFDLFlBQUQsRUFBZSxJQUFBLHVCQUFmLENBQTNCLENBQUE7U0FKRixDQUFBLENBQUE7T0FNRDs7TUFFRCxJQUFJLFdBQVcsS0FBSyxJQUFBLDhCQUFwQixFQUFtRDtRQUNqRCxxQkFBcUIsSUFBckIsQ0FBQTtRQUVBLENBQUEsQ0FBQSxFQUFBLFlBQUEsUUFBQSxFQUFZLFVBQVosRUFBd0IsTUFBTTtVQUM1QixxQkFBcUIsS0FBckIsQ0FBQTtVQUNBLE1BQU0sZUFBZSxrQkFBa0IsRUFBdkMsQ0FBQTtVQUNBLFVBQVUsYUFBVixHQUEwQixZQUExQixDQUFBO1VBQ0EsMkJBQTJCLENBQ3pCLFlBRHlCLEVBRXpCLElBQUEsOEJBRnlCLENBQTNCLENBQUE7U0FKRixDQUFBLENBQUE7T0FTRDs7TUFFRCxJQUFJLFdBQVcsS0FBSyxJQUFBLDRCQUFwQixFQUFpRDtRQUMvQyxNQUFNLFFBQVEsVUFBVSxPQUFWLElBQUEsR0FBZCxDQUFBO1FBQ0EsbUJBQW1CLENBQUMsS0FBRCxDQUFuQixHQUE2QixJQUE3QixDQUFBO1FBRUEsQ0FBQSxDQUFBLEVBQUEsWUFBQSxRQUFBLEVBQVksVUFBWixFQUF3QixNQUFNO1VBQzVCLE9BQU8sbUJBQW1CLENBQUMsS0FBRCxDQUExQixDQUFBO1VBQ0EsTUFBTSxlQUFlLGtCQUFrQixFQUF2QyxDQUFBO1VBQ0EsVUFBVSxhQUFWLEdBQTBCLFlBQTFCLENBQUE7VUFDQSwyQkFBMkIsQ0FDekIsWUFEeUIsRUFFekIsSUFBQSw0QkFGeUIsQ0FBM0IsQ0FBQTtTQUpGLENBQUEsQ0FBQTtPQVNEO0tBMURILE1BMkRPLElBQ0wsU0FBUyxJQUNULFNBQVMsT0FBVCxLQUFxQixlQUFlLE9BRHBDLElBRUEsU0FBUyxTQUFULEtBQXVCLGVBQWUsU0FIakMsRUFJTDtNQUNBLE1BQU0sYUFBYSxJQUFJLG9CQUFBLFFBQUosQ0FBZSxVQUFmLENBQW5CLENBQUE7TUFDQSxVQUFVLDJCQUFWLENBQXNDO1FBQ3BDLGtCQUFrQixVQUFBO09BRHBCLENBQUEsQ0FBQTtLQU5LLE1BU0E7TUFDTCxJQUFJLFVBQVUsT0FBVixJQUFxQixVQUFVLE9BQVYsSUFBckIsSUFBOEMsVUFBVSxPQUFWLElBQWxELEVBQXlFO1FBQ3ZFLE1BQU0sUUFBUSxVQUFVLE9BQVYsSUFBQSxHQUFkLENBQUE7UUFDQSxNQUFNLE1BQU0sSUFBSSxHQUFKLENBQVEsVUFBVSxPQUFWLElBQVIsQ0FBWixDQUFBO1FBQ0EsTUFBTTs7U0FBQSxHQUFhLEdBQW5CLENBQUE7UUFFQSxVQUFVLFVBQVYsWUFBQSxDQUFrQyxPQUFRO1VBQ3hDLElBQUksR0FBRyxLQUFILElBQVksR0FBRyxLQUFILE9BQUEsS0FBb0IscUJBQXBDLEVBQTJEO1lBQ3pELG9CQUFvQixDQUFDLE1BQUQsQ0FBcEIsR0FBK0IsS0FBL0IsQ0FBQTtXQUNEO1NBSEgsQ0FBQSxDQUFBO09BS0Q7O01BQ0QsZUFBZSxDQUFDLFVBQUQsQ0FBZixDQUFBO0tBQ0Q7R0F6TStEOzs7RUE2TWxFLHFDQUFxQztJQUNuQyxNQUFNLGFBQWEsSUFBSSxvQkFBQSxRQUFKLENBQWUsVUFBZixDQUFuQixDQUFBO0lBQ0EsVUFBVSw0QkFBVixDQUF1QztNQUNyQyxrQkFBa0IsVUFEbUI7TUFFckMsUUFBUSxVQUFVLE9BQUM7S0FGckIsQ0FBQSxDQUFBO0dBL01nRTs7Ozs7RUF5TmxFLFdBQVcsRUFBQSxDQUFBO0VBQ1gsVUFBVSxhQUFWLEdBQUEsQ0FDRSxtQkFBQSwyQkFBQSxhQURGLEVBRUUsV0FGRixDQUFBLENBQUE7RUFJQSxVQUFVLGVBQVYsR0FBQSxDQUNFLG1CQUFBLDJCQUFBLGFBREYsRUFFRSxXQUZGLENBQUEsQ0FBQTtFQUlBLFVBQVUsdUJBQVYsR0FBQSxDQUNFLG1CQUFBLDJCQUFBLGFBREYsRUFFRSxXQUZGLENBQUEsQ0FBQTtFQUlBLFVBQVUsc0JBQVYsR0FBQSxDQUNFLG1CQUFBLDJCQUFBLGFBREYsRUFFRSxXQUZGLENBQUEsQ0FBQTtFQUlBLFVBQVUsMkJBQVYsR0FBQSxDQUNFLG1CQUFBLDJCQUFBLGFBREYsRUFFRSxXQUZGLENBQUEsQ0FBQTtFQUlBLFVBQVUsb0JBQVYsR0FBQSxDQUNFLG1CQUFBLDJCQUFBLGFBREYsRUFFRSxXQUZGLENBQUEsQ0FBQTtFQUlBLFVBQVUsbUJBQVYsR0FBQSxDQUNFLG1CQUFBLDJCQUFBLGFBREYsRUFFRSxXQUZGLENBQUEsQ0FBQTtFQUtBLFVBQVUsb0JBQVYsVUFBQSxDQUNFLG1CQUFBLDJCQUFBLHNCQURGLEVBRUUsV0FGRixDQUFBLENBQUE7Ozs7OztFQVNBLHVCQUF1QjtJQUNyQixJQUFJLFFBQVEsRUFBWixDQUFBO0lBQ0EsTUFBTSxRQUFRLDZCQUE2QixFQUEzQyxDQUFBOztJQUNBLElBQUksS0FBSixFQUFXO01BQ1QsUUFBUSxNQUFNLENBQUMsS0FBRCxDQUFkLENBQUE7S0FKbUI7OztJQU9yQixJQUFJLEdBQUEsYUFBSixFQUFrQjtNQUNoQixxQkFBQSxRQUFBLE9BQUEsYUFBQSxDQUE0QjtRQUFFLE1BQU0sS0FBQTtPQUFwQyxDQUFBLENBQUE7O01BQ0EscUJBQUEsUUFBQSxPQUFBLHdCQUFBLENBQXVDO1FBQUUsT0FBTyxTQUFBO09BQWhELENBQUEsQ0FBQTtLQUZGLE1BR087TUFDTCxxQkFBQSxRQUFBLGNBQUEsYUFBQSxDQUFtQztRQUFFLE1BQU0sS0FBQTtPQUEzQyxDQUFBLENBQUE7O01BQ0EscUJBQUEsUUFBQSxjQUFBLHdCQUFBLENBQThDO1FBQUUsT0FBTyxTQUFBO09BQXZELENBQUEsQ0FBQTtLQUNEO0dBQ0Y7O0VBRUQseUNBQXlDO0lBQ3ZDLE1BQU0sb0JBQW9CLFVBQVUsYUFBVixxQkFBQSxFQUExQixDQUFBO0lBQ0EsTUFBTTs7S0FBQSxHQUF5QixVQUFVLGVBQXpDLENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQWlDLFVBQVUsdUJBQWpELENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQWdDLFVBQVUsc0JBQWhELENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQ0osVUFBVSwyQkFEWixDQUFBO0lBRUEsTUFBTTs7S0FBQSxHQUFtQyxVQUFVLG9CQUFuRCxDQUFBO0lBQ0EsTUFBTSx1QkFDSixVQUFVLG1CQUFWLHNCQUFBLEVBREYsQ0FBQTtJQUVBLE1BQU0sd0JBQ0osVUFBVSxtQkFBVixpQkFBQSxPQURGLENBQUE7SUFFQSxPQUNFLGlCQUFpQixHQUNqQixrQkFEQSxHQUVBLDBCQUZBLEdBR0EseUJBSEEsR0FJQSxxQ0FKQSxHQUtBLDRCQUxBLEdBTUEsb0JBTkEsR0FPQSxxQkFSRixDQUFBO0dBVUQ7O0VBRUQsbUJBQW1CLEdBQW5CLENBQ0Usb0JBQUEsNEJBQUEsYUFERixFQUVFLENBQUM7O0dBQUQsS0FBNkI7SUFDM0IsSUFBSSxDQUFDLG1CQUFMLEVBQTBCO01BQ3hCLDZCQUE2QixFQUFBLENBQUE7S0FEL0IsTUFFTyxJQUFJLDZCQUE2QixFQUFBLEdBQUssQ0FBdEMsRUFBeUM7TUFDOUMsU0FBUyxFQUFBLENBQUE7S0FDVjtHQVBMLENBQUEsQ0FBQTs7RUFXQSx5Q0FBeUM7SUFDdkMsTUFBTSxLQUFOLENBQ0UsVUFBVSxhQUFWLGVBQUEsb0JBQUEsRUFERixDQUFBLFFBQUEsQ0FFVyxRQUNULFVBQVUsYUFBVixlQUFBLG9CQUFBLENBQTJELElBQTNELENBSEYsQ0FBQSxDQUFBO0lBS0EsVUFBVSxlQUFWLFNBQUEsT0FBQSxDQUNXLE9BQVEsR0FBRyxPQUFILEtBQWUsWUFEbEMsQ0FBQSxRQUFBLENBRVksTUFDUixVQUFVLGVBQVYsVUFBQSxDQUNFLEVBQUUsR0FESixFQUVFLFlBQUEsOEJBRkYsQ0FISixDQUFBLENBQUE7SUFRQSxVQUFVLHVCQUFWLFNBQUEsT0FBQSxDQUNXLE9BQVEsR0FBRyxPQUFILEtBQWUsWUFEbEMsQ0FBQSxRQUFBLENBRVksTUFDUixVQUFVLHVCQUFWLFVBQUEsQ0FDRSxFQUFFLEdBREosRUFFRSxZQUFBLDhCQUZGLENBSEosQ0FBQSxDQUFBO0lBUUEsVUFBVSxvQkFBVixTQUFBLE9BQUEsQ0FDVyxPQUFRLEdBQUcsT0FBSCxLQUFlLFlBRGxDLENBQUEsUUFBQSxDQUVZLE1BQ1IsVUFBVSxvQkFBVixVQUFBLENBQ0UsRUFBRSxHQURKLEVBRUUsWUFBQSw4QkFGRixDQUhKLENBQUEsQ0FBQTtJQVFBLFVBQVUsc0JBQVYsU0FBQSxPQUFBLENBQ1csT0FBUSxHQUFHLE9BQUgsS0FBZSxZQURsQyxDQUFBLFFBQUEsQ0FFWSxNQUNSLFVBQVUsc0JBQVYsVUFBQSxDQUNFLEVBQUUsR0FESixFQUVFLFlBQUEsMEJBRkYsQ0FISixDQUFBLENBQUE7SUFRQSxVQUFVLDJCQUFWLFNBQUEsT0FBQSxDQUNXLE9BQVEsR0FBRyxPQUFILEtBQWUsWUFEbEMsQ0FBQSxRQUFBLENBRVksTUFDUixVQUFVLDJCQUFWLFVBQUEsQ0FDRSxFQUFFLEdBREosRUFFRSxZQUFBLDBCQUZGLENBSEosQ0FBQSxDQXRDdUM7O0lBZ0R2QyxVQUFVLG1CQUFWLE1BQUEsQ0FDRSxhQUFBLFVBQUEsU0FBQSxvQkFBQSxFQURGLENBQUEsQ0FBQTtJQUlBLFdBQVcsRUFBQSxDQUFBO0dBQ1o7Ozs7Ozs7Ozs7QUFVSCwyQkFBMkI7RUFDekIsTUFBTSxPQUFPLE1BQU0sUUFBUSxjQUFSLEVBQW5CLENBQUE7RUFDQSxNQUFNLDZCQUE2QixPQUFPLENBQ3hDLElBQUksS0FBSixDQUFXLE9BQVEsbUJBQW1CLENBQUMsR0FBRyxHQUFKLENBQXRDLENBRHdDLENBQTFDLENBRnlCOzs7RUFPekIsTUFBTSxZQUNKLElBQUksT0FBSixHQUFjLENBQWQsSUFDQSxJQUFJLENBQUMsQ0FBRCxDQUFKLFFBREEsSUFFQSxJQUFJLENBQUMsQ0FBRCxDQUFKLFFBQUEsUUFBQSxDQUF3QixhQUF4QixDQUFBLEdBQXlDLENBQUMsQ0FINUMsQ0FBQTs7RUFJQSxJQUNFLENBQUMsY0FBRCxLQUNDLFNBQVMsSUFBSSxDQUFDLFdBRGYsQ0FBQSxJQUVBLENBQUMsMEJBSEgsRUFJRTtJQUNBLGlCQUFpQixJQUFqQixDQUFBOztJQUNBLElBQUk7TUFDRixNQUFNLG1CQUFtQixVQUFuQixFQUFOLENBQUE7S0FERixTQUVVO01BQ1IsaUJBQWlCLEtBQWpCLENBQUE7S0FDRDtHQUNGO0NBQ0Y7Ozs7Ozs7QUFNRCwyQkFBMkI7RUFDekIsTUFBTSxTQUFTLEVBQWYsQ0FBQTtFQUNBLE1BQU0sSUFBSSxPQUFKLENBQWEsV0FBWTtJQUM3QixNQUFNLFdBQVcsV0FBVyxDQUFDLE1BQU07TUFDakMsSUFBSSxDQUFDLGtCQUFMLEVBQXlCO1FBQ3ZCLGFBQWEsQ0FBQyxRQUFELENBQWIsQ0FBQTtRQUNBLE9BQU8sRUFBQSxDQUFBO09BQ1I7S0FKeUIsRUFLekIsS0FBQSxPQUx5QixDQUE1QixDQUFBO0dBREksQ0FBTixDQUFBOzs7O0FBV0YsTUFBTSx1QkFBdUIsTUFBTTtFQUNqQyxJQUFJLFVBQUosRUFBZ0I7SUFDZCxVQUFVLHNCQUFWLGFBQUEsQ0FBOEM7TUFDNUMsQ0FBQyxZQUFBLE9BQUEsaUJBQUQsR0FBMkIsSUFBSSxJQUFKLEVBQUEsWUFBQSxFQUFBLE1BQUEsQ0FBK0IsR0FBL0IsQ0FBQSxDQUFvQyxDQUFwQyxDQURpQjs7S0FBOUMsQ0FBQSxDQUFBO0lBR0EsVUFBVSxzQkFBViwyQkFBQSxDQUE0RDtNQUMxRCxVQUFVLFlBQUEsTUFBQSxXQUFBLElBRGdEO01BRTFELE9BQU8sWUFBQSxZQUFBLGNBRm1EO01BRzFELFlBQVksRUFBQTtLQUhkLENBQUEsQ0FBQTtJQUtBLE9BQUE7R0FDRDs7RUFDRCxVQUFVLENBQUMsTUFBTTs7SUFFZixvQkFBb0IsRUFBQSxDQUFBO0dBRlosRUFHUCxJQUhPLENBQVYsQ0FBQTtDQVpGOzs7QUFtQkEscUJBQUEsUUFBQSxRQUFBLFlBQUEsWUFBQSxDQUF3QyxDQUFDOztDQUFELEtBQWdCO0VBQ3RELElBQ0UsTUFBTSxLQUFLLFNBQVgsSUFDQSxFQUFFLE9BQU8sSUFBUCxlQUFBLElBQThCLE9BQU8sSUFBUCxRQUFoQyxDQUZGLEVBR0U7SUFDQSxvQkFBb0IsRUFBQSxDQUFBO0lBQ3BCLFFBQVEsdUJBQVIsRUFBQSxDQUFBO0dBQ0Q7Q0FQSCxDQUFBLENBQUE7O0FBVUEsMENBQTBDO0VBQ3hDLE1BQU0sWUFBTixlQUFBLEdBQW9DLFlBQVk7SUFDOUMsTUFBTSxZQUFZLEtBQUssU0FBTCxFQUFsQixDQUFBO0lBQ0EsTUFBTSxhQUFhLENBQUEsQ0FBQSxFQUFBLE9BQUEsV0FBQSxFQUFXO01BQUUsVUFBVSxTQUFBO0tBQXZCLEVBQW9DLFlBQUEsYUFBcEMsQ0FBbkIsQ0FBQTtJQUNBLE9BQU87TUFDTCxTQUFTLE1BQU0sVUFBTixVQURKO01BRUwsT0FBTyxVQUZGO01BR0wsU0FBUyxRQUFRLFdBQVIsRUFBQTtLQUhYLENBQUE7R0FIRixDQUFBO0NBU0QiLCJmaWxlIjoiYmFja2dyb3VuZC00LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTeW1ib2xzSW47XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUFycmF5O1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyksXG4gICAgY2xvbmVEYXRhVmlldyA9IHJlcXVpcmUoJy4vX2Nsb25lRGF0YVZpZXcnKSxcbiAgICBjbG9uZVJlZ0V4cCA9IHJlcXVpcmUoJy4vX2Nsb25lUmVnRXhwJyksXG4gICAgY2xvbmVTeW1ib2wgPSByZXF1aXJlKCcuL19jbG9uZVN5bWJvbCcpLFxuICAgIGNsb25lVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vX2Nsb25lVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVCeVRhZztcbiIsInZhciBiYXNlQ3JlYXRlID0gcmVxdWlyZSgnLi9fYmFzZUNyZWF0ZScpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZU9iamVjdDtcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmltbWVkRW5kSW5kZXg7XG4iLCJ2YXIgYmFzZUNsb25lID0gcmVxdWlyZSgnLi9fYmFzZUNsb25lJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG4iLCJ2YXIgYmFzZUluUmFuZ2UgPSByZXF1aXJlKCcuL19iYXNlSW5SYW5nZScpLFxuICAgIHRvRmluaXRlID0gcmVxdWlyZSgnLi90b0Zpbml0ZScpLFxuICAgIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgbmAgaXMgYmV0d2VlbiBgc3RhcnRgIGFuZCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBJZlxuICogYGVuZGAgaXMgbm90IHNwZWNpZmllZCwgaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gKiBuZWdhdGl2ZSByYW5nZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjMuMFxuICogQGNhdGVnb3J5IE51bWJlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBzZWUgXy5yYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaW5SYW5nZSgzLCAyLCA0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluUmFuZ2UoNCwgOCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pblJhbmdlKDQsIDIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluUmFuZ2UoMiwgMik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaW5SYW5nZSgxLjIsIDIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaW5SYW5nZSg1LjIsIDQpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmluUmFuZ2UoLTMsIC0yLCAtNik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKSB7XG4gIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgZW5kID0gdG9GaW5pdGUoZW5kKTtcbiAgfVxuICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICByZXR1cm4gYmFzZUluUmFuZ2UobnVtYmVyLCBzdGFydCwgZW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpblJhbmdlO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxuICpcbiAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICogcHJvcGVydGllcy5cbiAqXG4gKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAqIGpRdWVyeS1saWtlIGNvbGxlY3Rpb25zIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBsZW5ndGhgIG9mIGAwYC5cbiAqIFNpbWlsYXJseSwgbWFwcyBhbmQgc2V0cyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgc2l6ZWAgb2YgYDBgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNFbXB0eShudWxsKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkodHJ1ZSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KDEpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJlxuICAgICAgKGlzQXJyYXkodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL3RvSW50ZWdlcicpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gKiBbYE51bWJlci5pc0ludGVnZXJgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNJbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNJbnRlZ2VyKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PSB0b0ludGVnZXIodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW50ZWdlcjtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwidmFyIHRvTnVtYmVyID0gcmVxdWlyZSgnLi90b051bWJlcicpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDg7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0Zpbml0ZTtcbiIsInZhciB0b0Zpbml0ZSA9IHJlcXVpcmUoJy4vdG9GaW5pdGUnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0ludGVnZXI7XG4iLCJ2YXIgYmFzZVRyaW0gPSByZXF1aXJlKCcuL19iYXNlVHJpbScpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b051bWJlcjtcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VOYW1lfSBCYXNlTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cblxuLyoqXG4gKiBDbGFzcyB0byBlbmNvZGUvZGVjb2RlIGluIHRoZSBzdXBwb3J0ZWQgQmFzZXNcbiAqXG4gKi9cbmNsYXNzIEJhc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtCYXNlTmFtZX0gbmFtZVxuICAgKiBAcGFyYW0ge0Jhc2VDb2RlfSBjb2RlXG4gICAqIEBwYXJhbSB7Q29kZWNGYWN0b3J5fSBmYWN0b3J5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIGNvZGUsIGZhY3RvcnksIGFscGhhYmV0KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICB0aGlzLmNvZGVCdWYgPSBlbmNvZGVUZXh0KHRoaXMuY29kZSlcbiAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXRcbiAgICB0aGlzLmNvZGVjID0gZmFjdG9yeShhbHBoYWJldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5jb2RlIChidWYpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlYy5lbmNvZGUoYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBkZWNvZGUgKHN0cmluZykge1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhYmV0ICYmIHRoaXMuYWxwaGFiZXQuaW5kZXhPZihjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgaW4gJyR7c3RyaW5nfSdgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb2RlYy5kZWNvZGUoc3RyaW5nKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2VYID0gcmVxdWlyZSgnQG11bHRpZm9ybWF0cy9iYXNlLXgnKVxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpXG5jb25zdCB7IHJmYzQ2NDggfSA9IHJlcXVpcmUoJy4vcmZjNDY0OCcpXG5jb25zdCB7IGRlY29kZVRleHQsIGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY30gQ29kZWMgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkJhc2VOYW1lfSBCYXNlTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQmFzZUNvZGV9IEJhc2VDb2RlICovXG5cbi8qKiBAdHlwZSB7Q29kZWNGYWN0b3J5fSAqL1xuY29uc3QgaWRlbnRpdHkgPSAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBkZWNvZGVUZXh0LFxuICAgIGRlY29kZTogZW5jb2RlVGV4dFxuICB9XG59XG5cbi8qKlxuICpcbiAqIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuICpcbiAqIEB0eXBlIHtBcnJheTxbQmFzZU5hbWUsIEJhc2VDb2RlLCBDb2RlY0ZhY3RvcnksIHN0cmluZ10+fVxuICovXG5jb25zdCBjb25zdGFudHMgPSBbXG4gIFsnaWRlbnRpdHknLCAnXFx4MDAnLCBpZGVudGl0eSwgJyddLFxuICBbJ2Jhc2UyJywgJzAnLCByZmM0NjQ4KDEpLCAnMDEnXSxcbiAgWydiYXNlOCcsICc3JywgcmZjNDY0OCgzKSwgJzAxMjM0NTY3J10sXG4gIFsnYmFzZTEwJywgJzknLCBiYXNlWCwgJzAxMjM0NTY3ODknXSxcbiAgWydiYXNlMTYnLCAnZicsIHJmYzQ2NDgoNCksICcwMTIzNDU2Nzg5YWJjZGVmJ10sXG4gIFsnYmFzZTE2dXBwZXInLCAnRicsIHJmYzQ2NDgoNCksICcwMTIzNDU2Nzg5QUJDREVGJ10sXG4gIFsnYmFzZTMyaGV4JywgJ3YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnXSxcbiAgWydiYXNlMzJoZXh1cHBlcicsICdWJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ10sXG4gIFsnYmFzZTMyaGV4cGFkJywgJ3QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9J10sXG4gIFsnYmFzZTMyaGV4cGFkdXBwZXInLCAnVCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nXSxcbiAgWydiYXNlMzInLCAnYicsIHJmYzQ2NDgoNSksICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NyddLFxuICBbJ2Jhc2UzMnVwcGVyJywgJ0InLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnXSxcbiAgWydiYXNlMzJwYWQnLCAnYycsIHJmYzQ2NDgoNSksICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nXSxcbiAgWydiYXNlMzJwYWR1cHBlcicsICdDJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PSddLFxuICBbJ2Jhc2UzMnonLCAnaCcsIHJmYzQ2NDgoNSksICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OSddLFxuICBbJ2Jhc2UzNicsICdrJywgYmFzZVgsICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlMzZ1cHBlcicsICdLJywgYmFzZVgsICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNThidGMnLCAneicsIGJhc2VYLCAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2U1OGZsaWNrcicsICdaJywgYmFzZVgsICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTY0JywgJ20nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLFxuICBbJ2Jhc2U2NHBhZCcsICdNJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J10sXG4gIFsnYmFzZTY0dXJsJywgJ3UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXyddLFxuICBbJ2Jhc2U2NHVybHBhZCcsICdVJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89J11cbl1cblxuLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZU5hbWUsQmFzZT59ICovXG5jb25zdCBuYW1lcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVswXV0gPSBuZXcgQmFzZSh0dXBwbGVbMF0sIHR1cHBsZVsxXSwgdHVwcGxlWzJdLCB0dXBwbGVbM10pXG4gIHJldHVybiBwcmV2XG59LCAvKiogQHR5cGUge1JlY29yZDxCYXNlTmFtZSxCYXNlPn0gKi8oe30pKVxuXG4vKiogQHR5cGUge1JlY29yZDxCYXNlQ29kZSxCYXNlPn0gKi9cbmNvbnN0IGNvZGVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzFdXSA9IG5hbWVzW3R1cHBsZVswXV1cbiAgcmV0dXJuIHByZXZcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPEJhc2VDb2RlLEJhc2U+fSAqLyh7fSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lcyxcbiAgY29kZXNcbn1cbiIsIi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFttdWx0aWJhc2VdKGh0dHBzOi8vZ2l0aHViLmNvbS9tdWx0aWZvcm1hdHMvbXVsdGliYXNlKSBzcGVjaWZpY2F0aW9uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcbmNvbnN0IHsgZW5jb2RlVGV4dCwgZGVjb2RlVGV4dCwgY29uY2F0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vYmFzZScpfSBCYXNlICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VOYW1lT3JDb2RlfSBCYXNlTmFtZU9yQ29kZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXyhcIi4vdHlwZXNcIikuQmFzZU5hbWV9IEJhc2VOYW1lICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFVpbnQ4QXJyYXkgd2l0aCB0aGUgbXVsdGliYXNlIHZhcmludCtjb2RlLlxuICpcbiAqIEBwYXJhbSB7QmFzZU5hbWVPckNvZGV9IG5hbWVPckNvZGUgLSBUaGUgbXVsdGliYXNlIG5hbWUgb3IgY29kZSBudW1iZXIuXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZiAtIFRoZSBkYXRhIHRvIGJlIHByZWZpeGVkIHdpdGggbXVsdGliYXNlLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBtdWx0aWJhc2UgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBpZiAoIWJ1Zikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYW4gZW5jb2RlZCBVaW50OEFycmF5JylcbiAgfVxuICBjb25zdCB7IG5hbWUsIGNvZGVCdWYgfSA9IGVuY29kaW5nKG5hbWVPckNvZGUpXG4gIHZhbGlkRW5jb2RlKG5hbWUsIGJ1ZilcblxuICByZXR1cm4gY29uY2F0KFtjb2RlQnVmLCBidWZdLCBjb2RlQnVmLmxlbmd0aCArIGJ1Zi5sZW5ndGgpXG59XG5cbi8qKlxuICogRW5jb2RlIGRhdGEgd2l0aCB0aGUgc3BlY2lmaWVkIGJhc2UgYW5kIGFkZCB0aGUgbXVsdGliYXNlIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcbiAgY29uc3QgZGF0YSA9IGVuY29kZVRleHQoZW5jLmVuY29kZShidWYpKVxuXG4gIHJldHVybiBjb25jYXQoW2VuYy5jb2RlQnVmLCBkYXRhXSwgZW5jLmNvZGVCdWYubGVuZ3RoICsgZGF0YS5sZW5ndGgpXG59XG5cbi8qKlxuICogVGFrZXMgYSBVaW50OEFycmF5IG9yIHN0cmluZyBlbmNvZGVkIHdpdGggbXVsdGliYXNlIGhlYWRlciwgZGVjb2RlcyBpdCBhbmRcbiAqIHJldHVybnMgdGhlIGRlY29kZWQgYnVmZmVyXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cbiAgY29uc3QgcHJlZml4ID0gZGF0YVswXVxuXG4gIC8vIE1ha2UgYWxsIGVuY29kaW5ncyBjYXNlLWluc2Vuc2l0aXZlIGV4Y2VwdCB0aGUgb25lcyB0aGF0IGluY2x1ZGUgdXBwZXIgYW5kIGxvd2VyIGNoYXJzIGluIHRoZSBhbHBoYWJldFxuICBpZiAoWydmJywgJ0YnLCAndicsICdWJywgJ3QnLCAnVCcsICdiJywgJ0InLCAnYycsICdDJywgJ2gnLCAnaycsICdLJ10uaW5jbHVkZXMocHJlZml4KSkge1xuICAgIGRhdGEgPSBkYXRhLnRvTG93ZXJDYXNlKClcbiAgfVxuICBjb25zdCBlbmMgPSBlbmNvZGluZygvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhkYXRhWzBdKSlcbiAgcmV0dXJuIGVuYy5kZWNvZGUoZGF0YS5zdWJzdHJpbmcoMSkpXG59XG5cbi8qKlxuICogSXMgdGhlIGdpdmVuIGRhdGEgbXVsdGliYXNlIGVuY29kZWQ/XG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fHN0cmluZ30gZGF0YVxuICovXG5mdW5jdGlvbiBpc0VuY29kZWQgKGRhdGEpIHtcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgZGF0YSA9IGRlY29kZVRleHQoZGF0YSlcbiAgfVxuXG4gIC8vIEVuc3VyZSBidWZPclN0cmluZyBpcyBhIHN0cmluZ1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpICE9PSAnW29iamVjdCBTdHJpbmddJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBlbmMgPSBlbmNvZGluZygvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhkYXRhWzBdKSlcbiAgICByZXR1cm4gZW5jLm5hbWVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSBlbmNvZGVkIGRhdGFcbiAqXG4gKiBAcGFyYW0ge0Jhc2VOYW1lT3JDb2RlfSBuYW1lXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiB2YWxpZEVuY29kZSAobmFtZSwgYnVmKSB7XG4gIGNvbnN0IGVuYyA9IGVuY29kaW5nKG5hbWUpXG4gIGVuYy5kZWNvZGUoZGVjb2RlVGV4dChidWYpKVxufVxuXG4vKipcbiAqIEdldCB0aGUgZW5jb2RpbmcgYnkgbmFtZSBvciBjb2RlXG4gKlxuICogQHBhcmFtIHtCYXNlTmFtZU9yQ29kZX0gbmFtZU9yQ29kZVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZyAobmFtZU9yQ29kZSkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnN0YW50cy5uYW1lcywgLyoqIEB0eXBlIHtCYXNlTmFtZX0gKi8obmFtZU9yQ29kZSkpKSB7XG4gICAgcmV0dXJuIGNvbnN0YW50cy5uYW1lc1svKiogQHR5cGUge0Jhc2VOYW1lfSAqLyhuYW1lT3JDb2RlKV1cbiAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uc3RhbnRzLmNvZGVzLCAvKiogQHR5cGUge0Jhc2VDb2RlfSAqLyhuYW1lT3JDb2RlKSkpIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLmNvZGVzWy8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKG5hbWVPckNvZGUpXVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZW5jb2Rpbmc6ICR7bmFtZU9yQ29kZX1gKVxuICB9XG59XG5cbi8qKlxuICogR2V0IGVuY29kaW5nIGZyb20gZGF0YVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfFVpbnQ4QXJyYXl9IGRhdGFcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmdGcm9tRGF0YSAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgcmV0dXJuIGVuY29kaW5nKC8qKiBAdHlwZSB7QmFzZUNvZGV9ICovKGRhdGFbMF0pKVxufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBtdWx0aWJhc2VcbmV4cG9ydHMuZW5jb2RlID0gZW5jb2RlXG5leHBvcnRzLmRlY29kZSA9IGRlY29kZVxuZXhwb3J0cy5pc0VuY29kZWQgPSBpc0VuY29kZWRcbmV4cG9ydHMuZW5jb2RpbmcgPSBlbmNvZGluZ1xuZXhwb3J0cy5lbmNvZGluZ0Zyb21EYXRhID0gZW5jb2RpbmdGcm9tRGF0YVxuY29uc3QgbmFtZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5uYW1lcylcbmNvbnN0IGNvZGVzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMuY29kZXMpXG5leHBvcnRzLm5hbWVzID0gbmFtZXNcbmV4cG9ydHMuY29kZXMgPSBjb2Rlc1xuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBkZWNvZGUgPSAoc3RyaW5nLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgLy8gQnVpbGQgdGhlIGNoYXJhY3RlciBsb29rdXAgdGFibGU6XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgbnVtYmVyPn0gKi9cbiAgY29uc3QgY29kZXMgPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaVxuICB9XG5cbiAgLy8gQ291bnQgdGhlIHBhZGRpbmcgYnl0ZXM6XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoXG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kXG4gIH1cblxuICAvLyBBbGxvY2F0ZSB0aGUgb3V0cHV0OlxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApXG5cbiAgLy8gUGFyc2UgdGhlIGRhdGE6XG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBsZXQgd3JpdHRlbiA9IDAgLy8gTmV4dCBieXRlIHRvIHdyaXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAvLyBSZWFkIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RyaW5nOlxuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICcgKyBzdHJpbmdbaV0pXG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXRzIHRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZVxuICAgIGJpdHMgKz0gYml0c1BlckNoYXJcblxuICAgIC8vIFdyaXRlIG91dCBzb21lIGJpdHMgaWYgdGhlIGJ1ZmZlciBoYXMgYSBieXRlJ3Mgd29ydGg6XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDB4ZmYgJiAoYnVmZmVyID4+IGJpdHMpXG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBqdXN0IGVub3VnaCBiaXRzOlxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAweGZmICYgKGJ1ZmZlciA8PCAoOCAtIGJpdHMpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxXG4gIGxldCBvdXQgPSAnJ1xuXG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBTbHVycCBkYXRhIGludG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgLy8gV3JpdGUgb3V0IGFzIG11Y2ggYXMgd2UgY2FuOlxuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXJcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA+PiBiaXRzKV1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJ0aWFsIGNoYXJhY3RlcjpcbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPDwgKGJpdHNQZXJDaGFyIC0gYml0cykpXVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmcgY2hhcmFjdGVycyB1bnRpbCB3ZSBoaXQgYSBieXRlIGJvdW5kYXJ5OlxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykge1xuICAgICAgb3V0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBSRkM0NjQ4IEZhY3RvcnlcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtDb2RlY0ZhY3Rvcnl9XG4gKi9cbmNvbnN0IHJmYzQ2NDggPSAoYml0c1BlckNoYXIpID0+IChhbHBoYWJldCkgPT4ge1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGVuY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBlbmNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgICAqL1xuICAgIGRlY29kZSAoaW5wdXQpIHtcbiAgICAgIHJldHVybiBkZWNvZGUoaW5wdXQsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcilcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHJmYzQ2NDggfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXd8QXJyYXlCdWZmZXJ9IGJ5dGVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5jb25zdCBkZWNvZGVUZXh0ID0gKGJ5dGVzKSA9PiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpXG5cbmNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5jb25zdCBlbmNvZGVUZXh0ID0gKHRleHQpID0+IHRleHRFbmNvZGVyLmVuY29kZSh0ZXh0KVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgVWludDhBcnJheSBjcmVhdGVkIGJ5IGNvbmNhdGVuYXRpbmcgdGhlIHBhc3NlZCBBcnJheXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCAoYXJycywgbGVuZ3RoKSB7XG4gIGNvbnN0IG91dHB1dCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgbGV0IG9mZnNldCA9IDBcblxuICBmb3IgKGNvbnN0IGFyciBvZiBhcnJzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgZGVjb2RlVGV4dCwgZW5jb2RlVGV4dCwgY29uY2F0IH1cbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oXCIuL3R5cGVzXCIpLkJhc2VOYW1lfSBCYXNlTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi90eXBlc1wiKS5CYXNlQ29kZX0gQmFzZUNvZGUgKi9cblxuLyoqXG4gKiBDbGFzcyB0byBlbmNvZGUvZGVjb2RlIGluIHRoZSBzdXBwb3J0ZWQgQmFzZXNcbiAqXG4gKi9cbmNsYXNzIEJhc2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtCYXNlTmFtZX0gbmFtZVxuICAgKiBAcGFyYW0ge0Jhc2VDb2RlfSBjb2RlXG4gICAqIEBwYXJhbSB7Q29kZWNGYWN0b3J5fSBmYWN0b3J5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIGNvZGUsIGZhY3RvcnksIGFscGhhYmV0KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICB0aGlzLmNvZGVCdWYgPSBlbmNvZGVUZXh0KHRoaXMuY29kZSlcbiAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXRcbiAgICB0aGlzLmNvZGVjID0gZmFjdG9yeShhbHBoYWJldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5jb2RlIChidWYpIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlYy5lbmNvZGUoYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gICAqL1xuICBkZWNvZGUgKHN0cmluZykge1xuICAgIGZvciAoY29uc3QgY2hhciBvZiBzdHJpbmcpIHtcbiAgICAgIGlmICh0aGlzLmFscGhhYmV0ICYmIHRoaXMuYWxwaGFiZXQuaW5kZXhPZihjaGFyKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGNoYXJhY3RlciAnJHtjaGFyfScgaW4gJyR7c3RyaW5nfSdgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb2RlYy5kZWNvZGUoc3RyaW5nKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2VYID0gcmVxdWlyZSgnQG11bHRpZm9ybWF0cy9iYXNlLXgnKVxuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZS5qcycpXG5jb25zdCB7IHJmYzQ2NDggfSA9IHJlcXVpcmUoJy4vcmZjNDY0OCcpXG5jb25zdCB7IGRlY29kZVRleHQsIGVuY29kZVRleHQgfSA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkNvZGVjRmFjdG9yeX0gQ29kZWNGYWN0b3J5ICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY30gQ29kZWMgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi90eXBlcycpLkJhc2VOYW1lfSBCYXNlTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL3R5cGVzJykuQmFzZUNvZGV9IEJhc2VDb2RlICovXG5cbi8qKiBAdHlwZSB7Q29kZWNGYWN0b3J5fSAqL1xuY29uc3QgaWRlbnRpdHkgPSAoKSA9PiB7XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBkZWNvZGVUZXh0LFxuICAgIGRlY29kZTogZW5jb2RlVGV4dFxuICB9XG59XG5cbi8qKlxuICpcbiAqIG5hbWUsIGNvZGUsIGltcGxlbWVudGF0aW9uLCBhbHBoYWJldFxuICpcbiAqIEB0eXBlIHtBcnJheTxbQmFzZU5hbWUsIEJhc2VDb2RlLCBDb2RlY0ZhY3RvcnksIHN0cmluZ10+fVxuICovXG5jb25zdCBjb25zdGFudHMgPSBbXG4gIFsnaWRlbnRpdHknLCAnXFx4MDAnLCBpZGVudGl0eSwgJyddLFxuICBbJ2Jhc2UyJywgJzAnLCByZmM0NjQ4KDEpLCAnMDEnXSxcbiAgWydiYXNlOCcsICc3JywgcmZjNDY0OCgzKSwgJzAxMjM0NTY3J10sXG4gIFsnYmFzZTEwJywgJzknLCBiYXNlWCwgJzAxMjM0NTY3ODknXSxcbiAgWydiYXNlMTYnLCAnZicsIHJmYzQ2NDgoNCksICcwMTIzNDU2Nzg5YWJjZGVmJ10sXG4gIFsnYmFzZTE2dXBwZXInLCAnRicsIHJmYzQ2NDgoNCksICcwMTIzNDU2Nzg5QUJDREVGJ10sXG4gIFsnYmFzZTMyaGV4JywgJ3YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXYnXSxcbiAgWydiYXNlMzJoZXh1cHBlcicsICdWJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWJ10sXG4gIFsnYmFzZTMyaGV4cGFkJywgJ3QnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OWFiY2RlZmdoaWprbG1ub3BxcnN0dXY9J10sXG4gIFsnYmFzZTMyaGV4cGFkdXBwZXInLCAnVCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVj0nXSxcbiAgWydiYXNlMzInLCAnYicsIHJmYzQ2NDgoNSksICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2NyddLFxuICBbJ2Jhc2UzMnVwcGVyJywgJ0InLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1NjcnXSxcbiAgWydiYXNlMzJwYWQnLCAnYycsIHJmYzQ2NDgoNSksICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2Nz0nXSxcbiAgWydiYXNlMzJwYWR1cHBlcicsICdDJywgcmZjNDY0OCg1KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaMjM0NTY3PSddLFxuICBbJ2Jhc2UzMnonLCAnaCcsIHJmYzQ2NDgoNSksICd5Ym5kcmZnOGVqa21jcHF4b3QxdXdpc3phMzQ1aDc2OSddLFxuICBbJ2Jhc2UzNicsICdrJywgYmFzZVgsICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonXSxcbiAgWydiYXNlMzZ1cHBlcicsICdLJywgYmFzZVgsICcwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNThidGMnLCAneicsIGJhc2VYLCAnMTIzNDU2Nzg5QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaYWJjZGVmZ2hpamttbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2U1OGZsaWNrcicsICdaJywgYmFzZVgsICcxMjM0NTY3ODlhYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6QUJDREVGR0hKS0xNTlBRUlNUVVZXWFlaJ10sXG4gIFsnYmFzZTY0JywgJ20nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyddLFxuICBbJ2Jhc2U2NHBhZCcsICdNJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89J10sXG4gIFsnYmFzZTY0dXJsJywgJ3UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXyddLFxuICBbJ2Jhc2U2NHVybHBhZCcsICdVJywgcmZjNDY0OCg2KSwgJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89J11cbl1cblxuLyoqIEB0eXBlIHtSZWNvcmQ8QmFzZU5hbWUsQmFzZT59ICovXG5jb25zdCBuYW1lcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVswXV0gPSBuZXcgQmFzZSh0dXBwbGVbMF0sIHR1cHBsZVsxXSwgdHVwcGxlWzJdLCB0dXBwbGVbM10pXG4gIHJldHVybiBwcmV2XG59LCAvKiogQHR5cGUge1JlY29yZDxCYXNlTmFtZSxCYXNlPn0gKi8oe30pKVxuXG4vKiogQHR5cGUge1JlY29yZDxCYXNlQ29kZSxCYXNlPn0gKi9cbmNvbnN0IGNvZGVzID0gY29uc3RhbnRzLnJlZHVjZSgocHJldiwgdHVwcGxlKSA9PiB7XG4gIHByZXZbdHVwcGxlWzFdXSA9IG5hbWVzW3R1cHBsZVswXV1cbiAgcmV0dXJuIHByZXZcbn0sIC8qKiBAdHlwZSB7UmVjb3JkPEJhc2VDb2RlLEJhc2U+fSAqLyh7fSkpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lcyxcbiAgY29kZXNcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vdHlwZXMnKS5Db2RlY0ZhY3Rvcnl9IENvZGVjRmFjdG9yeSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBhbHBoYWJldFxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZGVjb2RlID0gKHN0cmluZywgYWxwaGFiZXQsIGJpdHNQZXJDaGFyKSA9PiB7XG4gIC8vIEJ1aWxkIHRoZSBjaGFyYWN0ZXIgbG9va3VwIHRhYmxlOlxuICAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIG51bWJlcj59ICovXG4gIGNvbnN0IGNvZGVzID0ge31cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7ICsraSkge1xuICAgIGNvZGVzW2FscGhhYmV0W2ldXSA9IGlcbiAgfVxuXG4gIC8vIENvdW50IHRoZSBwYWRkaW5nIGJ5dGVzOlxuICBsZXQgZW5kID0gc3RyaW5nLmxlbmd0aFxuICB3aGlsZSAoc3RyaW5nW2VuZCAtIDFdID09PSAnPScpIHtcbiAgICAtLWVuZFxuICB9XG5cbiAgLy8gQWxsb2NhdGUgdGhlIG91dHB1dDpcbiAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoKGVuZCAqIGJpdHNQZXJDaGFyIC8gOCkgfCAwKVxuXG4gIC8vIFBhcnNlIHRoZSBkYXRhOlxuICBsZXQgYml0cyA9IDAgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgbGV0IGJ1ZmZlciA9IDAgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgbGV0IHdyaXR0ZW4gPSAwIC8vIE5leHQgYnl0ZSB0byB3cml0ZVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuZDsgKytpKSB7XG4gICAgLy8gUmVhZCBvbmUgY2hhcmFjdGVyIGZyb20gdGhlIHN0cmluZzpcbiAgICBjb25zdCB2YWx1ZSA9IGNvZGVzW3N0cmluZ1tpXV1cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciAnICsgc3RyaW5nW2ldKVxuICAgIH1cblxuICAgIC8vIEFwcGVuZCB0aGUgYml0cyB0byB0aGUgYnVmZmVyOlxuICAgIGJ1ZmZlciA9IChidWZmZXIgPDwgYml0c1BlckNoYXIpIHwgdmFsdWVcbiAgICBiaXRzICs9IGJpdHNQZXJDaGFyXG5cbiAgICAvLyBXcml0ZSBvdXQgc29tZSBiaXRzIGlmIHRoZSBidWZmZXIgaGFzIGEgYnl0ZSdzIHdvcnRoOlxuICAgIGlmIChiaXRzID49IDgpIHtcbiAgICAgIGJpdHMgLT0gOFxuICAgICAgb3V0W3dyaXR0ZW4rK10gPSAweGZmICYgKGJ1ZmZlciA+PiBiaXRzKVxuICAgIH1cbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHdlIGhhdmUgcmVjZWl2ZWQganVzdCBlbm91Z2ggYml0czpcbiAgaWYgKGJpdHMgPj0gYml0c1BlckNoYXIgfHwgMHhmZiAmIChidWZmZXIgPDwgKDggLSBiaXRzKSkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGRhdGEnKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGVuY29kZSA9IChkYXRhLCBhbHBoYWJldCwgYml0c1BlckNoYXIpID0+IHtcbiAgY29uc3QgcGFkID0gYWxwaGFiZXRbYWxwaGFiZXQubGVuZ3RoIC0gMV0gPT09ICc9J1xuICBjb25zdCBtYXNrID0gKDEgPDwgYml0c1BlckNoYXIpIC0gMVxuICBsZXQgb3V0ID0gJydcblxuICBsZXQgYml0cyA9IDAgLy8gTnVtYmVyIG9mIGJpdHMgY3VycmVudGx5IGluIHRoZSBidWZmZXJcbiAgbGV0IGJ1ZmZlciA9IDAgLy8gQml0cyB3YWl0aW5nIHRvIGJlIHdyaXR0ZW4gb3V0LCBNU0IgZmlyc3RcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gU2x1cnAgZGF0YSBpbnRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCA4KSB8IGRhdGFbaV1cbiAgICBiaXRzICs9IDhcblxuICAgIC8vIFdyaXRlIG91dCBhcyBtdWNoIGFzIHdlIGNhbjpcbiAgICB3aGlsZSAoYml0cyA+IGJpdHNQZXJDaGFyKSB7XG4gICAgICBiaXRzIC09IGJpdHNQZXJDaGFyXG4gICAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPj4gYml0cyldXG4gICAgfVxuICB9XG5cbiAgLy8gUGFydGlhbCBjaGFyYWN0ZXI6XG4gIGlmIChiaXRzKSB7XG4gICAgb3V0ICs9IGFscGhhYmV0W21hc2sgJiAoYnVmZmVyIDw8IChiaXRzUGVyQ2hhciAtIGJpdHMpKV1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nIGNoYXJhY3RlcnMgdW50aWwgd2UgaGl0IGEgYnl0ZSBib3VuZGFyeTpcbiAgaWYgKHBhZCkge1xuICAgIHdoaWxlICgob3V0Lmxlbmd0aCAqIGJpdHNQZXJDaGFyKSAmIDcpIHtcbiAgICAgIG91dCArPSAnPSdcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogUkZDNDY0OCBGYWN0b3J5XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdHNQZXJDaGFyXG4gKiBAcmV0dXJucyB7Q29kZWNGYWN0b3J5fVxuICovXG5jb25zdCByZmM0NjQ4ID0gKGJpdHNQZXJDaGFyKSA9PiAoYWxwaGFiZXQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBlbmNvZGUgKGlucHV0KSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpXG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyByZmM0NjQ4IH1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vLyBAdHMtaWdub3JlXG5jb25zdCB7IFRleHRFbmNvZGVyLCBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld3xBcnJheUJ1ZmZlcn0gYnl0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGRlY29kZVRleHQgPSAoYnl0ZXMpID0+IHRleHREZWNvZGVyLmRlY29kZShieXRlcylcblxuY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGVuY29kZVRleHQgPSAodGV4dCkgPT4gdGV4dEVuY29kZXIuZW5jb2RlKHRleHQpXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5c1xuICpcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlMaWtlPG51bWJlcj4+fSBhcnJzXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJzLCBsZW5ndGgpIHtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBsZXQgb2Zmc2V0ID0gMFxuXG4gIGZvciAoY29uc3QgYXJyIG9mIGFycnMpIHtcbiAgICBvdXRwdXQuc2V0KGFyciwgb2Zmc2V0KVxuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gb3V0cHV0XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0LCBjb25jYXQgfVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5TGlrZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyYXlzXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbmFtZXMgfSA9IHJlcXVpcmUoJ211bHRpYmFzZS9zcmMvY29uc3RhbnRzJylcbmNvbnN0IHsgVGV4dEVuY29kZXIgfSA9IHJlcXVpcmUoJ3dlYi1lbmNvZGluZycpXG5jb25zdCB1dGY4RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG5cbi8qKlxuICogSW50ZXJwZXJldHMgZWFjaCBjaGFyYWN0ZXIgaW4gYSBzdHJpbmcgYXMgYSBieXRlIGFuZFxuICogcmV0dXJucyBhIFVpbnQ4QXJyYXkgb2YgdGhvc2UgYnl0ZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHR1cm4gaW50byBhbiBhcnJheVxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGFzY2lpU3RyaW5nVG9VaW50OEFycmF5IChzdHJpbmcpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShzdHJpbmcubGVuZ3RoKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFVpbnQ4QXJyYXlgIGZyb20gdGhlIHBhc3NlZCBzdHJpbmdcbiAqXG4gKiBTdXBwb3J0cyBgdXRmOGAsIGB1dGYtOGAgYW5kIGFueSBlbmNvZGluZyBzdXBwb3J0ZWQgYnkgdGhlIG11bHRpYmFzZSBtb2R1bGUuXG4gKlxuICogQWxzbyBgYXNjaWlgIHdoaWNoIGlzIHNpbWlsYXIgdG8gbm9kZSdzICdiaW5hcnknIGVuY29kaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9dXRmOF0gdXRmOCwgYmFzZTE2LCBiYXNlNjQsIGJhc2U2NHVybHBhZCwgZXRjXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpYmFzZXxtdWx0aWJhc2V9IGZvciBzdXBwb3J0ZWQgZW5jb2RpbmdzIG90aGVyIHRoYW4gYHV0ZjhgXG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOEVuY29kZXIuZW5jb2RlKHN0cmluZylcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiBhc2NpaVN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpXG4gIH1cblxuICBjb25zdCBjb2RlYyA9IG5hbWVzW2VuY29kaW5nXVxuXG4gIGlmICghY29kZWMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmFzZScpXG4gIH1cblxuICByZXR1cm4gY29kZWMuZGVjb2RlKHN0cmluZylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmcm9tU3RyaW5nXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgeyBuYW1lcyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlL3NyYy9jb25zdGFudHMnKVxuY29uc3QgeyBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcbmNvbnN0IHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGY4JylcblxuLyoqXG4gKiBUdXJucyBhIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgaW50byBhIHN0cmluZyB3aXRoIGVhY2hcbiAqIGNoYXJhY3RlciBiZWluZyB0aGUgY2hhciBjb2RlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nIChhcnJheSkge1xuICBsZXQgc3RyaW5nID0gJydcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYXJyYXlbaV0pXG4gIH1cbiAgcmV0dXJuIHN0cmluZ1xufVxuXG4vKipcbiAqIFR1cm5zIGEgYFVpbnQ4QXJyYXlgIGludG8gYSBzdHJpbmcuXG4gKlxuICogU3VwcG9ydHMgYHV0ZjhgLCBgdXRmLThgIGFuZCBhbnkgZW5jb2Rpbmcgc3VwcG9ydGVkIGJ5IHRoZSBtdWx0aWJhc2UgbW9kdWxlLlxuICpcbiAqIEFsc28gYGFzY2lpYCB3aGljaCBpcyBzaW1pbGFyIHRvIG5vZGUncyAnYmluYXJ5JyBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9dXRmOF0gVGhlIGVuY29kaW5nIHRvIHVzZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL211bHRpYmFzZXxtdWx0aWJhc2V9IGZvciBzdXBwb3J0ZWQgZW5jb2RpbmdzIG90aGVyIHRoYW4gYHV0ZjhgXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nIChhcnJheSwgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOERlY29kZXIuZGVjb2RlKGFycmF5KVxuICB9XG5cbiAgaWYgKGVuY29kaW5nID09PSAnYXNjaWknKSB7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0FzY2lpU3RyaW5nKGFycmF5KVxuICB9XG5cbiAgY29uc3QgY29kZWMgPSBuYW1lc1tlbmNvZGluZ11cblxuICBpZiAoIWNvZGVjKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJhc2UnKVxuICB9XG5cbiAgcmV0dXJuIGNvZGVjLmVuY29kZShhcnJheSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZ1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZWFkXG5cbnZhciBNU0IgPSAweDgwXG4gICwgUkVTVCA9IDB4N0ZcblxuZnVuY3Rpb24gcmVhZChidWYsIG9mZnNldCkge1xuICB2YXIgcmVzICAgID0gMFxuICAgICwgb2Zmc2V0ID0gb2Zmc2V0IHx8IDBcbiAgICAsIHNoaWZ0ICA9IDBcbiAgICAsIGNvdW50ZXIgPSBvZmZzZXRcbiAgICAsIGJcbiAgICAsIGwgPSBidWYubGVuZ3RoXG5cbiAgZG8ge1xuICAgIGlmIChjb3VudGVyID49IGwgfHwgc2hpZnQgPiA0OSkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgaWYgKE51bWJlci5NQVhfU0FGRV9JTlRFR0VSICYmIG51bSA+IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgZW5jb2RlLmJ5dGVzID0gMFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZW5jb2RlIHZhcmludCcpXG4gIH1cbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCIvLyBETyBOT1QgQ0hBTkdFIFRISVMgRklMRS4gSVQgSVMgR0VORVJBVEVEIEJZIHRvb2xzL3VwZGF0ZS10YWJsZS5qc1xuLyogZXNsaW50IHF1b3RlLXByb3BzOiBvZmYgKi9cbid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEB0eXBlIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLk5hbWVOdW1iZXJNYXB9XG4gKi9cbmNvbnN0IGJhc2VUYWJsZSA9IE9iamVjdC5mcmVlemUoe1xuICAnaWRlbnRpdHknOiAweDAwLFxuICAnY2lkdjEnOiAweDAxLFxuICAnY2lkdjInOiAweDAyLFxuICAnY2lkdjMnOiAweDAzLFxuICAnaXA0JzogMHgwNCxcbiAgJ3RjcCc6IDB4MDYsXG4gICdzaGExJzogMHgxMSxcbiAgJ3NoYTItMjU2JzogMHgxMixcbiAgJ3NoYTItNTEyJzogMHgxMyxcbiAgJ3NoYTMtNTEyJzogMHgxNCxcbiAgJ3NoYTMtMzg0JzogMHgxNSxcbiAgJ3NoYTMtMjU2JzogMHgxNixcbiAgJ3NoYTMtMjI0JzogMHgxNyxcbiAgJ3NoYWtlLTEyOCc6IDB4MTgsXG4gICdzaGFrZS0yNTYnOiAweDE5LFxuICAna2VjY2FrLTIyNCc6IDB4MWEsXG4gICdrZWNjYWstMjU2JzogMHgxYixcbiAgJ2tlY2Nhay0zODQnOiAweDFjLFxuICAna2VjY2FrLTUxMic6IDB4MWQsXG4gICdibGFrZTMnOiAweDFlLFxuICAnZGNjcCc6IDB4MjEsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogMHgyMyxcbiAgJ2lwNic6IDB4MjksXG4gICdpcDZ6b25lJzogMHgyYSxcbiAgJ3BhdGgnOiAweDJmLFxuICAnbXVsdGljb2RlYyc6IDB4MzAsXG4gICdtdWx0aWhhc2gnOiAweDMxLFxuICAnbXVsdGlhZGRyJzogMHgzMixcbiAgJ211bHRpYmFzZSc6IDB4MzMsXG4gICdkbnMnOiAweDM1LFxuICAnZG5zNCc6IDB4MzYsXG4gICdkbnM2JzogMHgzNyxcbiAgJ2Ruc2FkZHInOiAweDM4LFxuICAncHJvdG9idWYnOiAweDUwLFxuICAnY2Jvcic6IDB4NTEsXG4gICdyYXcnOiAweDU1LFxuICAnZGJsLXNoYTItMjU2JzogMHg1NixcbiAgJ3JscCc6IDB4NjAsXG4gICdiZW5jb2RlJzogMHg2MyxcbiAgJ2RhZy1wYic6IDB4NzAsXG4gICdkYWctY2Jvcic6IDB4NzEsXG4gICdsaWJwMnAta2V5JzogMHg3MixcbiAgJ2dpdC1yYXcnOiAweDc4LFxuICAndG9ycmVudC1pbmZvJzogMHg3YixcbiAgJ3RvcnJlbnQtZmlsZSc6IDB4N2MsXG4gICdsZW9mY29pbi1ibG9jayc6IDB4ODEsXG4gICdsZW9mY29pbi10eCc6IDB4ODIsXG4gICdsZW9mY29pbi1wcic6IDB4ODMsXG4gICdzY3RwJzogMHg4NCxcbiAgJ2RhZy1qb3NlJzogMHg4NSxcbiAgJ2RhZy1jb3NlJzogMHg4NixcbiAgJ2V0aC1ibG9jayc6IDB4OTAsXG4gICdldGgtYmxvY2stbGlzdCc6IDB4OTEsXG4gICdldGgtdHgtdHJpZSc6IDB4OTIsXG4gICdldGgtdHgnOiAweDkzLFxuICAnZXRoLXR4LXJlY2VpcHQtdHJpZSc6IDB4OTQsXG4gICdldGgtdHgtcmVjZWlwdCc6IDB4OTUsXG4gICdldGgtc3RhdGUtdHJpZSc6IDB4OTYsXG4gICdldGgtYWNjb3VudC1zbmFwc2hvdCc6IDB4OTcsXG4gICdldGgtc3RvcmFnZS10cmllJzogMHg5OCxcbiAgJ2JpdGNvaW4tYmxvY2snOiAweGIwLFxuICAnYml0Y29pbi10eCc6IDB4YjEsXG4gICdiaXRjb2luLXdpdG5lc3MtY29tbWl0bWVudCc6IDB4YjIsXG4gICd6Y2FzaC1ibG9jayc6IDB4YzAsXG4gICd6Y2FzaC10eCc6IDB4YzEsXG4gICdkb2NpZCc6IDB4Y2UsXG4gICdzdGVsbGFyLWJsb2NrJzogMHhkMCxcbiAgJ3N0ZWxsYXItdHgnOiAweGQxLFxuICAnbWQ0JzogMHhkNCxcbiAgJ21kNSc6IDB4ZDUsXG4gICdibXQnOiAweGQ2LFxuICAnZGVjcmVkLWJsb2NrJzogMHhlMCxcbiAgJ2RlY3JlZC10eCc6IDB4ZTEsXG4gICdpcGxkLW5zJzogMHhlMixcbiAgJ2lwZnMtbnMnOiAweGUzLFxuICAnc3dhcm0tbnMnOiAweGU0LFxuICAnaXBucy1ucyc6IDB4ZTUsXG4gICd6ZXJvbmV0JzogMHhlNixcbiAgJ3NlY3AyNTZrMS1wdWInOiAweGU3LFxuICAnYmxzMTJfMzgxLWcxLXB1Yic6IDB4ZWEsXG4gICdibHMxMl8zODEtZzItcHViJzogMHhlYixcbiAgJ3gyNTUxOS1wdWInOiAweGVjLFxuICAnZWQyNTUxOS1wdWInOiAweGVkLFxuICAnYmxzMTJfMzgxLWcxZzItcHViJzogMHhlZSxcbiAgJ2Rhc2gtYmxvY2snOiAweGYwLFxuICAnZGFzaC10eCc6IDB4ZjEsXG4gICdzd2FybS1tYW5pZmVzdCc6IDB4ZmEsXG4gICdzd2FybS1mZWVkJzogMHhmYixcbiAgJ3VkcCc6IDB4MDExMSxcbiAgJ3AycC13ZWJydGMtc3Rhcic6IDB4MDExMyxcbiAgJ3AycC13ZWJydGMtZGlyZWN0JzogMHgwMTE0LFxuICAncDJwLXN0YXJkdXN0JzogMHgwMTE1LFxuICAncDJwLWNpcmN1aXQnOiAweDAxMjIsXG4gICdkYWctanNvbic6IDB4MDEyOSxcbiAgJ3VkdCc6IDB4MDEyZCxcbiAgJ3V0cCc6IDB4MDEyZSxcbiAgJ3VuaXgnOiAweDAxOTAsXG4gICdwMnAnOiAweDAxYTUsXG4gICdpcGZzJzogMHgwMWE1LFxuICAnaHR0cHMnOiAweDAxYmIsXG4gICdvbmlvbic6IDB4MDFiYyxcbiAgJ29uaW9uMyc6IDB4MDFiZCxcbiAgJ2dhcmxpYzY0JzogMHgwMWJlLFxuICAnZ2FybGljMzInOiAweDAxYmYsXG4gICd0bHMnOiAweDAxYzAsXG4gICdxdWljJzogMHgwMWNjLFxuICAnd3MnOiAweDAxZGQsXG4gICd3c3MnOiAweDAxZGUsXG4gICdwMnAtd2Vic29ja2V0LXN0YXInOiAweDAxZGYsXG4gICdodHRwJzogMHgwMWUwLFxuICAnanNvbic6IDB4MDIwMCxcbiAgJ21lc3NhZ2VwYWNrJzogMHgwMjAxLFxuICAnbGlicDJwLXBlZXItcmVjb3JkJzogMHgwMzAxLFxuICAnc2hhMi0yNTYtdHJ1bmMyNTQtcGFkZGVkJzogMHgxMDEyLFxuICAncmlwZW1kLTEyOCc6IDB4MTA1MixcbiAgJ3JpcGVtZC0xNjAnOiAweDEwNTMsXG4gICdyaXBlbWQtMjU2JzogMHgxMDU0LFxuICAncmlwZW1kLTMyMCc6IDB4MTA1NSxcbiAgJ3gxMSc6IDB4MTEwMCxcbiAgJ3AyNTYtcHViJzogMHgxMjAwLFxuICAncDM4NC1wdWInOiAweDEyMDEsXG4gICdwNTIxLXB1Yic6IDB4MTIwMixcbiAgJ2VkNDQ4LXB1Yic6IDB4MTIwMyxcbiAgJ3g0NDgtcHViJzogMHgxMjA0LFxuICAnZWQyNTUxOS1wcml2JzogMHgxMzAwLFxuICAna2FuZ2Fyb290d2VsdmUnOiAweDFkMDEsXG4gICdzbTMtMjU2JzogMHg1MzRkLFxuICAnYmxha2UyYi04JzogMHhiMjAxLFxuICAnYmxha2UyYi0xNic6IDB4YjIwMixcbiAgJ2JsYWtlMmItMjQnOiAweGIyMDMsXG4gICdibGFrZTJiLTMyJzogMHhiMjA0LFxuICAnYmxha2UyYi00MCc6IDB4YjIwNSxcbiAgJ2JsYWtlMmItNDgnOiAweGIyMDYsXG4gICdibGFrZTJiLTU2JzogMHhiMjA3LFxuICAnYmxha2UyYi02NCc6IDB4YjIwOCxcbiAgJ2JsYWtlMmItNzInOiAweGIyMDksXG4gICdibGFrZTJiLTgwJzogMHhiMjBhLFxuICAnYmxha2UyYi04OCc6IDB4YjIwYixcbiAgJ2JsYWtlMmItOTYnOiAweGIyMGMsXG4gICdibGFrZTJiLTEwNCc6IDB4YjIwZCxcbiAgJ2JsYWtlMmItMTEyJzogMHhiMjBlLFxuICAnYmxha2UyYi0xMjAnOiAweGIyMGYsXG4gICdibGFrZTJiLTEyOCc6IDB4YjIxMCxcbiAgJ2JsYWtlMmItMTM2JzogMHhiMjExLFxuICAnYmxha2UyYi0xNDQnOiAweGIyMTIsXG4gICdibGFrZTJiLTE1Mic6IDB4YjIxMyxcbiAgJ2JsYWtlMmItMTYwJzogMHhiMjE0LFxuICAnYmxha2UyYi0xNjgnOiAweGIyMTUsXG4gICdibGFrZTJiLTE3Nic6IDB4YjIxNixcbiAgJ2JsYWtlMmItMTg0JzogMHhiMjE3LFxuICAnYmxha2UyYi0xOTInOiAweGIyMTgsXG4gICdibGFrZTJiLTIwMCc6IDB4YjIxOSxcbiAgJ2JsYWtlMmItMjA4JzogMHhiMjFhLFxuICAnYmxha2UyYi0yMTYnOiAweGIyMWIsXG4gICdibGFrZTJiLTIyNCc6IDB4YjIxYyxcbiAgJ2JsYWtlMmItMjMyJzogMHhiMjFkLFxuICAnYmxha2UyYi0yNDAnOiAweGIyMWUsXG4gICdibGFrZTJiLTI0OCc6IDB4YjIxZixcbiAgJ2JsYWtlMmItMjU2JzogMHhiMjIwLFxuICAnYmxha2UyYi0yNjQnOiAweGIyMjEsXG4gICdibGFrZTJiLTI3Mic6IDB4YjIyMixcbiAgJ2JsYWtlMmItMjgwJzogMHhiMjIzLFxuICAnYmxha2UyYi0yODgnOiAweGIyMjQsXG4gICdibGFrZTJiLTI5Nic6IDB4YjIyNSxcbiAgJ2JsYWtlMmItMzA0JzogMHhiMjI2LFxuICAnYmxha2UyYi0zMTInOiAweGIyMjcsXG4gICdibGFrZTJiLTMyMCc6IDB4YjIyOCxcbiAgJ2JsYWtlMmItMzI4JzogMHhiMjI5LFxuICAnYmxha2UyYi0zMzYnOiAweGIyMmEsXG4gICdibGFrZTJiLTM0NCc6IDB4YjIyYixcbiAgJ2JsYWtlMmItMzUyJzogMHhiMjJjLFxuICAnYmxha2UyYi0zNjAnOiAweGIyMmQsXG4gICdibGFrZTJiLTM2OCc6IDB4YjIyZSxcbiAgJ2JsYWtlMmItMzc2JzogMHhiMjJmLFxuICAnYmxha2UyYi0zODQnOiAweGIyMzAsXG4gICdibGFrZTJiLTM5Mic6IDB4YjIzMSxcbiAgJ2JsYWtlMmItNDAwJzogMHhiMjMyLFxuICAnYmxha2UyYi00MDgnOiAweGIyMzMsXG4gICdibGFrZTJiLTQxNic6IDB4YjIzNCxcbiAgJ2JsYWtlMmItNDI0JzogMHhiMjM1LFxuICAnYmxha2UyYi00MzInOiAweGIyMzYsXG4gICdibGFrZTJiLTQ0MCc6IDB4YjIzNyxcbiAgJ2JsYWtlMmItNDQ4JzogMHhiMjM4LFxuICAnYmxha2UyYi00NTYnOiAweGIyMzksXG4gICdibGFrZTJiLTQ2NCc6IDB4YjIzYSxcbiAgJ2JsYWtlMmItNDcyJzogMHhiMjNiLFxuICAnYmxha2UyYi00ODAnOiAweGIyM2MsXG4gICdibGFrZTJiLTQ4OCc6IDB4YjIzZCxcbiAgJ2JsYWtlMmItNDk2JzogMHhiMjNlLFxuICAnYmxha2UyYi01MDQnOiAweGIyM2YsXG4gICdibGFrZTJiLTUxMic6IDB4YjI0MCxcbiAgJ2JsYWtlMnMtOCc6IDB4YjI0MSxcbiAgJ2JsYWtlMnMtMTYnOiAweGIyNDIsXG4gICdibGFrZTJzLTI0JzogMHhiMjQzLFxuICAnYmxha2Uycy0zMic6IDB4YjI0NCxcbiAgJ2JsYWtlMnMtNDAnOiAweGIyNDUsXG4gICdibGFrZTJzLTQ4JzogMHhiMjQ2LFxuICAnYmxha2Uycy01Nic6IDB4YjI0NyxcbiAgJ2JsYWtlMnMtNjQnOiAweGIyNDgsXG4gICdibGFrZTJzLTcyJzogMHhiMjQ5LFxuICAnYmxha2Uycy04MCc6IDB4YjI0YSxcbiAgJ2JsYWtlMnMtODgnOiAweGIyNGIsXG4gICdibGFrZTJzLTk2JzogMHhiMjRjLFxuICAnYmxha2Uycy0xMDQnOiAweGIyNGQsXG4gICdibGFrZTJzLTExMic6IDB4YjI0ZSxcbiAgJ2JsYWtlMnMtMTIwJzogMHhiMjRmLFxuICAnYmxha2Uycy0xMjgnOiAweGIyNTAsXG4gICdibGFrZTJzLTEzNic6IDB4YjI1MSxcbiAgJ2JsYWtlMnMtMTQ0JzogMHhiMjUyLFxuICAnYmxha2Uycy0xNTInOiAweGIyNTMsXG4gICdibGFrZTJzLTE2MCc6IDB4YjI1NCxcbiAgJ2JsYWtlMnMtMTY4JzogMHhiMjU1LFxuICAnYmxha2Uycy0xNzYnOiAweGIyNTYsXG4gICdibGFrZTJzLTE4NCc6IDB4YjI1NyxcbiAgJ2JsYWtlMnMtMTkyJzogMHhiMjU4LFxuICAnYmxha2Uycy0yMDAnOiAweGIyNTksXG4gICdibGFrZTJzLTIwOCc6IDB4YjI1YSxcbiAgJ2JsYWtlMnMtMjE2JzogMHhiMjViLFxuICAnYmxha2Uycy0yMjQnOiAweGIyNWMsXG4gICdibGFrZTJzLTIzMic6IDB4YjI1ZCxcbiAgJ2JsYWtlMnMtMjQwJzogMHhiMjVlLFxuICAnYmxha2Uycy0yNDgnOiAweGIyNWYsXG4gICdibGFrZTJzLTI1Nic6IDB4YjI2MCxcbiAgJ3NrZWluMjU2LTgnOiAweGIzMDEsXG4gICdza2VpbjI1Ni0xNic6IDB4YjMwMixcbiAgJ3NrZWluMjU2LTI0JzogMHhiMzAzLFxuICAnc2tlaW4yNTYtMzInOiAweGIzMDQsXG4gICdza2VpbjI1Ni00MCc6IDB4YjMwNSxcbiAgJ3NrZWluMjU2LTQ4JzogMHhiMzA2LFxuICAnc2tlaW4yNTYtNTYnOiAweGIzMDcsXG4gICdza2VpbjI1Ni02NCc6IDB4YjMwOCxcbiAgJ3NrZWluMjU2LTcyJzogMHhiMzA5LFxuICAnc2tlaW4yNTYtODAnOiAweGIzMGEsXG4gICdza2VpbjI1Ni04OCc6IDB4YjMwYixcbiAgJ3NrZWluMjU2LTk2JzogMHhiMzBjLFxuICAnc2tlaW4yNTYtMTA0JzogMHhiMzBkLFxuICAnc2tlaW4yNTYtMTEyJzogMHhiMzBlLFxuICAnc2tlaW4yNTYtMTIwJzogMHhiMzBmLFxuICAnc2tlaW4yNTYtMTI4JzogMHhiMzEwLFxuICAnc2tlaW4yNTYtMTM2JzogMHhiMzExLFxuICAnc2tlaW4yNTYtMTQ0JzogMHhiMzEyLFxuICAnc2tlaW4yNTYtMTUyJzogMHhiMzEzLFxuICAnc2tlaW4yNTYtMTYwJzogMHhiMzE0LFxuICAnc2tlaW4yNTYtMTY4JzogMHhiMzE1LFxuICAnc2tlaW4yNTYtMTc2JzogMHhiMzE2LFxuICAnc2tlaW4yNTYtMTg0JzogMHhiMzE3LFxuICAnc2tlaW4yNTYtMTkyJzogMHhiMzE4LFxuICAnc2tlaW4yNTYtMjAwJzogMHhiMzE5LFxuICAnc2tlaW4yNTYtMjA4JzogMHhiMzFhLFxuICAnc2tlaW4yNTYtMjE2JzogMHhiMzFiLFxuICAnc2tlaW4yNTYtMjI0JzogMHhiMzFjLFxuICAnc2tlaW4yNTYtMjMyJzogMHhiMzFkLFxuICAnc2tlaW4yNTYtMjQwJzogMHhiMzFlLFxuICAnc2tlaW4yNTYtMjQ4JzogMHhiMzFmLFxuICAnc2tlaW4yNTYtMjU2JzogMHhiMzIwLFxuICAnc2tlaW41MTItOCc6IDB4YjMyMSxcbiAgJ3NrZWluNTEyLTE2JzogMHhiMzIyLFxuICAnc2tlaW41MTItMjQnOiAweGIzMjMsXG4gICdza2VpbjUxMi0zMic6IDB4YjMyNCxcbiAgJ3NrZWluNTEyLTQwJzogMHhiMzI1LFxuICAnc2tlaW41MTItNDgnOiAweGIzMjYsXG4gICdza2VpbjUxMi01Nic6IDB4YjMyNyxcbiAgJ3NrZWluNTEyLTY0JzogMHhiMzI4LFxuICAnc2tlaW41MTItNzInOiAweGIzMjksXG4gICdza2VpbjUxMi04MCc6IDB4YjMyYSxcbiAgJ3NrZWluNTEyLTg4JzogMHhiMzJiLFxuICAnc2tlaW41MTItOTYnOiAweGIzMmMsXG4gICdza2VpbjUxMi0xMDQnOiAweGIzMmQsXG4gICdza2VpbjUxMi0xMTInOiAweGIzMmUsXG4gICdza2VpbjUxMi0xMjAnOiAweGIzMmYsXG4gICdza2VpbjUxMi0xMjgnOiAweGIzMzAsXG4gICdza2VpbjUxMi0xMzYnOiAweGIzMzEsXG4gICdza2VpbjUxMi0xNDQnOiAweGIzMzIsXG4gICdza2VpbjUxMi0xNTInOiAweGIzMzMsXG4gICdza2VpbjUxMi0xNjAnOiAweGIzMzQsXG4gICdza2VpbjUxMi0xNjgnOiAweGIzMzUsXG4gICdza2VpbjUxMi0xNzYnOiAweGIzMzYsXG4gICdza2VpbjUxMi0xODQnOiAweGIzMzcsXG4gICdza2VpbjUxMi0xOTInOiAweGIzMzgsXG4gICdza2VpbjUxMi0yMDAnOiAweGIzMzksXG4gICdza2VpbjUxMi0yMDgnOiAweGIzM2EsXG4gICdza2VpbjUxMi0yMTYnOiAweGIzM2IsXG4gICdza2VpbjUxMi0yMjQnOiAweGIzM2MsXG4gICdza2VpbjUxMi0yMzInOiAweGIzM2QsXG4gICdza2VpbjUxMi0yNDAnOiAweGIzM2UsXG4gICdza2VpbjUxMi0yNDgnOiAweGIzM2YsXG4gICdza2VpbjUxMi0yNTYnOiAweGIzNDAsXG4gICdza2VpbjUxMi0yNjQnOiAweGIzNDEsXG4gICdza2VpbjUxMi0yNzInOiAweGIzNDIsXG4gICdza2VpbjUxMi0yODAnOiAweGIzNDMsXG4gICdza2VpbjUxMi0yODgnOiAweGIzNDQsXG4gICdza2VpbjUxMi0yOTYnOiAweGIzNDUsXG4gICdza2VpbjUxMi0zMDQnOiAweGIzNDYsXG4gICdza2VpbjUxMi0zMTInOiAweGIzNDcsXG4gICdza2VpbjUxMi0zMjAnOiAweGIzNDgsXG4gICdza2VpbjUxMi0zMjgnOiAweGIzNDksXG4gICdza2VpbjUxMi0zMzYnOiAweGIzNGEsXG4gICdza2VpbjUxMi0zNDQnOiAweGIzNGIsXG4gICdza2VpbjUxMi0zNTInOiAweGIzNGMsXG4gICdza2VpbjUxMi0zNjAnOiAweGIzNGQsXG4gICdza2VpbjUxMi0zNjgnOiAweGIzNGUsXG4gICdza2VpbjUxMi0zNzYnOiAweGIzNGYsXG4gICdza2VpbjUxMi0zODQnOiAweGIzNTAsXG4gICdza2VpbjUxMi0zOTInOiAweGIzNTEsXG4gICdza2VpbjUxMi00MDAnOiAweGIzNTIsXG4gICdza2VpbjUxMi00MDgnOiAweGIzNTMsXG4gICdza2VpbjUxMi00MTYnOiAweGIzNTQsXG4gICdza2VpbjUxMi00MjQnOiAweGIzNTUsXG4gICdza2VpbjUxMi00MzInOiAweGIzNTYsXG4gICdza2VpbjUxMi00NDAnOiAweGIzNTcsXG4gICdza2VpbjUxMi00NDgnOiAweGIzNTgsXG4gICdza2VpbjUxMi00NTYnOiAweGIzNTksXG4gICdza2VpbjUxMi00NjQnOiAweGIzNWEsXG4gICdza2VpbjUxMi00NzInOiAweGIzNWIsXG4gICdza2VpbjUxMi00ODAnOiAweGIzNWMsXG4gICdza2VpbjUxMi00ODgnOiAweGIzNWQsXG4gICdza2VpbjUxMi00OTYnOiAweGIzNWUsXG4gICdza2VpbjUxMi01MDQnOiAweGIzNWYsXG4gICdza2VpbjUxMi01MTInOiAweGIzNjAsXG4gICdza2VpbjEwMjQtOCc6IDB4YjM2MSxcbiAgJ3NrZWluMTAyNC0xNic6IDB4YjM2MixcbiAgJ3NrZWluMTAyNC0yNCc6IDB4YjM2MyxcbiAgJ3NrZWluMTAyNC0zMic6IDB4YjM2NCxcbiAgJ3NrZWluMTAyNC00MCc6IDB4YjM2NSxcbiAgJ3NrZWluMTAyNC00OCc6IDB4YjM2NixcbiAgJ3NrZWluMTAyNC01Nic6IDB4YjM2NyxcbiAgJ3NrZWluMTAyNC02NCc6IDB4YjM2OCxcbiAgJ3NrZWluMTAyNC03Mic6IDB4YjM2OSxcbiAgJ3NrZWluMTAyNC04MCc6IDB4YjM2YSxcbiAgJ3NrZWluMTAyNC04OCc6IDB4YjM2YixcbiAgJ3NrZWluMTAyNC05Nic6IDB4YjM2YyxcbiAgJ3NrZWluMTAyNC0xMDQnOiAweGIzNmQsXG4gICdza2VpbjEwMjQtMTEyJzogMHhiMzZlLFxuICAnc2tlaW4xMDI0LTEyMCc6IDB4YjM2ZixcbiAgJ3NrZWluMTAyNC0xMjgnOiAweGIzNzAsXG4gICdza2VpbjEwMjQtMTM2JzogMHhiMzcxLFxuICAnc2tlaW4xMDI0LTE0NCc6IDB4YjM3MixcbiAgJ3NrZWluMTAyNC0xNTInOiAweGIzNzMsXG4gICdza2VpbjEwMjQtMTYwJzogMHhiMzc0LFxuICAnc2tlaW4xMDI0LTE2OCc6IDB4YjM3NSxcbiAgJ3NrZWluMTAyNC0xNzYnOiAweGIzNzYsXG4gICdza2VpbjEwMjQtMTg0JzogMHhiMzc3LFxuICAnc2tlaW4xMDI0LTE5Mic6IDB4YjM3OCxcbiAgJ3NrZWluMTAyNC0yMDAnOiAweGIzNzksXG4gICdza2VpbjEwMjQtMjA4JzogMHhiMzdhLFxuICAnc2tlaW4xMDI0LTIxNic6IDB4YjM3YixcbiAgJ3NrZWluMTAyNC0yMjQnOiAweGIzN2MsXG4gICdza2VpbjEwMjQtMjMyJzogMHhiMzdkLFxuICAnc2tlaW4xMDI0LTI0MCc6IDB4YjM3ZSxcbiAgJ3NrZWluMTAyNC0yNDgnOiAweGIzN2YsXG4gICdza2VpbjEwMjQtMjU2JzogMHhiMzgwLFxuICAnc2tlaW4xMDI0LTI2NCc6IDB4YjM4MSxcbiAgJ3NrZWluMTAyNC0yNzInOiAweGIzODIsXG4gICdza2VpbjEwMjQtMjgwJzogMHhiMzgzLFxuICAnc2tlaW4xMDI0LTI4OCc6IDB4YjM4NCxcbiAgJ3NrZWluMTAyNC0yOTYnOiAweGIzODUsXG4gICdza2VpbjEwMjQtMzA0JzogMHhiMzg2LFxuICAnc2tlaW4xMDI0LTMxMic6IDB4YjM4NyxcbiAgJ3NrZWluMTAyNC0zMjAnOiAweGIzODgsXG4gICdza2VpbjEwMjQtMzI4JzogMHhiMzg5LFxuICAnc2tlaW4xMDI0LTMzNic6IDB4YjM4YSxcbiAgJ3NrZWluMTAyNC0zNDQnOiAweGIzOGIsXG4gICdza2VpbjEwMjQtMzUyJzogMHhiMzhjLFxuICAnc2tlaW4xMDI0LTM2MCc6IDB4YjM4ZCxcbiAgJ3NrZWluMTAyNC0zNjgnOiAweGIzOGUsXG4gICdza2VpbjEwMjQtMzc2JzogMHhiMzhmLFxuICAnc2tlaW4xMDI0LTM4NCc6IDB4YjM5MCxcbiAgJ3NrZWluMTAyNC0zOTInOiAweGIzOTEsXG4gICdza2VpbjEwMjQtNDAwJzogMHhiMzkyLFxuICAnc2tlaW4xMDI0LTQwOCc6IDB4YjM5MyxcbiAgJ3NrZWluMTAyNC00MTYnOiAweGIzOTQsXG4gICdza2VpbjEwMjQtNDI0JzogMHhiMzk1LFxuICAnc2tlaW4xMDI0LTQzMic6IDB4YjM5NixcbiAgJ3NrZWluMTAyNC00NDAnOiAweGIzOTcsXG4gICdza2VpbjEwMjQtNDQ4JzogMHhiMzk4LFxuICAnc2tlaW4xMDI0LTQ1Nic6IDB4YjM5OSxcbiAgJ3NrZWluMTAyNC00NjQnOiAweGIzOWEsXG4gICdza2VpbjEwMjQtNDcyJzogMHhiMzliLFxuICAnc2tlaW4xMDI0LTQ4MCc6IDB4YjM5YyxcbiAgJ3NrZWluMTAyNC00ODgnOiAweGIzOWQsXG4gICdza2VpbjEwMjQtNDk2JzogMHhiMzllLFxuICAnc2tlaW4xMDI0LTUwNCc6IDB4YjM5ZixcbiAgJ3NrZWluMTAyNC01MTInOiAweGIzYTAsXG4gICdza2VpbjEwMjQtNTIwJzogMHhiM2ExLFxuICAnc2tlaW4xMDI0LTUyOCc6IDB4YjNhMixcbiAgJ3NrZWluMTAyNC01MzYnOiAweGIzYTMsXG4gICdza2VpbjEwMjQtNTQ0JzogMHhiM2E0LFxuICAnc2tlaW4xMDI0LTU1Mic6IDB4YjNhNSxcbiAgJ3NrZWluMTAyNC01NjAnOiAweGIzYTYsXG4gICdza2VpbjEwMjQtNTY4JzogMHhiM2E3LFxuICAnc2tlaW4xMDI0LTU3Nic6IDB4YjNhOCxcbiAgJ3NrZWluMTAyNC01ODQnOiAweGIzYTksXG4gICdza2VpbjEwMjQtNTkyJzogMHhiM2FhLFxuICAnc2tlaW4xMDI0LTYwMCc6IDB4YjNhYixcbiAgJ3NrZWluMTAyNC02MDgnOiAweGIzYWMsXG4gICdza2VpbjEwMjQtNjE2JzogMHhiM2FkLFxuICAnc2tlaW4xMDI0LTYyNCc6IDB4YjNhZSxcbiAgJ3NrZWluMTAyNC02MzInOiAweGIzYWYsXG4gICdza2VpbjEwMjQtNjQwJzogMHhiM2IwLFxuICAnc2tlaW4xMDI0LTY0OCc6IDB4YjNiMSxcbiAgJ3NrZWluMTAyNC02NTYnOiAweGIzYjIsXG4gICdza2VpbjEwMjQtNjY0JzogMHhiM2IzLFxuICAnc2tlaW4xMDI0LTY3Mic6IDB4YjNiNCxcbiAgJ3NrZWluMTAyNC02ODAnOiAweGIzYjUsXG4gICdza2VpbjEwMjQtNjg4JzogMHhiM2I2LFxuICAnc2tlaW4xMDI0LTY5Nic6IDB4YjNiNyxcbiAgJ3NrZWluMTAyNC03MDQnOiAweGIzYjgsXG4gICdza2VpbjEwMjQtNzEyJzogMHhiM2I5LFxuICAnc2tlaW4xMDI0LTcyMCc6IDB4YjNiYSxcbiAgJ3NrZWluMTAyNC03MjgnOiAweGIzYmIsXG4gICdza2VpbjEwMjQtNzM2JzogMHhiM2JjLFxuICAnc2tlaW4xMDI0LTc0NCc6IDB4YjNiZCxcbiAgJ3NrZWluMTAyNC03NTInOiAweGIzYmUsXG4gICdza2VpbjEwMjQtNzYwJzogMHhiM2JmLFxuICAnc2tlaW4xMDI0LTc2OCc6IDB4YjNjMCxcbiAgJ3NrZWluMTAyNC03NzYnOiAweGIzYzEsXG4gICdza2VpbjEwMjQtNzg0JzogMHhiM2MyLFxuICAnc2tlaW4xMDI0LTc5Mic6IDB4YjNjMyxcbiAgJ3NrZWluMTAyNC04MDAnOiAweGIzYzQsXG4gICdza2VpbjEwMjQtODA4JzogMHhiM2M1LFxuICAnc2tlaW4xMDI0LTgxNic6IDB4YjNjNixcbiAgJ3NrZWluMTAyNC04MjQnOiAweGIzYzcsXG4gICdza2VpbjEwMjQtODMyJzogMHhiM2M4LFxuICAnc2tlaW4xMDI0LTg0MCc6IDB4YjNjOSxcbiAgJ3NrZWluMTAyNC04NDgnOiAweGIzY2EsXG4gICdza2VpbjEwMjQtODU2JzogMHhiM2NiLFxuICAnc2tlaW4xMDI0LTg2NCc6IDB4YjNjYyxcbiAgJ3NrZWluMTAyNC04NzInOiAweGIzY2QsXG4gICdza2VpbjEwMjQtODgwJzogMHhiM2NlLFxuICAnc2tlaW4xMDI0LTg4OCc6IDB4YjNjZixcbiAgJ3NrZWluMTAyNC04OTYnOiAweGIzZDAsXG4gICdza2VpbjEwMjQtOTA0JzogMHhiM2QxLFxuICAnc2tlaW4xMDI0LTkxMic6IDB4YjNkMixcbiAgJ3NrZWluMTAyNC05MjAnOiAweGIzZDMsXG4gICdza2VpbjEwMjQtOTI4JzogMHhiM2Q0LFxuICAnc2tlaW4xMDI0LTkzNic6IDB4YjNkNSxcbiAgJ3NrZWluMTAyNC05NDQnOiAweGIzZDYsXG4gICdza2VpbjEwMjQtOTUyJzogMHhiM2Q3LFxuICAnc2tlaW4xMDI0LTk2MCc6IDB4YjNkOCxcbiAgJ3NrZWluMTAyNC05NjgnOiAweGIzZDksXG4gICdza2VpbjEwMjQtOTc2JzogMHhiM2RhLFxuICAnc2tlaW4xMDI0LTk4NCc6IDB4YjNkYixcbiAgJ3NrZWluMTAyNC05OTInOiAweGIzZGMsXG4gICdza2VpbjEwMjQtMTAwMCc6IDB4YjNkZCxcbiAgJ3NrZWluMTAyNC0xMDA4JzogMHhiM2RlLFxuICAnc2tlaW4xMDI0LTEwMTYnOiAweGIzZGYsXG4gICdza2VpbjEwMjQtMTAyNCc6IDB4YjNlMCxcbiAgJ3Bvc2VpZG9uLWJsczEyXzM4MS1hMi1mYzEnOiAweGI0MDEsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxLXNjJzogMHhiNDAyLFxuICAnemVyb3hjZXJ0LWltcHJpbnQtMjU2JzogMHhjZTExLFxuICAnZmlsLWNvbW1pdG1lbnQtdW5zZWFsZWQnOiAweGYxMDEsXG4gICdmaWwtY29tbWl0bWVudC1zZWFsZWQnOiAweGYxMDIsXG4gICdob2xvY2hhaW4tYWRyLXYwJzogMHg4MDcxMjQsXG4gICdob2xvY2hhaW4tYWRyLXYxJzogMHg4MTcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYwJzogMHg5NDcxMjQsXG4gICdob2xvY2hhaW4ta2V5LXYxJzogMHg5NTcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYwJzogMHhhMjcxMjQsXG4gICdob2xvY2hhaW4tc2lnLXYxJzogMHhhMzcxMjQsXG4gICdza3luZXQtbnMnOiAweGIxOTkxMFxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IGJhc2VUYWJsZSB9XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvbnN0YW50TnVtYmVyTWFwfSBDb25zdGFudE51bWJlck1hcCAqL1xuXG5jb25zdCB7IGJhc2VUYWJsZSB9ID0gcmVxdWlyZSgnLi9iYXNlLXRhYmxlJylcblxuY29uc3QgY29uc3RhbnRzID0gLyoqIEB0eXBlIHtDb25zdGFudE51bWJlck1hcH0gKi8oe30pXG5cbmZvciAoY29uc3QgW25hbWUsIGNvZGVdIG9mIE9iamVjdC5lbnRyaWVzKGJhc2VUYWJsZSkpIHtcbiAgY29uc3QgY29uc3RhbnQgPSBuYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnXycpXG4gIGNvbnN0YW50c1tjb25zdGFudF0gPSBjb2RlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShjb25zdGFudHMpXG4iLCIvKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBtdWx0aWNvZGVjIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBtdWx0aWNvZGVjXG4gKiBAZXhhbXBsZVxuICogY29uc3QgbXVsdGljb2RlYyA9IHJlcXVpcmUoJ211bHRpY29kZWMnKVxuICpcbiAqIGNvbnN0IHByZWZpeGVkUHJvdG9idWYgPSBtdWx0aWNvZGVjLmFkZFByZWZpeCgncHJvdG9idWYnLCBwcm90b2J1ZkJ1ZmZlcilcbiAqIC8vIHByZWZpeGVkUHJvdG9idWYgMHg1MC4uLlxuICpcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5Db2RlY05hbWV9IENvZGVjTmFtZSAqL1xuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTnVtYmVyfSBDb2RlY051bWJlciAqL1xuXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgaW50VGFibGUgPSByZXF1aXJlKCcuL2ludC10YWJsZScpXG5jb25zdCBjb2RlY05hbWVUb0NvZGVWYXJpbnQgPSByZXF1aXJlKCcuL3ZhcmludC10YWJsZScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgnLi91dGlsJylcbmNvbnN0IHVpbnQ4QXJyYXlDb25jYXQgPSByZXF1aXJlKCd1aW50OGFycmF5cy9jb25jYXQnKVxuXG4vKipcbiAqIFByZWZpeCBhIGJ1ZmZlciB3aXRoIGEgbXVsdGljb2RlYy1wYWNrZWQuXG4gKlxuICogQHBhcmFtIHtDb2RlY05hbWV8VWludDhBcnJheX0gbXVsdGljb2RlY1N0ck9yQ29kZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gYWRkUHJlZml4IChtdWx0aWNvZGVjU3RyT3JDb2RlLCBkYXRhKSB7XG4gIGxldCBwcmVmaXhcblxuICBpZiAobXVsdGljb2RlY1N0ck9yQ29kZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBwcmVmaXggPSB1dGlsLnZhcmludFVpbnQ4QXJyYXlFbmNvZGUobXVsdGljb2RlY1N0ck9yQ29kZSlcbiAgfSBlbHNlIHtcbiAgICBpZiAoY29kZWNOYW1lVG9Db2RlVmFyaW50W211bHRpY29kZWNTdHJPckNvZGVdKSB7XG4gICAgICBwcmVmaXggPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbbXVsdGljb2RlY1N0ck9yQ29kZV1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWNvZGVjIG5vdCByZWNvZ25pemVkJylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVpbnQ4QXJyYXlDb25jYXQoW3ByZWZpeCwgZGF0YV0sIHByZWZpeC5sZW5ndGggKyBkYXRhLmxlbmd0aClcbn1cblxuLyoqXG4gKiBEZWNhcHN1bGF0ZSB0aGUgbXVsdGljb2RlYy1wYWNrZWQgcHJlZml4IGZyb20gdGhlIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gcm1QcmVmaXggKGRhdGEpIHtcbiAgdmFyaW50LmRlY29kZShkYXRhKVxuICByZXR1cm4gZGF0YS5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29kZWMgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY05hbWV9XG4gKi9cbmZ1bmN0aW9uIGdldENvZGVjIChwcmVmaXhlZERhdGEpIHtcbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUocHJlZml4ZWREYXRhKVxuICBjb25zdCBjb2RlY05hbWUgPSBpbnRUYWJsZS5nZXQoY29kZSlcbiAgaWYgKGNvZGVjTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlICR7Y29kZX0gbm90IGZvdW5kYClcbiAgfVxuICByZXR1cm4gY29kZWNOYW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb2RlYy5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTnVtYmVyfSBjb2RlY1xuICogQHJldHVybnMge0NvZGVjTmFtZXx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldE5hbWUgKGNvZGVjKSB7XG4gIHJldHVybiBpbnRUYWJsZS5nZXQoY29kZWMpXG59XG5cbi8qKlxuICogR2V0IHRoZSBjb2RlIG9mIHRoZSBjb2RlY1xuICpcbiAqIEBwYXJhbSB7Q29kZWNOYW1lfSBuYW1lXG4gKiBAcmV0dXJucyB7Q29kZWNOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldE51bWJlciAobmFtZSkge1xuICBjb25zdCBjb2RlID0gY29kZWNOYW1lVG9Db2RlVmFyaW50W25hbWVdXG4gIGlmIChjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVjIGAnICsgbmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIHZhcmludC5kZWNvZGUoY29kZSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgb2YgdGhlIHByZWZpeGVkIGRhdGEuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBwcmVmaXhlZERhdGFcbiAqIEByZXR1cm5zIHtDb2RlY051bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZSAocHJlZml4ZWREYXRhKSB7XG4gIHJldHVybiB2YXJpbnQuZGVjb2RlKHByZWZpeGVkRGF0YSlcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGNvZGUgYXMgdmFyaW50IG9mIGEgY29kZWMgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0NvZGVjTmFtZX0gY29kZWNOYW1lXG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29kZVZhcmludCAoY29kZWNOYW1lKSB7XG4gIGNvbnN0IGNvZGUgPSBjb2RlY05hbWVUb0NvZGVWYXJpbnRbY29kZWNOYW1lXVxuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlYyBgJyArIGNvZGVjTmFtZSArICdgIG5vdCBmb3VuZCcpXG4gIH1cbiAgcmV0dXJuIGNvZGVcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHZhcmludCBvZiBhIGNvZGUuXG4gKlxuICogQHBhcmFtIHtDb2RlY051bWJlcn0gY29kZVxuICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxuICovXG5mdW5jdGlvbiBnZXRWYXJpbnQgKGNvZGUpIHtcbiAgcmV0dXJuIHZhcmludC5lbmNvZGUoY29kZSlcbn1cblxuLy8gTWFrZSB0aGUgY29uc3RhbnRzIHRvcC1sZXZlbCBjb25zdGFudHNcbmNvbnN0IGNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJylcblxuLy8gSHVtYW4gZnJpZW5kbHkgbmFtZXMgZm9yIHByaW50aW5nLCBlLmcuIGluIGVycm9yIG1lc3NhZ2VzXG5jb25zdCBwcmludCA9IHJlcXVpcmUoJy4vcHJpbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRkUHJlZml4LFxuICBybVByZWZpeCxcbiAgZ2V0Q29kZWMsXG4gIGdldE5hbWUsXG4gIGdldE51bWJlcixcbiAgZ2V0Q29kZSxcbiAgZ2V0Q29kZVZhcmludCxcbiAgZ2V0VmFyaW50LFxuICBwcmludCxcbiAgLi4uY29uc3RhbnRzXG59XG4iLCIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCcuL2dlbmVyYXRlZC10eXBlcycpLkNvZGVjTmFtZX0gQ29kZWNOYW1lICovXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOdW1iZXJ9IENvZGVjTnVtYmVyICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG4vKipcbiAqIEB0eXBlIHtNYXA8Q29kZWNOdW1iZXIsQ29kZWNOYW1lPn1cbiAqL1xuY29uc3QgbmFtZVRhYmxlID0gbmV3IE1hcCgpXG5cbmZvciAoY29uc3QgZW5jb2RpbmdOYW1lIGluIGJhc2VUYWJsZSkge1xuICBjb25zdCBjb2RlID0gYmFzZVRhYmxlW2VuY29kaW5nTmFtZV1cbiAgbmFtZVRhYmxlLnNldChjb2RlLCAvKiogQHR5cGUge0NvZGVjTmFtZX0gKi8oZW5jb2RpbmdOYW1lKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZnJlZXplKG5hbWVUYWJsZSlcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGVkZWYge19faW1wb3J0X18oJy4vZ2VuZXJhdGVkLXR5cGVzJykuQ29kZWNOYW1lfSBDb2RlY05hbWUgKi9cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OdW1iZXJOYW1lTWFwfSBOdW1iZXJOYW1lTWFwICovXG5cbmNvbnN0IHsgYmFzZVRhYmxlIH0gPSByZXF1aXJlKCcuL2Jhc2UtdGFibGUnKVxuXG5jb25zdCB0YWJsZUJ5Q29kZSA9IC8qKiBAdHlwZSB7TnVtYmVyTmFtZU1hcH0gKi8oe30pXG5cbmZvciAoY29uc3QgW25hbWUsIGNvZGVdIG9mIE9iamVjdC5lbnRyaWVzKGJhc2VUYWJsZSkpIHtcbiAgaWYgKHRhYmxlQnlDb2RlW2NvZGVdID09PSB1bmRlZmluZWQpIHtcbiAgICB0YWJsZUJ5Q29kZVtjb2RlXSA9IC8qKiBAdHlwZSB7Q29kZWNOYW1lfSAqKi8obmFtZSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IC8qKiBAdHlwZSB7TnVtYmVyTmFtZU1hcH0gKi8oT2JqZWN0LmZyZWV6ZSh0YWJsZUJ5Q29kZSkpXG4iLCIndXNlIHN0cmljdCdcblxuY29uc3QgdmFyaW50ID0gcmVxdWlyZSgndmFyaW50JylcbmNvbnN0IHVpbnQ4QXJyYXlUb1N0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL3RvLXN0cmluZycpXG5jb25zdCB1aW50OEFycmF5RnJvbVN0cmluZyA9IHJlcXVpcmUoJ3VpbnQ4YXJyYXlzL2Zyb20tc3RyaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG51bWJlclRvVWludDhBcnJheSxcbiAgdWludDhBcnJheVRvTnVtYmVyLFxuICB2YXJpbnRVaW50OEFycmF5RW5jb2RlLFxuICB2YXJpbnRFbmNvZGVcbn1cblxuZnVuY3Rpb24gdWludDhBcnJheVRvTnVtYmVyIChidWYpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHVpbnQ4QXJyYXlUb1N0cmluZyhidWYsICdiYXNlMTYnKSwgMTYpXG59XG5cbmZ1bmN0aW9uIG51bWJlclRvVWludDhBcnJheSAobnVtKSB7XG4gIGxldCBoZXhTdHJpbmcgPSBudW0udG9TdHJpbmcoMTYpXG4gIGlmIChoZXhTdHJpbmcubGVuZ3RoICUgMiA9PT0gMSkge1xuICAgIGhleFN0cmluZyA9ICcwJyArIGhleFN0cmluZ1xuICB9XG4gIHJldHVybiB1aW50OEFycmF5RnJvbVN0cmluZyhoZXhTdHJpbmcsICdiYXNlMTYnKVxufVxuXG5mdW5jdGlvbiB2YXJpbnRVaW50OEFycmF5RW5jb2RlIChpbnB1dCkge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKHZhcmludC5lbmNvZGUodWludDhBcnJheVRvTnVtYmVyKGlucHV0KSkpXG59XG5cbmZ1bmN0aW9uIHZhcmludEVuY29kZSAobnVtKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20odmFyaW50LmVuY29kZShudW0pKVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9nZW5lcmF0ZWQtdHlwZXMnKS5OYW1lVWludDhBcnJheU1hcH0gTmFtZVVpbnQ4QXJyYXlNYXAgKi9cblxuY29uc3QgeyBiYXNlVGFibGUgfSA9IHJlcXVpcmUoJy4vYmFzZS10YWJsZScpXG5jb25zdCB2YXJpbnRFbmNvZGUgPSByZXF1aXJlKCcuL3V0aWwnKS52YXJpbnRFbmNvZGVcblxuY29uc3QgdmFyaW50VGFibGUgPSAvKiogQHR5cGUge05hbWVVaW50OEFycmF5TWFwfSAqLyAoe30pXG5cbmZvciAoY29uc3QgZW5jb2RpbmdOYW1lIGluIGJhc2VUYWJsZSkge1xuICBjb25zdCBjb2RlID0gYmFzZVRhYmxlW2VuY29kaW5nTmFtZV1cbiAgdmFyaW50VGFibGVbZW5jb2RpbmdOYW1lXSA9IHZhcmludEVuY29kZShjb2RlKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUodmFyaW50VGFibGUpXG4iLCIvLyBAdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ29kZWNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVWludDhBcnJheSk6c3RyaW5nfSBlbmNvZGVcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oc3RyaW5nKTpVaW50OEFycmF5fSBkZWNvZGVcbiAqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb24oc3RyaW5nKTpDb2RlY30gQ29kZWNGYWN0b3J5XG4gKi9cblxuY2xhc3MgQmFzZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgKiBAcGFyYW0ge0NvZGVjRmFjdG9yeX0gaW1wbGVtZW50YXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFscGhhYmV0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAobmFtZSwgY29kZSwgaW1wbGVtZW50YXRpb24sIGFscGhhYmV0KSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29kZSA9IGNvZGVcbiAgICB0aGlzLmNvZGVCdWYgPSBCdWZmZXIuZnJvbSh0aGlzLmNvZGUpXG4gICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0XG4gICAgdGhpcy5lbmdpbmUgPSBpbXBsZW1lbnRhdGlvbihhbHBoYWJldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZW5jb2RlIChidWYpIHtcbiAgICByZXR1cm4gdGhpcy5lbmdpbmUuZW5jb2RlKGJ1ZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZGVjb2RlIChzdHJpbmcpIHtcbiAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygc3RyaW5nKSB7XG4gICAgICBpZiAodGhpcy5hbHBoYWJldCAmJiB0aGlzLmFscGhhYmV0LmluZGV4T2YoY2hhcikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjaGFyYWN0ZXIgJyR7Y2hhcn0nIGluICcke3N0cmluZ30nYClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZW5naW5lLmRlY29kZShzdHJpbmcpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlXG4iLCIvLyBAdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlWCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBCYXNlID0gcmVxdWlyZSgnLi9iYXNlLmpzJylcbmNvbnN0IHJmYzQ2NDggPSByZXF1aXJlKCcuL3JmYzQ2NDgnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBlbmNvZGVUZXh0IH0gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5jb25zdCBpZGVudGl0eSA9ICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGRlY29kZVRleHQsXG4gICAgZGVjb2RlOiBlbmNvZGVUZXh0XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9iYXNlJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnlcbiAqXG4gKiBuYW1lLCBjb2RlLCBpbXBsZW1lbnRhdGlvbiwgYWxwaGFiZXRcbiAqIEB0eXBlIHtBcnJheTxbc3RyaW5nLCBzdHJpbmcsIENvZGVjRmFjdG9yeSwgc3RyaW5nXT59XG4gKi9cbmNvbnN0IGNvbnN0YW50cyA9IFtcbiAgWydpZGVudGl0eScsICdcXHgwMCcsIGlkZW50aXR5LCAnJ10sXG4gIFsnYmFzZTInLCAnMCcsIHJmYzQ2NDgoMSksICcwMSddLFxuICBbJ2Jhc2U4JywgJzcnLCByZmM0NjQ4KDMpLCAnMDEyMzQ1NjcnXSxcbiAgWydiYXNlMTAnLCAnOScsIGJhc2VYLCAnMDEyMzQ1Njc4OSddLFxuICBbJ2Jhc2UxNicsICdmJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlhYmNkZWYnXSxcbiAgWydiYXNlMTZ1cHBlcicsICdGJywgcmZjNDY0OCg0KSwgJzAxMjM0NTY3ODlBQkNERUYnXSxcbiAgWydiYXNlMzJoZXgnLCAndicsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1diddLFxuICBbJ2Jhc2UzMmhleHVwcGVyJywgJ1YnLCByZmM0NjQ4KDUpLCAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVYnXSxcbiAgWydiYXNlMzJoZXhwYWQnLCAndCcsIHJmYzQ2NDgoNSksICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dj0nXSxcbiAgWydiYXNlMzJoZXhwYWR1cHBlcicsICdUJywgcmZjNDY0OCg1KSwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWPSddLFxuICBbJ2Jhc2UzMicsICdiJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3J10sXG4gIFsnYmFzZTMydXBwZXInLCAnQicsIHJmYzQ2NDgoNSksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjIzNDU2NyddLFxuICBbJ2Jhc2UzMnBhZCcsICdjJywgcmZjNDY0OCg1KSwgJ2FiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MjM0NTY3PSddLFxuICBbJ2Jhc2UzMnBhZHVwcGVyJywgJ0MnLCByZmM0NjQ4KDUpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVoyMzQ1Njc9J10sXG4gIFsnYmFzZTMyeicsICdoJywgcmZjNDY0OCg1KSwgJ3libmRyZmc4ZWprbWNwcXhvdDF1d2lzemEzNDVoNzY5J10sXG4gIFsnYmFzZTM2JywgJ2snLCBiYXNlWCwgJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eiddLFxuICBbJ2Jhc2UzNnVwcGVyJywgJ0snLCBiYXNlWCwgJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiddLFxuICBbJ2Jhc2U1OGJ0YycsICd6JywgYmFzZVgsICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J10sXG4gIFsnYmFzZTU4ZmxpY2tyJywgJ1onLCBiYXNlWCwgJzEyMzQ1Njc4OWFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpBQkNERUZHSEpLTE1OUFFSU1RVVldYWVonXSxcbiAgWydiYXNlNjQnLCAnbScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ10sXG4gIFsnYmFzZTY0cGFkJywgJ00nLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nXSxcbiAgWydiYXNlNjR1cmwnLCAndScsIHJmYzQ2NDgoNiksICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OS1fJ10sXG4gIFsnYmFzZTY0dXJscGFkJywgJ1UnLCByZmM0NjQ4KDYpLCAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktXz0nXVxuXVxuXG5jb25zdCBuYW1lcyA9IGNvbnN0YW50cy5yZWR1Y2UoKHByZXYsIHR1cHBsZSkgPT4ge1xuICBwcmV2W3R1cHBsZVswXV0gPSBuZXcgQmFzZSh0dXBwbGVbMF0sIHR1cHBsZVsxXSwgdHVwcGxlWzJdLCB0dXBwbGVbM10pXG4gIHJldHVybiBwcmV2XG59LCB7fSlcblxuY29uc3QgY29kZXMgPSBjb25zdGFudHMucmVkdWNlKChwcmV2LCB0dXBwbGUpID0+IHtcbiAgcHJldlt0dXBwbGVbMV1dID0gbmFtZXNbdHVwcGxlWzBdXVxuICByZXR1cm4gcHJldlxufSwge30pXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBuYW1lcyxcbiAgY29kZXNcbn1cbiIsIi8vIEB0cy1jaGVja1xuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW211bHRpYmFzZV0oaHR0cHM6Ly9naXRodWIuY29tL211bHRpZm9ybWF0cy9tdWx0aWJhc2UpIHNwZWNpZmljYXRpb24uXG4gKlxuICogQG1vZHVsZSBNdWx0aWJhc2VcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3QgY29uc3RhbnRzID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBkZWNvZGVUZXh0LCBhc0J1ZmZlciB9ID0gcmVxdWlyZSgnLi91dGlsJylcblxuLyoqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKFwiLi9iYXNlXCIpfSBCYXNlICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGJ1ZmZlciB3aXRoIHRoZSBtdWx0aWJhc2UgdmFyaW50K2NvZGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBuYW1lT3JDb2RlIC0gVGhlIG11bHRpYmFzZSBuYW1lIG9yIGNvZGUgbnVtYmVyLlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWYgLSBUaGUgZGF0YSB0byBiZSBwcmVmaXhlZCB3aXRoIG11bHRpYmFzZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBtdWx0aWJhc2UgKG5hbWVPckNvZGUsIGJ1Zikge1xuICBpZiAoIWJ1Zikge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVxdWlyZXMgYW4gZW5jb2RlZCBidWZmZXInKVxuICB9XG4gIGNvbnN0IHsgbmFtZSwgY29kZUJ1ZiB9ID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcbiAgdmFsaWRFbmNvZGUobmFtZSwgYnVmKVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhjb2RlQnVmLmxlbmd0aCArIGJ1Zi5sZW5ndGgpXG4gIGJ1ZmZlci5zZXQoY29kZUJ1ZiwgMClcbiAgYnVmZmVyLnNldChidWYsIGNvZGVCdWYubGVuZ3RoKVxuXG4gIHJldHVybiBidWZmZXJcbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIHRoZSBzcGVjaWZpZWQgYmFzZSBhbmQgYWRkIHRoZSBtdWx0aWJhc2UgcHJlZml4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZU9yQ29kZSAtIFRoZSBtdWx0aWJhc2UgbmFtZSBvciBjb2RlIG51bWJlci5cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIC0gVGhlIGRhdGEgdG8gYmUgZW5jb2RlZC5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZW5jb2RlIChuYW1lT3JDb2RlLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZU9yQ29kZSlcblxuICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jLmNvZGVCdWYsIEJ1ZmZlci5mcm9tKGVuYy5lbmNvZGUoYnVmKSldKVxufVxuXG4vKipcbiAqIFRha2VzIGEgVWludDhBcnJheSBvciBzdHJpbmcgZW5jb2RlZCB3aXRoIG11bHRpYmFzZSBoZWFkZXIsIGRlY29kZXMgaXQgYW5kXG4gKiByZXR1cm5zIHRoZSBkZWNvZGVkIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqL1xuZnVuY3Rpb24gZGVjb2RlIChkYXRhKSB7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGFbMF1cblxuICAvLyBNYWtlIGFsbCBlbmNvZGluZ3MgY2FzZS1pbnNlbnNpdGl2ZSBleGNlcHQgdGhlIG9uZXMgdGhhdCBpbmNsdWRlIHVwcGVyIGFuZCBsb3dlciBjaGFycyBpbiB0aGUgYWxwaGFiZXRcbiAgaWYgKFsnZicsICdGJywgJ3YnLCAnVicsICd0JywgJ1QnLCAnYicsICdCJywgJ2MnLCAnQycsICdoJywgJ2snLCAnSyddLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpXG4gIH1cbiAgY29uc3QgZW5jID0gZW5jb2RpbmcoZGF0YVswXSlcbiAgcmV0dXJuIGFzQnVmZmVyKGVuYy5kZWNvZGUoZGF0YS5zdWJzdHJpbmcoMSkpKVxufVxuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBkYXRhIG11bHRpYmFzZSBlbmNvZGVkP1xuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheXxzdHJpbmd9IGRhdGFcbiAqIEByZXR1cm5zIHtmYWxzZXxzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGlzRW5jb2RlZCAoZGF0YSkge1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICBkYXRhID0gZGVjb2RlVGV4dChkYXRhKVxuICB9XG5cbiAgLy8gRW5zdXJlIGJ1Zk9yU3RyaW5nIGlzIGEgc3RyaW5nXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgIT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IGVuYyA9IGVuY29kaW5nKGRhdGFbMF0pXG4gICAgcmV0dXJuIGVuYy5uYW1lXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKlxuICogVmFsaWRhdGUgZW5jb2RlZCBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge0Vycm9yfSBXaWxsIHRocm93IGlmIHRoZSBlbmNvZGluZyBpcyBub3Qgc3VwcG9ydGVkXG4gKi9cbmZ1bmN0aW9uIHZhbGlkRW5jb2RlIChuYW1lLCBidWYpIHtcbiAgY29uc3QgZW5jID0gZW5jb2RpbmcobmFtZSlcbiAgZW5jLmRlY29kZShkZWNvZGVUZXh0KGJ1ZikpXG59XG5cbi8qKlxuICogR2V0IHRoZSBlbmNvZGluZyBieSBuYW1lIG9yIGNvZGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IG5hbWVPckNvZGVcbiAqIEByZXR1cm5zIHtCYXNlfVxuICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgaWYgdGhlIGVuY29kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcbiAqL1xuZnVuY3Rpb24gZW5jb2RpbmcgKG5hbWVPckNvZGUpIHtcbiAgaWYgKGNvbnN0YW50cy5uYW1lc1tuYW1lT3JDb2RlXSkge1xuICAgIHJldHVybiBjb25zdGFudHMubmFtZXNbbmFtZU9yQ29kZV1cbiAgfSBlbHNlIGlmIChjb25zdGFudHMuY29kZXNbbmFtZU9yQ29kZV0pIHtcbiAgICByZXR1cm4gY29uc3RhbnRzLmNvZGVzW25hbWVPckNvZGVdXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBlbmNvZGluZzogJHtuYW1lT3JDb2RlfWApXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgZW5jb2RpbmcgZnJvbSBkYXRhXG4gKlxuICogQHBhcmFtIHtzdHJpbmd8VWludDhBcnJheX0gZGF0YVxuICogQHJldHVybnMge0Jhc2V9XG4gKiBAdGhyb3dzIHtFcnJvcn0gV2lsbCB0aHJvdyBpZiB0aGUgZW5jb2RpbmcgaXMgbm90IHN1cHBvcnRlZFxuICovXG5mdW5jdGlvbiBlbmNvZGluZ0Zyb21EYXRhIChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGRhdGEgPSBkZWNvZGVUZXh0KGRhdGEpXG4gIH1cblxuICByZXR1cm4gZW5jb2RpbmcoZGF0YVswXSlcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbXVsdGliYXNlXG5leHBvcnRzLmVuY29kZSA9IGVuY29kZVxuZXhwb3J0cy5kZWNvZGUgPSBkZWNvZGVcbmV4cG9ydHMuaXNFbmNvZGVkID0gaXNFbmNvZGVkXG5leHBvcnRzLmVuY29kaW5nID0gZW5jb2RpbmdcbmV4cG9ydHMuZW5jb2RpbmdGcm9tRGF0YSA9IGVuY29kaW5nRnJvbURhdGFcbmV4cG9ydHMubmFtZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5uYW1lcylcbmV4cG9ydHMuY29kZXMgPSBPYmplY3QuZnJlZXplKGNvbnN0YW50cy5jb2RlcylcbiIsIi8vIEB0cy1jaGVja1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnLi9iYXNlJykuQ29kZWNGYWN0b3J5fSBDb2RlY0ZhY3RvcnkgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGRlY29kZSA9IChzdHJpbmcsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICAvLyBCdWlsZCB0aGUgY2hhcmFjdGVyIGxvb2t1cCB0YWJsZTpcbiAgY29uc3QgY29kZXMgPSB7fVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgY29kZXNbYWxwaGFiZXRbaV1dID0gaVxuICB9XG5cbiAgLy8gQ291bnQgdGhlIHBhZGRpbmcgYnl0ZXM6XG4gIGxldCBlbmQgPSBzdHJpbmcubGVuZ3RoXG4gIHdoaWxlIChzdHJpbmdbZW5kIC0gMV0gPT09ICc9Jykge1xuICAgIC0tZW5kXG4gIH1cblxuICAvLyBBbGxvY2F0ZSB0aGUgb3V0cHV0OlxuICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSgoZW5kICogYml0c1BlckNoYXIgLyA4KSB8IDApXG5cbiAgLy8gUGFyc2UgdGhlIGRhdGE6XG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBsZXQgd3JpdHRlbiA9IDAgLy8gTmV4dCBieXRlIHRvIHdyaXRlXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZW5kOyArK2kpIHtcbiAgICAvLyBSZWFkIG9uZSBjaGFyYWN0ZXIgZnJvbSB0aGUgc3RyaW5nOlxuICAgIGNvbnN0IHZhbHVlID0gY29kZXNbc3RyaW5nW2ldXVxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ0ludmFsaWQgY2hhcmFjdGVyICcgKyBzdHJpbmdbaV0pXG4gICAgfVxuXG4gICAgLy8gQXBwZW5kIHRoZSBiaXRzIHRvIHRoZSBidWZmZXI6XG4gICAgYnVmZmVyID0gKGJ1ZmZlciA8PCBiaXRzUGVyQ2hhcikgfCB2YWx1ZVxuICAgIGJpdHMgKz0gYml0c1BlckNoYXJcblxuICAgIC8vIFdyaXRlIG91dCBzb21lIGJpdHMgaWYgdGhlIGJ1ZmZlciBoYXMgYSBieXRlJ3Mgd29ydGg6XG4gICAgaWYgKGJpdHMgPj0gOCkge1xuICAgICAgYml0cyAtPSA4XG4gICAgICBvdXRbd3JpdHRlbisrXSA9IDB4ZmYgJiAoYnVmZmVyID4+IGJpdHMpXG4gICAgfVxuICB9XG5cbiAgLy8gVmVyaWZ5IHRoYXQgd2UgaGF2ZSByZWNlaXZlZCBqdXN0IGVub3VnaCBiaXRzOlxuICBpZiAoYml0cyA+PSBiaXRzUGVyQ2hhciB8fCAweGZmICYgKGJ1ZmZlciA8PCAoOCAtIGJpdHMpKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgZGF0YScpXG4gIH1cblxuICByZXR1cm4gb3V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gYWxwaGFiZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRzUGVyQ2hhclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlID0gKGRhdGEsIGFscGhhYmV0LCBiaXRzUGVyQ2hhcikgPT4ge1xuICBjb25zdCBwYWQgPSBhbHBoYWJldFthbHBoYWJldC5sZW5ndGggLSAxXSA9PT0gJz0nXG4gIGNvbnN0IG1hc2sgPSAoMSA8PCBiaXRzUGVyQ2hhcikgLSAxXG4gIGxldCBvdXQgPSAnJ1xuXG4gIGxldCBiaXRzID0gMCAvLyBOdW1iZXIgb2YgYml0cyBjdXJyZW50bHkgaW4gdGhlIGJ1ZmZlclxuICBsZXQgYnVmZmVyID0gMCAvLyBCaXRzIHdhaXRpbmcgdG8gYmUgd3JpdHRlbiBvdXQsIE1TQiBmaXJzdFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBTbHVycCBkYXRhIGludG8gdGhlIGJ1ZmZlcjpcbiAgICBidWZmZXIgPSAoYnVmZmVyIDw8IDgpIHwgZGF0YVtpXVxuICAgIGJpdHMgKz0gOFxuXG4gICAgLy8gV3JpdGUgb3V0IGFzIG11Y2ggYXMgd2UgY2FuOlxuICAgIHdoaWxlIChiaXRzID4gYml0c1BlckNoYXIpIHtcbiAgICAgIGJpdHMgLT0gYml0c1BlckNoYXJcbiAgICAgIG91dCArPSBhbHBoYWJldFttYXNrICYgKGJ1ZmZlciA+PiBiaXRzKV1cbiAgICB9XG4gIH1cblxuICAvLyBQYXJ0aWFsIGNoYXJhY3RlcjpcbiAgaWYgKGJpdHMpIHtcbiAgICBvdXQgKz0gYWxwaGFiZXRbbWFzayAmIChidWZmZXIgPDwgKGJpdHNQZXJDaGFyIC0gYml0cykpXVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmcgY2hhcmFjdGVycyB1bnRpbCB3ZSBoaXQgYSBieXRlIGJvdW5kYXJ5OlxuICBpZiAocGFkKSB7XG4gICAgd2hpbGUgKChvdXQubGVuZ3RoICogYml0c1BlckNoYXIpICYgNykge1xuICAgICAgb3V0ICs9ICc9J1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gYml0c1BlckNoYXJcbiAqIEByZXR1cm5zIHtDb2RlY0ZhY3Rvcnl9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gKGJpdHNQZXJDaGFyKSA9PiAoYWxwaGFiZXQpID0+IHtcbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGlucHV0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBlbmNvZGUgKGlucHV0KSB7XG4gICAgICByZXR1cm4gZW5jb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICAgKi9cbiAgICBkZWNvZGUgKGlucHV0KSB7XG4gICAgICByZXR1cm4gZGVjb2RlKGlucHV0LCBhbHBoYWJldCwgYml0c1BlckNoYXIpXG4gICAgfVxuICB9XG59XG4iLCIvLyBAdHMtY2hlY2tcbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IHsgVGV4dEVuY29kZXIsIFRleHREZWNvZGVyIH0gPSByZXF1aXJlKCd3ZWItZW5jb2RpbmcnKVxuXG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3fEFycmF5QnVmZmVyfSBieXRlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuY29uc3QgZGVjb2RlVGV4dCA9IChieXRlcykgPT4gdGV4dERlY29kZXIuZGVjb2RlKGJ5dGVzKVxuXG5jb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAqL1xuY29uc3QgZW5jb2RlVGV4dCA9ICh0ZXh0KSA9PiB0ZXh0RW5jb2Rlci5lbmNvZGUodGV4dClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyVmlld30gYnl0ZXNcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmNvbnN0IGFzQnVmZmVyID0gKHsgYnVmZmVyLCBieXRlTGVuZ3RoLCBieXRlT2Zmc2V0IH0pID0+XG4gIEJ1ZmZlci5mcm9tKGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aClcblxubW9kdWxlLmV4cG9ydHMgPSB7IGRlY29kZVRleHQsIGVuY29kZVRleHQsIGFzQnVmZmVyIH1cbiIsIi8qIGVzbGludCBxdW90ZS1wcm9wczogb2ZmICovXG4ndXNlIHN0cmljdCdcblxuY29uc3QgbmFtZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2lkZW50aXR5JzogMHgwMCxcbiAgJ3NoYTEnOiAweDExLFxuICAnc2hhMi0yNTYnOiAweDEyLFxuICAnc2hhMi01MTInOiAweDEzLFxuICAnc2hhMy01MTInOiAweDE0LFxuICAnc2hhMy0zODQnOiAweDE1LFxuICAnc2hhMy0yNTYnOiAweDE2LFxuICAnc2hhMy0yMjQnOiAweDE3LFxuICAnc2hha2UtMTI4JzogMHgxOCxcbiAgJ3NoYWtlLTI1Nic6IDB4MTksXG4gICdrZWNjYWstMjI0JzogMHgxYSxcbiAgJ2tlY2Nhay0yNTYnOiAweDFiLFxuICAna2VjY2FrLTM4NCc6IDB4MWMsXG4gICdrZWNjYWstNTEyJzogMHgxZCxcbiAgJ2JsYWtlMyc6IDB4MWUsXG4gICdtdXJtdXIzLTEyOCc6IDB4MjIsXG4gICdtdXJtdXIzLTMyJzogMHgyMyxcbiAgJ2RibC1zaGEyLTI1Nic6IDB4NTYsXG4gICdtZDQnOiAweGQ0LFxuICAnbWQ1JzogMHhkNSxcbiAgJ2JtdCc6IDB4ZDYsXG4gICdzaGEyLTI1Ni10cnVuYzI1NC1wYWRkZWQnOiAweDEwMTIsXG4gICdyaXBlbWQtMTI4JzogMHgxMDUyLFxuICAncmlwZW1kLTE2MCc6IDB4MTA1MyxcbiAgJ3JpcGVtZC0yNTYnOiAweDEwNTQsXG4gICdyaXBlbWQtMzIwJzogMHgxMDU1LFxuICAneDExJzogMHgxMTAwLFxuICAnc20zLTI1Nic6IDB4NTM0ZCxcbiAgJ2JsYWtlMmItOCc6IDB4YjIwMSxcbiAgJ2JsYWtlMmItMTYnOiAweGIyMDIsXG4gICdibGFrZTJiLTI0JzogMHhiMjAzLFxuICAnYmxha2UyYi0zMic6IDB4YjIwNCxcbiAgJ2JsYWtlMmItNDAnOiAweGIyMDUsXG4gICdibGFrZTJiLTQ4JzogMHhiMjA2LFxuICAnYmxha2UyYi01Nic6IDB4YjIwNyxcbiAgJ2JsYWtlMmItNjQnOiAweGIyMDgsXG4gICdibGFrZTJiLTcyJzogMHhiMjA5LFxuICAnYmxha2UyYi04MCc6IDB4YjIwYSxcbiAgJ2JsYWtlMmItODgnOiAweGIyMGIsXG4gICdibGFrZTJiLTk2JzogMHhiMjBjLFxuICAnYmxha2UyYi0xMDQnOiAweGIyMGQsXG4gICdibGFrZTJiLTExMic6IDB4YjIwZSxcbiAgJ2JsYWtlMmItMTIwJzogMHhiMjBmLFxuICAnYmxha2UyYi0xMjgnOiAweGIyMTAsXG4gICdibGFrZTJiLTEzNic6IDB4YjIxMSxcbiAgJ2JsYWtlMmItMTQ0JzogMHhiMjEyLFxuICAnYmxha2UyYi0xNTInOiAweGIyMTMsXG4gICdibGFrZTJiLTE2MCc6IDB4YjIxNCxcbiAgJ2JsYWtlMmItMTY4JzogMHhiMjE1LFxuICAnYmxha2UyYi0xNzYnOiAweGIyMTYsXG4gICdibGFrZTJiLTE4NCc6IDB4YjIxNyxcbiAgJ2JsYWtlMmItMTkyJzogMHhiMjE4LFxuICAnYmxha2UyYi0yMDAnOiAweGIyMTksXG4gICdibGFrZTJiLTIwOCc6IDB4YjIxYSxcbiAgJ2JsYWtlMmItMjE2JzogMHhiMjFiLFxuICAnYmxha2UyYi0yMjQnOiAweGIyMWMsXG4gICdibGFrZTJiLTIzMic6IDB4YjIxZCxcbiAgJ2JsYWtlMmItMjQwJzogMHhiMjFlLFxuICAnYmxha2UyYi0yNDgnOiAweGIyMWYsXG4gICdibGFrZTJiLTI1Nic6IDB4YjIyMCxcbiAgJ2JsYWtlMmItMjY0JzogMHhiMjIxLFxuICAnYmxha2UyYi0yNzInOiAweGIyMjIsXG4gICdibGFrZTJiLTI4MCc6IDB4YjIyMyxcbiAgJ2JsYWtlMmItMjg4JzogMHhiMjI0LFxuICAnYmxha2UyYi0yOTYnOiAweGIyMjUsXG4gICdibGFrZTJiLTMwNCc6IDB4YjIyNixcbiAgJ2JsYWtlMmItMzEyJzogMHhiMjI3LFxuICAnYmxha2UyYi0zMjAnOiAweGIyMjgsXG4gICdibGFrZTJiLTMyOCc6IDB4YjIyOSxcbiAgJ2JsYWtlMmItMzM2JzogMHhiMjJhLFxuICAnYmxha2UyYi0zNDQnOiAweGIyMmIsXG4gICdibGFrZTJiLTM1Mic6IDB4YjIyYyxcbiAgJ2JsYWtlMmItMzYwJzogMHhiMjJkLFxuICAnYmxha2UyYi0zNjgnOiAweGIyMmUsXG4gICdibGFrZTJiLTM3Nic6IDB4YjIyZixcbiAgJ2JsYWtlMmItMzg0JzogMHhiMjMwLFxuICAnYmxha2UyYi0zOTInOiAweGIyMzEsXG4gICdibGFrZTJiLTQwMCc6IDB4YjIzMixcbiAgJ2JsYWtlMmItNDA4JzogMHhiMjMzLFxuICAnYmxha2UyYi00MTYnOiAweGIyMzQsXG4gICdibGFrZTJiLTQyNCc6IDB4YjIzNSxcbiAgJ2JsYWtlMmItNDMyJzogMHhiMjM2LFxuICAnYmxha2UyYi00NDAnOiAweGIyMzcsXG4gICdibGFrZTJiLTQ0OCc6IDB4YjIzOCxcbiAgJ2JsYWtlMmItNDU2JzogMHhiMjM5LFxuICAnYmxha2UyYi00NjQnOiAweGIyM2EsXG4gICdibGFrZTJiLTQ3Mic6IDB4YjIzYixcbiAgJ2JsYWtlMmItNDgwJzogMHhiMjNjLFxuICAnYmxha2UyYi00ODgnOiAweGIyM2QsXG4gICdibGFrZTJiLTQ5Nic6IDB4YjIzZSxcbiAgJ2JsYWtlMmItNTA0JzogMHhiMjNmLFxuICAnYmxha2UyYi01MTInOiAweGIyNDAsXG4gICdibGFrZTJzLTgnOiAweGIyNDEsXG4gICdibGFrZTJzLTE2JzogMHhiMjQyLFxuICAnYmxha2Uycy0yNCc6IDB4YjI0MyxcbiAgJ2JsYWtlMnMtMzInOiAweGIyNDQsXG4gICdibGFrZTJzLTQwJzogMHhiMjQ1LFxuICAnYmxha2Uycy00OCc6IDB4YjI0NixcbiAgJ2JsYWtlMnMtNTYnOiAweGIyNDcsXG4gICdibGFrZTJzLTY0JzogMHhiMjQ4LFxuICAnYmxha2Uycy03Mic6IDB4YjI0OSxcbiAgJ2JsYWtlMnMtODAnOiAweGIyNGEsXG4gICdibGFrZTJzLTg4JzogMHhiMjRiLFxuICAnYmxha2Uycy05Nic6IDB4YjI0YyxcbiAgJ2JsYWtlMnMtMTA0JzogMHhiMjRkLFxuICAnYmxha2Uycy0xMTInOiAweGIyNGUsXG4gICdibGFrZTJzLTEyMCc6IDB4YjI0ZixcbiAgJ2JsYWtlMnMtMTI4JzogMHhiMjUwLFxuICAnYmxha2Uycy0xMzYnOiAweGIyNTEsXG4gICdibGFrZTJzLTE0NCc6IDB4YjI1MixcbiAgJ2JsYWtlMnMtMTUyJzogMHhiMjUzLFxuICAnYmxha2Uycy0xNjAnOiAweGIyNTQsXG4gICdibGFrZTJzLTE2OCc6IDB4YjI1NSxcbiAgJ2JsYWtlMnMtMTc2JzogMHhiMjU2LFxuICAnYmxha2Uycy0xODQnOiAweGIyNTcsXG4gICdibGFrZTJzLTE5Mic6IDB4YjI1OCxcbiAgJ2JsYWtlMnMtMjAwJzogMHhiMjU5LFxuICAnYmxha2Uycy0yMDgnOiAweGIyNWEsXG4gICdibGFrZTJzLTIxNic6IDB4YjI1YixcbiAgJ2JsYWtlMnMtMjI0JzogMHhiMjVjLFxuICAnYmxha2Uycy0yMzInOiAweGIyNWQsXG4gICdibGFrZTJzLTI0MCc6IDB4YjI1ZSxcbiAgJ2JsYWtlMnMtMjQ4JzogMHhiMjVmLFxuICAnYmxha2Uycy0yNTYnOiAweGIyNjAsXG4gICdza2VpbjI1Ni04JzogMHhiMzAxLFxuICAnc2tlaW4yNTYtMTYnOiAweGIzMDIsXG4gICdza2VpbjI1Ni0yNCc6IDB4YjMwMyxcbiAgJ3NrZWluMjU2LTMyJzogMHhiMzA0LFxuICAnc2tlaW4yNTYtNDAnOiAweGIzMDUsXG4gICdza2VpbjI1Ni00OCc6IDB4YjMwNixcbiAgJ3NrZWluMjU2LTU2JzogMHhiMzA3LFxuICAnc2tlaW4yNTYtNjQnOiAweGIzMDgsXG4gICdza2VpbjI1Ni03Mic6IDB4YjMwOSxcbiAgJ3NrZWluMjU2LTgwJzogMHhiMzBhLFxuICAnc2tlaW4yNTYtODgnOiAweGIzMGIsXG4gICdza2VpbjI1Ni05Nic6IDB4YjMwYyxcbiAgJ3NrZWluMjU2LTEwNCc6IDB4YjMwZCxcbiAgJ3NrZWluMjU2LTExMic6IDB4YjMwZSxcbiAgJ3NrZWluMjU2LTEyMCc6IDB4YjMwZixcbiAgJ3NrZWluMjU2LTEyOCc6IDB4YjMxMCxcbiAgJ3NrZWluMjU2LTEzNic6IDB4YjMxMSxcbiAgJ3NrZWluMjU2LTE0NCc6IDB4YjMxMixcbiAgJ3NrZWluMjU2LTE1Mic6IDB4YjMxMyxcbiAgJ3NrZWluMjU2LTE2MCc6IDB4YjMxNCxcbiAgJ3NrZWluMjU2LTE2OCc6IDB4YjMxNSxcbiAgJ3NrZWluMjU2LTE3Nic6IDB4YjMxNixcbiAgJ3NrZWluMjU2LTE4NCc6IDB4YjMxNyxcbiAgJ3NrZWluMjU2LTE5Mic6IDB4YjMxOCxcbiAgJ3NrZWluMjU2LTIwMCc6IDB4YjMxOSxcbiAgJ3NrZWluMjU2LTIwOCc6IDB4YjMxYSxcbiAgJ3NrZWluMjU2LTIxNic6IDB4YjMxYixcbiAgJ3NrZWluMjU2LTIyNCc6IDB4YjMxYyxcbiAgJ3NrZWluMjU2LTIzMic6IDB4YjMxZCxcbiAgJ3NrZWluMjU2LTI0MCc6IDB4YjMxZSxcbiAgJ3NrZWluMjU2LTI0OCc6IDB4YjMxZixcbiAgJ3NrZWluMjU2LTI1Nic6IDB4YjMyMCxcbiAgJ3NrZWluNTEyLTgnOiAweGIzMjEsXG4gICdza2VpbjUxMi0xNic6IDB4YjMyMixcbiAgJ3NrZWluNTEyLTI0JzogMHhiMzIzLFxuICAnc2tlaW41MTItMzInOiAweGIzMjQsXG4gICdza2VpbjUxMi00MCc6IDB4YjMyNSxcbiAgJ3NrZWluNTEyLTQ4JzogMHhiMzI2LFxuICAnc2tlaW41MTItNTYnOiAweGIzMjcsXG4gICdza2VpbjUxMi02NCc6IDB4YjMyOCxcbiAgJ3NrZWluNTEyLTcyJzogMHhiMzI5LFxuICAnc2tlaW41MTItODAnOiAweGIzMmEsXG4gICdza2VpbjUxMi04OCc6IDB4YjMyYixcbiAgJ3NrZWluNTEyLTk2JzogMHhiMzJjLFxuICAnc2tlaW41MTItMTA0JzogMHhiMzJkLFxuICAnc2tlaW41MTItMTEyJzogMHhiMzJlLFxuICAnc2tlaW41MTItMTIwJzogMHhiMzJmLFxuICAnc2tlaW41MTItMTI4JzogMHhiMzMwLFxuICAnc2tlaW41MTItMTM2JzogMHhiMzMxLFxuICAnc2tlaW41MTItMTQ0JzogMHhiMzMyLFxuICAnc2tlaW41MTItMTUyJzogMHhiMzMzLFxuICAnc2tlaW41MTItMTYwJzogMHhiMzM0LFxuICAnc2tlaW41MTItMTY4JzogMHhiMzM1LFxuICAnc2tlaW41MTItMTc2JzogMHhiMzM2LFxuICAnc2tlaW41MTItMTg0JzogMHhiMzM3LFxuICAnc2tlaW41MTItMTkyJzogMHhiMzM4LFxuICAnc2tlaW41MTItMjAwJzogMHhiMzM5LFxuICAnc2tlaW41MTItMjA4JzogMHhiMzNhLFxuICAnc2tlaW41MTItMjE2JzogMHhiMzNiLFxuICAnc2tlaW41MTItMjI0JzogMHhiMzNjLFxuICAnc2tlaW41MTItMjMyJzogMHhiMzNkLFxuICAnc2tlaW41MTItMjQwJzogMHhiMzNlLFxuICAnc2tlaW41MTItMjQ4JzogMHhiMzNmLFxuICAnc2tlaW41MTItMjU2JzogMHhiMzQwLFxuICAnc2tlaW41MTItMjY0JzogMHhiMzQxLFxuICAnc2tlaW41MTItMjcyJzogMHhiMzQyLFxuICAnc2tlaW41MTItMjgwJzogMHhiMzQzLFxuICAnc2tlaW41MTItMjg4JzogMHhiMzQ0LFxuICAnc2tlaW41MTItMjk2JzogMHhiMzQ1LFxuICAnc2tlaW41MTItMzA0JzogMHhiMzQ2LFxuICAnc2tlaW41MTItMzEyJzogMHhiMzQ3LFxuICAnc2tlaW41MTItMzIwJzogMHhiMzQ4LFxuICAnc2tlaW41MTItMzI4JzogMHhiMzQ5LFxuICAnc2tlaW41MTItMzM2JzogMHhiMzRhLFxuICAnc2tlaW41MTItMzQ0JzogMHhiMzRiLFxuICAnc2tlaW41MTItMzUyJzogMHhiMzRjLFxuICAnc2tlaW41MTItMzYwJzogMHhiMzRkLFxuICAnc2tlaW41MTItMzY4JzogMHhiMzRlLFxuICAnc2tlaW41MTItMzc2JzogMHhiMzRmLFxuICAnc2tlaW41MTItMzg0JzogMHhiMzUwLFxuICAnc2tlaW41MTItMzkyJzogMHhiMzUxLFxuICAnc2tlaW41MTItNDAwJzogMHhiMzUyLFxuICAnc2tlaW41MTItNDA4JzogMHhiMzUzLFxuICAnc2tlaW41MTItNDE2JzogMHhiMzU0LFxuICAnc2tlaW41MTItNDI0JzogMHhiMzU1LFxuICAnc2tlaW41MTItNDMyJzogMHhiMzU2LFxuICAnc2tlaW41MTItNDQwJzogMHhiMzU3LFxuICAnc2tlaW41MTItNDQ4JzogMHhiMzU4LFxuICAnc2tlaW41MTItNDU2JzogMHhiMzU5LFxuICAnc2tlaW41MTItNDY0JzogMHhiMzVhLFxuICAnc2tlaW41MTItNDcyJzogMHhiMzViLFxuICAnc2tlaW41MTItNDgwJzogMHhiMzVjLFxuICAnc2tlaW41MTItNDg4JzogMHhiMzVkLFxuICAnc2tlaW41MTItNDk2JzogMHhiMzVlLFxuICAnc2tlaW41MTItNTA0JzogMHhiMzVmLFxuICAnc2tlaW41MTItNTEyJzogMHhiMzYwLFxuICAnc2tlaW4xMDI0LTgnOiAweGIzNjEsXG4gICdza2VpbjEwMjQtMTYnOiAweGIzNjIsXG4gICdza2VpbjEwMjQtMjQnOiAweGIzNjMsXG4gICdza2VpbjEwMjQtMzInOiAweGIzNjQsXG4gICdza2VpbjEwMjQtNDAnOiAweGIzNjUsXG4gICdza2VpbjEwMjQtNDgnOiAweGIzNjYsXG4gICdza2VpbjEwMjQtNTYnOiAweGIzNjcsXG4gICdza2VpbjEwMjQtNjQnOiAweGIzNjgsXG4gICdza2VpbjEwMjQtNzInOiAweGIzNjksXG4gICdza2VpbjEwMjQtODAnOiAweGIzNmEsXG4gICdza2VpbjEwMjQtODgnOiAweGIzNmIsXG4gICdza2VpbjEwMjQtOTYnOiAweGIzNmMsXG4gICdza2VpbjEwMjQtMTA0JzogMHhiMzZkLFxuICAnc2tlaW4xMDI0LTExMic6IDB4YjM2ZSxcbiAgJ3NrZWluMTAyNC0xMjAnOiAweGIzNmYsXG4gICdza2VpbjEwMjQtMTI4JzogMHhiMzcwLFxuICAnc2tlaW4xMDI0LTEzNic6IDB4YjM3MSxcbiAgJ3NrZWluMTAyNC0xNDQnOiAweGIzNzIsXG4gICdza2VpbjEwMjQtMTUyJzogMHhiMzczLFxuICAnc2tlaW4xMDI0LTE2MCc6IDB4YjM3NCxcbiAgJ3NrZWluMTAyNC0xNjgnOiAweGIzNzUsXG4gICdza2VpbjEwMjQtMTc2JzogMHhiMzc2LFxuICAnc2tlaW4xMDI0LTE4NCc6IDB4YjM3NyxcbiAgJ3NrZWluMTAyNC0xOTInOiAweGIzNzgsXG4gICdza2VpbjEwMjQtMjAwJzogMHhiMzc5LFxuICAnc2tlaW4xMDI0LTIwOCc6IDB4YjM3YSxcbiAgJ3NrZWluMTAyNC0yMTYnOiAweGIzN2IsXG4gICdza2VpbjEwMjQtMjI0JzogMHhiMzdjLFxuICAnc2tlaW4xMDI0LTIzMic6IDB4YjM3ZCxcbiAgJ3NrZWluMTAyNC0yNDAnOiAweGIzN2UsXG4gICdza2VpbjEwMjQtMjQ4JzogMHhiMzdmLFxuICAnc2tlaW4xMDI0LTI1Nic6IDB4YjM4MCxcbiAgJ3NrZWluMTAyNC0yNjQnOiAweGIzODEsXG4gICdza2VpbjEwMjQtMjcyJzogMHhiMzgyLFxuICAnc2tlaW4xMDI0LTI4MCc6IDB4YjM4MyxcbiAgJ3NrZWluMTAyNC0yODgnOiAweGIzODQsXG4gICdza2VpbjEwMjQtMjk2JzogMHhiMzg1LFxuICAnc2tlaW4xMDI0LTMwNCc6IDB4YjM4NixcbiAgJ3NrZWluMTAyNC0zMTInOiAweGIzODcsXG4gICdza2VpbjEwMjQtMzIwJzogMHhiMzg4LFxuICAnc2tlaW4xMDI0LTMyOCc6IDB4YjM4OSxcbiAgJ3NrZWluMTAyNC0zMzYnOiAweGIzOGEsXG4gICdza2VpbjEwMjQtMzQ0JzogMHhiMzhiLFxuICAnc2tlaW4xMDI0LTM1Mic6IDB4YjM4YyxcbiAgJ3NrZWluMTAyNC0zNjAnOiAweGIzOGQsXG4gICdza2VpbjEwMjQtMzY4JzogMHhiMzhlLFxuICAnc2tlaW4xMDI0LTM3Nic6IDB4YjM4ZixcbiAgJ3NrZWluMTAyNC0zODQnOiAweGIzOTAsXG4gICdza2VpbjEwMjQtMzkyJzogMHhiMzkxLFxuICAnc2tlaW4xMDI0LTQwMCc6IDB4YjM5MixcbiAgJ3NrZWluMTAyNC00MDgnOiAweGIzOTMsXG4gICdza2VpbjEwMjQtNDE2JzogMHhiMzk0LFxuICAnc2tlaW4xMDI0LTQyNCc6IDB4YjM5NSxcbiAgJ3NrZWluMTAyNC00MzInOiAweGIzOTYsXG4gICdza2VpbjEwMjQtNDQwJzogMHhiMzk3LFxuICAnc2tlaW4xMDI0LTQ0OCc6IDB4YjM5OCxcbiAgJ3NrZWluMTAyNC00NTYnOiAweGIzOTksXG4gICdza2VpbjEwMjQtNDY0JzogMHhiMzlhLFxuICAnc2tlaW4xMDI0LTQ3Mic6IDB4YjM5YixcbiAgJ3NrZWluMTAyNC00ODAnOiAweGIzOWMsXG4gICdza2VpbjEwMjQtNDg4JzogMHhiMzlkLFxuICAnc2tlaW4xMDI0LTQ5Nic6IDB4YjM5ZSxcbiAgJ3NrZWluMTAyNC01MDQnOiAweGIzOWYsXG4gICdza2VpbjEwMjQtNTEyJzogMHhiM2EwLFxuICAnc2tlaW4xMDI0LTUyMCc6IDB4YjNhMSxcbiAgJ3NrZWluMTAyNC01MjgnOiAweGIzYTIsXG4gICdza2VpbjEwMjQtNTM2JzogMHhiM2EzLFxuICAnc2tlaW4xMDI0LTU0NCc6IDB4YjNhNCxcbiAgJ3NrZWluMTAyNC01NTInOiAweGIzYTUsXG4gICdza2VpbjEwMjQtNTYwJzogMHhiM2E2LFxuICAnc2tlaW4xMDI0LTU2OCc6IDB4YjNhNyxcbiAgJ3NrZWluMTAyNC01NzYnOiAweGIzYTgsXG4gICdza2VpbjEwMjQtNTg0JzogMHhiM2E5LFxuICAnc2tlaW4xMDI0LTU5Mic6IDB4YjNhYSxcbiAgJ3NrZWluMTAyNC02MDAnOiAweGIzYWIsXG4gICdza2VpbjEwMjQtNjA4JzogMHhiM2FjLFxuICAnc2tlaW4xMDI0LTYxNic6IDB4YjNhZCxcbiAgJ3NrZWluMTAyNC02MjQnOiAweGIzYWUsXG4gICdza2VpbjEwMjQtNjMyJzogMHhiM2FmLFxuICAnc2tlaW4xMDI0LTY0MCc6IDB4YjNiMCxcbiAgJ3NrZWluMTAyNC02NDgnOiAweGIzYjEsXG4gICdza2VpbjEwMjQtNjU2JzogMHhiM2IyLFxuICAnc2tlaW4xMDI0LTY2NCc6IDB4YjNiMyxcbiAgJ3NrZWluMTAyNC02NzInOiAweGIzYjQsXG4gICdza2VpbjEwMjQtNjgwJzogMHhiM2I1LFxuICAnc2tlaW4xMDI0LTY4OCc6IDB4YjNiNixcbiAgJ3NrZWluMTAyNC02OTYnOiAweGIzYjcsXG4gICdza2VpbjEwMjQtNzA0JzogMHhiM2I4LFxuICAnc2tlaW4xMDI0LTcxMic6IDB4YjNiOSxcbiAgJ3NrZWluMTAyNC03MjAnOiAweGIzYmEsXG4gICdza2VpbjEwMjQtNzI4JzogMHhiM2JiLFxuICAnc2tlaW4xMDI0LTczNic6IDB4YjNiYyxcbiAgJ3NrZWluMTAyNC03NDQnOiAweGIzYmQsXG4gICdza2VpbjEwMjQtNzUyJzogMHhiM2JlLFxuICAnc2tlaW4xMDI0LTc2MCc6IDB4YjNiZixcbiAgJ3NrZWluMTAyNC03NjgnOiAweGIzYzAsXG4gICdza2VpbjEwMjQtNzc2JzogMHhiM2MxLFxuICAnc2tlaW4xMDI0LTc4NCc6IDB4YjNjMixcbiAgJ3NrZWluMTAyNC03OTInOiAweGIzYzMsXG4gICdza2VpbjEwMjQtODAwJzogMHhiM2M0LFxuICAnc2tlaW4xMDI0LTgwOCc6IDB4YjNjNSxcbiAgJ3NrZWluMTAyNC04MTYnOiAweGIzYzYsXG4gICdza2VpbjEwMjQtODI0JzogMHhiM2M3LFxuICAnc2tlaW4xMDI0LTgzMic6IDB4YjNjOCxcbiAgJ3NrZWluMTAyNC04NDAnOiAweGIzYzksXG4gICdza2VpbjEwMjQtODQ4JzogMHhiM2NhLFxuICAnc2tlaW4xMDI0LTg1Nic6IDB4YjNjYixcbiAgJ3NrZWluMTAyNC04NjQnOiAweGIzY2MsXG4gICdza2VpbjEwMjQtODcyJzogMHhiM2NkLFxuICAnc2tlaW4xMDI0LTg4MCc6IDB4YjNjZSxcbiAgJ3NrZWluMTAyNC04ODgnOiAweGIzY2YsXG4gICdza2VpbjEwMjQtODk2JzogMHhiM2QwLFxuICAnc2tlaW4xMDI0LTkwNCc6IDB4YjNkMSxcbiAgJ3NrZWluMTAyNC05MTInOiAweGIzZDIsXG4gICdza2VpbjEwMjQtOTIwJzogMHhiM2QzLFxuICAnc2tlaW4xMDI0LTkyOCc6IDB4YjNkNCxcbiAgJ3NrZWluMTAyNC05MzYnOiAweGIzZDUsXG4gICdza2VpbjEwMjQtOTQ0JzogMHhiM2Q2LFxuICAnc2tlaW4xMDI0LTk1Mic6IDB4YjNkNyxcbiAgJ3NrZWluMTAyNC05NjAnOiAweGIzZDgsXG4gICdza2VpbjEwMjQtOTY4JzogMHhiM2Q5LFxuICAnc2tlaW4xMDI0LTk3Nic6IDB4YjNkYSxcbiAgJ3NrZWluMTAyNC05ODQnOiAweGIzZGIsXG4gICdza2VpbjEwMjQtOTkyJzogMHhiM2RjLFxuICAnc2tlaW4xMDI0LTEwMDAnOiAweGIzZGQsXG4gICdza2VpbjEwMjQtMTAwOCc6IDB4YjNkZSxcbiAgJ3NrZWluMTAyNC0xMDE2JzogMHhiM2RmLFxuICAnc2tlaW4xMDI0LTEwMjQnOiAweGIzZTAsXG4gICdwb3NlaWRvbi1ibHMxMl8zODEtYTItZmMxJzogMHhiNDAxLFxuICAncG9zZWlkb24tYmxzMTJfMzgxLWEyLWZjMS1zYyc6IDB4YjQwMlxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7IG5hbWVzIH1cbiIsIi8vIEB0cy1jaGVja1xuLyogZXNsaW50LWRpc2FibGUgZ3VhcmQtZm9yLWluICovXG4vKipcbiAqIE11bHRpaGFzaCBpbXBsZW1lbnRhdGlvbiBpbiBKYXZhU2NyaXB0LlxuICpcbiAqIEBtb2R1bGUgbXVsdGloYXNoXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IEJ1ZmZlciB9ID0gcmVxdWlyZSgnYnVmZmVyJylcbmNvbnN0IG11bHRpYmFzZSA9IHJlcXVpcmUoJ211bHRpYmFzZScpXG5jb25zdCB2YXJpbnQgPSByZXF1aXJlKCd2YXJpbnQnKVxuY29uc3QgeyBuYW1lcyB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKVxuY29uc3QgeyBUZXh0RGVjb2RlciB9ID0gcmVxdWlyZSgnd2ViLWVuY29kaW5nJylcblxuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKVxuY29uc3QgY29kZXMgPSB7fVxuXG5mb3IgKGNvbnN0IGtleSBpbiBuYW1lcykge1xuICBjb2Rlc1tuYW1lc1trZXldXSA9IGtleVxufVxuZXhwb3J0cy5uYW1lcyA9IG5hbWVzXG5leHBvcnRzLmNvZGVzID0gT2JqZWN0LmZyZWV6ZShjb2RlcylcblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBtdWx0aWhhc2ggdG8gYSBoZXggZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBoYXNoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gdG9IZXhTdHJpbmcgKGhhc2gpIHtcbiAgaWYgKCEoaGFzaCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdXN0IGJlIHBhc3NlZCBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyKGhhc2gpXG4gICAgPyBoYXNoXG4gICAgOiBCdWZmZXIuZnJvbShoYXNoLmJ1ZmZlciwgaGFzaC5ieXRlT2Zmc2V0LCBoYXNoLmJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygnaGV4Jylcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBoZXggZW5jb2RlZCBzdHJpbmcgdG8gYSBtdWx0aWhhc2guXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhhc2hcbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZnJvbUhleFN0cmluZyA9IGZ1bmN0aW9uIGZyb21IZXhTdHJpbmcgKGhhc2gpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGhhc2gsICdoZXgnKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIG11bHRpaGFzaCB0byBhIGJhc2U1OCBlbmNvZGVkIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGhhc2hcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9CNThTdHJpbmcgPSBmdW5jdGlvbiB0b0I1OFN0cmluZyAoaGFzaCkge1xuICBpZiAoIShoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211c3QgYmUgcGFzc2VkIGEgVWludDhBcnJheScpXG4gIH1cblxuICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKG11bHRpYmFzZS5lbmNvZGUoJ2Jhc2U1OGJ0YycsIGhhc2gpKS5zbGljZSgxKVxufVxuXG4vKipcbiAqIENvbnZlcnQgdGhlIGdpdmVuIGJhc2U1OCBlbmNvZGVkIHN0cmluZyB0byBhIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ3xVaW50OEFycmF5fSBoYXNoXG4gKiBAcmV0dXJucyB7QnVmZmVyfVxuICovXG5leHBvcnRzLmZyb21CNThTdHJpbmcgPSBmdW5jdGlvbiBmcm9tQjU4U3RyaW5nIChoYXNoKSB7XG4gIGNvbnN0IGVuY29kZWQgPSBoYXNoIGluc3RhbmNlb2YgVWludDhBcnJheVxuICAgID8gdGV4dERlY29kZXIuZGVjb2RlKGhhc2gpXG4gICAgOiBoYXNoXG5cbiAgcmV0dXJuIG11bHRpYmFzZS5kZWNvZGUoJ3onICsgZW5jb2RlZClcbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBoYXNoIGZyb20gdGhlIGdpdmVuIG11bHRpaGFzaC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcmV0dXJucyB7e2NvZGU6IG51bWJlciwgbmFtZTogc3RyaW5nLCBsZW5ndGg6IG51bWJlciwgZGlnZXN0OiBCdWZmZXJ9fSByZXN1bHRcbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiBkZWNvZGUgKGJ5dGVzKSB7XG4gIGlmICghKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBtdXN0IGJlIGEgVWludDhBcnJheScpXG4gIH1cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5pc0J1ZmZlcihieXRlcylcbiAgICA/IGJ5dGVzXG4gICAgOiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpXG5cbiAgaWYgKGJ1Zi5sZW5ndGggPCAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdtdWx0aWhhc2ggdG9vIHNob3J0LiBtdXN0IGJlID4gMiBieXRlcy4nKVxuICB9XG5cbiAgY29uc3QgY29kZSA9IHZhcmludC5kZWNvZGUoYnVmKVxuICBpZiAoIWV4cG9ydHMuaXNWYWxpZENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCB1bmtub3duIGZ1bmN0aW9uIGNvZGU6IDB4JHtjb2RlLnRvU3RyaW5nKDE2KX1gKVxuICB9XG4gIGJ1ZiA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGNvbnN0IGxlbiA9IHZhcmludC5kZWNvZGUoYnVmKVxuICBpZiAobGVuIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgbXVsdGloYXNoIGludmFsaWQgbGVuZ3RoOiAke2xlbn1gKVxuICB9XG4gIGJ1ZiA9IGJ1Zi5zbGljZSh2YXJpbnQuZGVjb2RlLmJ5dGVzKVxuXG4gIGlmIChidWYubGVuZ3RoICE9PSBsZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYG11bHRpaGFzaCBsZW5ndGggaW5jb25zaXN0ZW50OiAweCR7YnVmLnRvU3RyaW5nKCdoZXgnKX1gKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb2RlLFxuICAgIG5hbWU6IGNvZGVzW2NvZGVdLFxuICAgIGxlbmd0aDogbGVuLFxuICAgIGRpZ2VzdDogYnVmXG4gIH1cbn1cblxuLyoqXG4gKiAgRW5jb2RlIGEgaGFzaCBkaWdlc3QgYWxvbmcgd2l0aCB0aGUgc3BlY2lmaWVkIGZ1bmN0aW9uIGNvZGUuXG4gKlxuICogPiAqKk5vdGU6KiogdGhlIGxlbmd0aCBpcyBkZXJpdmVkIGZyb20gdGhlIGxlbmd0aCBvZiB0aGUgZGlnZXN0IGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRpZ2VzdFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBjb2RlXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqIEByZXR1cm5zIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlIChkaWdlc3QsIGNvZGUsIGxlbmd0aCkge1xuICBpZiAoIWRpZ2VzdCB8fCBjb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpaGFzaCBlbmNvZGUgcmVxdWlyZXMgYXQgbGVhc3QgdHdvIGFyZ3M6IGRpZ2VzdCwgY29kZScpXG4gIH1cblxuICAvLyBlbnN1cmUgaXQncyBhIGhhc2hmdW5jdGlvbiBjb2RlLlxuICBjb25zdCBoYXNoZm4gPSBleHBvcnRzLmNvZXJjZUNvZGUoY29kZSlcblxuICBpZiAoIShkaWdlc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0IHNob3VsZCBiZSBhIFVpbnQ4QXJyYXknKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA9PSBudWxsKSB7XG4gICAgbGVuZ3RoID0gZGlnZXN0Lmxlbmd0aFxuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiBkaWdlc3QubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2RpZ2VzdCBsZW5ndGggc2hvdWxkIGJlIGVxdWFsIHRvIHNwZWNpZmllZCBsZW5ndGguJylcbiAgfVxuXG4gIGNvbnN0IGhhc2ggPSB2YXJpbnQuZW5jb2RlKGhhc2hmbilcbiAgY29uc3QgbGVuID0gdmFyaW50LmVuY29kZShsZW5ndGgpXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhoYXNoLmxlbmd0aCArIGxlbi5sZW5ndGggKyBkaWdlc3QubGVuZ3RoKVxuICBidWZmZXIuc2V0KGhhc2gsIDApXG4gIGJ1ZmZlci5zZXQobGVuLCBoYXNoLmxlbmd0aClcbiAgYnVmZmVyLnNldChkaWdlc3QsIGhhc2gubGVuZ3RoICsgbGVuLmxlbmd0aClcbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgaGFzaCBmdW5jdGlvbiBuYW1lIGludG8gdGhlIG1hdGNoaW5nIGNvZGUuXG4gKiBJZiBwYXNzZWQgYSBudW1iZXIgaXQgd2lsbCByZXR1cm4gdGhlIG51bWJlciBpZiBpdCdzIGEgdmFsaWQgY29kZS5cbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gbmFtZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5jb2VyY2VDb2RlID0gZnVuY3Rpb24gY29lcmNlQ29kZSAobmFtZSkge1xuICBsZXQgY29kZSA9IG5hbWVcblxuICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKG5hbWVzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGhhc2ggZnVuY3Rpb24gbmFtZWQ6ICR7bmFtZX1gKVxuICAgIH1cbiAgICBjb2RlID0gbmFtZXNbbmFtZV1cbiAgfVxuXG4gIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEhhc2ggZnVuY3Rpb24gY29kZSBzaG91bGQgYmUgYSBudW1iZXIuIEdvdDogJHtjb2RlfWApXG4gIH1cblxuICBpZiAoY29kZXNbY29kZV0gPT09IHVuZGVmaW5lZCAmJiAhZXhwb3J0cy5pc0FwcENvZGUoY29kZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBmdW5jdGlvbiBjb2RlOiAke2NvZGV9YClcbiAgfVxuXG4gIHJldHVybiBjb2RlXG59XG5cbi8qKlxuICogQ2hlY2tzIHdldGhlciBhIGNvZGUgaXMgcGFydCBvZiB0aGUgYXBwIHJhbmdlXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzQXBwQ29kZSA9IGZ1bmN0aW9uIGFwcENvZGUgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPiAwICYmIGNvZGUgPCAweDEwXG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgYSBtdWx0aWhhc2ggY29kZSBpcyB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY29kZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENvZGUgPSBmdW5jdGlvbiB2YWxpZENvZGUgKGNvZGUpIHtcbiAgaWYgKGV4cG9ydHMuaXNBcHBDb2RlKGNvZGUpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGlmIChjb2Rlc1tjb2RlXSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gYnVmZmVyIGlzIGEgdmFsaWQgbXVsdGloYXNoLiBUaHJvd3MgYW4gZXJyb3IgaWYgaXQgaXMgbm90IHZhbGlkLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gbXVsdGloYXNoXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZSAobXVsdGloYXNoKSB7XG4gIGV4cG9ydHMuZGVjb2RlKG11bHRpaGFzaCkgLy8gdGhyb3dzIGlmIGJhZC5cbn1cbmV4cG9ydHMudmFsaWRhdGUgPSB2YWxpZGF0ZVxuXG4vKipcbiAqIFJldHVybnMgYSBwcmVmaXggZnJvbSBhIHZhbGlkIG11bHRpaGFzaC4gVGhyb3dzIGFuIGVycm9yIGlmIGl0IGlzIG5vdCB2YWxpZC5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IG11bHRpaGFzaFxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICovXG5leHBvcnRzLnByZWZpeCA9IGZ1bmN0aW9uIHByZWZpeCAobXVsdGloYXNoKSB7XG4gIHZhbGlkYXRlKG11bHRpaGFzaClcblxuICByZXR1cm4gQnVmZmVyLmZyb20obXVsdGloYXNoLmJ1ZmZlciwgbXVsdGloYXNoLmJ5dGVPZmZzZXQsIDIpXG59XG4iLCIvLyBUaGlzIGZpbGUgcmVwbGFjZXMgYGluZGV4LmpzYCBpbiBidW5kbGVycyBsaWtlIHdlYnBhY2sgb3IgUm9sbHVwLFxuLy8gYWNjb3JkaW5nIHRvIGBicm93c2VyYCBjb25maWcgaW4gYHBhY2thZ2UuanNvbmAuXG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBBbGwgYnVuZGxlcnMgd2lsbCByZW1vdmUgdGhpcyBibG9jayBpbiBwcm9kdWN0aW9uIGJ1bmRsZVxuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnUmVhY3QgTmF0aXZlIGRvZXMgbm90IGhhdmUgYSBidWlsdC1pbiBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgYG5hbm9pZC9ub24tc2VjdXJlYC4gJyArXG4gICAgICAnRm9yIHNlY3VyZSBJRCBpbnN0YWxsIGBleHBvLXJhbmRvbWAgbG9jYWxseSBhbmQgdXNlIGBuYW5vaWQvYXN5bmNgLidcbiAgICApXG4gIH1cbiAgaWYgKHR5cGVvZiBzZWxmID09PSAndW5kZWZpbmVkJyB8fCAoIXNlbGYuY3J5cHRvICYmICFzZWxmLm1zQ3J5cHRvKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdZb3VyIGJyb3dzZXIgZG9lcyBub3QgaGF2ZSBzZWN1cmUgcmFuZG9tIGdlbmVyYXRvci4gJyArXG4gICAgICAnSWYgeW91IGRvbuKAmXQgbmVlZCB1bnByZWRpY3RhYmxlIElEcywgeW91IGNhbiB1c2UgbmFub2lkL25vbi1zZWN1cmUuJ1xuICAgIClcbiAgfVxufVxuXG52YXIgY3J5cHRvID0gc2VsZi5jcnlwdG8gfHwgc2VsZi5tc0NyeXB0b1xuXG4vLyBUaGlzIGFscGhhYmV0IHVzZXMgYS16IEEtWiAwLTkgXy0gc3ltYm9scy5cbi8vIFN5bWJvbHMgYXJlIGdlbmVyYXRlZCBmb3Igc21hbGxlciBzaXplLlxuLy8gLV96eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYTk4NzY1NDMyMTBaWVhXVlVUU1JRUE9OTUxLSklIR0ZFRENCQVxudmFyIHVybCA9ICctXydcbi8vIExvb3AgZnJvbSAzNiB0byAwIChmcm9tIHogdG8gYSBhbmQgOSB0byAwIGluIEJhc2UzNikuXG52YXIgaSA9IDM2XG53aGlsZSAoaS0tKSB7XG4gIC8vIDM2IGlzIHJhZGl4LiBOdW1iZXIucHJvdG90eXBlLnRvU3RyaW5nKDM2KSByZXR1cm5zIG51bWJlclxuICAvLyBpbiBCYXNlMzYgcmVwcmVzZW50YXRpb24uIEJhc2UzNiBpcyBsaWtlIGhleCwgYnV0IGl0IHVzZXMgMOKAkzkgYW5kIGEtei5cbiAgdXJsICs9IGkudG9TdHJpbmcoMzYpXG59XG4vLyBMb29wIGZyb20gMzYgdG8gMTAgKGZyb20gWiB0byBBIGluIEJhc2UzNikuXG5pID0gMzZcbndoaWxlIChpLS0gLSAxMCkge1xuICB1cmwgKz0gaS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHZhciBpZCA9ICcnXG4gIHZhciBieXRlcyA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSB8fCAyMSkpXG4gIGkgPSBzaXplIHx8IDIxXG5cbiAgLy8gQ29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKWBcbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIFdlIGNhbuKAmXQgdXNlIGJ5dGVzIGJpZ2dlciB0aGFuIHRoZSBhbHBoYWJldC4gNjMgaXMgMDAxMTExMTEgYml0bWFzay5cbiAgICAvLyBUaGlzIG1hc2sgcmVkdWNlcyByYW5kb20gYnl0ZSAwLTI1NSB0byAwLTYzIHZhbHVlcy5cbiAgICAvLyBUaGVyZSBpcyBubyBuZWVkIGluIGB8fCAnJ2AgYW5kIGAqIDEuNmAgaGFja3MgaW4gaGVyZSxcbiAgICAvLyBiZWNhdXNlIGJpdG1hc2sgdHJpbSBieXRlcyBleGFjdCB0byBhbHBoYWJldCBzaXplLlxuICAgIGlkICs9IHVybFtieXRlc1tpXSAmIDYzXVxuICB9XG4gIHJldHVybiBpZFxufVxuIiwiY29uc3QgRXRoUXVlcnkgPSByZXF1aXJlKCdldGhqcy1xdWVyeScpXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgTXV0ZXggPSByZXF1aXJlKCdhd2FpdC1zZW1hcGhvcmUnKS5NdXRleFxuLyoqXG4gIEBwYXJhbSBvcHRzIHtPYmplY3R9XG4gICAgQHBhcmFtIHtPYmplY3R9IG9wdHMucHJvdmlkZXIgYSBldGhlcmV1bSBwcm92aWRlclxuICAgIEBwYXJhbSB7RnVuY3Rpb259IG9wdHMuZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBhcnJheSBvZiB0eE1ldGFcbiAgICB3aG9zZWUgc3RhdHVzIGlzIGBzdWJtaXR0ZWRgXG4gICAgQHBhcmFtIHtGdW5jdGlvbn0gb3B0cy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gYXJyYXkgb2YgdHhNZXRhXG4gICAgd2hvc2Ugc3RhdHVzIGlzIGBjb25maXJtZWRgXG4gIEBjbGFzc1xuKi9cbmNsYXNzIE5vbmNlVHJhY2tlciB7XG5cbiAgY29uc3RydWN0b3IgKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgZ2V0UGVuZGluZ1RyYW5zYWN0aW9ucywgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zIH0pIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXJcbiAgICB0aGlzLmJsb2NrVHJhY2tlciA9IGJsb2NrVHJhY2tlclxuICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgRXRoUXVlcnkocHJvdmlkZXIpXG4gICAgdGhpcy5nZXRQZW5kaW5nVHJhbnNhY3Rpb25zID0gZ2V0UGVuZGluZ1RyYW5zYWN0aW9uc1xuICAgIHRoaXMuZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zID0gZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb25zXG4gICAgdGhpcy5sb2NrTWFwID0ge31cbiAgfVxuXG4gIC8qKlxuICAgIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IHdpdGggdGhlIGtleSByZWxlYXNlTG9jayAodGhlIGdsb2FibCBtdXRleClcbiAgKi9cbiAgYXN5bmMgZ2V0R2xvYmFsTG9jayAoKSB7XG4gICAgY29uc3QgZ2xvYmFsTXV0ZXggPSB0aGlzLl9sb29rdXBNdXRleCgnZ2xvYmFsJylcbiAgICAvLyBhd2FpdCBnbG9iYWwgbXV0ZXggZnJlZVxuICAgIGNvbnN0IHJlbGVhc2VMb2NrID0gYXdhaXQgZ2xvYmFsTXV0ZXguYWNxdWlyZSgpXG4gICAgcmV0dXJuIHsgcmVsZWFzZUxvY2sgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIE5vbmNlRGV0YWlsc1xuICAgKiBAcHJvcGVydHkge251bWJlcn0gaGlnaGVzdExvY2FsbHlDb25maXJtZWQgLSBBIGhleCBzdHJpbmcgb2YgdGhlIGhpZ2hlc3Qgbm9uY2Ugb24gYSBjb25maXJtZWQgdHJhbnNhY3Rpb24uXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBuZXh0TmV0d29ya05vbmNlIC0gVGhlIG5leHQgbm9uY2Ugc3VnZ2VzdGVkIGJ5IHRoZSBldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCBtZXRob2QuXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoaWdoZXN0U3VnZ2VzdGVkIC0gVGhlIG1heGltdW0gYmV0d2VlbiB0aGUgb3RoZXIgdHdvLCB0aGUgbnVtYmVyIHJldHVybmVkLlxuICAgKi9cblxuICAvKipcbiAgdGhpcyB3aWxsIHJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgYG5leHROb25jZWAgYG5vbmNlRGV0YWlsc2AsIGFuZCB0aGUgcmVsZWFzZUxvY2tcbiAgTm90ZTogcmVsZWFzZUxvY2sgbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgYWRkaW5nIGEgc2lnbmVkIHR4IHRvIHBlbmRpbmcgdHJhbnNhY3Rpb25zIChvciBkaXNjYXJkaW5nKS5cblxuICBAcGFyYW0gYWRkcmVzcyB7c3RyaW5nfSB0aGUgaGV4IHN0cmluZyBmb3IgdGhlIGFkZHJlc3Mgd2hvc2Ugbm9uY2Ugd2UgYXJlIGNhbGN1bGF0aW5nXG4gIEByZXR1cm5zIHtQcm9taXNlPE5vbmNlRGV0YWlscz59XG4gICovXG4gIGFzeW5jIGdldE5vbmNlTG9jayAoYWRkcmVzcykge1xuICAgIC8vIGF3YWl0IGdsb2JhbCBtdXRleCBmcmVlXG4gICAgYXdhaXQgdGhpcy5fZ2xvYmFsTXV0ZXhGcmVlKClcbiAgICAvLyBhd2FpdCBsb2NrIGZyZWUsIHRoZW4gdGFrZSBsb2NrXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLl90YWtlTXV0ZXgoYWRkcmVzcylcbiAgICB0cnkge1xuICAgICAgLy8gZXZhbHVhdGUgbXVsdGlwbGUgbmV4dE5vbmNlIHN0cmF0ZWdpZXNcbiAgICAgIGNvbnN0IG5vbmNlRGV0YWlscyA9IHt9XG4gICAgICBjb25zdCBuZXR3b3JrTm9uY2VSZXN1bHQgPSBhd2FpdCB0aGlzLl9nZXROZXR3b3JrTmV4dE5vbmNlKGFkZHJlc3MpXG4gICAgICBjb25zdCBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZCA9IHRoaXMuX2dldEhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkKGFkZHJlc3MpXG4gICAgICBjb25zdCBuZXh0TmV0d29ya05vbmNlID0gbmV0d29ya05vbmNlUmVzdWx0Lm5vbmNlXG4gICAgICBjb25zdCBoaWdoZXN0U3VnZ2VzdGVkID0gTWF0aC5tYXgobmV4dE5ldHdvcmtOb25jZSwgaGlnaGVzdExvY2FsbHlDb25maXJtZWQpXG5cbiAgICAgIGNvbnN0IHBlbmRpbmdUeHMgPSB0aGlzLmdldFBlbmRpbmdUcmFuc2FjdGlvbnMoYWRkcmVzcylcbiAgICAgIGNvbnN0IGxvY2FsTm9uY2VSZXN1bHQgPSB0aGlzLl9nZXRIaWdoZXN0Q29udGludW91c0Zyb20ocGVuZGluZ1R4cywgaGlnaGVzdFN1Z2dlc3RlZCkgfHwgMFxuXG4gICAgICBub25jZURldGFpbHMucGFyYW1zID0ge1xuICAgICAgICBoaWdoZXN0TG9jYWxseUNvbmZpcm1lZCxcbiAgICAgICAgaGlnaGVzdFN1Z2dlc3RlZCxcbiAgICAgICAgbmV4dE5ldHdvcmtOb25jZSxcbiAgICAgIH1cbiAgICAgIG5vbmNlRGV0YWlscy5sb2NhbCA9IGxvY2FsTm9uY2VSZXN1bHRcbiAgICAgIG5vbmNlRGV0YWlscy5uZXR3b3JrID0gbmV0d29ya05vbmNlUmVzdWx0XG5cbiAgICAgIGNvbnN0IG5leHROb25jZSA9IE1hdGgubWF4KG5ldHdvcmtOb25jZVJlc3VsdC5ub25jZSwgbG9jYWxOb25jZVJlc3VsdC5ub25jZSlcbiAgICAgIGFzc2VydChOdW1iZXIuaXNJbnRlZ2VyKG5leHROb25jZSksIGBub25jZS10cmFja2VyIC0gbmV4dE5vbmNlIGlzIG5vdCBhbiBpbnRlZ2VyIC0gZ290OiAoJHt0eXBlb2YgbmV4dE5vbmNlfSkgXCIke25leHROb25jZX1cImApXG5cbiAgICAgIC8vIHJldHVybiBub25jZSBhbmQgcmVsZWFzZSBjYlxuICAgICAgcmV0dXJuIHsgbmV4dE5vbmNlLCBub25jZURldGFpbHMsIHJlbGVhc2VMb2NrIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHJlbGVhc2UgbG9jayBpZiB3ZSBlbmNvdW50ZXIgYW4gZXJyb3JcbiAgICAgIHJlbGVhc2VMb2NrKClcbiAgICAgIHRocm93IGVyclxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF9nbG9iYWxNdXRleEZyZWUgKCkge1xuICAgIGNvbnN0IGdsb2JhbE11dGV4ID0gdGhpcy5fbG9va3VwTXV0ZXgoJ2dsb2JhbCcpXG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCBnbG9iYWxNdXRleC5hY3F1aXJlKClcbiAgICByZWxlYXNlTG9jaygpXG4gIH1cblxuICBhc3luYyBfdGFrZU11dGV4IChsb2NrSWQpIHtcbiAgICBjb25zdCBtdXRleCA9IHRoaXMuX2xvb2t1cE11dGV4KGxvY2tJZClcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IG11dGV4LmFjcXVpcmUoKVxuICAgIHJldHVybiByZWxlYXNlTG9ja1xuICB9XG5cbiAgX2xvb2t1cE11dGV4IChsb2NrSWQpIHtcbiAgICBsZXQgbXV0ZXggPSB0aGlzLmxvY2tNYXBbbG9ja0lkXVxuICAgIGlmICghbXV0ZXgpIHtcbiAgICAgIG11dGV4ID0gbmV3IE11dGV4KClcbiAgICAgIHRoaXMubG9ja01hcFtsb2NrSWRdID0gbXV0ZXhcbiAgICB9XG4gICAgcmV0dXJuIG11dGV4XG4gIH1cblxuICBhc3luYyBfZ2V0TmV0d29ya05leHROb25jZSAoYWRkcmVzcykge1xuICAgIC8vIGNhbGN1bGF0ZSBuZXh0IG5vbmNlXG4gICAgLy8gd2UgbmVlZCB0byBtYWtlIHN1cmUgb3VyIGJhc2UgY291bnRcbiAgICAvLyBhbmQgcGVuZGluZyBjb3VudCBhcmUgZnJvbSB0aGUgc2FtZSBibG9ja1xuICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKVxuICAgIGNvbnN0IGJhc2VDb3VudEJOID0gYXdhaXQgdGhpcy5ldGhRdWVyeS5nZXRUcmFuc2FjdGlvbkNvdW50KGFkZHJlc3MsIGJsb2NrTnVtYmVyKVxuICAgIGNvbnN0IGJhc2VDb3VudCA9IGJhc2VDb3VudEJOLnRvTnVtYmVyKClcbiAgICBhc3NlcnQoTnVtYmVyLmlzSW50ZWdlcihiYXNlQ291bnQpLCBgbm9uY2UtdHJhY2tlciAtIGJhc2VDb3VudCBpcyBub3QgYW4gaW50ZWdlciAtIGdvdDogKCR7dHlwZW9mIGJhc2VDb3VudH0pIFwiJHtiYXNlQ291bnR9XCJgKVxuICAgIGNvbnN0IG5vbmNlRGV0YWlscyA9IHsgYmxvY2tOdW1iZXIsIGJhc2VDb3VudCB9XG4gICAgcmV0dXJuIHsgbmFtZTogJ25ldHdvcmsnLCBub25jZTogYmFzZUNvdW50LCBkZXRhaWxzOiBub25jZURldGFpbHMgfVxuICB9XG5cbiAgX2dldEhpZ2hlc3RMb2NhbGx5Q29uZmlybWVkIChhZGRyZXNzKSB7XG4gICAgY29uc3QgY29uZmlybWVkVHJhbnNhY3Rpb25zID0gdGhpcy5nZXRDb25maXJtZWRUcmFuc2FjdGlvbnMoYWRkcmVzcylcbiAgICBjb25zdCBoaWdoZXN0ID0gdGhpcy5fZ2V0SGlnaGVzdE5vbmNlKGNvbmZpcm1lZFRyYW5zYWN0aW9ucylcbiAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihoaWdoZXN0KSA/IGhpZ2hlc3QgKyAxIDogMFxuICB9XG5cbiAgX2dldEhpZ2hlc3ROb25jZSAodHhMaXN0KSB7XG4gICAgY29uc3Qgbm9uY2VzID0gdHhMaXN0Lm1hcCgodHhNZXRhKSA9PiB7XG4gICAgICBjb25zdCBub25jZSA9IHR4TWV0YS50eFBhcmFtcy5ub25jZVxuICAgICAgYXNzZXJ0KHR5cGVvZiBub25jZSwgJ3N0cmluZycsICdub25jZXMgc2hvdWxkIGJlIGhleCBzdHJpbmdzJylcbiAgICAgIHJldHVybiBwYXJzZUludChub25jZSwgMTYpXG4gICAgfSlcbiAgICBjb25zdCBoaWdoZXN0Tm9uY2UgPSBNYXRoLm1heC5hcHBseShudWxsLCBub25jZXMpXG4gICAgcmV0dXJuIGhpZ2hlc3ROb25jZVxuICB9XG5cbiAgLyoqXG4gICAgQHR5cGVkZWYge29iamVjdH0gaGlnaGVzdENvbnRpbnVvdXNGcm9tXG4gICAgQHByb3BlcnR5IHtzdHJpbmd9IC0gbmFtZSB0aGUgbmFtZSBmb3IgaG93IHRoZSBub25jZSB3YXMgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZGF0YSB1c2VkXG4gICAgQHByb3BlcnR5IHtudW1iZXJ9IC0gbm9uY2UgdGhlIG5leHQgc3VnZ2VzdGVkIG5vbmNlXG4gICAgQHByb3BlcnR5IHtvYmplY3R9IC0gZGV0YWlscyB0aGUgcHJvdmlkZWQgc3RhcnRpbmcgbm9uY2UgdGhhdCB3YXMgdXNlZCAoZm9yIGRlYnVnZ2luZylcbiAgKi9cbiAgLyoqXG4gICAgQHBhcmFtIHR4TGlzdCB7YXJyYXl9IC0gbGlzdCBvZiB0eE1ldGEnc1xuICAgIEBwYXJhbSBzdGFydFBvaW50IHtudW1iZXJ9IC0gdGhlIGhpZ2hlc3Qga25vd24gbG9jYWxseSBjb25maXJtZWQgbm9uY2VcbiAgICBAcmV0dXJucyB7aGlnaGVzdENvbnRpbnVvdXNGcm9tfVxuICAqL1xuICBfZ2V0SGlnaGVzdENvbnRpbnVvdXNGcm9tICh0eExpc3QsIHN0YXJ0UG9pbnQpIHtcbiAgICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcbiAgICAgIGNvbnN0IG5vbmNlID0gdHhNZXRhLnR4UGFyYW1zLm5vbmNlXG4gICAgICBhc3NlcnQodHlwZW9mIG5vbmNlLCAnc3RyaW5nJywgJ25vbmNlcyBzaG91bGQgYmUgaGV4IHN0cmluZ3MnKVxuICAgICAgcmV0dXJuIHBhcnNlSW50KG5vbmNlLCAxNilcbiAgICB9KVxuXG4gICAgbGV0IGhpZ2hlc3QgPSBzdGFydFBvaW50XG4gICAgd2hpbGUgKG5vbmNlcy5pbmNsdWRlcyhoaWdoZXN0KSkge1xuICAgICAgaGlnaGVzdCsrXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmFtZTogJ2xvY2FsJywgbm9uY2U6IGhpZ2hlc3QsIGRldGFpbHM6IHsgc3RhcnRQb2ludCwgaGlnaGVzdCB9IH1cbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTm9uY2VUcmFja2VyXG4iLCJcbi8qKlxuICogUmVtb3ZlIHRyYWlsaW5nIHNsYXNoZXMgZnJvbSB0aGUgZ2l2ZW4gYHN0cmBcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKGV4cG9ydHMuZXhwciwgJycpO1xufTtcblxuLyoqXG4gKiBFeHBvc2UgdGhlIHJlZ2V4XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG5leHBvcnRzLmV4cHIgPSAvXFwvKyQvO1xuIiwidmFyIHBia2RmMlN5bmMgPSByZXF1aXJlKCdwYmtkZjInKS5wYmtkZjJTeW5jXG5cbnZhciBNQVhfVkFMVUUgPSAweDdmZmZmZmZmXG5cbi8vIE4gPSBDcHUgY29zdCwgciA9IE1lbW9yeSBjb3N0LCBwID0gcGFyYWxsZWxpemF0aW9uIGNvc3RcbmZ1bmN0aW9uIHNjcnlwdCAoa2V5LCBzYWx0LCBOLCByLCBwLCBka0xlbiwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICBpZiAoTiA9PT0gMCB8fCAoTiAmIChOIC0gMSkpICE9PSAwKSB0aHJvdyBFcnJvcignTiBtdXN0IGJlID4gMCBhbmQgYSBwb3dlciBvZiAyJylcblxuICBpZiAoTiA+IE1BWF9WQUxVRSAvIDEyOCAvIHIpIHRocm93IEVycm9yKCdQYXJhbWV0ZXIgTiBpcyB0b28gbGFyZ2UnKVxuICBpZiAociA+IE1BWF9WQUxVRSAvIDEyOCAvIHApIHRocm93IEVycm9yKCdQYXJhbWV0ZXIgciBpcyB0b28gbGFyZ2UnKVxuXG4gIHZhciBYWSA9IG5ldyBCdWZmZXIoMjU2ICogcilcbiAgdmFyIFYgPSBuZXcgQnVmZmVyKDEyOCAqIHIgKiBOKVxuXG4gIC8vIHBzZXVkbyBnbG9iYWxcbiAgdmFyIEIzMiA9IG5ldyBJbnQzMkFycmF5KDE2KSAvLyBzYWxzYTIwXzhcbiAgdmFyIHggPSBuZXcgSW50MzJBcnJheSgxNikgLy8gc2Fsc2EyMF84XG4gIHZhciBfWCA9IG5ldyBCdWZmZXIoNjQpIC8vIGJsb2NrbWl4X3NhbHNhOFxuXG4gIC8vIHBzZXVkbyBnbG9iYWxcbiAgdmFyIEIgPSBwYmtkZjJTeW5jKGtleSwgc2FsdCwgMSwgcCAqIDEyOCAqIHIsICdzaGEyNTYnKVxuXG4gIHZhciB0aWNrQ2FsbGJhY2tcbiAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB2YXIgdG90YWxPcHMgPSBwICogTiAqIDJcbiAgICB2YXIgY3VycmVudE9wID0gMFxuXG4gICAgdGlja0NhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgKytjdXJyZW50T3BcblxuICAgICAgLy8gc2VuZCBwcm9ncmVzcyBub3RpZmljYXRpb25zIG9uY2UgZXZlcnkgMSwwMDAgb3BzXG4gICAgICBpZiAoY3VycmVudE9wICUgMTAwMCA9PT0gMCkge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKHtcbiAgICAgICAgICBjdXJyZW50OiBjdXJyZW50T3AsXG4gICAgICAgICAgdG90YWw6IHRvdGFsT3BzLFxuICAgICAgICAgIHBlcmNlbnQ6IChjdXJyZW50T3AgLyB0b3RhbE9wcykgKiAxMDAuMFxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcDsgaSsrKSB7XG4gICAgc21peChCLCBpICogMTI4ICogciwgciwgTiwgViwgWFkpXG4gIH1cblxuICByZXR1cm4gcGJrZGYyU3luYyhrZXksIEIsIDEsIGRrTGVuLCAnc2hhMjU2JylcblxuICAvLyBhbGwgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZSBhY3R1YWxseSBtb3ZlZCB0byB0aGUgdG9wXG4gIC8vIGR1ZSB0byBmdW5jdGlvbiBob2lzdGluZ1xuXG4gIGZ1bmN0aW9uIHNtaXggKEIsIEJpLCByLCBOLCBWLCBYWSkge1xuICAgIHZhciBYaSA9IDBcbiAgICB2YXIgWWkgPSAxMjggKiByXG4gICAgdmFyIGlcblxuICAgIEIuY29weShYWSwgWGksIEJpLCBCaSArIFlpKVxuXG4gICAgZm9yIChpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgWFkuY29weShWLCBpICogWWksIFhpLCBYaSArIFlpKVxuICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBYaSwgWWksIHIpXG5cbiAgICAgIGlmICh0aWNrQ2FsbGJhY2spIHRpY2tDYWxsYmFjaygpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdmFyIG9mZnNldCA9IFhpICsgKDIgKiByIC0gMSkgKiA2NFxuICAgICAgdmFyIGogPSBYWS5yZWFkVUludDMyTEUob2Zmc2V0KSAmIChOIC0gMSlcbiAgICAgIGJsb2NreG9yKFYsIGogKiBZaSwgWFksIFhpLCBZaSlcbiAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWGksIFlpLCByKVxuXG4gICAgICBpZiAodGlja0NhbGxiYWNrKSB0aWNrQ2FsbGJhY2soKVxuICAgIH1cblxuICAgIFhZLmNvcHkoQiwgQmksIFhpLCBYaSArIFlpKVxuICB9XG5cbiAgZnVuY3Rpb24gYmxvY2ttaXhfc2Fsc2E4IChCWSwgQmksIFlpLCByKSB7XG4gICAgdmFyIGlcblxuICAgIGFycmF5Y29weShCWSwgQmkgKyAoMiAqIHIgLSAxKSAqIDY0LCBfWCwgMCwgNjQpXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgMiAqIHI7IGkrKykge1xuICAgICAgYmxvY2t4b3IoQlksIGkgKiA2NCwgX1gsIDAsIDY0KVxuICAgICAgc2Fsc2EyMF84KF9YKVxuICAgICAgYXJyYXljb3B5KF9YLCAwLCBCWSwgWWkgKyAoaSAqIDY0KSwgNjQpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMikgKiA2NCwgQlksIEJpICsgKGkgKiA2NCksIDY0KVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIHtcbiAgICAgIGFycmF5Y29weShCWSwgWWkgKyAoaSAqIDIgKyAxKSAqIDY0LCBCWSwgQmkgKyAoaSArIHIpICogNjQsIDY0KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIFIgKGEsIGIpIHtcbiAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpXG4gIH1cblxuICBmdW5jdGlvbiBzYWxzYTIwXzggKEIpIHtcbiAgICB2YXIgaVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgIEIzMltpXSA9IChCW2kgKiA0ICsgMF0gJiAweGZmKSA8PCAwXG4gICAgICBCMzJbaV0gfD0gKEJbaSAqIDQgKyAxXSAmIDB4ZmYpIDw8IDhcbiAgICAgIEIzMltpXSB8PSAoQltpICogNCArIDJdICYgMHhmZikgPDwgMTZcbiAgICAgIEIzMltpXSB8PSAoQltpICogNCArIDNdICYgMHhmZikgPDwgMjRcbiAgICAgIC8vIEIzMltpXSA9IEIucmVhZFVJbnQzMkxFKGkqNCkgICA8LS0tIHRoaXMgaXMgc2lnbmZpY2FudGx5IHNsb3dlciBldmVuIGluIE5vZGUuanNcbiAgICB9XG5cbiAgICBhcnJheWNvcHkoQjMyLCAwLCB4LCAwLCAxNilcblxuICAgIGZvciAoaSA9IDg7IGkgPiAwOyBpIC09IDIpIHtcbiAgICAgIHhbIDRdIF49IFIoeFsgMF0gKyB4WzEyXSwgNylcbiAgICAgIHhbIDhdIF49IFIoeFsgNF0gKyB4WyAwXSwgOSlcbiAgICAgIHhbMTJdIF49IFIoeFsgOF0gKyB4WyA0XSwgMTMpXG4gICAgICB4WyAwXSBePSBSKHhbMTJdICsgeFsgOF0sIDE4KVxuICAgICAgeFsgOV0gXj0gUih4WyA1XSArIHhbIDFdLCA3KVxuICAgICAgeFsxM10gXj0gUih4WyA5XSArIHhbIDVdLCA5KVxuICAgICAgeFsgMV0gXj0gUih4WzEzXSArIHhbIDldLCAxMylcbiAgICAgIHhbIDVdIF49IFIoeFsgMV0gKyB4WzEzXSwgMTgpXG4gICAgICB4WzE0XSBePSBSKHhbMTBdICsgeFsgNl0sIDcpXG4gICAgICB4WyAyXSBePSBSKHhbMTRdICsgeFsxMF0sIDkpXG4gICAgICB4WyA2XSBePSBSKHhbIDJdICsgeFsxNF0sIDEzKVxuICAgICAgeFsxMF0gXj0gUih4WyA2XSArIHhbIDJdLCAxOClcbiAgICAgIHhbIDNdIF49IFIoeFsxNV0gKyB4WzExXSwgNylcbiAgICAgIHhbIDddIF49IFIoeFsgM10gKyB4WzE1XSwgOSlcbiAgICAgIHhbMTFdIF49IFIoeFsgN10gKyB4WyAzXSwgMTMpXG4gICAgICB4WzE1XSBePSBSKHhbMTFdICsgeFsgN10sIDE4KVxuICAgICAgeFsgMV0gXj0gUih4WyAwXSArIHhbIDNdLCA3KVxuICAgICAgeFsgMl0gXj0gUih4WyAxXSArIHhbIDBdLCA5KVxuICAgICAgeFsgM10gXj0gUih4WyAyXSArIHhbIDFdLCAxMylcbiAgICAgIHhbIDBdIF49IFIoeFsgM10gKyB4WyAyXSwgMTgpXG4gICAgICB4WyA2XSBePSBSKHhbIDVdICsgeFsgNF0sIDcpXG4gICAgICB4WyA3XSBePSBSKHhbIDZdICsgeFsgNV0sIDkpXG4gICAgICB4WyA0XSBePSBSKHhbIDddICsgeFsgNl0sIDEzKVxuICAgICAgeFsgNV0gXj0gUih4WyA0XSArIHhbIDddLCAxOClcbiAgICAgIHhbMTFdIF49IFIoeFsxMF0gKyB4WyA5XSwgNylcbiAgICAgIHhbIDhdIF49IFIoeFsxMV0gKyB4WzEwXSwgOSlcbiAgICAgIHhbIDldIF49IFIoeFsgOF0gKyB4WzExXSwgMTMpXG4gICAgICB4WzEwXSBePSBSKHhbIDldICsgeFsgOF0sIDE4KVxuICAgICAgeFsxMl0gXj0gUih4WzE1XSArIHhbMTRdLCA3KVxuICAgICAgeFsxM10gXj0gUih4WzEyXSArIHhbMTVdLCA5KVxuICAgICAgeFsxNF0gXj0gUih4WzEzXSArIHhbMTJdLCAxMylcbiAgICAgIHhbMTVdIF49IFIoeFsxNF0gKyB4WzEzXSwgMTgpXG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IDE2OyArK2kpIEIzMltpXSA9IHhbaV0gKyBCMzJbaV1cblxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICB2YXIgYmkgPSBpICogNFxuICAgICAgQltiaSArIDBdID0gKEIzMltpXSA+PiAwICYgMHhmZilcbiAgICAgIEJbYmkgKyAxXSA9IChCMzJbaV0gPj4gOCAmIDB4ZmYpXG4gICAgICBCW2JpICsgMl0gPSAoQjMyW2ldID4+IDE2ICYgMHhmZilcbiAgICAgIEJbYmkgKyAzXSA9IChCMzJbaV0gPj4gMjQgJiAweGZmKVxuICAgICAgLy8gQi53cml0ZUludDMyTEUoQjMyW2ldLCBpKjQpICAvLzwtLS0gdGhpcyBpcyBzaWduZmljYW50bHkgc2xvd2VyIGV2ZW4gaW4gTm9kZS5qc1xuICAgIH1cbiAgfVxuXG4gIC8vIG5haXZlIGFwcHJvYWNoLi4uIGdvaW5nIGJhY2sgdG8gbG9vcCB1bnJvbGxpbmcgbWF5IHlpZWxkIGFkZGl0aW9uYWwgcGVyZm9ybWFuY2VcbiAgZnVuY3Rpb24gYmxvY2t4b3IgKFMsIFNpLCBELCBEaSwgbGVuKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgRFtEaSArIGldIF49IFNbU2kgKyBpXVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcnJheWNvcHkgKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzcmMpICYmIEJ1ZmZlci5pc0J1ZmZlcihkZXN0KSkge1xuICAgIHNyYy5jb3B5KGRlc3QsIGRlc3RQb3MsIHNyY1Bvcywgc3JjUG9zICsgbGVuZ3RoKVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNjcnlwdFxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpKHJlcXVpcmUoJy4vbGliL2VsbGlwdGljJykpXG4iLCJjb25zdCBFQyA9IHJlcXVpcmUoJ2VsbGlwdGljJykuZWNcblxuY29uc3QgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpXG5jb25zdCBlY3BhcmFtcyA9IGVjLmN1cnZlXG5cbi8vIEhhY2ssIHdlIGNhbiBub3QgdXNlIGJuLmpzQDUsIHdoaWxlIGVsbGlwdGljIHVzZXMgYm4uanNANFxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2VsbGlwdGljL2lzc3Vlcy8xOTEjaXNzdWVjb21tZW50LTU2OTg4ODc1OFxuY29uc3QgQk4gPSBlY3BhcmFtcy5uLmNvbnN0cnVjdG9yXG5cbmZ1bmN0aW9uIGxvYWRDb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeGJ1Zikge1xuICBsZXQgeCA9IG5ldyBCTih4YnVmKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwKSByZXR1cm4gbnVsbFxuICB4ID0geC50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gY29tcHV0ZSBjb3JyZXNwb25kaW5nIFlcbiAgbGV0IHkgPSB4LnJlZFNxcigpLnJlZElNdWwoeCkucmVkSUFkZChlY3BhcmFtcy5iKS5yZWRTcXJ0KClcbiAgaWYgKChmaXJzdCA9PT0gMHgwMykgIT09IHkuaXNPZGQoKSkgeSA9IHkucmVkTmVnKClcblxuICByZXR1cm4gZWMua2V5UGFpcih7IHB1YjogeyB4OiB4LCB5OiB5IH0gfSlcbn1cblxuZnVuY3Rpb24gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleSAoZmlyc3QsIHhidWYsIHlidWYpIHtcbiAgbGV0IHggPSBuZXcgQk4oeGJ1ZilcbiAgbGV0IHkgPSBuZXcgQk4oeWJ1ZilcblxuICAvLyBvdmVyZmxvd1xuICBpZiAoeC5jbXAoZWNwYXJhbXMucCkgPj0gMCB8fCB5LmNtcChlY3BhcmFtcy5wKSA+PSAwKSByZXR1cm4gbnVsbFxuXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcbiAgeSA9IHkudG9SZWQoZWNwYXJhbXMucmVkKVxuXG4gIC8vIGlzIG9kZCBmbGFnXG4gIGlmICgoZmlyc3QgPT09IDB4MDYgfHwgZmlyc3QgPT09IDB4MDcpICYmIHkuaXNPZGQoKSAhPT0gKGZpcnN0ID09PSAweDA3KSkgcmV0dXJuIG51bGxcblxuICAvLyB4KngqeCArIGIgPSB5KnlcbiAgY29uc3QgeDMgPSB4LnJlZFNxcigpLnJlZElNdWwoeClcbiAgaWYgKCF5LnJlZFNxcigpLnJlZElTdWIoeDMucmVkSUFkZChlY3BhcmFtcy5iKSkuaXNaZXJvKCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkgKHB1YmtleSkge1xuICAvLyBsZW5ndGggc2hvdWxkIGJlIHZhbGlkYXRlZCBpbiBpbnRlcmZhY2VcbiAgY29uc3QgZmlyc3QgPSBwdWJrZXlbMF1cbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHgwMjpcbiAgICBjYXNlIDB4MDM6XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gMzMpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmtleS5zdWJhcnJheSgxLCAzMykpXG4gICAgY2FzZSAweDA0OlxuICAgIGNhc2UgMHgwNjpcbiAgICBjYXNlIDB4MDc6XG4gICAgICBpZiAocHVia2V5Lmxlbmd0aCAhPT0gNjUpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVia2V5LnN1YmFycmF5KDEsIDMzKSwgcHVia2V5LnN1YmFycmF5KDMzLCA2NSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gc2F2ZVB1YmxpY0tleSAob3V0cHV0LCBwb2ludCkge1xuICBjb25zdCBwdWJrZXkgPSBwb2ludC5lbmNvZGUobnVsbCwgb3V0cHV0Lmxlbmd0aCA9PT0gMzMpXG4gIC8vIExvb3Agc2hvdWxkIGJlIGZhc3RlciBiZWNhdXNlIHdlIGRvIG5vdCBuZWVkIGNyZWF0ZSBleHRyYSBVaW50OEFycmF5XG4gIC8vIG91dHB1dC5zZXQobmV3IFVpbnQ4QXJyYXkocHVia2V5KSlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyArK2kpIG91dHB1dFtpXSA9IHB1YmtleVtpXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29udGV4dFJhbmRvbWl6ZSAoKSB7XG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VmVyaWZ5IChzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgcmV0dXJuIGJuLmNtcChlY3BhcmFtcy5uKSA8IDAgJiYgIWJuLmlzWmVybygpID8gMCA6IDFcbiAgfSxcblxuICBwcml2YXRlS2V5TmVnYXRlIChzZWNrZXkpIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTihzZWNrZXkpXG4gICAgY29uc3QgbmVnYXRlID0gZWNwYXJhbXMubi5zdWIoYm4pLnVtb2QoZWNwYXJhbXMubikudG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldChuZWdhdGUpXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwcml2YXRlS2V5VHdlYWtBZGQgKHNlY2tleSwgdHdlYWspIHtcbiAgICBjb25zdCBibiA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBibi5pYWRkKG5ldyBCTihzZWNrZXkpKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4uaXN1YihlY3BhcmFtcy5uKVxuICAgIGlmIChibi5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGNvbnN0IHR3ZWFrZWQgPSBibi50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMilcbiAgICBzZWNrZXkuc2V0KHR3ZWFrZWQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgIGxldCBibiA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBibi5pbXVsKG5ldyBCTihzZWNrZXkpKVxuICAgIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4gPSBibi51bW9kKGVjcGFyYW1zLm4pXG5cbiAgICBjb25zdCB0d2Vha2VkID0gYm4udG9BcnJheUxpa2UoVWludDhBcnJheSwgJ2JlJywgMzIpXG4gICAgc2Vja2V5LnNldCh0d2Vha2VkKVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICByZXR1cm4gcGFpciA9PT0gbnVsbCA/IDEgOiAwXG4gIH0sXG5cbiAgcHVibGljS2V5Q3JlYXRlIChvdXRwdXQsIHNlY2tleSkge1xuICAgIGNvbnN0IGJuID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHJldHVybiAxXG5cbiAgICBjb25zdCBwb2ludCA9IGVjLmtleUZyb21Qcml2YXRlKHNlY2tleSkuZ2V0UHVibGljKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleUNvbnZlcnQgKG91dHB1dCwgcHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgc2F2ZVB1YmxpY0tleShvdXRwdXQsIHBvaW50KVxuXG4gICAgcmV0dXJuIDBcbiAgfSxcblxuICBwdWJsaWNLZXlOZWdhdGUgKG91dHB1dCwgcHVia2V5KSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgcG9pbnQueSA9IHBvaW50LnkucmVkTmVnKClcbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleUNvbWJpbmUgKG91dHB1dCwgcHVia2V5cykge1xuICAgIGNvbnN0IHBhaXJzID0gbmV3IEFycmF5KHB1YmtleXMubGVuZ3RoKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHVia2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgcGFpcnNbaV0gPSBsb2FkUHVibGljS2V5KHB1YmtleXNbaV0pXG4gICAgICBpZiAocGFpcnNbaV0gPT09IG51bGwpIHJldHVybiAxXG4gICAgfVxuXG4gICAgbGV0IHBvaW50ID0gcGFpcnNbMF0uZ2V0UHVibGljKClcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHBhaXJzLmxlbmd0aDsgKytpKSBwb2ludCA9IHBvaW50LmFkZChwYWlyc1tpXS5wdWIpXG4gICAgaWYgKHBvaW50LmlzSW5maW5pdHkoKSkgcmV0dXJuIDJcblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgcHVibGljS2V5VHdlYWtBZGQgKG91dHB1dCwgcHVia2V5LCB0d2Vhaykge1xuICAgIGNvbnN0IHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmtleSlcbiAgICBpZiAocGFpciA9PT0gbnVsbCkgcmV0dXJuIDFcblxuICAgIHR3ZWFrID0gbmV3IEJOKHR3ZWFrKVxuICAgIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5hZGQoZWNwYXJhbXMuZy5tdWwodHdlYWspKVxuICAgIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHJldHVybiAyXG5cbiAgICBzYXZlUHVibGljS2V5KG91dHB1dCwgcG9pbnQpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIHB1YmxpY0tleVR3ZWFrTXVsIChvdXRwdXQsIHB1YmtleSwgdHdlYWspIHtcbiAgICBjb25zdCBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJrZXkpXG4gICAgaWYgKHBhaXIgPT09IG51bGwpIHJldHVybiAxXG5cbiAgICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgICBpZiAodHdlYWsuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgdHdlYWsuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICBjb25zdCBwb2ludCA9IHBhaXIuZ2V0UHVibGljKCkubXVsKHR3ZWFrKVxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgc2lnbmF0dXJlTm9ybWFsaXplIChzaWcpIHtcbiAgICBjb25zdCByID0gbmV3IEJOKHNpZy5zdWJhcnJheSgwLCAzMikpXG4gICAgY29uc3QgcyA9IG5ldyBCTihzaWcuc3ViYXJyYXkoMzIsIDY0KSlcbiAgICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuXG4gICAgaWYgKHMuY21wKGVjLm5oKSA9PT0gMSkge1xuICAgICAgc2lnLnNldChlY3BhcmFtcy5uLnN1YihzKS50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuICAgIH1cblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgLy8gQ29waWVkIDEtdG8tMSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYmlwNjYvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgLy8gQWRhcHRlZCBmb3IgVWludDhBcnJheSBpbnN0ZWFkIEJ1ZmZlclxuICBzaWduYXR1cmVFeHBvcnQgKG9iaiwgc2lnKSB7XG4gICAgY29uc3Qgc2lnUiA9IHNpZy5zdWJhcnJheSgwLCAzMilcbiAgICBjb25zdCBzaWdTID0gc2lnLnN1YmFycmF5KDMyLCA2NClcbiAgICBpZiAobmV3IEJOKHNpZ1IpLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuICAgIGlmIChuZXcgQk4oc2lnUykuY21wKGVjcGFyYW1zLm4pID49IDApIHJldHVybiAxXG5cbiAgICBjb25zdCB7IG91dHB1dCB9ID0gb2JqXG5cbiAgICAvLyBQcmVwYXJlIFJcbiAgICBsZXQgciA9IG91dHB1dC5zdWJhcnJheSg0LCA0ICsgMzMpXG4gICAgclswXSA9IDB4MDBcbiAgICByLnNldChzaWdSLCAxKVxuXG4gICAgbGV0IGxlblIgPSAzM1xuICAgIGxldCBwb3NSID0gMFxuICAgIGZvciAoOyBsZW5SID4gMSAmJiByW3Bvc1JdID09PSAweDAwICYmICEocltwb3NSICsgMV0gJiAweDgwKTsgLS1sZW5SLCArK3Bvc1IpO1xuXG4gICAgciA9IHIuc3ViYXJyYXkocG9zUilcbiAgICBpZiAoclswXSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblIgPiAxICYmIChyWzBdID09PSAweDAwKSAmJiAhKHJbMV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIC8vIFByZXBhcmUgU1xuICAgIGxldCBzID0gb3V0cHV0LnN1YmFycmF5KDYgKyAzMywgNiArIDMzICsgMzMpXG4gICAgc1swXSA9IDB4MDBcbiAgICBzLnNldChzaWdTLCAxKVxuXG4gICAgbGV0IGxlblMgPSAzM1xuICAgIGxldCBwb3NTID0gMFxuICAgIGZvciAoOyBsZW5TID4gMSAmJiBzW3Bvc1NdID09PSAweDAwICYmICEoc1twb3NTICsgMV0gJiAweDgwKTsgLS1sZW5TLCArK3Bvc1MpO1xuXG4gICAgcyA9IHMuc3ViYXJyYXkocG9zUylcbiAgICBpZiAoc1swXSAmIDB4ODApIHJldHVybiAxXG4gICAgaWYgKGxlblMgPiAxICYmIChzWzBdID09PSAweDAwKSAmJiAhKHNbMV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIC8vIFNldCBvdXRwdXQgbGVuZ3RoIGZvciByZXR1cm5cbiAgICBvYmoub3V0cHV0bGVuID0gNiArIGxlblIgKyBsZW5TXG5cbiAgICAvLyBPdXRwdXQgaW4gc3BlY2lmaWVkIGZvcm1hdFxuICAgIC8vIDB4MzAgW3RvdGFsLWxlbmd0aF0gMHgwMiBbUi1sZW5ndGhdIFtSXSAweDAyIFtTLWxlbmd0aF0gW1NdXG4gICAgb3V0cHV0WzBdID0gMHgzMFxuICAgIG91dHB1dFsxXSA9IG9iai5vdXRwdXRsZW4gLSAyXG4gICAgb3V0cHV0WzJdID0gMHgwMlxuICAgIG91dHB1dFszXSA9IHIubGVuZ3RoXG4gICAgb3V0cHV0LnNldChyLCA0KVxuICAgIG91dHB1dFs0ICsgbGVuUl0gPSAweDAyXG4gICAgb3V0cHV0WzUgKyBsZW5SXSA9IHMubGVuZ3RoXG4gICAgb3V0cHV0LnNldChzLCA2ICsgbGVuUilcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgLy8gQ29waWVkIDEtdG8tMSBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luanMvYmlwNjYvYmxvYi9tYXN0ZXIvaW5kZXguanNcbiAgLy8gQWRhcHRlZCBmb3IgVWludDhBcnJheSBpbnN0ZWFkIEJ1ZmZlclxuICBzaWduYXR1cmVJbXBvcnQgKG91dHB1dCwgc2lnKSB7XG4gICAgaWYgKHNpZy5sZW5ndGggPCA4KSByZXR1cm4gMVxuICAgIGlmIChzaWcubGVuZ3RoID4gNzIpIHJldHVybiAxXG4gICAgaWYgKHNpZ1swXSAhPT0gMHgzMCkgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzFdICE9PSBzaWcubGVuZ3RoIC0gMikgcmV0dXJuIDFcbiAgICBpZiAoc2lnWzJdICE9PSAweDAyKSByZXR1cm4gMVxuXG4gICAgY29uc3QgbGVuUiA9IHNpZ1szXVxuICAgIGlmIChsZW5SID09PSAwKSByZXR1cm4gMVxuICAgIGlmICg1ICsgbGVuUiA+PSBzaWcubGVuZ3RoKSByZXR1cm4gMVxuICAgIGlmIChzaWdbNCArIGxlblJdICE9PSAweDAyKSByZXR1cm4gMVxuXG4gICAgY29uc3QgbGVuUyA9IHNpZ1s1ICsgbGVuUl1cbiAgICBpZiAobGVuUyA9PT0gMCkgcmV0dXJuIDFcbiAgICBpZiAoKDYgKyBsZW5SICsgbGVuUykgIT09IHNpZy5sZW5ndGgpIHJldHVybiAxXG5cbiAgICBpZiAoc2lnWzRdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUiA+IDEgJiYgKHNpZ1s0XSA9PT0gMHgwMCkgJiYgIShzaWdbNV0gJiAweDgwKSkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdbbGVuUiArIDZdICYgMHg4MCkgcmV0dXJuIDFcbiAgICBpZiAobGVuUyA+IDEgJiYgKHNpZ1tsZW5SICsgNl0gPT09IDB4MDApICYmICEoc2lnW2xlblIgKyA3XSAmIDB4ODApKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1IgPSBzaWcuc3ViYXJyYXkoNCwgNCArIGxlblIpXG4gICAgaWYgKHNpZ1IubGVuZ3RoID09PSAzMyAmJiBzaWdSWzBdID09PSAweDAwKSBzaWdSID0gc2lnUi5zdWJhcnJheSgxKVxuICAgIGlmIChzaWdSLmxlbmd0aCA+IDMyKSByZXR1cm4gMVxuXG4gICAgbGV0IHNpZ1MgPSBzaWcuc3ViYXJyYXkoNiArIGxlblIpXG4gICAgaWYgKHNpZ1MubGVuZ3RoID09PSAzMyAmJiBzaWdTWzBdID09PSAweDAwKSBzaWdTID0gc2lnUy5zbGljZSgxKVxuICAgIGlmIChzaWdTLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1MgbGVuZ3RoIGlzIHRvbyBsb25nJylcblxuICAgIGxldCByID0gbmV3IEJOKHNpZ1IpXG4gICAgaWYgKHIuY21wKGVjcGFyYW1zLm4pID49IDApIHIgPSBuZXcgQk4oMClcblxuICAgIGxldCBzID0gbmV3IEJOKHNpZy5zdWJhcnJheSg2ICsgbGVuUikpXG4gICAgaWYgKHMuY21wKGVjcGFyYW1zLm4pID49IDApIHMgPSBuZXcgQk4oMClcblxuICAgIG91dHB1dC5zZXQoci50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDApXG4gICAgb3V0cHV0LnNldChzLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMzIpXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZHNhU2lnbiAob2JqLCBtZXNzYWdlLCBzZWNrZXksIGRhdGEsIG5vbmNlZm4pIHtcbiAgICBpZiAobm9uY2Vmbikge1xuICAgICAgY29uc3QgX25vbmNlZm4gPSBub25jZWZuXG4gICAgICBub25jZWZuID0gKGNvdW50ZXIpID0+IHtcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBfbm9uY2VmbihtZXNzYWdlLCBzZWNrZXksIG51bGwsIGRhdGEsIGNvdW50ZXIpXG5cbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IG5vbmNlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBub25jZS5sZW5ndGggPT09IDMyXG4gICAgICAgIGlmICghaXNWYWxpZCkgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIHRoZSB3YXknKVxuXG4gICAgICAgIHJldHVybiBuZXcgQk4obm9uY2UpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZCA9IG5ldyBCTihzZWNrZXkpXG4gICAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgcmV0dXJuIDFcblxuICAgIGxldCBzaWdcbiAgICB0cnkge1xuICAgICAgc2lnID0gZWMuc2lnbihtZXNzYWdlLCBzZWNrZXksIHsgY2Fub25pY2FsOiB0cnVlLCBrOiBub25jZWZuLCBwZXJzOiBkYXRhIH0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gMVxuICAgIH1cblxuICAgIG9iai5zaWduYXR1cmUuc2V0KHNpZy5yLnRvQXJyYXlMaWtlKFVpbnQ4QXJyYXksICdiZScsIDMyKSwgMClcbiAgICBvYmouc2lnbmF0dXJlLnNldChzaWcucy50b0FycmF5TGlrZShVaW50OEFycmF5LCAnYmUnLCAzMiksIDMyKVxuICAgIG9iai5yZWNpZCA9IHNpZy5yZWNvdmVyeVBhcmFtXG5cbiAgICByZXR1cm4gMFxuICB9LFxuXG4gIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICBjb25zdCBzaWdPYmogPSB7IHI6IHNpZy5zdWJhcnJheSgwLCAzMiksIHM6IHNpZy5zdWJhcnJheSgzMiwgNjQpIH1cblxuICAgIGNvbnN0IHNpZ3IgPSBuZXcgQk4oc2lnT2JqLnIpXG4gICAgY29uc3Qgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgICBpZiAoc2lnci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzaWdzLmNtcChlY3BhcmFtcy5uKSA+PSAwKSByZXR1cm4gMVxuICAgIGlmIChzaWdzLmNtcChlYy5uaCkgPT09IDEgfHwgc2lnci5pc1plcm8oKSB8fCBzaWdzLmlzWmVybygpKSByZXR1cm4gM1xuXG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMlxuXG4gICAgY29uc3QgcG9pbnQgPSBwYWlyLmdldFB1YmxpYygpXG4gICAgY29uc3QgaXNWYWxpZCA9IGVjLnZlcmlmeShtc2czMiwgc2lnT2JqLCBwb2ludClcbiAgICByZXR1cm4gaXNWYWxpZCA/IDAgOiAzXG4gIH0sXG5cbiAgZWNkc2FSZWNvdmVyIChvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSB7XG4gICAgY29uc3Qgc2lnT2JqID0geyByOiBzaWcuc2xpY2UoMCwgMzIpLCBzOiBzaWcuc2xpY2UoMzIsIDY0KSB9XG5cbiAgICBjb25zdCBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICAgIGNvbnN0IHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gICAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcmV0dXJuIDFcblxuICAgIGlmIChzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiAyXG5cbiAgICAvLyBDYW4gdGhyb3cgYHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgc2VuY29uZCBrZXkgY2FuZGluYXRlJyk7YFxuICAgIGxldCBwb2ludFxuICAgIHRyeSB7XG4gICAgICBwb2ludCA9IGVjLnJlY292ZXJQdWJLZXkobXNnMzIsIHNpZ09iaiwgcmVjaWQpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gMlxuICAgIH1cblxuICAgIHNhdmVQdWJsaWNLZXkob3V0cHV0LCBwb2ludClcblxuICAgIHJldHVybiAwXG4gIH0sXG5cbiAgZWNkaCAob3V0cHV0LCBwdWJrZXksIHNlY2tleSwgZGF0YSwgaGFzaGZuLCB4YnVmLCB5YnVmKSB7XG4gICAgY29uc3QgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVia2V5KVxuICAgIGlmIChwYWlyID09PSBudWxsKSByZXR1cm4gMVxuXG4gICAgY29uc3Qgc2NhbGFyID0gbmV3IEJOKHNlY2tleSlcbiAgICBpZiAoc2NhbGFyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkgcmV0dXJuIDJcblxuICAgIGNvbnN0IHBvaW50ID0gcGFpci5nZXRQdWJsaWMoKS5tdWwoc2NhbGFyKVxuXG4gICAgaWYgKGhhc2hmbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBkYXRhID0gcG9pbnQuZW5jb2RlKG51bGwsIHRydWUpXG4gICAgICBjb25zdCBzaGEyNTYgPSBlYy5oYXNoKCkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIG91dHB1dFtpXSA9IHNoYTI1NltpXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXhidWYpIHhidWYgPSBuZXcgVWludDhBcnJheSgzMilcbiAgICAgIGNvbnN0IHggPSBwb2ludC5nZXRYKCkudG9BcnJheSgnYmUnLCAzMilcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzI7ICsraSkgeGJ1ZltpXSA9IHhbaV1cblxuICAgICAgaWYgKCF5YnVmKSB5YnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG4gICAgICBjb25zdCB5ID0gcG9pbnQuZ2V0WSgpLnRvQXJyYXkoJ2JlJywgMzIpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyArK2kpIHlidWZbaV0gPSB5W2ldXG5cbiAgICAgIGNvbnN0IGhhc2ggPSBoYXNoZm4oeGJ1ZiwgeWJ1ZiwgZGF0YSlcblxuICAgICAgY29uc3QgaXNWYWxpZCA9IGhhc2ggaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGhhc2gubGVuZ3RoID09PSBvdXRwdXQubGVuZ3RoXG4gICAgICBpZiAoIWlzVmFsaWQpIHJldHVybiAyXG5cbiAgICAgIG91dHB1dC5zZXQoaGFzaClcbiAgICB9XG5cbiAgICByZXR1cm4gMFxuICB9XG59XG4iLCJjb25zdCBlcnJvcnMgPSB7XG4gIElNUE9TU0lCTEVfQ0FTRTogJ0ltcG9zc2libGUgY2FzZS4gUGxlYXNlIGNyZWF0ZSBpc3N1ZS4nLFxuICBUV0VBS19BREQ6XG4gICAgJ1RoZSB0d2VhayB3YXMgb3V0IG9mIHJhbmdlIG9yIHRoZSByZXN1bHRlZCBwcml2YXRlIGtleSBpcyBpbnZhbGlkJyxcbiAgVFdFQUtfTVVMOiAnVGhlIHR3ZWFrIHdhcyBvdXQgb2YgcmFuZ2Ugb3IgZXF1YWwgdG8gemVybycsXG4gIENPTlRFWFRfUkFORE9NSVpFX1VOS05PVzogJ1Vua25vdyBlcnJvciBvbiBjb250ZXh0IHJhbmRvbWl6YXRpb24nLFxuICBTRUNLRVlfSU5WQUxJRDogJ1ByaXZhdGUgS2V5IGlzIGludmFsaWQnLFxuICBQVUJLRVlfUEFSU0U6ICdQdWJsaWMgS2V5IGNvdWxkIG5vdCBiZSBwYXJzZWQnLFxuICBQVUJLRVlfU0VSSUFMSVpFOiAnUHVibGljIEtleSBzZXJpYWxpemF0aW9uIGVycm9yJyxcbiAgUFVCS0VZX0NPTUJJTkU6ICdUaGUgc3VtIG9mIHRoZSBwdWJsaWMga2V5cyBpcyBub3QgdmFsaWQnLFxuICBTSUdfUEFSU0U6ICdTaWduYXR1cmUgY291bGQgbm90IGJlIHBhcnNlZCcsXG4gIFNJR046ICdUaGUgbm9uY2UgZ2VuZXJhdGlvbiBmdW5jdGlvbiBmYWlsZWQsIG9yIHRoZSBwcml2YXRlIGtleSB3YXMgaW52YWxpZCcsXG4gIFJFQ09WRVI6ICdQdWJsaWMga2V5IGNvdWxkIG5vdCBiZSByZWNvdmVyJyxcbiAgRUNESDogJ1NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZCwgbXNnKSB7XG4gIGlmICghY29uZCkgdGhyb3cgbmV3IEVycm9yKG1zZylcbn1cblxuZnVuY3Rpb24gaXNVaW50OEFycmF5IChuYW1lLCB2YWx1ZSwgbGVuZ3RoKSB7XG4gIGFzc2VydCh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXksIGBFeHBlY3RlZCAke25hbWV9IHRvIGJlIGFuIFVpbnQ4QXJyYXlgKVxuXG4gIGlmIChsZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGxlbmd0aCkpIHtcbiAgICAgIGNvbnN0IG51bWJlcnMgPSBsZW5ndGguam9pbignLCAnKVxuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCBbJHtudW1iZXJzfV1gXG4gICAgICBhc3NlcnQobGVuZ3RoLmluY2x1ZGVzKHZhbHVlLmxlbmd0aCksIG1zZylcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGVkICR7bmFtZX0gdG8gYmUgYW4gVWludDhBcnJheSB3aXRoIGxlbmd0aCAke2xlbmd0aH1gXG4gICAgICBhc3NlcnQodmFsdWUubGVuZ3RoID09PSBsZW5ndGgsIG1zZylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNDb21wcmVzc2VkICh2YWx1ZSkge1xuICBhc3NlcnQodG9UeXBlU3RyaW5nKHZhbHVlKSA9PT0gJ0Jvb2xlYW4nLCAnRXhwZWN0ZWQgY29tcHJlc3NlZCB0byBiZSBhIEJvb2xlYW4nKVxufVxuXG5mdW5jdGlvbiBnZXRBc3NlcnRlZE91dHB1dCAob3V0cHV0ID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Ygb3V0cHV0ID09PSAnZnVuY3Rpb24nKSBvdXRwdXQgPSBvdXRwdXQobGVuZ3RoKVxuICBpc1VpbnQ4QXJyYXkoJ291dHB1dCcsIG91dHB1dCwgbGVuZ3RoKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbmZ1bmN0aW9uIHRvVHlwZVN0cmluZyAodmFsdWUpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gKHNlY3AyNTZrMSkgPT4ge1xuICByZXR1cm4ge1xuICAgIGNvbnRleHRSYW5kb21pemUgKHNlZWQpIHtcbiAgICAgIGFzc2VydChcbiAgICAgICAgc2VlZCA9PT0gbnVsbCB8fCBzZWVkIGluc3RhbmNlb2YgVWludDhBcnJheSxcbiAgICAgICAgJ0V4cGVjdGVkIHNlZWQgdG8gYmUgYW4gVWludDhBcnJheSBvciBudWxsJ1xuICAgICAgKVxuICAgICAgaWYgKHNlZWQgIT09IG51bGwpIGlzVWludDhBcnJheSgnc2VlZCcsIHNlZWQsIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5jb250ZXh0UmFuZG9taXplKHNlZWQpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLkNPTlRFWFRfUkFORE9NSVpFX1VOS05PVylcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVZlcmlmeSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KHNlY2tleSkgPT09IDBcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZSAoc2Vja2V5KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShzZWNrZXkpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gc2Vja2V5XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleVR3ZWFrQWRkIChzZWNrZXksIHR3ZWFrKSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3ByaXZhdGUga2V5Jywgc2Vja2V5LCAzMilcbiAgICAgIGlzVWludDhBcnJheSgndHdlYWsnLCB0d2VhaywgMzIpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChzZWNrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNlY2tleVxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5UV0VBS19BREQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlUd2Vha011bCAoc2Vja2V5LCB0d2Vhaykge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wcml2YXRlS2V5VHdlYWtNdWwoc2Vja2V5LCB0d2VhaykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBzZWNrZXlcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnkgKHB1YmtleSkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVia2V5KSA9PT0gMFxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGUgKHNlY2tleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnB1YmxpY0tleUNyZWF0ZShvdXRwdXQsIHNlY2tleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0VDS0VZX0lOVkFMSUQpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleUNvbnZlcnQgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29udmVydChvdXRwdXQsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfU0VSSUFMSVpFKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlOZWdhdGUgKHB1YmtleSwgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5TmVnYXRlKG91dHB1dCwgcHVia2V5KSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1NFUklBTElaRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29tYmluZSAocHVia2V5cywgY29tcHJlc3NlZCA9IHRydWUsIG91dHB1dCkge1xuICAgICAgYXNzZXJ0KEFycmF5LmlzQXJyYXkocHVia2V5cyksICdFeHBlY3RlZCBwdWJsaWMga2V5cyB0byBiZSBhbiBBcnJheScpXG4gICAgICBhc3NlcnQocHVia2V5cy5sZW5ndGggPiAwLCAnRXhwZWN0ZWQgcHVibGljIGtleXMgYXJyYXkgd2lsbCBoYXZlIG1vcmUgdGhhbiB6ZXJvIGl0ZW1zJylcbiAgICAgIGZvciAoY29uc3QgcHVia2V5IG9mIHB1YmtleXMpIHtcbiAgICAgICAgaXNVaW50OEFycmF5KCdwdWJsaWMga2V5JywgcHVia2V5LCBbMzMsIDY1XSlcbiAgICAgIH1cbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShvdXRwdXQsIHB1YmtleXMpKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX0NPTUJJTkUpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9TRVJJQUxJWkUpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHB1YmxpY0tleVR3ZWFrQWRkIChwdWJrZXksIHR3ZWFrLCBjb21wcmVzc2VkID0gdHJ1ZSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCd0d2VhaycsIHR3ZWFrLCAzMilcbiAgICAgIGlzQ29tcHJlc3NlZChjb21wcmVzc2VkKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCBjb21wcmVzc2VkID8gMzMgOiA2NSlcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQob3V0cHV0LCBwdWJrZXksIHR3ZWFrKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlRXRUFLX0FERClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcHVibGljS2V5VHdlYWtNdWwgKHB1YmtleSwgdHdlYWssIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG4gICAgICBpc1VpbnQ4QXJyYXkoJ3R3ZWFrJywgdHdlYWssIDMyKVxuICAgICAgaXNDb21wcmVzc2VkKGNvbXByZXNzZWQpXG4gICAgICBvdXRwdXQgPSBnZXRBc3NlcnRlZE91dHB1dChvdXRwdXQsIGNvbXByZXNzZWQgPyAzMyA6IDY1KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChvdXRwdXQsIHB1YmtleSwgdHdlYWspKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByZXR1cm4gb3V0cHV0XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlBVQktFWV9QQVJTRSlcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuVFdFQUtfTVVMKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemUgKHNpZykge1xuICAgICAgaXNVaW50OEFycmF5KCdzaWduYXR1cmUnLCBzaWcsIDY0KVxuXG4gICAgICBzd2l0Y2ggKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIHNpZ1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNzIpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgb3V0cHV0LCBvdXRwdXRsZW46IDcyIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChvYmosIHNpZykpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXQuc2xpY2UoMCwgb2JqLm91dHB1dGxlbilcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydCAoc2lnLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnKVxuICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCA2NClcblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuc2lnbmF0dXJlSW1wb3J0KG91dHB1dCwgc2lnKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkc2FTaWduIChtc2czMiwgc2Vja2V5LCBvcHRpb25zID0ge30sIG91dHB1dCkge1xuICAgICAgaXNVaW50OEFycmF5KCdtZXNzYWdlJywgbXNnMzIsIDMyKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5ub25jZWZuICE9PSB1bmRlZmluZWQpIGFzc2VydCh0b1R5cGVTdHJpbmcob3B0aW9ucy5ub25jZWZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMubm9uY2VmbiB0byBiZSBhIEZ1bmN0aW9uJylcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgNjQpXG5cbiAgICAgIGNvbnN0IG9iaiA9IHsgc2lnbmF0dXJlOiBvdXRwdXQsIHJlY2lkOiBudWxsIH1cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhU2lnbihvYmosIG1zZzMyLCBzZWNrZXksIG9wdGlvbnMuZGF0YSwgb3B0aW9ucy5ub25jZWZuKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdOKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5JTVBPU1NJQkxFX0NBU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhVmVyaWZ5IChzaWcsIG1zZzMyLCBwdWJrZXkpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGlzVWludDhBcnJheSgnbWVzc2FnZScsIG1zZzMyLCAzMilcbiAgICAgIGlzVWludDhBcnJheSgncHVibGljIGtleScsIHB1YmtleSwgWzMzLCA2NV0pXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KHNpZywgbXNnMzIsIHB1YmtleSkpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuU0lHX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5QVUJLRVlfUEFSU0UpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVjZHNhUmVjb3ZlciAoc2lnLCByZWNpZCwgbXNnMzIsIGNvbXByZXNzZWQgPSB0cnVlLCBvdXRwdXQpIHtcbiAgICAgIGlzVWludDhBcnJheSgnc2lnbmF0dXJlJywgc2lnLCA2NClcbiAgICAgIGFzc2VydChcbiAgICAgICAgdG9UeXBlU3RyaW5nKHJlY2lkKSA9PT0gJ051bWJlcicgJiZcbiAgICAgICAgICByZWNpZCA+PSAwICYmXG4gICAgICAgICAgcmVjaWQgPD0gMyxcbiAgICAgICAgJ0V4cGVjdGVkIHJlY292ZXJ5IGlkIHRvIGJlIGEgTnVtYmVyIHdpdGhpbiBpbnRlcnZhbCBbMCwgM10nXG4gICAgICApXG4gICAgICBpc1VpbnQ4QXJyYXkoJ21lc3NhZ2UnLCBtc2czMiwgMzIpXG4gICAgICBpc0NvbXByZXNzZWQoY29tcHJlc3NlZClcbiAgICAgIG91dHB1dCA9IGdldEFzc2VydGVkT3V0cHV0KG91dHB1dCwgY29tcHJlc3NlZCA/IDMzIDogNjUpXG5cbiAgICAgIHN3aXRjaCAoc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihvdXRwdXQsIHNpZywgcmVjaWQsIG1zZzMyKSkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5TSUdfUEFSU0UpXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLlJFQ09WRVIpXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JzLklNUE9TU0lCTEVfQ0FTRSlcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZWNkaCAocHVia2V5LCBzZWNrZXksIG9wdGlvbnMgPSB7fSwgb3V0cHV0KSB7XG4gICAgICBpc1VpbnQ4QXJyYXkoJ3B1YmxpYyBrZXknLCBwdWJrZXksIFszMywgNjVdKVxuICAgICAgaXNVaW50OEFycmF5KCdwcml2YXRlIGtleScsIHNlY2tleSwgMzIpXG4gICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMpID09PSAnT2JqZWN0JywgJ0V4cGVjdGVkIG9wdGlvbnMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIGlmIChvcHRpb25zLmRhdGEgIT09IHVuZGVmaW5lZCkgaXNVaW50OEFycmF5KCdvcHRpb25zLmRhdGEnLCBvcHRpb25zLmRhdGEpXG4gICAgICBpZiAob3B0aW9ucy5oYXNoZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQodG9UeXBlU3RyaW5nKG9wdGlvbnMuaGFzaGZuKSA9PT0gJ0Z1bmN0aW9uJywgJ0V4cGVjdGVkIG9wdGlvbnMuaGFzaGZuIHRvIGJlIGEgRnVuY3Rpb24nKVxuICAgICAgICBpZiAob3B0aW9ucy54YnVmICE9PSB1bmRlZmluZWQpIGlzVWludDhBcnJheSgnb3B0aW9ucy54YnVmJywgb3B0aW9ucy54YnVmLCAzMilcbiAgICAgICAgaWYgKG9wdGlvbnMueWJ1ZiAhPT0gdW5kZWZpbmVkKSBpc1VpbnQ4QXJyYXkoJ29wdGlvbnMueWJ1ZicsIG9wdGlvbnMueWJ1ZiwgMzIpXG4gICAgICAgIGlzVWludDhBcnJheSgnb3V0cHV0Jywgb3V0cHV0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gZ2V0QXNzZXJ0ZWRPdXRwdXQob3V0cHV0LCAzMilcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChzZWNwMjU2azEuZWNkaChvdXRwdXQsIHB1YmtleSwgc2Vja2V5LCBvcHRpb25zLmRhdGEsIG9wdGlvbnMuaGFzaGZuLCBvcHRpb25zLnhidWYsIG9wdGlvbnMueWJ1ZikpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcnMuUFVCS0VZX1BBUlNFKVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9ycy5FQ0RIKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICovXG5cbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZmFpbHVyZSwgZmFpbHVyZXMpIHtcbiAgICBsZXQgY2FjaGVkO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IGZhaWx1cmU7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IG1zZyA9IHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IGBBdCBwYXRoOiAke3BhdGguam9pbignLicpfSAtLSAke21lc3NhZ2V9YDtcbiAgICBzdXBlcihtc2cpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMucmVmaW5lbWVudCA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy5icmFuY2ggPSB2b2lkIDA7XG4gICAgdGhpcy5mYWlsdXJlcyA9IHZvaWQgMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gY2FjaGVkID8/IChjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV0pO1xuICAgIH07XG4gIH1cblxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbi8qKlxuICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogYCR7dmFsdWV9YDtcbn1cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cblxuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICBjb25zdCB7XG4gICAgZG9uZSxcbiAgICB2YWx1ZVxuICB9ID0gaW5wdXQubmV4dCgpO1xuICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbWVzc2FnZTogcmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qge1xuICAgIHJlZmluZW1lbnQsXG4gICAgbWVzc2FnZSA9IGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXFxgJHt0eXBlfVxcYCR7cmVmaW5lbWVudCA/IGAgd2l0aCByZWZpbmVtZW50IFxcYCR7cmVmaW5lbWVudH1cXGBgIDogJyd9LCBidXQgcmVjZWl2ZWQ6IFxcYCR7cHJpbnQodmFsdWUpfVxcYGBcbiAgfSA9IHJlc3VsdDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICB0eXBlLFxuICAgIHJlZmluZW1lbnQsXG4gICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgcGF0aCxcbiAgICBicmFuY2gsXG4gICAgLi4ucmVzdWx0LFxuICAgIG1lc3NhZ2VcbiAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5cbmZ1bmN0aW9uKiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICB9XG5cbiAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgIGNvbnN0IGZhaWx1cmUgPSB0b0ZhaWx1cmUociwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSk7XG5cbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cblxuZnVuY3Rpb24qIHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7XG4gICAgcGF0aCA9IFtdLFxuICAgIGJyYW5jaCA9IFt2YWx1ZV0sXG4gICAgY29lcmNlID0gZmFsc2UsXG4gICAgbWFzayA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBjdHggPSB7XG4gICAgcGF0aCxcbiAgICBicmFuY2hcbiAgfTtcblxuICBpZiAoY29lcmNlKSB7XG4gICAgdmFsdWUgPSBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcblxuICAgIGlmIChtYXNrICYmIHN0cnVjdC50eXBlICE9PSAndHlwZScgJiYgaXNPYmplY3Qoc3RydWN0LnNjaGVtYSkgJiYgaXNPYmplY3QodmFsdWUpICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKHN0cnVjdC5zY2hlbWFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZGVsZXRlIHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsZXQgc3RhdHVzID0gJ3ZhbGlkJztcblxuICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgIHN0YXR1cyA9ICdub3RfdmFsaWQnO1xuICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgIGJyYW5jaDogayA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgdl0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgIHN0YXR1cyA9IHRbMF0ucmVmaW5lbWVudCAhPSBudWxsID8gJ25vdF9yZWZpbmVkJyA6ICdub3RfdmFsaWQnO1xuICAgICAgICB5aWVsZCBbdFswXSwgdW5kZWZpbmVkXTtcbiAgICAgIH0gZWxzZSBpZiAoY29lcmNlKSB7XG4gICAgICAgIHYgPSB0WzFdO1xuXG4gICAgICAgIGlmIChrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YWx1ZSA9IHY7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICB2YWx1ZS5zZXQoaywgdik7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICB2YWx1ZS5hZGQodik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKHYgIT09IHVuZGVmaW5lZCkgdmFsdWVba10gPSB2O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXR1cyAhPT0gJ25vdF92YWxpZCcpIHtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgIHN0YXR1cyA9ICdub3RfcmVmaW5lZCc7XG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhdHVzID09PSAndmFsaWQnKSB7XG4gICAgeWllbGQgW3VuZGVmaW5lZCwgdmFsdWVdO1xuICB9XG59XG5cbi8qKlxuICogYFN0cnVjdGAgb2JqZWN0cyBlbmNhcHN1bGF0ZSB0aGUgdmFsaWRhdGlvbiBsb2dpYyBmb3IgYSBzcGVjaWZpYyB0eXBlIG9mXG4gKiB2YWx1ZXMuIE9uY2UgY29uc3RydWN0ZWQsIHlvdSB1c2UgdGhlIGBhc3NlcnRgLCBgaXNgIG9yIGB2YWxpZGF0ZWAgaGVscGVycyB0b1xuICogdmFsaWRhdGUgdW5rbm93biBpbnB1dCBkYXRhIGFnYWluc3QgdGhlIHN0cnVjdC5cbiAqL1xuXG5jbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHRoaXMuVFlQRSA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5zY2hlbWEgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2VyY2VyID0gdm9pZCAwO1xuICAgIHRoaXMudmFsaWRhdG9yID0gdm9pZCAwO1xuICAgIHRoaXMucmVmaW5lciA9IHZvaWQgMDtcbiAgICB0aGlzLmVudHJpZXMgPSB2b2lkIDA7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIHZhbGlkYXRvcixcbiAgICAgIHJlZmluZXIsXG4gICAgICBjb2VyY2VyID0gdmFsdWUgPT4gdmFsdWUsXG4gICAgICBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHt9XG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyO1xuXG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgIH1cblxuICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICovXG5cblxuICBhc3NlcnQodmFsdWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAqL1xuXG5cbiAgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgKi9cblxuXG4gIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBkZWZpbmVkIGJ5IHRoZSBzdHJ1Y3QncyBzY2hlbWEuXG4gICAqL1xuXG5cbiAgbWFzayh2YWx1ZSkge1xuICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICpcbiAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgKi9cblxuXG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gIH1cblxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwge1xuICAgIGNvZXJjZTogdHJ1ZVxuICB9KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbi8qKlxuICogTWFzayBhIHZhbHVlLCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgZGVmaW5lZCBieSBhIHN0cnVjdC5cbiAqL1xuXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwge1xuICAgIGNvZXJjZTogdHJ1ZSxcbiAgICBtYXNrOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdC5cbiAqL1xuXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuICByZXR1cm4gIXJlc3VsdFswXTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCByZXR1cm5pbmcgYW4gZXJyb3IgaWYgaW52YWxpZCwgb3IgdGhlXG4gKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHR1cGxlcyA9IHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zKTtcbiAgY29uc3QgdHVwbGUgPSBzaGlmdEl0ZXJhdG9yKHR1cGxlcyk7XG5cbiAgaWYgKHR1cGxlWzBdKSB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgU3RydWN0RXJyb3IodHVwbGVbMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBmb3IgKGNvbnN0IHQgb2YgdHVwbGVzKSB7XG4gICAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgICAgeWllbGQgdFswXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbZXJyb3IsIHVuZGVmaW5lZF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdiA9IHR1cGxlWzFdO1xuICAgIHJldHVybiBbdW5kZWZpbmVkLCB2XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ24oKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBTdHJ1Y3RzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIFN0cnVjdHNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBjb25zdCBpc1R5cGUgPSBTdHJ1Y3RzWzBdLnR5cGUgPT09ICd0eXBlJztcbiAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKHMgPT4gcy5zY2hlbWEpO1xuICBjb25zdCBzY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zY2hlbWFzKTtcbiAgcmV0dXJuIGlzVHlwZSA/IHR5cGUoc2NoZW1hKSA6IG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IG5hbWUsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgIHZhbGlkYXRvclxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cblxuZnVuY3Rpb24gZHluYW1pYyhmbikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5cbmZ1bmN0aW9uIGxhenkoZm4pIHtcbiAgbGV0IHN0cnVjdDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsYXp5JyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBzdHJ1Y3QgPz8gKHN0cnVjdCA9IGZuKCkpO1xuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHN0cnVjdCA/PyAoc3RydWN0ID0gZm4oKSk7XG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgc3RydWN0ID8/IChzdHJ1Y3QgPSBmbigpKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICBjb25zdCB7XG4gICAgc2NoZW1hXG4gIH0gPSBzdHJ1Y3Q7XG4gIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hXG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICBjYXNlICd0eXBlJzpcbiAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IHdpdGggYWxsIG9mIGl0c1xuICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQYXJ0aWFsYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gIGNvbnN0IHNjaGVtYSA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYVxuICB9IDogeyAuLi5zdHJ1Y3RcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBzY2hlbWFba2V5XSA9IG9wdGlvbmFsKHNjaGVtYVtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgY29uc3Qge1xuICAgIHNjaGVtYVxuICB9ID0gc3RydWN0O1xuICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgc3Vic2NoZW1hW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cblxuZnVuY3Rpb24gc3RydWN0KG5hbWUsIHZhbGlkYXRvcikge1xuICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgc2NoZW1hOiBFbGVtZW50LFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBhcnJheSB2YWx1ZSwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJpZ2ludC5cbiAqL1xuXG5mdW5jdGlvbiBiaWdpbnQoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2JpZ2ludCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYmlnaW50JztcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBib29sZWFuLlxuICovXG5cbmZ1bmN0aW9uIGJvb2xlYW4oKSB7XG4gIHJldHVybiBkZWZpbmUoJ2Jvb2xlYW4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHZhbGlkIGBEYXRlYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGFsc28gZW5zdXJlcyB0aGF0IHRoZSB2YWx1ZSBpcyAqbm90KiBhbiBpbnZhbGlkIGBEYXRlYCBvYmplY3QsXG4gKiB3aGljaCBjYW4gb2NjdXIgd2hlbiBwYXJzaW5nIGEgZGF0ZSBmYWlscyBidXQgc3RpbGwgcmV0dXJucyBhIGBEYXRlYC5cbiAqL1xuXG5mdW5jdGlvbiBkYXRlKCkge1xuICByZXR1cm4gZGVmaW5lKCdkYXRlJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIERhdGUgJiYgIWlzTmFOKHZhbHVlLmdldFRpbWUoKSkgfHwgYEV4cGVjdGVkIGEgdmFsaWQgXFxgRGF0ZVxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgY29uc3Qgc2NoZW1hID0ge307XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVzLm1hcCh2ID0+IHByaW50KHYpKS5qb2luKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2VudW1zJyxcbiAgICBzY2hlbWEsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8IGBFeHBlY3RlZCBvbmUgb2YgXFxgJHtkZXNjcmlwdGlvbn1cXGAsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBmdW5jKCkge1xuICByZXR1cm4gZGVmaW5lKCdmdW5jJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgfHwgYEV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuXG5mdW5jdGlvbiBpbnN0YW5jZShDbGFzcykge1xuICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDbGFzcyB8fCBgRXhwZWN0ZWQgYSBcXGAke0NsYXNzLm5hbWV9XFxgIGluc3RhbmNlLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cblxuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgYWxsIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICBjb25zdCB0ID0gdHlwZW9mIGNvbnN0YW50O1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IGNvbnN0YW50IHx8IGBFeHBlY3RlZCB0aGUgbGl0ZXJhbCBcXGAke2Rlc2NyaXB0aW9ufVxcYCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbWFwJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEtleSAmJiBWYWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IGBFeHBlY3RlZCBhIFxcYE1hcFxcYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IG5vIHZhbHVlIGV2ZXIgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xufVxuLyoqXG4gKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuXG5mdW5jdGlvbiBudW1iZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ251bWJlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpIHx8IGBFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWVcbiAgICAgIH0gOiB2YWx1ZTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGgga2V5cyBhbmQgdmFsdWVzIG9mIHNwZWNpZmljIHR5cGVzLCBidXRcbiAqIHdpdGhvdXQgZW5zdXJpbmcgYW55IHNwZWNpZmljIHNoYXBlIG9mIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFJlY29yZGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3JlY29yZCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IGBFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAqIHlvdSBuZWVkIHRvIHVzZSB0aGUgYHBhdHRlcm4oKWAgcmVmaW5lbWVudC5cbiAqL1xuXG5mdW5jdGlvbiByZWdleHAoKSB7XG4gIHJldHVybiBkZWZpbmUoJ3JlZ2V4cCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdzZXQnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgfHwgYEV4cGVjdGVkIGEgXFxgU2V0XFxgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke3ByaW50KHZhbHVlKX1gO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gIHJldHVybiBkZWZpbmUoJ3N0cmluZycsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB0dXBsZSBvZiBhIHNwZWNpZmljIGxlbmd0aCwgYW5kIHRoYXQgZWFjaCBvZiBpdHNcbiAqIGVsZW1lbnRzIGlzIG9mIGEgc3BlY2lmaWMgdHlwZS5cbiAqL1xuXG5mdW5jdGlvbiB0dXBsZShTdHJ1Y3RzKSB7XG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd0dXBsZScsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBNYXRoLm1heChTdHJ1Y3RzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBTdHJ1Y3RzW2ldIHx8IE5ldmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogJHtwcmludCh2YWx1ZSl9YDtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R5cGUnLFxuICAgIHNjaGVtYSxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBgRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWA7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcChzID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndW5pb24nLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmlyc3RNYXRjaCA9IFN0cnVjdHMuZmluZChzID0+IHtcbiAgICAgICAgY29uc3QgW2VdID0gcy52YWxpZGF0ZSh2YWx1ZSwge1xuICAgICAgICAgIGNvZXJjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICFlO1xuICAgICAgfSkgfHwgdW5rbm93bigpO1xuICAgICAgcmV0dXJuIGZpcnN0TWF0Y2guY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuXG4gICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2BFeHBlY3RlZCB0aGUgdmFsdWUgdG8gc2F0aXNmeSBhIHVuaW9uIG9mIFxcYCR7ZGVzY3JpcHRpb259XFxgLCBidXQgcmVjZWl2ZWQ6ICR7cHJpbnQodmFsdWUpfWAsIC4uLmZhaWx1cmVzXTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqL1xuXG5mdW5jdGlvbiB1bmtub3duKCkge1xuICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG59XG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbikgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0ZWQoc3RydWN0LCBmYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHVua25vd24oKSwgeCA9PiB7XG4gICAgY29uc3QgZiA9IHR5cGVvZiBmYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IGZhbGxiYWNrKCkgOiBmYWxsYmFjaztcblxuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmO1xuICAgIH1cblxuICAgIGlmICghb3B0aW9ucy5zdHJpY3QgJiYgaXNQbGFpbk9iamVjdCh4KSAmJiBpc1BsYWluT2JqZWN0KGYpKSB7XG4gICAgICBjb25zdCByZXQgPSB7IC4uLnhcbiAgICAgIH07XG4gICAgICBsZXQgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBmKSB7XG4gICAgICAgIGlmIChyZXRba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0W2tleV0gPSBmW2tleV07XG4gICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geDtcbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gdHJpbSBzdHJpbmcgaW5wdXRzLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIHRyaW1tZWQoc3RydWN0KSB7XG4gIHJldHVybiBjb2VyY2Uoc3RydWN0LCBzdHJpbmcoKSwgeCA9PiB4LnRyaW0oKSk7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBtYXAsIG9yIHNldCBpcyBlbXB0eS5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eShzdHJ1Y3QpIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsIHZhbHVlID0+IHtcbiAgICBjb25zdCBzaXplID0gZ2V0U2l6ZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHNpemUgPT09IDAgfHwgYEV4cGVjdGVkIGFuIGVtcHR5ICR7c3RydWN0LnR5cGV9IGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgXFxgJHtzaXplfVxcYGA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgIHJldHVybiB2YWx1ZS5zaXplO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZS5sZW5ndGg7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGV4Y2x1c2l2ZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtYXgnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1c2l2ZSA/IHZhbHVlIDwgdGhyZXNob2xkIDogdmFsdWUgPD0gdGhyZXNob2xkIHx8IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGxlc3MgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGFib3ZlIGEgdGhyZXNob2xkLlxuICovXG5cbmZ1bmN0aW9uIG1pbihzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIGV4Y2x1c2l2ZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1c2l2ZSA/IHZhbHVlID4gdGhyZXNob2xkIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8IGBFeHBlY3RlZCBhICR7c3RydWN0LnR5cGV9IGdyZWF0ZXIgdGhhbiAke2V4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICd9JHt0aHJlc2hvbGR9IGJ1dCByZWNlaXZlZCBcXGAke3ZhbHVlfVxcYGA7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCBvciBzZXQgaXMgbm90IGVtcHR5LlxuICovXG5cbmZ1bmN0aW9uIG5vbmVtcHR5KHN0cnVjdCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ25vbmVtcHR5JywgdmFsdWUgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICByZXR1cm4gc2l6ZSA+IDAgfHwgYEV4cGVjdGVkIGEgbm9uZW1wdHkgJHtzdHJ1Y3QudHlwZX0gYnV0IHJlY2VpdmVkIGFuIGVtcHR5IG9uZWA7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSkgfHwgYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX0gbWF0Y2hpbmcgXFxgLyR7cmVnZXhwLnNvdXJjZX0vXFxgIGJ1dCByZWNlaXZlZCBcIiR7dmFsdWV9XCJgO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBzdHJpbmcsIGFycmF5LCBudW1iZXIsIGRhdGUsIG1hcCwgb3Igc2V0IGhhcyBhIHNpemUgKG9yIGxlbmd0aCwgb3IgdGltZSkgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAuXG4gKi9cblxuZnVuY3Rpb24gc2l6ZShzdHJ1Y3QsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT09IHZvaWQgMCkge1xuICAgIG1heCA9IG1pbjtcbiAgfVxuXG4gIGNvbnN0IGV4cGVjdGVkID0gYEV4cGVjdGVkIGEgJHtzdHJ1Y3QudHlwZX1gO1xuICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gYG9mIFxcYCR7bWlufVxcYGAgOiBgYmV0d2VlbiBcXGAke21pbn1cXGAgYW5kIFxcYCR7bWF4fVxcYGA7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnc2l6ZScsIHZhbHVlID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4IHx8IGAke2V4cGVjdGVkfSAke29mfSBidXQgcmVjZWl2ZWQgXFxgJHt2YWx1ZX1cXGBgO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2l6ZVxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1pbiA8PSBzaXplICYmIHNpemUgPD0gbWF4IHx8IGAke2V4cGVjdGVkfSB3aXRoIGEgc2l6ZSAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIFxcYCR7c2l6ZX1cXGBgO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG1pbiA8PSBsZW5ndGggJiYgbGVuZ3RoIDw9IG1heCB8fCBgJHtleHBlY3RlZH0gd2l0aCBhIGxlbmd0aCAke29mfSBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgXFxgJHtsZW5ndGh9XFxgYDtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgcmVmaW5lbWVudCB0byB0aGUgdmFsaWRhdGlvbi5cbiAqXG4gKiBUaGUgcmVmaW5lciBmdW5jdGlvbiBpcyBndWFyYW50ZWVkIHRvIHJlY2VpdmUgYSB2YWx1ZSBvZiB0aGUgc3RydWN0J3MgdHlwZSxcbiAqIGJlY2F1c2UgdGhlIHN0cnVjdCdzIGV4aXN0aW5nIHZhbGlkYXRpb24gd2lsbCBhbHJlYWR5IGhhdmUgcGFzc2VkLiBUaGlzXG4gKiBhbGxvd3MgeW91IHRvIGxheWVyIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiB0b3Agb2YgZXhpc3Rpbmcgc3RydWN0cy5cbiAqL1xuXG5mdW5jdGlvbiByZWZpbmUoc3RydWN0LCBuYW1lLCByZWZpbmVyKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuXG4gICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgeWllbGQqIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gdG9GYWlsdXJlcyhyZXN1bHQsIGN0eCwgc3RydWN0LCB2YWx1ZSk7XG5cbiAgICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBmYWlsdXJlcykge1xuICAgICAgICB5aWVsZCB7IC4uLmZhaWx1cmUsXG4gICAgICAgICAgcmVmaW5lbWVudDogbmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cblxuZXhwb3J0cy5TdHJ1Y3QgPSBTdHJ1Y3Q7XG5leHBvcnRzLlN0cnVjdEVycm9yID0gU3RydWN0RXJyb3I7XG5leHBvcnRzLmFueSA9IGFueTtcbmV4cG9ydHMuYXJyYXkgPSBhcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XG5leHBvcnRzLmJpZ2ludCA9IGJpZ2ludDtcbmV4cG9ydHMuYm9vbGVhbiA9IGJvb2xlYW47XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5kYXRlID0gZGF0ZTtcbmV4cG9ydHMuZGVmYXVsdGVkID0gZGVmYXVsdGVkO1xuZXhwb3J0cy5kZWZpbmUgPSBkZWZpbmU7XG5leHBvcnRzLmRlcHJlY2F0ZWQgPSBkZXByZWNhdGVkO1xuZXhwb3J0cy5keW5hbWljID0gZHluYW1pYztcbmV4cG9ydHMuZW1wdHkgPSBlbXB0eTtcbmV4cG9ydHMuZW51bXMgPSBlbnVtcztcbmV4cG9ydHMuZnVuYyA9IGZ1bmM7XG5leHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2U7XG5leHBvcnRzLmludGVnZXIgPSBpbnRlZ2VyO1xuZXhwb3J0cy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG5leHBvcnRzLmlzID0gaXM7XG5leHBvcnRzLmxhenkgPSBsYXp5O1xuZXhwb3J0cy5saXRlcmFsID0gbGl0ZXJhbDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5tYXNrID0gbWFzaztcbmV4cG9ydHMubWF4ID0gbWF4O1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm5ldmVyID0gbmV2ZXI7XG5leHBvcnRzLm5vbmVtcHR5ID0gbm9uZW1wdHk7XG5leHBvcnRzLm51bGxhYmxlID0gbnVsbGFibGU7XG5leHBvcnRzLm51bWJlciA9IG51bWJlcjtcbmV4cG9ydHMub2JqZWN0ID0gb2JqZWN0O1xuZXhwb3J0cy5vbWl0ID0gb21pdDtcbmV4cG9ydHMub3B0aW9uYWwgPSBvcHRpb25hbDtcbmV4cG9ydHMucGFydGlhbCA9IHBhcnRpYWw7XG5leHBvcnRzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuZXhwb3J0cy5waWNrID0gcGljaztcbmV4cG9ydHMucmVjb3JkID0gcmVjb3JkO1xuZXhwb3J0cy5yZWZpbmUgPSByZWZpbmU7XG5leHBvcnRzLnJlZ2V4cCA9IHJlZ2V4cDtcbmV4cG9ydHMuc2V0ID0gc2V0O1xuZXhwb3J0cy5zaXplID0gc2l6ZTtcbmV4cG9ydHMuc3RyaW5nID0gc3RyaW5nO1xuZXhwb3J0cy5zdHJ1Y3QgPSBzdHJ1Y3Q7XG5leHBvcnRzLnRyaW1tZWQgPSB0cmltbWVkO1xuZXhwb3J0cy50dXBsZSA9IHR1cGxlO1xuZXhwb3J0cy50eXBlID0gdHlwZTtcbmV4cG9ydHMudW5pb24gPSB1bmlvbjtcbmV4cG9ydHMudW5rbm93biA9IHVua25vd247XG5leHBvcnRzLnZhbGlkYXRlID0gdmFsaWRhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwXG4iLCJjb25zdCBmaWx0ZXJOb29wID0gKCkgPT4gdHJ1ZVxuY29uc3QgaW50ZXJuYWxFdmVudHMgPSBbJ25ld0xpc3RlbmVyJywgJ3JlbW92ZUxpc3RlbmVyJ11cbmNvbnN0IGV4dGVybmFsRXZlbnRGaWx0ZXIgPSAobmFtZSkgPT4gIWludGVybmFsRXZlbnRzLmluY2x1ZGVzKG5hbWUpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgKGluaXRpYWxUYXJnZXQsIG9wdHMpIHtcbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBvcHRzID0gb3B0cyB8fCB7fVxuICBsZXQgZXZlbnRGaWx0ZXIgPSBvcHRzLmV2ZW50RmlsdGVyIHx8IGZpbHRlck5vb3BcbiAgaWYgKGV2ZW50RmlsdGVyID09PSAnc2tpcEludGVybmFsJykgZXZlbnRGaWx0ZXIgPSBleHRlcm5hbEV2ZW50RmlsdGVyXG4gIGlmICh0eXBlb2YgZXZlbnRGaWx0ZXIgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignY3JlYXRlRXZlbnRFbWl0dGVyUHJveHkgLSBJbnZhbGlkIGV2ZW50RmlsdGVyJylcblxuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldFxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gJ3NldFRhcmdldCcpIHJldHVybiBzZXRUYXJnZXRcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSAnc2V0VGFyZ2V0Jykge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcHJveHlcblxuICBmdW5jdGlvbiBzZXRUYXJnZXQobmV3VGFyZ2V0KSB7XG4gICAgY29uc3Qgb2xkVGFyZ2V0ID0gdGFyZ2V0XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0XG4gICAgLy8gbWlncmF0ZSBsaXN0ZW5lcnNcbiAgICBvbGRUYXJnZXQuZXZlbnROYW1lcygpLmZpbHRlcihldmVudEZpbHRlcikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgZ2V0UmF3TGlzdGVuZXJzKG9sZFRhcmdldCwgbmFtZSkuZm9yRWFjaChoYW5kbGVyID0+IG5ld1RhcmdldC5vbihuYW1lLCBoYW5kbGVyKSlcbiAgICB9KVxuICAgIC8vIHJlbW92ZSBvbGRcbiAgICBvbGRUYXJnZXQucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSYXdMaXN0ZW5lcnMoZXZlbnRFbWl0dGVyLCBuYW1lKSB7XG4gIC8vIHByZWZlciBuYXRpdmVcbiAgaWYgKGV2ZW50RW1pdHRlci5yYXdMaXN0ZW5lcnMpIHJldHVybiBldmVudEVtaXR0ZXIucmF3TGlzdGVuZXJzKG5hbWUpXG4gIC8vIGZhbGxiYWNrIHRvIGxvb2t1cCBhZ2FpbnN0IGludGVybmFsIG9iamVjdFxuICBsZXQgZXZlbnRzID0gZXZlbnRFbWl0dGVyLl9ldmVudHNbbmFtZV0gfHwgW11cbiAgLy8gZW5zdXJlIGFycmF5XG4gIGlmICghQXJyYXkuaXNBcnJheShldmVudHMpKSBldmVudHMgPSBbZXZlbnRzXVxuICAvLyByZXR1cm4gY29weVxuICByZXR1cm4gZXZlbnRzLnNsaWNlKClcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVTd2FwcGFibGVQcm94eSAoaW5pdGlhbFRhcmdldCkge1xuICBsZXQgdGFyZ2V0ID0gaW5pdGlhbFRhcmdldFxuXG4gIGNvbnN0IHByb3h5ID0gbmV3IFByb3h5KHt9LCB7XG4gICAgZ2V0OiAoXywgbmFtZSkgPT4ge1xuICAgICAgLy8gb3ZlcnJpZGUgYHNldFRhcmdldGAgYWNjZXNzXG4gICAgICBpZiAobmFtZSA9PT0gJ3NldFRhcmdldCcpIHJldHVybiBzZXRUYXJnZXRcbiAgICAgIHJldHVybiB0YXJnZXRbbmFtZV1cbiAgICB9LFxuICAgIHNldDogKF8sIG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAvLyBhbGxvdyBgc2V0VGFyZ2V0YCBvdmVycmlkZXNcbiAgICAgIGlmIChuYW1lID09PSAnc2V0VGFyZ2V0Jykge1xuICAgICAgICBzZXRUYXJnZXQgPSB2YWx1ZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgdGFyZ2V0W25hbWVdID0gdmFsdWVcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSxcbiAgfSlcblxuICByZXR1cm4gcHJveHlcblxuICBmdW5jdGlvbiBzZXRUYXJnZXQobmV3VGFyZ2V0KSB7XG4gICAgdGFyZ2V0ID0gbmV3VGFyZ2V0XG4gIH1cbn1cbiIsImNvbnN0IGNyZWF0ZVN3YXBwYWJsZVByb3h5ID0gcmVxdWlyZSgnLi9jcmVhdGVTd2FwcGFibGVQcm94eScpXG5jb25zdCBjcmVhdGVFdmVudEVtaXR0ZXJQcm94eSA9IHJlcXVpcmUoJy4vY3JlYXRlRXZlbnRFbWl0dGVyUHJveHknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlU3dhcHBhYmxlUHJveHksXG4gIGNyZWF0ZUV2ZW50RW1pdHRlclByb3h5LFxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0b0RhdGFWaWV3IChkYXRhKSB7XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgSW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8IGRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YS5idWZmZXIsIGRhdGEuYnl0ZU9mZnNldCwgZGF0YS5ieXRlTGVuZ3RoKVxuICB9XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgRGF0YVZpZXcoZGF0YSlcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBkYXRhYCB0byBiZSBhbiBBcnJheUJ1ZmZlciwgQnVmZmVyLCBJbnQ4QXJyYXksIFVpbnQ4QXJyYXkgb3IgVWludDhDbGFtcGVkQXJyYXknKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLkZJQVRfUkFURVNfVVBEQVRFID0gZXhwb3J0cy5OT1RJRklDQVRJT04gPSBleHBvcnRzLkJMT0NLID0gZXhwb3J0cy5DT05ORUNUID0gZXhwb3J0cy5FUlJPUiA9IHZvaWQgMDtcbi8vIGJsb2NrY2hhaW4gZXZlbnRzXG52YXIgRVJST1IgPSAnYmxvY2tjaGFpbi1lcnJvcic7XG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgQ09OTkVDVCA9ICdibG9ja2NoYWluLWNvbm5lY3QnO1xuZXhwb3J0cy5DT05ORUNUID0gQ09OTkVDVDtcbnZhciBCTE9DSyA9ICdibG9ja2NoYWluLWJsb2NrJztcbmV4cG9ydHMuQkxPQ0sgPSBCTE9DSztcbnZhciBOT1RJRklDQVRJT04gPSAnYmxvY2tjaGFpbi1ub3RpZmljYXRpb24nO1xuZXhwb3J0cy5OT1RJRklDQVRJT04gPSBOT1RJRklDQVRJT047XG52YXIgRklBVF9SQVRFU19VUERBVEUgPSAnZmlhdC1yYXRlcy11cGRhdGUnO1xuZXhwb3J0cy5GSUFUX1JBVEVTX1VQREFURSA9IEZJQVRfUkFURVNfVVBEQVRFOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5QT09MX1JFTEFZX1RZUEUgPSBleHBvcnRzLkNFUlRJRklDQVRFX1RZUEUgPSBleHBvcnRzLkFERFJFU1NfVFlQRSA9IGV4cG9ydHMuTkVUV09SS19JRFMgPSBleHBvcnRzLlBST1RPQ09MX01BR0lDUyA9IHZvaWQgMDtcbnZhciBQUk9UT0NPTF9NQUdJQ1MgPSBPYmplY3QuZnJlZXplKHtcbiAgbWFpbm5ldDogNzY0ODI0MDczLFxuICB0ZXN0bmV0OiA0MlxufSk7XG5leHBvcnRzLlBST1RPQ09MX01BR0lDUyA9IFBST1RPQ09MX01BR0lDUztcbnZhciBORVRXT1JLX0lEUyA9IE9iamVjdC5mcmVlemUoe1xuICBtYWlubmV0OiAxLFxuICB0ZXN0bmV0OiAwXG59KTsgLy8gY29uc3RhbnRzIGJlbG93IGFyZSBkZXByZWNhdGVkXG4vLyB1c2UgYENhcmRhbm9BZGRyZXNzVHlwZWAsIGBDYXJkYW5vQ2VydGlmaWNhdGVUeXBlYCBhbmQgYENhcmRhbm9Qb29sUmVsYXlUeXBlYCBmcm9tIHByb3RvYnVmIGluc3RlYWRcblxuZXhwb3J0cy5ORVRXT1JLX0lEUyA9IE5FVFdPUktfSURTO1xudmFyIEFERFJFU1NfVFlQRSA9IE9iamVjdC5mcmVlemUoe1xuICBCYXNlOiAwLFxuICBQb2ludGVyOiA0LFxuICBFbnRlcnByaXNlOiA2LFxuICBCeXJvbjogOCxcbiAgUmV3YXJkOiAxNFxufSk7XG5leHBvcnRzLkFERFJFU1NfVFlQRSA9IEFERFJFU1NfVFlQRTtcbnZhciBDRVJUSUZJQ0FURV9UWVBFID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlUmVnaXN0cmF0aW9uOiAwLFxuICBTdGFrZURlcmVnaXN0cmF0aW9uOiAxLFxuICBTdGFrZURlbGVnYXRpb246IDIsXG4gIFN0YWtlUG9vbFJlZ2lzdHJhdGlvbjogM1xufSk7XG5leHBvcnRzLkNFUlRJRklDQVRFX1RZUEUgPSBDRVJUSUZJQ0FURV9UWVBFO1xudmFyIFBPT0xfUkVMQVlfVFlQRSA9IE9iamVjdC5mcmVlemUoe1xuICBTaW5nbGVIb3N0SXA6IDAsXG4gIFNpbmdsZUhvc3ROYW1lOiAxLFxuICBNdWx0aXBsZUhvc3ROYW1lOiAyXG59KTtcbmV4cG9ydHMuUE9PTF9SRUxBWV9UWVBFID0gUE9PTF9SRUxBWV9UWVBFOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5XQUlUX0ZPUl9TRUxFQ1RJT04gPSBleHBvcnRzLldPUkQgPSBleHBvcnRzLlBBU1NQSFJBU0VfT05fREVWSUNFID0gZXhwb3J0cy5QQVNTUEhSQVNFID0gZXhwb3J0cy5QSU4gPSBleHBvcnRzLkJVVFRPTiA9IGV4cG9ydHMuTE9BRElORyA9IGV4cG9ydHMuVVNFRF9FTFNFV0hFUkUgPSBleHBvcnRzLlJFTEVBU0VEID0gZXhwb3J0cy5BQ1FVSVJFRCA9IGV4cG9ydHMuUkVMRUFTRSA9IGV4cG9ydHMuQUNRVUlSRSA9IGV4cG9ydHMuQ0hBTkdFRCA9IGV4cG9ydHMuRElTQ09OTkVDVCA9IGV4cG9ydHMuQ09OTkVDVF9VTkFDUVVJUkVEID0gZXhwb3J0cy5DT05ORUNUID0gdm9pZCAwO1xuLy8gZGV2aWNlIGxpc3QgZXZlbnRzXG52YXIgQ09OTkVDVCA9ICdkZXZpY2UtY29ubmVjdCc7XG5leHBvcnRzLkNPTk5FQ1QgPSBDT05ORUNUO1xudmFyIENPTk5FQ1RfVU5BQ1FVSVJFRCA9ICdkZXZpY2UtY29ubmVjdF91bmFjcXVpcmVkJztcbmV4cG9ydHMuQ09OTkVDVF9VTkFDUVVJUkVEID0gQ09OTkVDVF9VTkFDUVVJUkVEO1xudmFyIERJU0NPTk5FQ1QgPSAnZGV2aWNlLWRpc2Nvbm5lY3QnO1xuZXhwb3J0cy5ESVNDT05ORUNUID0gRElTQ09OTkVDVDtcbnZhciBDSEFOR0VEID0gJ2RldmljZS1jaGFuZ2VkJztcbmV4cG9ydHMuQ0hBTkdFRCA9IENIQU5HRUQ7XG52YXIgQUNRVUlSRSA9ICdkZXZpY2UtYWNxdWlyZSc7XG5leHBvcnRzLkFDUVVJUkUgPSBBQ1FVSVJFO1xudmFyIFJFTEVBU0UgPSAnZGV2aWNlLXJlbGVhc2UnO1xuZXhwb3J0cy5SRUxFQVNFID0gUkVMRUFTRTtcbnZhciBBQ1FVSVJFRCA9ICdkZXZpY2UtYWNxdWlyZWQnO1xuZXhwb3J0cy5BQ1FVSVJFRCA9IEFDUVVJUkVEO1xudmFyIFJFTEVBU0VEID0gJ2RldmljZS1yZWxlYXNlZCc7XG5leHBvcnRzLlJFTEVBU0VEID0gUkVMRUFTRUQ7XG52YXIgVVNFRF9FTFNFV0hFUkUgPSAnZGV2aWNlLXVzZWRfZWxzZXdoZXJlJztcbmV4cG9ydHMuVVNFRF9FTFNFV0hFUkUgPSBVU0VEX0VMU0VXSEVSRTtcbnZhciBMT0FESU5HID0gJ2RldmljZS1sb2FkaW5nJzsgLy8gdHJlem9yLWxpbmsgZXZlbnRzIGluIHByb3RvYnVmIGZvcm1hdFxuXG5leHBvcnRzLkxPQURJTkcgPSBMT0FESU5HO1xudmFyIEJVVFRPTiA9ICdidXR0b24nO1xuZXhwb3J0cy5CVVRUT04gPSBCVVRUT047XG52YXIgUElOID0gJ3Bpbic7XG5leHBvcnRzLlBJTiA9IFBJTjtcbnZhciBQQVNTUEhSQVNFID0gJ3Bhc3NwaHJhc2UnO1xuZXhwb3J0cy5QQVNTUEhSQVNFID0gUEFTU1BIUkFTRTtcbnZhciBQQVNTUEhSQVNFX09OX0RFVklDRSA9ICdwYXNzcGhyYXNlX29uX2RldmljZSc7XG5leHBvcnRzLlBBU1NQSFJBU0VfT05fREVWSUNFID0gUEFTU1BIUkFTRV9PTl9ERVZJQ0U7XG52YXIgV09SRCA9ICd3b3JkJzsgLy8gY3VzdG9tXG5cbmV4cG9ydHMuV09SRCA9IFdPUkQ7XG52YXIgV0FJVF9GT1JfU0VMRUNUSU9OID0gJ2RldmljZS13YWl0X2Zvcl9zZWxlY3Rpb24nO1xuZXhwb3J0cy5XQUlUX0ZPUl9TRUxFQ1RJT04gPSBXQUlUX0ZPUl9TRUxFQ1RJT047IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5MSUJVU0JfRVJST1JfTUVTU0FHRSA9IGV4cG9ydHMuV0VCVVNCX0VSUk9SX01FU1NBR0UgPSBleHBvcnRzLklOVkFMSURfUElOX0VSUk9SX01FU1NBR0UgPSBleHBvcnRzLldST05HX1BSRVZJT1VTX1NFU1NJT05fRVJST1JfTUVTU0FHRSA9IGV4cG9ydHMuVHlwZWRFcnJvciA9IGV4cG9ydHMuVHJlem9yRXJyb3IgPSBleHBvcnRzLkVSUk9SX0NPREVTID0gdm9pZCAwO1xuXG52YXIgX2luaGVyaXRzTG9vc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCIpKTtcblxudmFyIF93cmFwTmF0aXZlU3VwZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXJcIikpO1xuXG52YXIgRVJST1JfQ09ERVMgPSB7XG4gIEluaXRfTm90SW5pdGlhbGl6ZWQ6ICdUcmV6b3JDb25uZWN0IG5vdCB5ZXQgaW5pdGlhbGl6ZWQnLFxuICAvLyByYWNlIGNvbmRpdGlvbjogY2FsbCBvbiBub3QgaW5pdGlhbGl6ZWQgQ29yZSAodXN1YWxseSBob3QtcmVsb2FkaW5nKVxuICBJbml0X0FscmVhZHlJbml0aWFsaXplZDogJ1RyZXpvckNvbm5lY3QgaGFzIGJlZW4gYWxyZWFkeSBpbml0aWFsaXplZCcsXG4gIC8vIHRocm93biBieSAuaW5pdCBjYWxsZWQgbXVsdGlwbGUgdGltZXNcbiAgSW5pdF9JZnJhbWVCbG9ja2VkOiAnSWZyYW1lIGJsb2NrZWQnLFxuICAvLyBpZnJhbWUgaW5qZWN0aW9uIGJsb2NrZWQgKGFkLWJsb2NrZXIpXG4gIEluaXRfSWZyYW1lVGltZW91dDogJ0lmcmFtZSB0aW1lb3V0JyxcbiAgLy8gaWZyYW1lIGRpZG4ndCBsb2FkIGluIHNwZWNpZmllZCB0aW1lXG4gIEluaXRfTWFuaWZlc3RNaXNzaW5nOiAnTWFuaWZlc3Qgbm90IHNldC4gUmVhZCBtb3JlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS90cmV6b3IvY29ubmVjdC9ibG9iL2RldmVsb3AvZG9jcy9pbmRleC5tZCcsXG4gIC8vIG1hbmlmZXN0IGlzIG5vdCBzZXRcbiAgUG9wdXBfQ29ubmVjdGlvbk1pc3Npbmc6ICdVbmFibGUgdG8gZXN0YWJsaXNoIGNvbm5lY3Rpb24gd2l0aCBpZnJhbWUnLFxuICAvLyB0aHJvd24gYnkgcG9wdXBcbiAgVHJhbnNwb3J0X01pc3Npbmc6ICdUcmFuc3BvcnQgaXMgbWlzc2luZycsXG4gIC8vIG5vIHRyYW5zcG9ydCBhdmFpbGFibGVcbiAgVHJhbnNwb3J0X0ludmFsaWRQcm90b2J1ZjogJycsXG4gIC8vIGdlbmVyaWMgZXJyb3IgZnJvbSB0cmFuc3BvcnQgbGF5ZXIgKHRyZXpvci1saW5rKVxuICBNZXRob2RfSW52YWxpZFBhY2thZ2U6ICdUaGlzIHZlcnNpb24gb2YgdHJlem9yLWNvbm5lY3QgaXMgbm90IHN1aXRhYmxlIHRvIHdvcmsgd2l0aG91dCBicm93c2VyLiBVc2UgdHJlem9yLWNvbm5lY3RAZXh0ZW5kZWQgcGFja2FnZSBpbnN0ZWFkJyxcbiAgLy8gdGhyb3duIGJ5IG5vZGUgYW5kIHJlYWN0LW5hdGl2ZSBlbnYgd2hpbGUgdXNpbmcgcmVndWxhciAnd2ViJyBwYWNrYWdlXG4gIE1ldGhvZF9JbnZhbGlkUGFyYW1ldGVyOiAnJyxcbiAgLy8gcmVwbGFjZWQgYnkgZ2VuZXJpYyB0ZXh0XG4gIE1ldGhvZF9Ob3RBbGxvd2VkOiAnTWV0aG9kIG5vdCBhbGxvd2VkIGZvciB0aGlzIGNvbmZpZ3VyYXRpb24nLFxuICAvLyBleGFtcGxlOiBkZXZpY2UgbWFuYWdlbWVudCBpbiBwb3B1cCBtb2RlXG4gIE1ldGhvZF9QZXJtaXNzaW9uc05vdEdyYW50ZWQ6ICdQZXJtaXNzaW9ucyBub3QgZ3JhbnRlZCcsXG4gIC8vIHBlcm1pc3Npb24vY29uZmlybWF0aW9uIG5vdCBncmFudGVkIGluIHBvcHVwXG4gIE1ldGhvZF9DYW5jZWw6ICdDYW5jZWxsZWQnLFxuICAvLyBwZXJtaXNzaW9uL2NvbmZpcm1hdGlvbiBub3QgZ3JhbnRlZCBpbiBwb3B1cCBPUiAuY2FuY2VsKCkgY3VzdG9tIGVycm9yXG4gIE1ldGhvZF9JbnRlcnJ1cHRlZDogJ1BvcHVwIGNsb3NlZCcsXG4gIC8vIGludGVycnVwdGlvbjogcG9wdXAgY2xvc2VkXG4gIE1ldGhvZF9Vbmtub3duQ29pbjogJ0NvaW4gbm90IGZvdW5kJyxcbiAgLy8gY29pbiBkZWZpbml0aW9uIG5vdCBmb3VuZFxuICBNZXRob2RfQWRkcmVzc05vdE1hdGNoOiAnQWRkcmVzc2VzIGRvIG5vdCBtYXRjaCcsXG4gIC8vIHRocm93biBieSBhbGwgZ2V0QWRkcmVzcyBtZXRob2RzIHdpdGggY3VzdG9tIFVJIHZhbGlkYXRpb25cbiAgTWV0aG9kX0Zpcm13YXJlVXBkYXRlX0Rvd25sb2FkRmFpbGVkOiAnRmFpbGVkIHRvIGRvd25sb2FkIGZpcm13YXJlIGJpbmFyeScsXG4gIC8vIHRocm93biBieSBGaXJtd2FyZVVwZGF0ZSBtZXRob2RcbiAgTWV0aG9kX0N1c3RvbU1lc3NhZ2VfQ2FsbGJhY2s6ICdQYXJhbWV0ZXIgXCJjYWxsYmFja1wiIGlzIG5vdCBhIGZ1bmN0aW9uJyxcbiAgLy8gdGhyb3duIGJ5IEN1c3RvbU1lc3NhZ2UgbWV0aG9kXG4gIE1ldGhvZF9EaXNjb3ZlcnlfQnVuZGxlRXhjZXB0aW9uOiAnJyxcbiAgLy8gdGhyb3duIGJ5IGdldEFjY291bnRJbmZvIG1ldGhvZFxuICBNZXRob2RfT3ZlcnJpZGU6ICdvdmVycmlkZScsXG4gIC8vIGlubmVyIFwiZXJyb3JcIiwgaXQncyBtb3JlIGxpa2UgYSBpbnRlcnJ1cHRpb25cbiAgTWV0aG9kX05vUmVzcG9uc2U6ICdDYWxsIHJlc29sdmVkIHdpdGhvdXQgcmVzcG9uc2UnLFxuICAvLyB0aHJvd24gYnkgbnBtIGluZGV4KGVzKSwgY2FsbCB0byBDb3JlIHJlc29sdmVkIHdpdGhvdXQgcmVzcG9uc2UsIHNob3VsZCBub3QgaGFwcGVuXG4gIEJhY2tlbmRfTm90U3VwcG9ydGVkOiAnQmxvY2tjaGFpbkxpbmsgc2V0dGluZ3Mgbm90IGZvdW5kIGluIGNvaW5zLmpzb24nLFxuICAvLyB0aHJvd24gYnkgbWV0aG9kcyB3aGljaCB1c2luZyBiYWNrZW5kcywgYmxvY2tjaGFpbkxpbmsgbm90IGRlZmluZWQgZm9yIHRoaXMgY29pblxuICBCYWNrZW5kX1dvcmtlck1pc3Npbmc6ICcnLFxuICAvLyB0aHJvd24gYnkgQmxvY2tjaGFpbkxpbmsgY2xhc3MsIHdvcmtlciBub3Qgc3BlY2lmaWVkXG4gIEJhY2tlbmRfRGlzY29ubmVjdGVkOiAnQmFja2VuZCBkaXNjb25uZWN0ZWQnLFxuICAvLyB0aHJvd24gYnkgQmxvY2tjaGFpbkxpbmsgY2xhc3NcbiAgQmFja2VuZF9JbnZhbGlkOiAnSW52YWxpZCBiYWNrZW5kJyxcbiAgLy8gdGhyb3duIGJ5IEJsb2NrY2hhaW5MaW5rIGNsYXNzLCBpbnZhbGlkIGJhY2tlbmQgKGllOiBiYWNrZW5kIGZvciB3cm9uZyBjb2luIHNldClcbiAgQmFja2VuZF9FcnJvcjogJycsXG4gIC8vIHRocm93biBieSBCbG9ja2NoYWluTGluayBjbGFzcywgZ2VuZXJpYyBtZXNzYWdlIGZyb20gJ2Jsb2NrY2hhaW4tbGluaydcbiAgUnVudGltZTogJycsXG4gIC8vIHRocm93biBmcm9tIHNldmVyYWwgcGxhY2VzLCB0aGlzIHNob3VsZG4ndCBldmVyIGhhcHBlbiB0aG9cbiAgRGV2aWNlX05vdEZvdW5kOiAnRGV2aWNlIG5vdCBmb3VuZCcsXG4gIERldmljZV9Jbml0aWFsaXplRmFpbGVkOiAnJyxcbiAgLy8gZ2VuZXJpYyBlcnJvciBmcm9tIGZpcm13YXJlIHdoaWxlIGNhbGxpbmcgXCJJbml0aWFsaXplXCIgbWVzc2FnZVxuICBEZXZpY2VfRndFeGNlcHRpb246ICcnLFxuICAvLyBnZW5lcmljIEZpcm13YXJlRXhjZXB0aW9uIHR5cGVcbiAgRGV2aWNlX01vZGVFeGNlcHRpb246ICcnLFxuICAvLyBnZW5lcmljIERldmljZS5VbmV4cGVjdGVkTW9kZSB0eXBlXG4gIERldmljZV9EaXNjb25uZWN0ZWQ6ICdEZXZpY2UgZGlzY29ubmVjdGVkJyxcbiAgLy8gZGV2aWNlIGRpc2Nvbm5lY3RlZCBkdXJpbmcgY2FsbFxuICBEZXZpY2VfVXNlZEVsc2V3aGVyZTogJ0RldmljZSBpcyB1c2VkIGluIGFub3RoZXIgd2luZG93JyxcbiAgLy8gaW50ZXJydXB0aW9uOiBjdXJyZW50IHNlc3Npb24gdG9rZWQgYnkgb3RoZXIgYXBwbGljYXRpb25cbiAgRGV2aWNlX0ludmFsaWRTdGF0ZTogJ1Bhc3NwaHJhc2UgaXMgaW5jb3JyZWN0JyxcbiAgLy8gYXV0aG9yaXphdGlvbiBlcnJvciAoZGV2aWNlIHN0YXRlIGNvbXBhcmlzb24pXG4gIERldmljZV9DYWxsSW5Qcm9ncmVzczogJ0RldmljZSBjYWxsIGluIHByb2dyZXNzJyAvLyB0aHJvd24gd2hlbiB0cnlpbmcgdG8gbWFrZSBhbm90aGVyIGNhbGwgd2hpbGUgY3VycmVudCBpcyBzdGlsbCBydW5uaW5nXG5cbn07XG5leHBvcnRzLkVSUk9SX0NPREVTID0gRVJST1JfQ09ERVM7XG5cbnZhciBUcmV6b3JFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gICgwLCBfaW5oZXJpdHNMb29zZTJbXCJkZWZhdWx0XCJdKShUcmV6b3JFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBUcmV6b3JFcnJvcihjb2RlLCBtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX3RoaXMgPSBfRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBUcmV6b3JFcnJvcjtcbn0oIC8qI19fUFVSRV9fKi8oMCwgX3dyYXBOYXRpdmVTdXBlcjJbXCJkZWZhdWx0XCJdKShFcnJvcikpO1xuXG5leHBvcnRzLlRyZXpvckVycm9yID0gVHJlem9yRXJyb3I7XG5cbnZhciBUeXBlZEVycm9yID0gZnVuY3Rpb24gVHlwZWRFcnJvcihpZCwgbWVzc2FnZSkge1xuICByZXR1cm4gbmV3IFRyZXpvckVycm9yKGlkLCBtZXNzYWdlIHx8IEVSUk9SX0NPREVTW2lkXSk7XG59OyAvLyBhIHNsaWdodCBoYWNrXG4vLyB0aGlzIGVycm9yIHN0cmluZyBpcyBoYXJkLWNvZGVkXG4vLyBpbiBib3RoIGJyaWRnZSBhbmQgZXh0ZW5zaW9uXG5cblxuZXhwb3J0cy5UeXBlZEVycm9yID0gVHlwZWRFcnJvcjtcbnZhciBXUk9OR19QUkVWSU9VU19TRVNTSU9OX0VSUk9SX01FU1NBR0UgPSAnd3JvbmcgcHJldmlvdXMgc2Vzc2lvbic7XG5leHBvcnRzLldST05HX1BSRVZJT1VTX1NFU1NJT05fRVJST1JfTUVTU0FHRSA9IFdST05HX1BSRVZJT1VTX1NFU1NJT05fRVJST1JfTUVTU0FHRTtcbnZhciBJTlZBTElEX1BJTl9FUlJPUl9NRVNTQUdFID0gJ1BJTiBpbnZhbGlkJztcbmV4cG9ydHMuSU5WQUxJRF9QSU5fRVJST1JfTUVTU0FHRSA9IElOVkFMSURfUElOX0VSUk9SX01FU1NBR0U7XG52YXIgV0VCVVNCX0VSUk9SX01FU1NBR0UgPSAnTmV0d29ya0Vycm9yOiBVbmFibGUgdG8gY2xhaW0gaW50ZXJmYWNlLic7IC8vIHRyZXpvcmQgZXJyb3IgcHJlZml4LlxuLy8gdXNlciBoYXMgaW5zdWZmaWNpZW50IHBlcm1pc3Npb25zLiBtYXkgb2NjdXIgaW4gTGludXggKG1pc3NpbmcgdWRldiBydWxlcyksIFdpbmRvd3MgYW5kIE1hY09TLlxuXG5leHBvcnRzLldFQlVTQl9FUlJPUl9NRVNTQUdFID0gV0VCVVNCX0VSUk9SX01FU1NBR0U7XG52YXIgTElCVVNCX0VSUk9SX01FU1NBR0UgPSAnTElCVVNCX0VSUk9SJztcbmV4cG9ydHMuTElCVVNCX0VSUk9SX01FU1NBR0UgPSBMSUJVU0JfRVJST1JfTUVTU0FHRTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ0FMTCA9IGV4cG9ydHMuRVJST1IgPSBleHBvcnRzLklOSVQgPSBleHBvcnRzLkxPQURFRCA9IGV4cG9ydHMuQk9PVFNUUkFQID0gdm9pZCAwO1xuLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpZnJhbWUuaHRtbCBpbmxpbmUgc2NyaXB0IGJlZm9yZSBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gaWZyYW1lIHRvIHdpbmRvdy5vcGVuZXIuXG52YXIgQk9PVFNUUkFQID0gJ2lmcmFtZS1ib290c3RyYXAnOyAvLyBNZXNzYWdlIGZyb20gaWZyYW1lLmpzIHRvIHdpbmRvdy5vcGVuZXIsIGNhbGxlZCBhZnRlciBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBzZWNvbmQgbWVzc2FnZSBmcm9tIGlmcmFtZSB0byB3aW5kb3cub3BlbmVyLlxuXG5leHBvcnRzLkJPT1RTVFJBUCA9IEJPT1RTVFJBUDtcbnZhciBMT0FERUQgPSAnaWZyYW1lLWxvYWRlZCc7IC8vIE1lc3NhZ2UgZnJvbSB3aW5kb3cub3BlbmVyIHRvIGlmcmFtZS5qc1xuXG5leHBvcnRzLkxPQURFRCA9IExPQURFRDtcbnZhciBJTklUID0gJ2lmcmFtZS1pbml0JzsgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIGlmcmFtZS5qcyB0byB3aW5kb3cub3BlbmVyLiBDb3VsZCBiZSB0aHJvd24gZHVyaW5nIGlmcmFtZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzXG5cbmV4cG9ydHMuSU5JVCA9IElOSVQ7XG52YXIgRVJST1IgPSAnaWZyYW1lLWVycm9yJzsgLy8gTWVzc2FnZSBmcm9tIHdpbmRvdy5vcGVuZXIgdG8gaWZyYW1lLiBDYWxsIG1ldGhvZFxuXG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgQ0FMTCA9ICdpZnJhbWUtY2FsbCc7XG5leHBvcnRzLkNBTEwgPSBDQUxMOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5DQVJEQU5PID0gZXhwb3J0cy5VSSA9IGV4cG9ydHMuVFJBTlNQT1JUID0gZXhwb3J0cy5QT1BVUCA9IGV4cG9ydHMuTkVUV09SSyA9IGV4cG9ydHMuSUZSQU1FID0gZXhwb3J0cy5FUlJPUlMgPSBleHBvcnRzLkRFVklDRSA9IGV4cG9ydHMuQkxPQ0tDSEFJTiA9IGV4cG9ydHMuQkxPQ0tDSEFJTl9FVkVOVCA9IGV4cG9ydHMuUkVTUE9OU0VfRVZFTlQgPSBleHBvcnRzLlRSQU5TUE9SVF9FVkVOVCA9IGV4cG9ydHMuREVWSUNFX0VWRU5UID0gZXhwb3J0cy5VSV9FVkVOVCA9IGV4cG9ydHMuQ09SRV9FVkVOVCA9IHZvaWQgMDtcblxudmFyIEJMT0NLQ0hBSU4gPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9ibG9ja2NoYWluXCIpKTtcblxuZXhwb3J0cy5CTE9DS0NIQUlOID0gQkxPQ0tDSEFJTjtcblxudmFyIERFVklDRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2RldmljZVwiKSk7XG5cbmV4cG9ydHMuREVWSUNFID0gREVWSUNFO1xuXG52YXIgRVJST1JTID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vZXJyb3JzXCIpKTtcblxuZXhwb3J0cy5FUlJPUlMgPSBFUlJPUlM7XG5cbnZhciBJRlJBTUUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9pZnJhbWVcIikpO1xuXG5leHBvcnRzLklGUkFNRSA9IElGUkFNRTtcblxudmFyIE5FVFdPUksgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3JrXCIpKTtcblxuZXhwb3J0cy5ORVRXT1JLID0gTkVUV09SSztcblxudmFyIFBPUFVQID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcG9wdXBcIikpO1xuXG5leHBvcnRzLlBPUFVQID0gUE9QVVA7XG5cbnZhciBUUkFOU1BPUlQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi90cmFuc3BvcnRcIikpO1xuXG5leHBvcnRzLlRSQU5TUE9SVCA9IFRSQU5TUE9SVDtcblxudmFyIFVJID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vdWlcIikpO1xuXG5leHBvcnRzLlVJID0gVUk7XG5cbnZhciBDQVJEQU5PID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vY2FyZGFub1wiKSk7XG5cbmV4cG9ydHMuQ0FSREFOTyA9IENBUkRBTk87XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9XG5cbnZhciBDT1JFX0VWRU5UID0gJ0NPUkVfRVZFTlQnO1xuZXhwb3J0cy5DT1JFX0VWRU5UID0gQ09SRV9FVkVOVDtcbnZhciBVSV9FVkVOVCA9ICdVSV9FVkVOVCc7XG5leHBvcnRzLlVJX0VWRU5UID0gVUlfRVZFTlQ7XG52YXIgREVWSUNFX0VWRU5UID0gJ0RFVklDRV9FVkVOVCc7XG5leHBvcnRzLkRFVklDRV9FVkVOVCA9IERFVklDRV9FVkVOVDtcbnZhciBUUkFOU1BPUlRfRVZFTlQgPSAnVFJBTlNQT1JUX0VWRU5UJztcbmV4cG9ydHMuVFJBTlNQT1JUX0VWRU5UID0gVFJBTlNQT1JUX0VWRU5UO1xudmFyIFJFU1BPTlNFX0VWRU5UID0gJ1JFU1BPTlNFX0VWRU5UJztcbmV4cG9ydHMuUkVTUE9OU0VfRVZFTlQgPSBSRVNQT05TRV9FVkVOVDtcbnZhciBCTE9DS0NIQUlOX0VWRU5UID0gJ0JMT0NLQ0hBSU5fRVZFTlQnO1xuZXhwb3J0cy5CTE9DS0NIQUlOX0VWRU5UID0gQkxPQ0tDSEFJTl9FVkVOVDsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuVFlQRVMgPSB2b2lkIDA7XG52YXIgVFlQRVMgPSBPYmplY3QuZnJlZXplKHtcbiAgYml0Y29pbjogJ0JpdGNvaW4nLFxuICBldGhlcmV1bTogJ0V0aGVyZXVtJyxcbiAgZW9zOiAnRW9zJyxcbiAgbmVtOiAnTkVNJyxcbiAgc3RlbGxhcjogJ1N0ZWxsYXInLFxuICBjYXJkYW5vOiAnQ2FyZGFubycsXG4gIHJpcHBsZTogJ1JpcHBsZScsXG4gIHRlem9zOiAnVGV6b3JzJyxcbiAgYmluYW5jZTogJ0JpbmFuY2UnXG59KTtcbmV4cG9ydHMuVFlQRVMgPSBUWVBFUzsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ0xPU0VfV0lORE9XID0gZXhwb3J0cy5DQU5DRUxfUE9QVVBfUkVRVUVTVCA9IGV4cG9ydHMuQ0xPU0VEID0gZXhwb3J0cy5IQU5EU0hBS0UgPSBleHBvcnRzLkVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlMgPSBleHBvcnRzLkVSUk9SID0gZXhwb3J0cy5JTklUID0gZXhwb3J0cy5MT0FERUQgPSBleHBvcnRzLkJPT1RTVFJBUCA9IHZvaWQgMDtcbi8vIE1lc3NhZ2UgY2FsbGVkIGZyb20gcG9wdXAuaHRtbCBpbmxpbmUgc2NyaXB0IGJlZm9yZSBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gcG9wdXAgdG8gd2luZG93Lm9wZW5lci5cbnZhciBCT09UU1RSQVAgPSAncG9wdXAtYm9vdHN0cmFwJzsgLy8gTWVzc2FnZSBmcm9tIHBvcHVwLmpzIHRvIHdpbmRvdy5vcGVuZXIsIGNhbGxlZCBhZnRlciBcIndpbmRvdy5vbmxvYWRcIiBldmVudC4gVGhpcyBpcyBzZWNvbmQgbWVzc2FnZSBmcm9tIHBvcHVwIHRvIHdpbmRvdy5vcGVuZXIuXG5cbmV4cG9ydHMuQk9PVFNUUkFQID0gQk9PVFNUUkFQO1xudmFyIExPQURFRCA9ICdwb3B1cC1sb2FkZWQnOyAvLyBNZXNzYWdlIGZyb20gd2luZG93Lm9wZW5lciB0byBwb3B1cC5qcy4gU2VuZCBzZXR0aW5ncyB0byBwb3B1cC4gVGhpcyBpcyBmaXJzdCBtZXNzYWdlIGZyb20gd2luZG93Lm9wZW5lciB0byBwb3B1cC5cblxuZXhwb3J0cy5MT0FERUQgPSBMT0FERUQ7XG52YXIgSU5JVCA9ICdwb3B1cC1pbml0JzsgLy8gRXJyb3IgbWVzc2FnZSBmcm9tIHBvcHVwIHRvIHdpbmRvdy5vcGVuZXIuIENvdWxkIGJlIHRocm93biBkdXJpbmcgcG9wdXAgaW5pdGlhbGl6YXRpb24gcHJvY2VzcyAoUE9QVVAuSU5JVClcblxuZXhwb3J0cy5JTklUID0gSU5JVDtcbnZhciBFUlJPUiA9ICdwb3B1cC1lcnJvcic7IC8vIE1lc3NhZ2UgdG8gd2ViZXh0ZW5zaW9ucywgb3BlbnMgXCJ0cmV6b3ItdXNiLXBlcm1pc3Npb24uaHRtbFwiIHdpdGhpbiB3ZWJleHRlbnNpb25cblxuZXhwb3J0cy5FUlJPUiA9IEVSUk9SO1xudmFyIEVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlMgPSAnb3Blbi11c2ItcGVybWlzc2lvbnMnOyAvLyBNZXNzYWdlIGNhbGxlZCBmcm9tIGJvdGggW3BvcHVwID4gaWZyYW1lXSB0aGVuIFtpZnJhbWUgPiBwb3B1cF0gaW4gdGhpcyBleGFjdCBvcmRlci5cbi8vIEZpcnN0bHkgcG9wdXAgY2FsbCBpZnJhbWUgdG8gcmVzb2x2ZSBwb3B1cCBwcm9taXNlIGluIENvcmVcbi8vIFRoZW4gaWZyYW1lIHJlYWN0cyB0byBQT1BVUC5IQU5EU0hBS0UgbWVzc2FnZSBhbmQgc2VuZHMgQ29ubmVjdFNldHRpbmdzLCB0cmFuc3BvcnQgaW5mb3JtYXRpb24gYW5kIHJlcXVlc3RlZCBtZXRob2QgZGV0YWlscyBiYWNrIHRvIHBvcHVwXG5cbmV4cG9ydHMuRVhURU5TSU9OX1VTQl9QRVJNSVNTSU9OUyA9IEVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlM7XG52YXIgSEFORFNIQUtFID0gJ3BvcHVwLWhhbmRzaGFrZSc7IC8vIEV2ZW50IGVtaXR0ZWQgZnJvbSBQb3B1cE1hbmFnZXIgYXQgdGhlIGVuZCBvZiBwb3B1cCBjbG9zaW5nIHByb2Nlc3MuXG4vLyBTZW50IGZyb20gcG9wdXAgdGhydSB3aW5kb3cub3BlbmVyIHRvIGFuIGlmcmFtZSBiZWNhdXNlIG1lc3NhZ2UgY2hhbm5lbCBiZXR3ZWVuIHBvcHVwIGFuZCBpZnJhbWUgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZVxuXG5leHBvcnRzLkhBTkRTSEFLRSA9IEhBTkRTSEFLRTtcbnZhciBDTE9TRUQgPSAncG9wdXAtY2xvc2VkJzsgLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpZnJhbWUgdG8gcG9wdXAsIGl0IG1lYW5zIHRoYXQgcG9wdXAgd2lsbCBub3QgYmUgbmVlZGVkIChleGFtcGxlOiBCbG9ja2NoYWluIG1ldGhvZHMgYXJlIG5vdCB1c2luZyBwb3B1cCBhdCBhbGwpXG4vLyBUaGlzIHdpbGwgY2xvc2UgYWN0aXZlIHBvcHVwIHdpbmRvdyBhbmQvb3IgY2xlYXIgb3BlbmluZyBwcm9jZXNzIGluIFBvcHVwTWFuYWdlciAobWF5YmUgcG9wdXAgd2Fzbid0IG9wZW5lZCB5ZXQpXG5cbmV4cG9ydHMuQ0xPU0VEID0gQ0xPU0VEO1xudmFyIENBTkNFTF9QT1BVUF9SRVFVRVNUID0gJ3VpLWNhbmNlbC1wb3B1cC1yZXF1ZXN0JzsgLy8gTWVzc2FnZSBjYWxsZWQgZnJvbSBpbmxpbmUgZWxlbWVudCBpbiBwb3B1cC5odG1sICh3aW5kb3cuY2xvc2VXaW5kb3cpLCB0aGlzIGlzIHVzZWQgb25seSB3aXRoIHdlYmV4dGVuc2lvbnMgdG8gcHJvcGVybHkgaGFuZGxlIHBvcHVwIGNsb3NlIGV2ZW50XG5cbmV4cG9ydHMuQ0FOQ0VMX1BPUFVQX1JFUVVFU1QgPSBDQU5DRUxfUE9QVVBfUkVRVUVTVDtcbnZhciBDTE9TRV9XSU5ET1cgPSAnd2luZG93LmNsb3NlJztcbmV4cG9ydHMuQ0xPU0VfV0lORE9XID0gQ0xPU0VfV0lORE9XOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5TVEFSVF9QRU5ESU5HID0gZXhwb3J0cy5ESVNBQkxFX1dFQlVTQiA9IGV4cG9ydHMuUkVRVUVTVCA9IGV4cG9ydHMuU1RSRUFNID0gZXhwb3J0cy5VUERBVEUgPSBleHBvcnRzLkVSUk9SID0gZXhwb3J0cy5TVEFSVCA9IHZvaWQgMDtcbnZhciBTVEFSVCA9ICd0cmFuc3BvcnQtc3RhcnQnO1xuZXhwb3J0cy5TVEFSVCA9IFNUQVJUO1xudmFyIEVSUk9SID0gJ3RyYW5zcG9ydC1lcnJvcic7XG5leHBvcnRzLkVSUk9SID0gRVJST1I7XG52YXIgVVBEQVRFID0gJ3RyYW5zcG9ydC11cGRhdGUnO1xuZXhwb3J0cy5VUERBVEUgPSBVUERBVEU7XG52YXIgU1RSRUFNID0gJ3RyYW5zcG9ydC1zdHJlYW0nO1xuZXhwb3J0cy5TVFJFQU0gPSBTVFJFQU07XG52YXIgUkVRVUVTVCA9ICd0cmFuc3BvcnQtcmVxdWVzdF9kZXZpY2UnO1xuZXhwb3J0cy5SRVFVRVNUID0gUkVRVUVTVDtcbnZhciBESVNBQkxFX1dFQlVTQiA9ICd0cmFuc3BvcnQtZGlzYWJsZV93ZWJ1c2InO1xuZXhwb3J0cy5ESVNBQkxFX1dFQlVTQiA9IERJU0FCTEVfV0VCVVNCO1xudmFyIFNUQVJUX1BFTkRJTkcgPSAndHJhbnNwb3J0LXN0YXJ0X3BlbmRpbmcnO1xuZXhwb3J0cy5TVEFSVF9QRU5ESU5HID0gU1RBUlRfUEVORElORzsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuSUZSQU1FX0ZBSUxVUkUgPSBleHBvcnRzLkFERFJFU1NfVkFMSURBVElPTiA9IGV4cG9ydHMuQlVORExFX1BST0dSRVNTID0gZXhwb3J0cy5MT0dJTl9DSEFMTEVOR0VfUkVTUE9OU0UgPSBleHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVFVRVNUID0gZXhwb3J0cy5DVVNUT01fTUVTU0FHRV9SRVNQT05TRSA9IGV4cG9ydHMuQ1VTVE9NX01FU1NBR0VfUkVRVUVTVCA9IGV4cG9ydHMuQ0hBTkdFX1NFVFRJTkdTID0gZXhwb3J0cy5SRUNFSVZFX1dPUkQgPSBleHBvcnRzLlJFQ0VJVkVfRkVFID0gZXhwb3J0cy5SRUNFSVZFX0FDQ09VTlQgPSBleHBvcnRzLkNIQU5HRV9BQ0NPVU5UID0gZXhwb3J0cy5SRUNFSVZFX0RFVklDRSA9IGV4cG9ydHMuUkVDRUlWRV9QQVNTUEhSQVNFID0gZXhwb3J0cy5SRUNFSVZFX1BJTiA9IGV4cG9ydHMuUkVDRUlWRV9DT05GSVJNQVRJT04gPSBleHBvcnRzLlJFQ0VJVkVfUEVSTUlTU0lPTiA9IGV4cG9ydHMuUkVRVUVTVF9XT1JEID0gZXhwb3J0cy5SRVFVRVNUX0JVVFRPTiA9IGV4cG9ydHMuSU5TVUZGSUNJRU5UX0ZVTkRTID0gZXhwb3J0cy5VUERBVEVfQ1VTVE9NX0ZFRSA9IGV4cG9ydHMuU0VMRUNUX0ZFRSA9IGV4cG9ydHMuU0VMRUNUX0FDQ09VTlQgPSBleHBvcnRzLlNFTEVDVF9ERVZJQ0UgPSBleHBvcnRzLlNFVF9PUEVSQVRJT04gPSBleHBvcnRzLkxPQURJTkcgPSBleHBvcnRzLkNPTk5FQ1QgPSBleHBvcnRzLklOVkFMSURfUEFTU1BIUkFTRV9BQ1RJT04gPSBleHBvcnRzLklOVkFMSURfUEFTU1BIUkFTRSA9IGV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFX09OX0RFVklDRSA9IGV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFID0gZXhwb3J0cy5JTlZBTElEX1BJTiA9IGV4cG9ydHMuUkVRVUVTVF9QSU4gPSBleHBvcnRzLlJFUVVFU1RfQ09ORklSTUFUSU9OID0gZXhwb3J0cy5SRVFVRVNUX1BFUk1JU1NJT04gPSBleHBvcnRzLkNMT1NFX1VJX1dJTkRPVyA9IGV4cG9ydHMuUkVRVUVTVF9VSV9XSU5ET1cgPSBleHBvcnRzLkRFVklDRV9ORUVEU19CQUNLVVAgPSBleHBvcnRzLkZJUk1XQVJFX1BST0dSRVNTID0gZXhwb3J0cy5GSVJNV0FSRV9OT1RfSU5TVEFMTEVEID0gZXhwb3J0cy5GSVJNV0FSRV9OT1RfQ09NUEFUSUJMRSA9IGV4cG9ydHMuRklSTVdBUkVfTk9UX1NVUFBPUlRFRCA9IGV4cG9ydHMuRklSTVdBUkVfT1VUREFURUQgPSBleHBvcnRzLkZJUk1XQVJFX09MRCA9IGV4cG9ydHMuU0VFRExFU1MgPSBleHBvcnRzLklOSVRJQUxJWkUgPSBleHBvcnRzLlJFUVVJUkVfTU9ERSA9IGV4cG9ydHMuTk9UX0lOX0JPT1RMT0FERVIgPSBleHBvcnRzLkJPT1RMT0FERVIgPSBleHBvcnRzLlRSQU5TUE9SVCA9IHZvaWQgMDtcbnZhciBUUkFOU1BPUlQgPSAndWktbm9fdHJhbnNwb3J0JztcbmV4cG9ydHMuVFJBTlNQT1JUID0gVFJBTlNQT1JUO1xudmFyIEJPT1RMT0FERVIgPSAndWktZGV2aWNlX2Jvb3Rsb2FkZXJfbW9kZSc7XG5leHBvcnRzLkJPT1RMT0FERVIgPSBCT09UTE9BREVSO1xudmFyIE5PVF9JTl9CT09UTE9BREVSID0gJ3VpLWRldmljZV9ub3RfaW5fYm9vdGxvYWRlcl9tb2RlJztcbmV4cG9ydHMuTk9UX0lOX0JPT1RMT0FERVIgPSBOT1RfSU5fQk9PVExPQURFUjtcbnZhciBSRVFVSVJFX01PREUgPSAndWktZGV2aWNlX3JlcXVpcmVfbW9kZSc7XG5leHBvcnRzLlJFUVVJUkVfTU9ERSA9IFJFUVVJUkVfTU9ERTtcbnZhciBJTklUSUFMSVpFID0gJ3VpLWRldmljZV9ub3RfaW5pdGlhbGl6ZWQnO1xuZXhwb3J0cy5JTklUSUFMSVpFID0gSU5JVElBTElaRTtcbnZhciBTRUVETEVTUyA9ICd1aS1kZXZpY2Vfc2VlZGxlc3MnO1xuZXhwb3J0cy5TRUVETEVTUyA9IFNFRURMRVNTO1xudmFyIEZJUk1XQVJFX09MRCA9ICd1aS1kZXZpY2VfZmlybXdhcmVfb2xkJztcbmV4cG9ydHMuRklSTVdBUkVfT0xEID0gRklSTVdBUkVfT0xEO1xudmFyIEZJUk1XQVJFX09VVERBVEVEID0gJ3VpLWRldmljZV9maXJtd2FyZV9vdXRkYXRlZCc7XG5leHBvcnRzLkZJUk1XQVJFX09VVERBVEVEID0gRklSTVdBUkVfT1VUREFURUQ7XG52YXIgRklSTVdBUkVfTk9UX1NVUFBPUlRFRCA9ICd1aS1kZXZpY2VfZmlybXdhcmVfdW5zdXBwb3J0ZWQnO1xuZXhwb3J0cy5GSVJNV0FSRV9OT1RfU1VQUE9SVEVEID0gRklSTVdBUkVfTk9UX1NVUFBPUlRFRDtcbnZhciBGSVJNV0FSRV9OT1RfQ09NUEFUSUJMRSA9ICd1aS1kZXZpY2VfZmlybXdhcmVfbm90X2NvbXBhdGlibGUnO1xuZXhwb3J0cy5GSVJNV0FSRV9OT1RfQ09NUEFUSUJMRSA9IEZJUk1XQVJFX05PVF9DT01QQVRJQkxFO1xudmFyIEZJUk1XQVJFX05PVF9JTlNUQUxMRUQgPSAndWktZGV2aWNlX2Zpcm13YXJlX25vdF9pbnN0YWxsZWQnO1xuZXhwb3J0cy5GSVJNV0FSRV9OT1RfSU5TVEFMTEVEID0gRklSTVdBUkVfTk9UX0lOU1RBTExFRDtcbnZhciBGSVJNV0FSRV9QUk9HUkVTUyA9ICd1aS1maXJtd2FyZS1wcm9ncmVzcyc7XG5leHBvcnRzLkZJUk1XQVJFX1BST0dSRVNTID0gRklSTVdBUkVfUFJPR1JFU1M7XG52YXIgREVWSUNFX05FRURTX0JBQ0tVUCA9ICd1aS1kZXZpY2VfbmVlZHNfYmFja3VwJztcbmV4cG9ydHMuREVWSUNFX05FRURTX0JBQ0tVUCA9IERFVklDRV9ORUVEU19CQUNLVVA7XG52YXIgUkVRVUVTVF9VSV9XSU5ET1cgPSAndWktcmVxdWVzdF93aW5kb3cnO1xuZXhwb3J0cy5SRVFVRVNUX1VJX1dJTkRPVyA9IFJFUVVFU1RfVUlfV0lORE9XO1xudmFyIENMT1NFX1VJX1dJTkRPVyA9ICd1aS1jbG9zZV93aW5kb3cnO1xuZXhwb3J0cy5DTE9TRV9VSV9XSU5ET1cgPSBDTE9TRV9VSV9XSU5ET1c7XG52YXIgUkVRVUVTVF9QRVJNSVNTSU9OID0gJ3VpLXJlcXVlc3RfcGVybWlzc2lvbic7XG5leHBvcnRzLlJFUVVFU1RfUEVSTUlTU0lPTiA9IFJFUVVFU1RfUEVSTUlTU0lPTjtcbnZhciBSRVFVRVNUX0NPTkZJUk1BVElPTiA9ICd1aS1yZXF1ZXN0X2NvbmZpcm1hdGlvbic7XG5leHBvcnRzLlJFUVVFU1RfQ09ORklSTUFUSU9OID0gUkVRVUVTVF9DT05GSVJNQVRJT047XG52YXIgUkVRVUVTVF9QSU4gPSAndWktcmVxdWVzdF9waW4nO1xuZXhwb3J0cy5SRVFVRVNUX1BJTiA9IFJFUVVFU1RfUElOO1xudmFyIElOVkFMSURfUElOID0gJ3VpLWludmFsaWRfcGluJztcbmV4cG9ydHMuSU5WQUxJRF9QSU4gPSBJTlZBTElEX1BJTjtcbnZhciBSRVFVRVNUX1BBU1NQSFJBU0UgPSAndWktcmVxdWVzdF9wYXNzcGhyYXNlJztcbmV4cG9ydHMuUkVRVUVTVF9QQVNTUEhSQVNFID0gUkVRVUVTVF9QQVNTUEhSQVNFO1xudmFyIFJFUVVFU1RfUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSAndWktcmVxdWVzdF9wYXNzcGhyYXNlX29uX2RldmljZSc7XG5leHBvcnRzLlJFUVVFU1RfUEFTU1BIUkFTRV9PTl9ERVZJQ0UgPSBSRVFVRVNUX1BBU1NQSFJBU0VfT05fREVWSUNFO1xudmFyIElOVkFMSURfUEFTU1BIUkFTRSA9ICd1aS1pbnZhbGlkX3Bhc3NwaHJhc2UnO1xuZXhwb3J0cy5JTlZBTElEX1BBU1NQSFJBU0UgPSBJTlZBTElEX1BBU1NQSFJBU0U7XG52YXIgSU5WQUxJRF9QQVNTUEhSQVNFX0FDVElPTiA9ICd1aS1pbnZhbGlkX3Bhc3NwaHJhc2VfYWN0aW9uJztcbmV4cG9ydHMuSU5WQUxJRF9QQVNTUEhSQVNFX0FDVElPTiA9IElOVkFMSURfUEFTU1BIUkFTRV9BQ1RJT047XG52YXIgQ09OTkVDVCA9ICd1aS1jb25uZWN0JztcbmV4cG9ydHMuQ09OTkVDVCA9IENPTk5FQ1Q7XG52YXIgTE9BRElORyA9ICd1aS1sb2FkaW5nJztcbmV4cG9ydHMuTE9BRElORyA9IExPQURJTkc7XG52YXIgU0VUX09QRVJBVElPTiA9ICd1aS1zZXRfb3BlcmF0aW9uJztcbmV4cG9ydHMuU0VUX09QRVJBVElPTiA9IFNFVF9PUEVSQVRJT047XG52YXIgU0VMRUNUX0RFVklDRSA9ICd1aS1zZWxlY3RfZGV2aWNlJztcbmV4cG9ydHMuU0VMRUNUX0RFVklDRSA9IFNFTEVDVF9ERVZJQ0U7XG52YXIgU0VMRUNUX0FDQ09VTlQgPSAndWktc2VsZWN0X2FjY291bnQnO1xuZXhwb3J0cy5TRUxFQ1RfQUNDT1VOVCA9IFNFTEVDVF9BQ0NPVU5UO1xudmFyIFNFTEVDVF9GRUUgPSAndWktc2VsZWN0X2ZlZSc7XG5leHBvcnRzLlNFTEVDVF9GRUUgPSBTRUxFQ1RfRkVFO1xudmFyIFVQREFURV9DVVNUT01fRkVFID0gJ3VpLXVwZGF0ZV9jdXN0b21fZmVlJztcbmV4cG9ydHMuVVBEQVRFX0NVU1RPTV9GRUUgPSBVUERBVEVfQ1VTVE9NX0ZFRTtcbnZhciBJTlNVRkZJQ0lFTlRfRlVORFMgPSAndWktaW5zdWZmaWNpZW50X2Z1bmRzJztcbmV4cG9ydHMuSU5TVUZGSUNJRU5UX0ZVTkRTID0gSU5TVUZGSUNJRU5UX0ZVTkRTO1xudmFyIFJFUVVFU1RfQlVUVE9OID0gJ3VpLWJ1dHRvbic7XG5leHBvcnRzLlJFUVVFU1RfQlVUVE9OID0gUkVRVUVTVF9CVVRUT047XG52YXIgUkVRVUVTVF9XT1JEID0gJ3VpLXJlcXVlc3Rfd29yZCc7XG5leHBvcnRzLlJFUVVFU1RfV09SRCA9IFJFUVVFU1RfV09SRDtcbnZhciBSRUNFSVZFX1BFUk1JU1NJT04gPSAndWktcmVjZWl2ZV9wZXJtaXNzaW9uJztcbmV4cG9ydHMuUkVDRUlWRV9QRVJNSVNTSU9OID0gUkVDRUlWRV9QRVJNSVNTSU9OO1xudmFyIFJFQ0VJVkVfQ09ORklSTUFUSU9OID0gJ3VpLXJlY2VpdmVfY29uZmlybWF0aW9uJztcbmV4cG9ydHMuUkVDRUlWRV9DT05GSVJNQVRJT04gPSBSRUNFSVZFX0NPTkZJUk1BVElPTjtcbnZhciBSRUNFSVZFX1BJTiA9ICd1aS1yZWNlaXZlX3Bpbic7XG5leHBvcnRzLlJFQ0VJVkVfUElOID0gUkVDRUlWRV9QSU47XG52YXIgUkVDRUlWRV9QQVNTUEhSQVNFID0gJ3VpLXJlY2VpdmVfcGFzc3BocmFzZSc7XG5leHBvcnRzLlJFQ0VJVkVfUEFTU1BIUkFTRSA9IFJFQ0VJVkVfUEFTU1BIUkFTRTtcbnZhciBSRUNFSVZFX0RFVklDRSA9ICd1aS1yZWNlaXZlX2RldmljZSc7XG5leHBvcnRzLlJFQ0VJVkVfREVWSUNFID0gUkVDRUlWRV9ERVZJQ0U7XG52YXIgQ0hBTkdFX0FDQ09VTlQgPSAndWktY2hhbmdlX2FjY291bnQnO1xuZXhwb3J0cy5DSEFOR0VfQUNDT1VOVCA9IENIQU5HRV9BQ0NPVU5UO1xudmFyIFJFQ0VJVkVfQUNDT1VOVCA9ICd1aS1yZWNlaXZlX2FjY291bnQnO1xuZXhwb3J0cy5SRUNFSVZFX0FDQ09VTlQgPSBSRUNFSVZFX0FDQ09VTlQ7XG52YXIgUkVDRUlWRV9GRUUgPSAndWktcmVjZWl2ZV9mZWUnO1xuZXhwb3J0cy5SRUNFSVZFX0ZFRSA9IFJFQ0VJVkVfRkVFO1xudmFyIFJFQ0VJVkVfV09SRCA9ICd1aS1yZWNlaXZlX3dvcmQnO1xuZXhwb3J0cy5SRUNFSVZFX1dPUkQgPSBSRUNFSVZFX1dPUkQ7XG52YXIgQ0hBTkdFX1NFVFRJTkdTID0gJ3VpLWNoYW5nZV9zZXR0aW5ncyc7XG5leHBvcnRzLkNIQU5HRV9TRVRUSU5HUyA9IENIQU5HRV9TRVRUSU5HUztcbnZhciBDVVNUT01fTUVTU0FHRV9SRVFVRVNUID0gJ3VpLWN1c3RvbV9yZXF1ZXN0JztcbmV4cG9ydHMuQ1VTVE9NX01FU1NBR0VfUkVRVUVTVCA9IENVU1RPTV9NRVNTQUdFX1JFUVVFU1Q7XG52YXIgQ1VTVE9NX01FU1NBR0VfUkVTUE9OU0UgPSAndWktY3VzdG9tX3Jlc3BvbnNlJztcbmV4cG9ydHMuQ1VTVE9NX01FU1NBR0VfUkVTUE9OU0UgPSBDVVNUT01fTUVTU0FHRV9SRVNQT05TRTtcbnZhciBMT0dJTl9DSEFMTEVOR0VfUkVRVUVTVCA9ICd1aS1sb2dpbl9jaGFsbGVuZ2VfcmVxdWVzdCc7XG5leHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVFVRVNUID0gTE9HSU5fQ0hBTExFTkdFX1JFUVVFU1Q7XG52YXIgTE9HSU5fQ0hBTExFTkdFX1JFU1BPTlNFID0gJ3VpLWxvZ2luX2NoYWxsZW5nZV9yZXNwb25zZSc7XG5leHBvcnRzLkxPR0lOX0NIQUxMRU5HRV9SRVNQT05TRSA9IExPR0lOX0NIQUxMRU5HRV9SRVNQT05TRTtcbnZhciBCVU5ETEVfUFJPR1JFU1MgPSAndWktYnVuZGxlX3Byb2dyZXNzJztcbmV4cG9ydHMuQlVORExFX1BST0dSRVNTID0gQlVORExFX1BST0dSRVNTO1xudmFyIEFERFJFU1NfVkFMSURBVElPTiA9ICd1aS1hZGRyZXNzX3ZhbGlkYXRpb24nO1xuZXhwb3J0cy5BRERSRVNTX1ZBTElEQVRJT04gPSBBRERSRVNTX1ZBTElEQVRJT047XG52YXIgSUZSQU1FX0ZBSUxVUkUgPSAndWktaWZyYW1lX2ZhaWx1cmUnO1xuZXhwb3J0cy5JRlJBTUVfRkFJTFVSRSA9IElGUkFNRV9GQUlMVVJFOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucGFyc2UgPSBleHBvcnRzLmNvcnNWYWxpZGF0b3IgPSBleHBvcnRzLmdldEVudiA9IGV4cG9ydHMuREVGQVVMVF9QUklPUklUWSA9IHZvaWQgMDtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLypcbiAqIEluaXRpYWwgc2V0dGluZ3MgZm9yIGNvbm5lY3QuXG4gKiBJdCBjb3VsZCBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgdmFsdWVzIGludG8gVHJlem9yQ29ubmVjdC5pbml0KC4uLikgbWV0aG9kXG4gKi9cbnZhciBWRVJTSU9OID0gJzguMi42JztcbnZhciB2ZXJzaW9uTiA9IFZFUlNJT04uc3BsaXQoJy4nKS5tYXAoZnVuY3Rpb24gKHMpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHMsIDEwKTtcbn0pOyAvLyBjb25zdCBESVJFQ1RPUlkgPSBgJHsgdmVyc2lvbk5bMF0gfSR7ICh2ZXJzaW9uTlsxXSA+IDAgPyBgLiR7dmVyc2lvbk5bMV19YCA6ICcnKSB9L2A7XG5cbnZhciBESVJFQ1RPUlkgPSB2ZXJzaW9uTlswXSArIFwiL1wiO1xudmFyIERFRkFVTFRfRE9NQUlOID0gXCJodHRwczovL2Nvbm5lY3QudHJlem9yLmlvL1wiICsgRElSRUNUT1JZO1xudmFyIERFRkFVTFRfUFJJT1JJVFkgPSAyO1xuZXhwb3J0cy5ERUZBVUxUX1BSSU9SSVRZID0gREVGQVVMVF9QUklPUklUWTtcbnZhciBpbml0aWFsU2V0dGluZ3MgPSB7XG4gIGNvbmZpZ1NyYzogJy4vZGF0YS9jb25maWcuanNvbicsXG4gIC8vIGNvbnN0YW50XG4gIHZlcnNpb246IFZFUlNJT04sXG4gIC8vIGNvbnN0YW50XG4gIGRlYnVnOiBmYWxzZSxcbiAgcHJpb3JpdHk6IERFRkFVTFRfUFJJT1JJVFksXG4gIHRydXN0ZWRIb3N0OiBmYWxzZSxcbiAgY29ubmVjdFNyYzogREVGQVVMVF9ET01BSU4sXG4gIGlmcmFtZVNyYzogREVGQVVMVF9ET01BSU4gKyBcImlmcmFtZS5odG1sXCIsXG4gIHBvcHVwOiB0cnVlLFxuICBwb3B1cFNyYzogREVGQVVMVF9ET01BSU4gKyBcInBvcHVwLmh0bWxcIixcbiAgd2VidXNiU3JjOiBERUZBVUxUX0RPTUFJTiArIFwid2VidXNiLmh0bWxcIixcbiAgdHJhbnNwb3J0UmVjb25uZWN0OiBmYWxzZSxcbiAgd2VidXNiOiB0cnVlLFxuICBwZW5kaW5nVHJhbnNwb3J0RXZlbnQ6IHRydWUsXG4gIHN1cHBvcnRlZEJyb3dzZXI6IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnID8gIS9UcmlkZW50fE1TSUV8RWRnZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSA6IHRydWUsXG4gIG1hbmlmZXN0OiBudWxsLFxuICBlbnY6ICd3ZWInLFxuICBsYXp5TG9hZDogZmFsc2UsXG4gIHRpbWVzdGFtcDogbmV3IERhdGUoKS5nZXRUaW1lKCksXG4gIGludGVyYWN0aW9uVGltZW91dDogNjAwIC8vIDUgbWludXRlc1xuXG59O1xudmFyIGN1cnJlbnRTZXR0aW5ncyA9IGluaXRpYWxTZXR0aW5ncztcblxudmFyIHBhcnNlTWFuaWZlc3QgPSBmdW5jdGlvbiBwYXJzZU1hbmlmZXN0KG1hbmlmZXN0KSB7XG4gIGlmICghbWFuaWZlc3QpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBtYW5pZmVzdC5lbWFpbCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgaWYgKHR5cGVvZiBtYW5pZmVzdC5hcHBVcmwgIT09ICdzdHJpbmcnKSByZXR1cm47XG4gIHJldHVybiB7XG4gICAgZW1haWw6IG1hbmlmZXN0LmVtYWlsLFxuICAgIGFwcFVybDogbWFuaWZlc3QuYXBwVXJsXG4gIH07XG59O1xuXG52YXIgZ2V0RW52ID0gZnVuY3Rpb24gZ2V0RW52KCkge1xuICAvLyAkRmxvd0lzc3VlOiBjaHJvbWUgaXMgbm90IGRlY2xhcmVkIG91dHNpZGUgdGhlIHByb2plY3RcbiAgaWYgKHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmIGNocm9tZS5ydW50aW1lICYmIHR5cGVvZiBjaHJvbWUucnVudGltZS5vbkNvbm5lY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuICd3ZWJleHRlbnNpb24nO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJykge1xuICAgICAgcmV0dXJuICdyZWFjdC1uYXRpdmUnO1xuICAgIH1cblxuICAgIHZhciB1c2VyQWdlbnQgPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG5cbiAgICBpZiAodXNlckFnZW50LmluZGV4T2YoJyBlbGVjdHJvbi8nKSA+IC0xKSB7XG4gICAgICByZXR1cm4gJ2VsZWN0cm9uJztcbiAgICB9XG4gIH0gLy8gaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ3N0cmluZycgJiYgbmF2aWdhdG9yLnByb2R1Y3QudG9Mb3dlckNhc2UoKSA9PT0gJ3JlYWN0bmF0aXZlJykge1xuICAvLyAgICAgcmV0dXJuICdyZWFjdC1uYXRpdmUnO1xuICAvLyB9XG4gIC8vIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy52ZXJzaW9ucy5oYXNPd25Qcm9wZXJ0eSgnZWxlY3Ryb24nKSkge1xuICAvLyAgICAgcmV0dXJuICdlbGVjdHJvbic7XG4gIC8vIH1cblxuXG4gIHJldHVybiAnd2ViJztcbn07IC8vIENvcnMgdmFsaWRhdGlvbiBjb3BpZWQgZnJvbSBUcmV6b3IgQnJpZGdlXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90cmV6b3IvdHJlem9yZC1nby9ibG9iLzA1OTkxY2VhNTkwMGQxOGJjYzZlY2U1YWU1ZTMxOWQxMzhmYzU1NTEvc2VydmVyL2FwaS9hcGkuZ28jTDIyOVxuLy8gSXRzIHBvaW50bGVzcyB0byBhbGxvdyBgdHJlem9yLWNvbm5lY3RgIGVuZHBvaW50cyB7IGNvbm5lY3RTcmMgfSBmb3IgZG9tYWlucyBvdGhlciB0aGFuIGxpc3RlZCBiZWxvd1xuLy8gYHRyZXpvcmRgIHdpbGwgYmxvY2sgY29tbXVuaWNhdGlvbiBhbnl3YXlcblxuXG5leHBvcnRzLmdldEVudiA9IGdldEVudjtcblxudmFyIGNvcnNWYWxpZGF0b3IgPSBmdW5jdGlvbiBjb3JzVmFsaWRhdG9yKHVybCkge1xuICBpZiAodHlwZW9mIHVybCAhPT0gJ3N0cmluZycpIHJldHVybjtcbiAgaWYgKHVybC5tYXRjaCgvXmh0dHBzOlxcL1xcLyhbQS1aYS16MC05XFwtX10rXFwuKSp0cmV6b3JcXC5pb1xcLy8pKSByZXR1cm4gdXJsO1xuICBpZiAodXJsLm1hdGNoKC9eaHR0cHM/OlxcL1xcL2xvY2FsaG9zdDpbNThdWzAtOV17M31cXC8vKSkgcmV0dXJuIHVybDtcbiAgaWYgKHVybC5tYXRjaCgvXmh0dHBzOlxcL1xcLyhbQS1aYS16MC05XFwtX10rXFwuKSpzbGRldlxcLmN6XFwvLykpIHJldHVybiB1cmw7XG4gIGlmICh1cmwubWF0Y2goL15odHRwcz86XFwvXFwvKFtBLVphLXowLTlcXC1fXStcXC4pKnRyZXpvcmlvdnBqY2FocHprcmV3ZWxjbHVsbXN6d2JxcHptemd1YjM3Z2Jjamx2bHV4dHJ1cWFkXFwub25pb25cXC8vKSkgcmV0dXJuIHVybDtcbn07XG5cbmV4cG9ydHMuY29yc1ZhbGlkYXRvciA9IGNvcnNWYWxpZGF0b3I7XG5cbnZhciBwYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PT0gdm9pZCAwKSB7XG4gICAgaW5wdXQgPSB7fTtcbiAgfVxuXG4gIHZhciBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQoe30sIGN1cnJlbnRTZXR0aW5ncyk7XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnB1dCwgJ2RlYnVnJykpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHsvLyBlbmFibGUgbG9nIHdpdGggcHJlZml4XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kZWJ1ZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBzZXR0aW5ncy5kZWJ1ZyA9IGlucHV0LmRlYnVnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0LmRlYnVnID09PSAnc3RyaW5nJykge1xuICAgICAgc2V0dGluZ3MuZGVidWcgPSBpbnB1dC5kZWJ1ZyA9PT0gJ3RydWUnO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQuY29ubmVjdFNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXR0aW5ncy5jb25uZWN0U3JjID0gaW5wdXQuY29ubmVjdFNyYztcbiAgfSAvLyBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIGBjb25uZWN0U3JjYCBjb3VsZCBiZSBkZWZpbmVkIGluIGBnbG9iYWwuX19UUkVaT1JfQ09OTkVDVF9TUkNgIHZhcmlhYmxlXG5cblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbC5fX1RSRVpPUl9DT05ORUNUX1NSQyA9PT0gJ3N0cmluZycpIHtcbiAgICBzZXR0aW5ncy5jb25uZWN0U3JjID0gY29yc1ZhbGlkYXRvcihnbG9iYWwuX19UUkVaT1JfQ09OTkVDVF9TUkMpO1xuICAgIHNldHRpbmdzLmRlYnVnID0gdHJ1ZTtcbiAgfSAvLyBGb3IgZGVidWdnaW5nIHB1cnBvc2VzIGBjb25uZWN0U3JjYCBjb3VsZCBiZSBkZWZpbmVkIGluIHVybCBxdWVyeSBvZiBob3N0aW5nIHBhZ2UuIFVzYWdlOlxuICAvLyBodHRwczovLzNyZHBhcnR5LXBhZ2UuY29tLz90cmV6b3ItY29ubmVjdC1zcmM9aHR0cHM6Ly9sb2NhbGhvc3Q6ODA4OC9cblxuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYXRpb24gJiYgdHlwZW9mIHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHZhcnMgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnNwbGl0KCcmJyk7XG4gICAgdmFyIGN1c3RvbVVybCA9IHZhcnMuZmluZChmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIHYuaW5kZXhPZigndHJlem9yLWNvbm5lY3Qtc3JjJykgPj0gMDtcbiAgICB9KTtcblxuICAgIGlmIChjdXN0b21VcmwpIHtcbiAgICAgIHZhciBfY3VzdG9tVXJsJHNwbGl0ID0gY3VzdG9tVXJsLnNwbGl0KCc9JyksXG4gICAgICAgICAgY29ubmVjdFNyYyA9IF9jdXN0b21Vcmwkc3BsaXRbMV07XG5cbiAgICAgIHNldHRpbmdzLmNvbm5lY3RTcmMgPSBjb3JzVmFsaWRhdG9yKGRlY29kZVVSSUNvbXBvbmVudChjb25uZWN0U3JjKSk7XG4gICAgICBzZXR0aW5ncy5kZWJ1ZyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNyYyA9IHNldHRpbmdzLmNvbm5lY3RTcmMgfHwgREVGQVVMVF9ET01BSU47XG4gIHNldHRpbmdzLmlmcmFtZVNyYyA9IHNyYyArIFwiaWZyYW1lLmh0bWxcIjtcbiAgc2V0dGluZ3MucG9wdXBTcmMgPSBzcmMgKyBcInBvcHVwLmh0bWxcIjtcbiAgc2V0dGluZ3Mud2VidXNiU3JjID0gc3JjICsgXCJ3ZWJ1c2IuaHRtbFwiO1xuXG4gIGlmICh0eXBlb2YgaW5wdXQudHJhbnNwb3J0UmVjb25uZWN0ID09PSAnYm9vbGVhbicpIHtcbiAgICBzZXR0aW5ncy50cmFuc3BvcnRSZWNvbm5lY3QgPSBpbnB1dC50cmFuc3BvcnRSZWNvbm5lY3Q7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LndlYnVzYiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc2V0dGluZ3Mud2VidXNiID0gaW5wdXQud2VidXNiO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5wb3B1cCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc2V0dGluZ3MucG9wdXAgPSBpbnB1dC5wb3B1cDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5wdXQubGF6eUxvYWQgPT09ICdib29sZWFuJykge1xuICAgIHNldHRpbmdzLmxhenlMb2FkID0gaW5wdXQubGF6eUxvYWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGlucHV0LnBlbmRpbmdUcmFuc3BvcnRFdmVudCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgc2V0dGluZ3MucGVuZGluZ1RyYW5zcG9ydEV2ZW50ID0gaW5wdXQucGVuZGluZ1RyYW5zcG9ydEV2ZW50O1xuICB9IC8vIGxvY2FsIGZpbGVzXG5cblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmxvY2F0aW9uICYmIHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgIHNldHRpbmdzLm9yaWdpbiA9IFwiZmlsZTovL1wiICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHNldHRpbmdzLndlYnVzYiA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5leHRlbnNpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgc2V0dGluZ3MuZXh0ZW5zaW9uID0gaW5wdXQuZXh0ZW5zaW9uO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5lbnYgPT09ICdzdHJpbmcnKSB7XG4gICAgc2V0dGluZ3MuZW52ID0gaW5wdXQuZW52O1xuICB9IGVsc2Uge1xuICAgIHNldHRpbmdzLmVudiA9IGdldEVudigpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC50aW1lc3RhbXAgPT09ICdudW1iZXInKSB7XG4gICAgc2V0dGluZ3MudGltZXN0YW1wID0gaW5wdXQudGltZXN0YW1wO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5pbnRlcmFjdGlvblRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgc2V0dGluZ3MuaW50ZXJhY3Rpb25UaW1lb3V0ID0gaW5wdXQuaW50ZXJhY3Rpb25UaW1lb3V0O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dC5tYW5pZmVzdCA9PT0gJ29iamVjdCcpIHtcbiAgICBzZXR0aW5ncy5tYW5pZmVzdCA9IHBhcnNlTWFuaWZlc3QoaW5wdXQubWFuaWZlc3QpO1xuICB9XG5cbiAgY3VycmVudFNldHRpbmdzID0gc2V0dGluZ3M7XG4gIHJldHVybiBjdXJyZW50U2V0dGluZ3M7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kaXNhYmxlV2ViVVNCID0gZXhwb3J0cy5yZXF1ZXN0TG9naW4gPSBleHBvcnRzLmN1c3RvbU1lc3NhZ2UgPSBleHBvcnRzLmdldFNldHRpbmdzID0gZXhwb3J0cy5yZW5kZXJXZWJVU0JCdXR0b24gPSBleHBvcnRzLnVpUmVzcG9uc2UgPSBleHBvcnRzLmNhbGwgPSBleHBvcnRzLmluaXQgPSBleHBvcnRzLmNhbmNlbCA9IGV4cG9ydHMuZGlzcG9zZSA9IGV4cG9ydHMubWFuaWZlc3QgPSBleHBvcnRzLmV2ZW50RW1pdHRlciA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9hc3luY1RvR2VuZXJhdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvclwiKSk7XG5cbnZhciBfZXZlbnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiZXZlbnRzXCIpKTtcblxudmFyIF9Qb3B1cE1hbmFnZXIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi9wb3B1cC9Qb3B1cE1hbmFnZXJcIikpO1xuXG52YXIgaWZyYW1lID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uLy4uL2lmcmFtZS9idWlsZGVyXCIpKTtcblxudmFyIF9idXR0b24gPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuLi8uLi93ZWJ1c2IvYnV0dG9uXCIpKTtcblxudmFyIF9tZXNzYWdlID0gcmVxdWlyZShcIi4uLy4uL21lc3NhZ2VcIik7XG5cbnZhciBfYnVpbGRlcjIgPSByZXF1aXJlKFwiLi4vLi4vbWVzc2FnZS9idWlsZGVyXCIpO1xuXG52YXIgX0Nvbm5lY3RTZXR0aW5ncyA9IHJlcXVpcmUoXCIuLi8uLi9kYXRhL0Nvbm5lY3RTZXR0aW5nc1wiKTtcblxudmFyIF9kZWJ1ZyA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9kZWJ1Z1wiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgJFQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vLi4vdHlwZXNcIikpO1xuXG5mdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsOyB2YXIgY2FjaGVCYWJlbEludGVyb3AgPSBuZXcgV2Vha01hcCgpOyB2YXIgY2FjaGVOb2RlSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IHJldHVybiBub2RlSW50ZXJvcCA/IGNhY2hlTm9kZUludGVyb3AgOiBjYWNoZUJhYmVsSW50ZXJvcDsgfSkobm9kZUludGVyb3ApOyB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaiwgbm9kZUludGVyb3ApIHsgaWYgKCFub2RlSW50ZXJvcCAmJiBvYmogJiYgb2JqLl9fZXNNb2R1bGUpIHsgcmV0dXJuIG9iajsgfSBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iaiAhPT0gXCJmdW5jdGlvblwiKSB7IHJldHVybiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfSB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApOyBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHsgcmV0dXJuIGNhY2hlLmdldChvYmopOyB9IHZhciBuZXdPYmogPSB7fTsgdmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IGlmIChrZXkgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHsgdmFyIGRlc2MgPSBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KSA6IG51bGw7IGlmIChkZXNjICYmIChkZXNjLmdldCB8fCBkZXNjLnNldCkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5ld09iaiwga2V5LCBkZXNjKTsgfSBlbHNlIHsgbmV3T2JqW2tleV0gPSBvYmpba2V5XTsgfSB9IH0gbmV3T2JqW1wiZGVmYXVsdFwiXSA9IG9iajsgaWYgKGNhY2hlKSB7IGNhY2hlLnNldChvYmosIG5ld09iaik7IH0gcmV0dXJuIG5ld09iajsgfVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgZXZlbnRFbWl0dGVyID0gbmV3IF9ldmVudHNbXCJkZWZhdWx0XCJdKCk7XG5leHBvcnRzLmV2ZW50RW1pdHRlciA9IGV2ZW50RW1pdHRlcjtcblxudmFyIF9sb2cgPSAoMCwgX2RlYnVnLmluaXRMb2cpKCdbdHJlem9yLWNvbm5lY3QuanNdJyk7XG5cbnZhciBfc2V0dGluZ3M7XG5cbnZhciBfcG9wdXBNYW5hZ2VyO1xuXG52YXIgaW5pdFBvcHVwTWFuYWdlciA9IGZ1bmN0aW9uIGluaXRQb3B1cE1hbmFnZXIoKSB7XG4gIHZhciBwbSA9IG5ldyBfUG9wdXBNYW5hZ2VyW1wiZGVmYXVsdFwiXShfc2V0dGluZ3MpO1xuICBwbS5vbihfY29uc3RhbnRzLlBPUFVQLkNMT1NFRCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICAgIHR5cGU6IF9jb25zdGFudHMuUE9QVVAuQ0xPU0VELFxuICAgICAgcGF5bG9hZDogZXJyb3IgPyB7XG4gICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgfSA6IG51bGxcbiAgICB9LCBmYWxzZSk7XG4gIH0pO1xuICByZXR1cm4gcG07XG59O1xuXG52YXIgbWFuaWZlc3QgPSBmdW5jdGlvbiBtYW5pZmVzdChkYXRhKSB7XG4gIF9zZXR0aW5ncyA9ICgwLCBfQ29ubmVjdFNldHRpbmdzLnBhcnNlKSh7XG4gICAgbWFuaWZlc3Q6IGRhdGFcbiAgfSk7XG59O1xuXG5leHBvcnRzLm1hbmlmZXN0ID0gbWFuaWZlc3Q7XG5cbnZhciBkaXNwb3NlID0gZnVuY3Rpb24gZGlzcG9zZSgpIHtcbiAgZXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZnJhbWUuZGlzcG9zZSgpO1xuXG4gIGlmIChfcG9wdXBNYW5hZ2VyKSB7XG4gICAgX3BvcHVwTWFuYWdlci5jbG9zZSgpO1xuICB9XG59O1xuXG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuXG52YXIgY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKGVycm9yKSB7XG4gIGlmIChfcG9wdXBNYW5hZ2VyKSB7XG4gICAgX3BvcHVwTWFuYWdlci5lbWl0KF9jb25zdGFudHMuUE9QVVAuQ0xPU0VELCBlcnJvcik7XG4gIH1cbn07IC8vIGhhbmRsZSBtZXNzYWdlIHJlY2VpdmVkIGZyb20gaWZyYW1lXG5cblxuZXhwb3J0cy5jYW5jZWwgPSBjYW5jZWw7XG5cbnZhciBoYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtZXNzYWdlRXZlbnQpIHtcbiAgLy8gaWdub3JlIG1lc3NhZ2VzIGZyb20gZG9tYWluIG90aGVyIHRoZW4gaWZyYW1lIG9yaWdpblxuICBpZiAobWVzc2FnZUV2ZW50Lm9yaWdpbiAhPT0gaWZyYW1lLm9yaWdpbikgcmV0dXJuO1xuICB2YXIgbWVzc2FnZSA9ICgwLCBfbWVzc2FnZS5wYXJzZU1lc3NhZ2UpKG1lc3NhZ2VFdmVudC5kYXRhKTtcbiAgdmFyIGV2ZW50ID0gbWVzc2FnZS5ldmVudCxcbiAgICAgIHR5cGUgPSBtZXNzYWdlLnR5cGUsXG4gICAgICBwYXlsb2FkID0gbWVzc2FnZS5wYXlsb2FkO1xuICB2YXIgaWQgPSBtZXNzYWdlLmlkIHx8IDA7XG5cbiAgX2xvZy5sb2coJ2hhbmRsZU1lc3NhZ2UnLCBtZXNzYWdlKTtcblxuICBzd2l0Y2ggKGV2ZW50KSB7XG4gICAgY2FzZSBfY29uc3RhbnRzLlJFU1BPTlNFX0VWRU5UOlxuICAgICAgaWYgKGlmcmFtZS5tZXNzYWdlUHJvbWlzZXNbaWRdKSB7XG4gICAgICAgIC8vIHJlc29sdmUgbWVzc2FnZSBwcm9taXNlIChzZW5kIHJlc3VsdCBvZiBjYWxsIG1ldGhvZClcbiAgICAgICAgaWZyYW1lLm1lc3NhZ2VQcm9taXNlc1tpZF0ucmVzb2x2ZSh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHN1Y2Nlc3M6IG1lc3NhZ2Uuc3VjY2VzcyxcbiAgICAgICAgICBwYXlsb2FkOiBwYXlsb2FkXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgaWZyYW1lLm1lc3NhZ2VQcm9taXNlc1tpZF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfbG9nLndhcm4oXCJVbmtub3duIG1lc3NhZ2UgaWQgXCIgKyBpZCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBfY29uc3RhbnRzLkRFVklDRV9FVkVOVDpcbiAgICAgIC8vIHBhc3MgREVWSUNFIGV2ZW50IHVwIHRvIGh0bWxcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50LCBtZXNzYWdlKTtcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KHR5cGUsIHBheWxvYWQpOyAvLyBERVZJQ0VfRVZFTlQgYWxzbyBlbWl0IHNpbmdsZSBldmVudHMgKGNvbm5lY3QvZGlzY29ubmVjdC4uLilcblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIF9jb25zdGFudHMuVFJBTlNQT1JUX0VWRU5UOlxuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQsIG1lc3NhZ2UpO1xuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQodHlwZSwgcGF5bG9hZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX2NvbnN0YW50cy5CTE9DS0NIQUlOX0VWRU5UOlxuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQoZXZlbnQsIG1lc3NhZ2UpO1xuICAgICAgZXZlbnRFbWl0dGVyLmVtaXQodHlwZSwgcGF5bG9hZCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgX2NvbnN0YW50cy5VSV9FVkVOVDpcbiAgICAgIGlmICh0eXBlID09PSBfY29uc3RhbnRzLklGUkFNRS5CT09UU1RSQVApIHtcbiAgICAgICAgaWZyYW1lLmNsZWFyVGltZW91dCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGUgPT09IF9jb25zdGFudHMuSUZSQU1FLkxPQURFRCkge1xuICAgICAgICBpZnJhbWUuaW5pdFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZSA9PT0gX2NvbnN0YW50cy5JRlJBTUUuRVJST1IpIHtcbiAgICAgICAgaWZyYW1lLmluaXRQcm9taXNlLnJlamVjdChwYXlsb2FkLmVycm9yKTtcbiAgICAgIH0gLy8gcGFzcyBVSSBldmVudCB1cFxuXG5cbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KGV2ZW50LCBtZXNzYWdlKTtcbiAgICAgIGV2ZW50RW1pdHRlci5lbWl0KHR5cGUsIHBheWxvYWQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgX2xvZy5sb2coJ1VuZGVmaW5lZCBtZXNzYWdlJywgZXZlbnQsIG1lc3NhZ2VFdmVudCk7XG5cbiAgfVxufTtcblxudmFyIGluaXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNldHRpbmdzKSB7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIHNldHRpbmdzID0ge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghaWZyYW1lLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9BbHJlYWR5SW5pdGlhbGl6ZWQnKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGlmICghX3NldHRpbmdzKSB7XG4gICAgICAgICAgICAgIF9zZXR0aW5ncyA9ICgwLCBfQ29ubmVjdFNldHRpbmdzLnBhcnNlKShzZXR0aW5ncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChfc2V0dGluZ3MubWFuaWZlc3QpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdJbml0X01hbmlmZXN0TWlzc2luZycpO1xuXG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgaWYgKCFfc2V0dGluZ3MubGF6eUxvYWQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyByZXNldCBcImxhenlMb2FkXCIgYWZ0ZXIgZmlyc3QgdXNlXG4gICAgICAgICAgICBfc2V0dGluZ3MubGF6eUxvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBpZiAoIV9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlciA9IGluaXRQb3B1cE1hbmFnZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2xvZy5lbmFibGVkID0gISFfc2V0dGluZ3MuZGVidWc7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3VubG9hZCcsIGRpc3Bvc2UpO1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE1O1xuICAgICAgICAgICAgcmV0dXJuIGlmcmFtZS5pbml0KF9zZXR0aW5ncyk7XG5cbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBpbml0KF94KSB7XG4gICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5pbml0ID0gaW5pdDtcblxudmFyIGNhbGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocGFyYW1zKSB7XG4gICAgdmFyIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEoIWlmcmFtZS5pbnN0YW5jZSAmJiAhaWZyYW1lLnRpbWVvdXQpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbml0IHBvcHVwIHdpdGggbGF6eSBsb2FkaW5nIGJlZm9yZSBpZnJhbWUgaW5pdGlhbGl6YXRpb25cbiAgICAgICAgICAgIF9zZXR0aW5ncyA9ICgwLCBfQ29ubmVjdFNldHRpbmdzLnBhcnNlKShfc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICBpZiAoX3NldHRpbmdzLm1hbmlmZXN0KSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfTWFuaWZlc3RNaXNzaW5nJykpKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmICghX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyID0gaW5pdFBvcHVwTWFuYWdlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLnJlcXVlc3QodHJ1ZSk7IC8vIGF1dG8gaW5pdCB3aXRoIGRlZmF1bHQgc2V0dGluZ3NcblxuXG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDY7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDk7XG4gICAgICAgICAgICByZXR1cm4gaW5pdChfc2V0dGluZ3MpO1xuXG4gICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5wcmV2ID0gMTE7XG4gICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSg2KTtcblxuICAgICAgICAgICAgaWYgKF9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgLy8gQ2F0Y2ggZmF0YWwgaWZyYW1lIGVycm9ycyAobm90IGxvYWRpbmcpXG4gICAgICAgICAgICAgIGlmIChbJ0luaXRfSWZyYW1lQmxvY2tlZCcsICdJbml0X0lmcmFtZVRpbWVvdXQnXS5pbmNsdWRlcyhfY29udGV4dDIudDAuY29kZSkpIHtcbiAgICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLnBvc3RNZXNzYWdlKCgwLCBfYnVpbGRlcjIuVWlNZXNzYWdlKShfY29uc3RhbnRzLlVJLklGUkFNRV9GQUlMVVJFKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlci5jbG9zZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb250ZXh0Mi50MCkpO1xuXG4gICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgIGlmICghaWZyYW1lLnRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfTWFuaWZlc3RNaXNzaW5nJykpKTtcblxuICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBpZiAoIWlmcmFtZS5lcnJvcikge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoaWZyYW1lLmVycm9yKSk7XG5cbiAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgLy8gcmVxdWVzdCBwb3B1cCB3aW5kb3cgaXQgbWlnaHQgYmUgdXNlZCBpbiB0aGUgZnV0dXJlXG4gICAgICAgICAgICBpZiAoX3NldHRpbmdzLnBvcHVwICYmIF9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlci5yZXF1ZXN0KCk7XG4gICAgICAgICAgICB9IC8vIHBvc3QgbWVzc2FnZSB0byBpZnJhbWVcblxuXG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDIwO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMztcbiAgICAgICAgICAgIHJldHVybiBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICB0eXBlOiBfY29uc3RhbnRzLklGUkFNRS5DQUxMLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBwYXJhbXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyLnNlbnQ7XG5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uuc3VjY2VzcyAmJiByZXNwb25zZS5wYXlsb2FkLmNvZGUgIT09ICdEZXZpY2VfQ2FsbEluUHJvZ3Jlc3MnICYmIF9wb3B1cE1hbmFnZXIpIHtcbiAgICAgICAgICAgICAgX3BvcHVwTWFuYWdlci51bmxvY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UpO1xuXG4gICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGlmIChfcG9wdXBNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgIF9wb3B1cE1hbmFnZXIudW5sb2NrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ01ldGhvZF9Ob1Jlc3BvbnNlJykpKTtcblxuICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDMxO1xuICAgICAgICAgICAgX2NvbnRleHQyLnQxID0gX2NvbnRleHQyW1wiY2F0Y2hcIl0oMjApO1xuXG4gICAgICAgICAgICBfbG9nLmVycm9yKCdfX2NhbGwgZXJyb3InLCBfY29udGV4dDIudDEpO1xuXG4gICAgICAgICAgICBpZiAoX3BvcHVwTWFuYWdlcikge1xuICAgICAgICAgICAgICBfcG9wdXBNYW5hZ2VyLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsICgwLCBfbWVzc2FnZS5lcnJvck1lc3NhZ2UpKF9jb250ZXh0Mi50MSkpO1xuXG4gICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzYsIDExXSwgWzIwLCAzMV1dKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBjYWxsKF94Mikge1xuICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLmNhbGwgPSBjYWxsO1xuXG52YXIgY3VzdG9tTWVzc2FnZVJlc3BvbnNlID0gZnVuY3Rpb24gY3VzdG9tTWVzc2FnZVJlc3BvbnNlKHBheWxvYWQpIHtcbiAgaWZyYW1lLnBvc3RNZXNzYWdlKHtcbiAgICBldmVudDogX2NvbnN0YW50cy5VSV9FVkVOVCxcbiAgICB0eXBlOiBfY29uc3RhbnRzLlVJLkNVU1RPTV9NRVNTQUdFX1JFU1BPTlNFLFxuICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgfSk7XG59O1xuXG52YXIgdWlSZXNwb25zZSA9IGZ1bmN0aW9uIHVpUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgdmFyIHR5cGUgPSByZXNwb25zZS50eXBlLFxuICAgICAgcGF5bG9hZCA9IHJlc3BvbnNlLnBheWxvYWQ7XG4gIGlmcmFtZS5wb3N0TWVzc2FnZSh7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuVUlfRVZFTlQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH0pO1xufTtcblxuZXhwb3J0cy51aVJlc3BvbnNlID0gdWlSZXNwb25zZTtcblxudmFyIHJlbmRlcldlYlVTQkJ1dHRvbiA9IGZ1bmN0aW9uIHJlbmRlcldlYlVTQkJ1dHRvbihjbGFzc05hbWUpIHtcbiAgKDAsIF9idXR0b25bXCJkZWZhdWx0XCJdKShjbGFzc05hbWUsIF9zZXR0aW5ncy53ZWJ1c2JTcmMsIGlmcmFtZS5vcmlnaW4pO1xufTtcblxuZXhwb3J0cy5yZW5kZXJXZWJVU0JCdXR0b24gPSByZW5kZXJXZWJVU0JCdXR0b247XG5cbnZhciBnZXRTZXR0aW5ncyA9IGZ1bmN0aW9uIGdldFNldHRpbmdzKCkge1xuICBpZiAoIWlmcmFtZS5pbnN0YW5jZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKDAsIF9tZXNzYWdlLmVycm9yTWVzc2FnZSkoX2NvbnN0YW50cy5FUlJPUlMuVHlwZWRFcnJvcignSW5pdF9Ob3RJbml0aWFsaXplZCcpKSk7XG4gIH1cblxuICByZXR1cm4gY2FsbCh7XG4gICAgbWV0aG9kOiAnZ2V0U2V0dGluZ3MnXG4gIH0pO1xufTtcblxuZXhwb3J0cy5nZXRTZXR0aW5ncyA9IGdldFNldHRpbmdzO1xuXG52YXIgY3VzdG9tTWVzc2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmMyA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNChwYXJhbXMpIHtcbiAgICB2YXIgY2FsbGJhY2ssIGN1c3RvbU1lc3NhZ2VMaXN0ZW5lciwgcmVzcG9uc2U7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoISh0eXBlb2YgcGFyYW1zLmNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgICBfY29udGV4dDQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCAoMCwgX21lc3NhZ2UuZXJyb3JNZXNzYWdlKShfY29uc3RhbnRzLkVSUk9SUy5UeXBlZEVycm9yKCdNZXRob2RfQ3VzdG9tTWVzc2FnZV9DYWxsYmFjaycpKSk7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAvLyBUT0RPOiBzZXQgbWVzc2FnZSBsaXN0ZW5lciBvbmx5IGlmIGlmcmFtZSBpcyBsb2FkZWQgY29ycmVjdGx5XG4gICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcy5jYWxsYmFjaztcblxuICAgICAgICAgICAgY3VzdG9tTWVzc2FnZUxpc3RlbmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWY0ID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEsIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLnR5cGUgPT09IF9jb25zdGFudHMuVUkuQ1VTVE9NX01FU1NBR0VfUkVRVUVTVCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEucGF5bG9hZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gX2NvbnRleHQzLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbU1lc3NhZ2VSZXNwb25zZShwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbU1lc3NhZ2VSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ3JlbGVhc2UnXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMpO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGN1c3RvbU1lc3NhZ2VMaXN0ZW5lcihfeDQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjdXN0b21NZXNzYWdlTGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBjYWxsKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ2N1c3RvbU1lc3NhZ2UnXG4gICAgICAgICAgICB9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbFxuICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmVzcG9uc2UgPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgY3VzdG9tTWVzc2FnZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNCk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gY3VzdG9tTWVzc2FnZShfeDMpIHtcbiAgICByZXR1cm4gX3JlZjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5jdXN0b21NZXNzYWdlID0gY3VzdG9tTWVzc2FnZTtcblxudmFyIHJlcXVlc3RMb2dpbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmNSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwYXJhbXMpIHtcbiAgICB2YXIgY2FsbGJhY2ssIGxvZ2luQ2hhbGxlbmdlTGlzdGVuZXIsIHJlc3BvbnNlO1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDYucHJldiA9IF9jb250ZXh0Ni5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgaWYgKCEodHlwZW9mIHBhcmFtcy5jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXMuY2FsbGJhY2s7IC8vIFRPRE86IHNldCBtZXNzYWdlIGxpc3RlbmVyIG9ubHkgaWYgaWZyYW1lIGlzIGxvYWRlZCBjb3JyZWN0bHlcblxuICAgICAgICAgICAgbG9naW5DaGFsbGVuZ2VMaXN0ZW5lciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHZhciBfcmVmNiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNShldmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhLCBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDUucHJldiA9IF9jb250ZXh0NS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGV2ZW50LmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGRhdGEgJiYgZGF0YS50eXBlID09PSBfY29uc3RhbnRzLlVJLkxPR0lOX0NIQUxMRU5HRV9SRVFVRVNUKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogX2NvbnN0YW50cy5VSV9FVkVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2NvbnN0YW50cy5VSS5MT0dJTl9DSEFMTEVOR0VfUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnByZXYgPSA5O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ1LnQwID0gX2NvbnRleHQ1W1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogX2NvbnN0YW50cy5VSV9FVkVOVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogX2NvbnN0YW50cy5VSS5MT0dJTl9DSEFMTEVOR0VfUkVTUE9OU0UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IF9jb250ZXh0NS50MC5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNSwgbnVsbCwgW1syLCA5XV0pO1xuICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxvZ2luQ2hhbGxlbmdlTGlzdGVuZXIoX3g2KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZWY2LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbG9naW5DaGFsbGVuZ2VMaXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSA2O1xuICAgICAgICAgICAgcmV0dXJuIGNhbGwoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAncmVxdWVzdExvZ2luJ1xuICAgICAgICAgICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgICAgICAgICAgYXN5bmNDaGFsbGVuZ2U6IHRydWUsXG4gICAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICByZXNwb25zZSA9IF9jb250ZXh0Ni5zZW50O1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsb2dpbkNoYWxsZW5nZUxpc3RlbmVyKTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIHJlc3BvbnNlKTtcblxuICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIGNhbGwoX29iamVjdFNwcmVhZCh7XG4gICAgICAgICAgICAgIG1ldGhvZDogJ3JlcXVlc3RMb2dpbidcbiAgICAgICAgICAgIH0sIHBhcmFtcykpKTtcblxuICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlNik7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdExvZ2luKF94NSkge1xuICAgIHJldHVybiBfcmVmNS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufSgpO1xuXG5leHBvcnRzLnJlcXVlc3RMb2dpbiA9IHJlcXVlc3RMb2dpbjtcblxudmFyIGRpc2FibGVXZWJVU0IgPSBmdW5jdGlvbiBkaXNhYmxlV2ViVVNCKCkge1xuICBpZnJhbWUucG9zdE1lc3NhZ2Uoe1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLlVJX0VWRU5ULFxuICAgIHR5cGU6IF9jb25zdGFudHMuVFJBTlNQT1JULkRJU0FCTEVfV0VCVVNCXG4gIH0pO1xufTtcblxuZXhwb3J0cy5kaXNhYmxlV2ViVVNCID0gZGlzYWJsZVdlYlVTQjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmdldE9yaWdpbiA9IGV4cG9ydHMuaHR0cFJlcXVlc3QgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9yZWdlbmVyYXRvclwiKSk7XG5cbnZhciBfYXN5bmNUb0dlbmVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3JcIikpO1xuXG52YXIgX2Nyb3NzRmV0Y2ggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKSk7XG5cbnZhciBodHRwUmVxdWVzdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHZhciBfcmVmID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUodXJsLCB0eXBlKSB7XG4gICAgdmFyIHJlc3BvbnNlLCB0eHQ7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGlmICh0eXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgdHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgICByZXR1cm4gKDAsIF9jcm9zc0ZldGNoW1wiZGVmYXVsdFwiXSkodXJsLCB7XG4gICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoISh0eXBlID09PSAnanNvbicpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA4O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKTtcblxuICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIHR4dCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIEpTT04ucGFyc2UodHh0KSk7XG5cbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgaWYgKCEodHlwZSA9PT0gJ2JpbmFyeScpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSk7XG5cbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXNwb25zZS50ZXh0KCkpO1xuXG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImh0dHBSZXF1ZXN0IGVycm9yOiBcIiArIHVybCArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG5cbiAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlKTtcbiAgfSkpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBodHRwUmVxdWVzdChfeCwgX3gyKSB7XG4gICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn0oKTtcblxuZXhwb3J0cy5odHRwUmVxdWVzdCA9IGh0dHBSZXF1ZXN0O1xuXG52YXIgZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luKHVybCkge1xuICBpZiAodXJsLmluZGV4T2YoJ2ZpbGU6Ly8nKSA9PT0gMCkgcmV0dXJuICdmaWxlOi8vJzsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtZXNjYXBlXG5cbiAgdmFyIHBhcnRzID0gdXJsLm1hdGNoKC9eLitcXDpcXC9cXC9bXlxcL10rLyk7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHBhcnRzKSAmJiBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAndW5rbm93bic7XG59O1xuXG5leHBvcnRzLmdldE9yaWdpbiA9IGdldE9yaWdpbjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQgPSByZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHRcIik7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNsZWFyVGltZW91dCA9IGV4cG9ydHMuZGlzcG9zZSA9IGV4cG9ydHMucG9zdE1lc3NhZ2UgPSBleHBvcnRzLmluaXQgPSBleHBvcnRzLm1lc3NhZ2VQcm9taXNlcyA9IGV4cG9ydHMuZXJyb3IgPSBleHBvcnRzLnRpbWVvdXQgPSBleHBvcnRzLmluaXRQcm9taXNlID0gZXhwb3J0cy5vcmlnaW4gPSBleHBvcnRzLmluc3RhbmNlID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9kZWZlcnJlZCA9IHJlcXVpcmUoXCIuLi91dGlscy9kZWZlcnJlZFwiKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuXG52YXIgX25ldHdvcmtVdGlscyA9IHJlcXVpcmUoXCIuLi9lbnYvYnJvd3Nlci9uZXR3b3JrVXRpbHNcIik7XG5cbnZhciBfaW5saW5lU3R5bGVzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9pbmxpbmUtc3R5bGVzXCIpKTtcblxuLyogZXNsaW50LWRpc2FibGUgaW1wb3J0L25vLW11dGFibGUtZXhwb3J0cyAqL1xudmFyIGluc3RhbmNlO1xuZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlO1xudmFyIG9yaWdpbjtcbmV4cG9ydHMub3JpZ2luID0gb3JpZ2luO1xudmFyIGluaXRQcm9taXNlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKCk7XG5leHBvcnRzLmluaXRQcm9taXNlID0gaW5pdFByb21pc2U7XG52YXIgdGltZW91dCA9IDA7XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xudmFyIGVycm9yO1xuLyogZXNsaW50LWVuYWJsZSBpbXBvcnQvbm8tbXV0YWJsZS1leHBvcnRzICovXG5cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbnZhciBfbWVzc2FnZUlEID0gMDsgLy8gZXZlcnkgcG9zdE1lc3NhZ2UgdG8gaWZyYW1lIGhhcyBpdHMgb3duIHByb21pc2UgdG8gcmVzb2x2ZVxuXG52YXIgbWVzc2FnZVByb21pc2VzID0ge307XG5leHBvcnRzLm1lc3NhZ2VQcm9taXNlcyA9IG1lc3NhZ2VQcm9taXNlcztcblxudmFyIGluaXQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHNldHRpbmdzKSB7XG4gICAgdmFyIGV4aXN0ZWRGcmFtZSwgc3JjLCBtYW5pZmVzdFN0cmluZywgbWFuaWZlc3QsIG9uTG9hZDtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgZXhwb3J0cy5pbml0UHJvbWlzZSA9IGluaXRQcm9taXNlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKCk7XG4gICAgICAgICAgICBleGlzdGVkRnJhbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHJlem9yY29ubmVjdCcpO1xuXG4gICAgICAgICAgICBpZiAoZXhpc3RlZEZyYW1lKSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZSA9IGV4aXN0ZWRGcmFtZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuaW5zdGFuY2UgPSBpbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mcmFtZUJvcmRlciA9ICcwJztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uud2lkdGggPSAnMHB4JztcbiAgICAgICAgICAgICAgaW5zdGFuY2UuaGVpZ2h0ID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3R5bGUuYm9yZGVyID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0eWxlLndpZHRoID0gJzBweCc7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0eWxlLmhlaWdodCA9ICcwcHgnO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5pZCA9ICd0cmV6b3Jjb25uZWN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVudiA9PT0gJ3dlYicpIHtcbiAgICAgICAgICAgICAgbWFuaWZlc3RTdHJpbmcgPSBzZXR0aW5ncy5tYW5pZmVzdCA/IEpTT04uc3RyaW5naWZ5KHNldHRpbmdzLm1hbmlmZXN0KSA6ICd1bmRlZmluZWQnOyAvLyBub3RlOiBidG9hKHVuZGVmaW5lZCkgPT09IGJ0b2EoJ3VuZGVmaW5lZCcpID09PSBcImRXNWtaV1pwYm1Wa1wiXG5cbiAgICAgICAgICAgICAgbWFuaWZlc3QgPSBcInZlcnNpb249XCIgKyBzZXR0aW5ncy52ZXJzaW9uICsgXCImbWFuaWZlc3Q9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoYnRvYShKU09OLnN0cmluZ2lmeShtYW5pZmVzdFN0cmluZykpKTtcbiAgICAgICAgICAgICAgc3JjID0gc2V0dGluZ3MuaWZyYW1lU3JjICsgXCI/XCIgKyBtYW5pZmVzdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNyYyA9IHNldHRpbmdzLmlmcmFtZVNyYztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2Uuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mud2VidXNiKSB7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnNldEF0dHJpYnV0ZSgnYWxsb3cnLCAndXNiJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cG9ydHMub3JpZ2luID0gb3JpZ2luID0gKDAsIF9uZXR3b3JrVXRpbHMuZ2V0T3JpZ2luKShpbnN0YW5jZS5zcmMpO1xuICAgICAgICAgICAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgaW5pdFByb21pc2UucmVqZWN0KF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lVGltZW91dCcpKTtcbiAgICAgICAgICAgIH0sIDEwMDAwKTtcblxuICAgICAgICAgICAgb25Mb2FkID0gZnVuY3Rpb24gb25Mb2FkKCkge1xuICAgICAgICAgICAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgaW5pdFByb21pc2UucmVqZWN0KF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGhvc3RpbmcgcGFnZSBpcyBhYmxlIHRvIGFjY2VzcyBjcm9zcy1vcmlnaW4gbG9jYXRpb24gaXQgbWVhbnMgdGhhdCB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWRcbiAgICAgICAgICAgICAgICB2YXIgaWZyYW1lT3JpZ2luID0gaW5zdGFuY2UuY29udGVudFdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG5cbiAgICAgICAgICAgICAgICBpZiAoIWlmcmFtZU9yaWdpbiB8fCBpZnJhbWVPcmlnaW4gPT09ICdudWxsJykge1xuICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG4gICAgICAgICAgICAgICAgICBoYW5kbGVJZnJhbWVCbG9ja2VkKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7Ly8gZW1wdHlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBleHRlbnNpb247IC8vICRGbG93SXNzdWUgY2hyb21lIGlzIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmIGNocm9tZS5ydW50aW1lICYmIHR5cGVvZiBjaHJvbWUucnVudGltZS5vbkNvbm5lY3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY2hyb21lLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgICAgICAgICAgICBleHRlbnNpb24gPSBjaHJvbWUucnVudGltZS5pZDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IF9jb25zdGFudHMuSUZSQU1FLklOSVQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgc2V0dGluZ3M6IHNldHRpbmdzLFxuICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uOiBleHRlbnNpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sIG9yaWdpbik7XG4gICAgICAgICAgICAgIGluc3RhbmNlLm9ubG9hZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07IC8vIElFIGhhY2tcblxuXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UuYXR0YWNoRXZlbnQpIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuYXR0YWNoRXZlbnQoJ29ubG9hZCcsIG9uTG9hZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jZS5vbmxvYWQgPSBvbkxvYWQ7XG4gICAgICAgICAgICB9IC8vIGluamVjdCBpZnJhbWUgaW50byBob3N0IGRvY3VtZW50IGJvZHlcblxuXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGluc3RhbmNlKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZS1iZWZvcmUtZGVmaW5lXG5cbiAgICAgICAgICAgICAgaW5qZWN0U3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICByZXR1cm4gaW5pdFByb21pc2UucHJvbWlzZTtcblxuICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjA7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTY7XG4gICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMTEpO1xuXG4gICAgICAgICAgICAvLyByZXNldCBzdGF0ZSB0byBhbGxvdyBpbml0aWFsaXphdGlvbiBhZ2FpblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpbnN0YW5jZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBleHBvcnRzLmluc3RhbmNlID0gaW5zdGFuY2UgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBfY29udGV4dC50MDtcblxuICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMjA7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgICAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuZmluaXNoKDIwKTtcblxuICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMTEsIDE2LCAyMCwgMjRdXSk7XG4gIH0pKTtcblxuICByZXR1cm4gZnVuY3Rpb24gaW5pdChfeCkge1xuICAgIHJldHVybiBfcmVmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuaW5pdCA9IGluaXQ7XG5cbnZhciBpbmplY3RTdHlsZVNoZWV0ID0gZnVuY3Rpb24gaW5qZWN0U3R5bGVTaGVldCgpIHtcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIHRocm93IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpO1xuICB9XG5cbiAgdmFyIGRvYyA9IGluc3RhbmNlLm93bmVyRG9jdW1lbnQ7XG4gIHZhciBoZWFkID0gZG9jLmhlYWQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gIHN0eWxlLnNldEF0dHJpYnV0ZSgndHlwZScsICd0ZXh0L2NzcycpO1xuICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ1RyZXpvckNvbm5lY3RTdHlsZXNoZWV0Jyk7IC8vICRGbG93SXNzdWVcblxuICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgIC8vIElFXG4gICAgLy8gJEZsb3dJc3N1ZVxuICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IF9pbmxpbmVTdHlsZXNbXCJkZWZhdWx0XCJdO1xuICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKF9pbmxpbmVTdHlsZXNbXCJkZWZhdWx0XCJdKSk7XG4gICAgaGVhZC5hcHBlbmQoc3R5bGUpO1xuICB9XG59O1xuXG52YXIgaGFuZGxlSWZyYW1lQmxvY2tlZCA9IGZ1bmN0aW9uIGhhbmRsZUlmcmFtZUJsb2NrZWQoKSB7XG4gIHdpbmRvdy5jbGVhclRpbWVvdXQodGltZW91dCk7XG4gIGV4cG9ydHMuZXJyb3IgPSBlcnJvciA9IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcblxuICBkaXNwb3NlKCk7XG4gIGluaXRQcm9taXNlLnJlamVjdChlcnJvcik7XG59OyAvLyBwb3N0IG1lc3NhZ2VzIHRvIGlmcmFtZVxuXG5cbnZhciBwb3N0TWVzc2FnZSA9IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1lc3NhZ2UsIHVzZVByb21pc2UpIHtcbiAgaWYgKHVzZVByb21pc2UgPT09IHZvaWQgMCkge1xuICAgIHVzZVByb21pc2UgPSB0cnVlO1xuICB9XG5cbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIHRocm93IF9jb25zdGFudHMuRVJST1JTLlR5cGVkRXJyb3IoJ0luaXRfSWZyYW1lQmxvY2tlZCcpO1xuICB9XG5cbiAgaWYgKHVzZVByb21pc2UpIHtcbiAgICBfbWVzc2FnZUlEKys7XG4gICAgbWVzc2FnZS5pZCA9IF9tZXNzYWdlSUQ7XG4gICAgbWVzc2FnZVByb21pc2VzW19tZXNzYWdlSURdID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKCk7XG4gICAgdmFyIHByb21pc2UgPSBtZXNzYWdlUHJvbWlzZXNbX21lc3NhZ2VJRF0ucHJvbWlzZTtcbiAgICBpbnN0YW5jZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBpbnN0YW5jZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1lc3NhZ2UsIG9yaWdpbik7XG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0cy5wb3N0TWVzc2FnZSA9IHBvc3RNZXNzYWdlO1xuXG52YXIgZGlzcG9zZSA9IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5wYXJlbnROb2RlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGluc3RhbmNlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW5zdGFuY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHsvLyBkbyBub3RoaW5nXG4gICAgfVxuICB9XG5cbiAgZXhwb3J0cy5pbnN0YW5jZSA9IGluc3RhbmNlID0gbnVsbDtcbiAgZXhwb3J0cy50aW1lb3V0ID0gdGltZW91dCA9IDA7XG59O1xuXG5leHBvcnRzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuXG52YXIgY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gY2xlYXJUaW1lb3V0KCkge1xuICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufTtcblxuZXhwb3J0cy5jbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBjc3MgPSAnLnRyZXpvcmNvbm5lY3QtY29udGFpbmVye3Bvc2l0aW9uOmZpeGVkIWltcG9ydGFudDtkaXNwbGF5Oi13ZWJraXQtYm94IWltcG9ydGFudDtkaXNwbGF5Oi13ZWJraXQtZmxleCFpbXBvcnRhbnQ7ZGlzcGxheTotbXMtZmxleGJveCFpbXBvcnRhbnQ7ZGlzcGxheTpmbGV4IWltcG9ydGFudDstd2Via2l0LWJveC1vcmllbnQ6dmVydGljYWwhaW1wb3J0YW50Oy13ZWJraXQtYm94LWRpcmVjdGlvbjpub3JtYWwhaW1wb3J0YW50Oy13ZWJraXQtZmxleC1kaXJlY3Rpb246Y29sdW1uIWltcG9ydGFudDstbXMtZmxleC1kaXJlY3Rpb246Y29sdW1uIWltcG9ydGFudDtmbGV4LWRpcmVjdGlvbjpjb2x1bW4haW1wb3J0YW50Oy13ZWJraXQtYm94LWFsaWduOmNlbnRlciFpbXBvcnRhbnQ7LXdlYmtpdC1hbGlnbi1pdGVtczpjZW50ZXIhaW1wb3J0YW50Oy1tcy1mbGV4LWFsaWduOmNlbnRlciFpbXBvcnRhbnQ7YWxpZ24taXRlbXM6Y2VudGVyIWltcG9ydGFudDt6LWluZGV4OjEwMDAwIWltcG9ydGFudDt3aWR0aDoxMDAlIWltcG9ydGFudDtoZWlnaHQ6MTAwJSFpbXBvcnRhbnQ7dG9wOjAhaW1wb3J0YW50O2xlZnQ6MCFpbXBvcnRhbnQ7YmFja2dyb3VuZDpyZ2JhKDAsMCwwLC4zNSkhaW1wb3J0YW50O292ZXJmbG93OmF1dG8haW1wb3J0YW50O3BhZGRpbmc6MjBweCFpbXBvcnRhbnQ7bWFyZ2luOjAhaW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3d7cG9zaXRpb246cmVsYXRpdmUhaW1wb3J0YW50O2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50O3dpZHRoOjM3MHB4IWltcG9ydGFudDtmb250LWZhbWlseTotYXBwbGUtc3lzdGVtLEJsaW5rTWFjU3lzdGVtRm9udCxcIlNlZ29lIFVJXCIsUm9ib3RvLFwiSGVsdmV0aWNhIE5ldWVcIixBcmlhbCxzYW5zLXNlcmlmIWltcG9ydGFudDttYXJnaW46YXV0byFpbXBvcnRhbnQ7Ym9yZGVyLXJhZGl1czozcHghaW1wb3J0YW50O2JhY2tncm91bmQtY29sb3I6I2ZmZiFpbXBvcnRhbnQ7dGV4dC1hbGlnbjpjZW50ZXIhaW1wb3J0YW50O292ZXJmbG93OmhpZGRlbiFpbXBvcnRhbnR9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1oZWFke3RleHQtYWxpZ246bGVmdDtwYWRkaW5nOjEycHggMjRweCFpbXBvcnRhbnQ7ZGlzcGxheTotd2Via2l0LWJveCFpbXBvcnRhbnQ7ZGlzcGxheTotd2Via2l0LWZsZXghaW1wb3J0YW50O2Rpc3BsYXk6LW1zLWZsZXhib3ghaW1wb3J0YW50O2Rpc3BsYXk6ZmxleCFpbXBvcnRhbnQ7LXdlYmtpdC1ib3gtYWxpZ246Y2VudGVyIWltcG9ydGFudDstd2Via2l0LWFsaWduLWl0ZW1zOmNlbnRlciFpbXBvcnRhbnQ7LW1zLWZsZXgtYWxpZ246Y2VudGVyIWltcG9ydGFudDthbGlnbi1pdGVtczpjZW50ZXIhaW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtaGVhZCAudHJlem9yY29ubmVjdC1sb2dvey13ZWJraXQtYm94LWZsZXg6MTstd2Via2l0LWZsZXg6MTstbXMtZmxleDoxO2ZsZXg6MX0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWhlYWQgLnRyZXpvcmNvbm5lY3QtY2xvc2V7Y3Vyc29yOnBvaW50ZXIhaW1wb3J0YW50O2hlaWdodDoyNHB4IWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWhlYWQgLnRyZXpvcmNvbm5lY3QtY2xvc2Ugc3Zne2ZpbGw6Izc1NzU3NTstd2Via2l0LXRyYW5zaXRpb246ZmlsbCAuM3MgZWFzZS1pbi1vdXQhaW1wb3J0YW50O3RyYW5zaXRpb246ZmlsbCAuM3MgZWFzZS1pbi1vdXQhaW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtaGVhZCAudHJlem9yY29ubmVjdC1jbG9zZTpob3ZlciBzdmd7ZmlsbDojNDk0OTQ5fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtYm9keXtwYWRkaW5nOjI0cHggMjRweCAzMnB4IWltcG9ydGFudDtiYWNrZ3JvdW5kOiNGQkZCRkIhaW1wb3J0YW50O2JvcmRlci10b3A6MXB4IHNvbGlkICNFQkVCRUJ9LnRyZXpvcmNvbm5lY3QtY29udGFpbmVyIC50cmV6b3Jjb25uZWN0LXdpbmRvdyAudHJlem9yY29ubmVjdC1ib2R5IGgze2NvbG9yOiM1MDUwNTAhaW1wb3J0YW50O2ZvbnQtc2l6ZToxNnB4IWltcG9ydGFudDtmb250LXdlaWdodDo1MDAhaW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtYm9keSBwe21hcmdpbjo4cHggMCAyNHB4IWltcG9ydGFudDtmb250LXdlaWdodDo0MDAhaW1wb3J0YW50O2NvbG9yOiNBOUE5QTkhaW1wb3J0YW50O2ZvbnQtc2l6ZToxMnB4IWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHkgYnV0dG9ue3dpZHRoOjEwMCUhaW1wb3J0YW50O3BhZGRpbmc6MTJweCAyNHB4IWltcG9ydGFudDttYXJnaW46MCFpbXBvcnRhbnQ7Ym9yZGVyLXJhZGl1czozcHghaW1wb3J0YW50O2ZvbnQtc2l6ZToxNHB4IWltcG9ydGFudDtmb250LXdlaWdodDozMDAhaW1wb3J0YW50O2N1cnNvcjpwb2ludGVyIWltcG9ydGFudDtiYWNrZ3JvdW5kOiMwMUI3NTchaW1wb3J0YW50O2NvbG9yOiNmZmYhaW1wb3J0YW50O2JvcmRlcjowIWltcG9ydGFudDstd2Via2l0LXRyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQhaW1wb3J0YW50O3RyYW5zaXRpb246YmFja2dyb3VuZC1jb2xvciAuM3MgZWFzZS1pbi1vdXQhaW1wb3J0YW50fS50cmV6b3Jjb25uZWN0LWNvbnRhaW5lciAudHJlem9yY29ubmVjdC13aW5kb3cgLnRyZXpvcmNvbm5lY3QtYm9keSBidXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMDBBQjUxIWltcG9ydGFudH0udHJlem9yY29ubmVjdC1jb250YWluZXIgLnRyZXpvcmNvbm5lY3Qtd2luZG93IC50cmV6b3Jjb25uZWN0LWJvZHkgYnV0dG9uOmFjdGl2ZXtiYWNrZ3JvdW5kLWNvbG9yOiMwMDk1NDYhaW1wb3J0YW50fS8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsZXlKMlpYSnphVzl1SWpvekxDSnpiM1Z5WTJWeklqcGJJbWx1Y0hWMElpd2lKSE4wWkdsdUlsMHNJbTVoYldWeklqcGJYU3dpYldGd2NHbHVaM01pT2lKQlFXTkJMSGxDUVVOSkxGTkJRVUVzWjBKQlEwRXNVVUZCUVN4elFrRkRRU3hSUVVGQkxIVkNRVU5CTEZGQlFVRXNjMEpCUlVFc1VVRkJRU3hsUVVOQkxHMUNRVUZCTEcxQ1FVTkJMSE5DUVVGQkxHbENRVU5CTEhWQ1FVRkJMR2xDUVVOQkxHMUNRVUZCTEdsQ1FVTkJMR1ZCUVVFc2FVSkJSVUVzYTBKQlFVRXNhVUpCUTBFc2IwSkJRVUVzYVVKQlEwRXNaVUZCUVN4cFFrTm1UU3haUVVGaExHbENSRUZ5UWl4UlFVRlRMR2RDUVd0Q1NDeE5RVUZCTEdWQlEwRXNUMEZCUVN4bFFVTkJMRWxCUVVFc1dVRkRRU3hMUVVGQkxGbEJRMEVzVjBGQlFTd3dRa0ZEUVN4VFFVRkJMR1ZCUTBFc1VVRkJRU3hsUVVOQkxFOUJRVUVzV1VOa1Vpd3JRMFJZUlN4VFFVRlZMRzFDUVRaQ1FTeFJRVUZCTEdkQ1FVTkJMRTFCUVVFc1owSkJRMEVzV1VGQlFTeGpRVUZCTEcxQ1FVRkJMRmRCUVVFc1QwRkJRU3hwUWtGQlFTeE5RVUZCTEhGQ1FVTkJMRTlCUVVFc1pVTm1WaXhqUVVGbExHTkVha0ptTEdsQ1FXbENSU3hsUVd0Q1dTeFhRVUZCTEdsQ1EyWmtMRk5CUVZVc2FVSkViVUpKTEcxRlFVTkJMRmRCUVVFc1MwTm9RbVFzVVVGQlV5eExRVUZMTEdWRWVFSmtMRkZCUVZNc2MwSkJNRU5UTEZGQlFVRXNkVUpCUTBFc1VVRkJRU3h6UWtObWJFSXNVVUZCVXl4bFJHbENTeXhyUWtFMVFsb3NhVUpCT0VKdlFpeHZRa0ZCUVN4cFFrTm9RbXhDTEdWQlFXZENMR2xDUkM5Q1dpeFpRV2xDVGl4cFFrRnpRMUVzZFVaQlEwRXNhVUpCUVVFc1JVTndRbFlzWVVGQll5eEZSSEJEVml4VFFVRlZMRVZCTWtSQkxFdEJRVUVzUlVGRlFTeDNSa053UW1Rc1QwRkJVU3hyUWtSNlExSXNUMEZCVVN4bFFXbEZUU3cwUmtGRFFTeExRVUZCTEZGQlEwRXNiVUpCUVVFc1MwRkJRU3hKUVVGQkxITkNRM0JDWkN4WFFVRlpMRXRCUVVzc1NVRkJTeXh6UWtSM1FsSXNhMGRCUTBFc1MwRkJRU3hSUVVWQkxHMUZRVU5CTEZGQlFVRXNTMEZCUVN4TFFVRkJMR1ZCUTBFc1YwRkJRU3hyUWtGRFFTeFhRVUZCTEVsQlFVRXNUVUZCUVN4UlFVVkJMSE5GUVVOQkxFMUJRVUVzYTBKQlEwRXNWVUZCUVN4bFEzSkNaQ3haUVVGaExHTkVkMEpMTEhGRlEzSkNiRUlzVDBGQlVTeEpRVUZKTEVWQlFVa3NaVVIzUWtZc1dVRkJRU3hqUVVOSkxFMUJRVUVzYTBKRGRFSnNRaXhWUVVGWExHVkJSV0lzTUVWQlEwVXNUVUZCVHl4bFFVTlFMRkZCUVZNc1MwRkJTeXhsUVVOa0xFOUJRVkVzV1VGRFVpeGpRVUZsTEdOQlEyWXNWVUZCVnl4bFFVTllMRmxCUVdFc1kwRkRZaXhQUVVGUkxHdENRVU5TTEZkQlFWa3NhMEpCUTFvc1RVRkJUeXhsUVVOUUxFOUJRVkVzV1VGRFVpeHRRa0ZCYjBJc2FVSkJRV2xDTEVsQlFVc3NjMEpCUXpGRExGZEJRVmtzYVVKQlFXbENMRWxCUVVzc2MwSkJSWEJETEdkR1FVTkZMR2xDUVVGclFpeHJRa0ZGY0VJc2FVWkJRMFVzYVVKQlFXdENJbjA9ICovJztcbnZhciBfZGVmYXVsdCA9IGNzcztcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIF9leHBvcnROYW1lcyA9IHt9O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9kZWZpbmVQcm9wZXJ0eVwiKSk7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuXG5PYmplY3Qua2V5cyhfY29uc3RhbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9leHBvcnROYW1lcywga2V5KSkgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfY29uc3RhbnRzW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2NvbnN0YW50c1trZXldO1xufSk7XG5cbnZhciBfbm9kZSA9IHJlcXVpcmUoXCIuL2Vudi9ub2RlXCIpO1xuXG52YXIgX3R5cGVzID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5cbk9iamVjdC5rZXlzKF90eXBlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZXhwb3J0TmFtZXMsIGtleSkpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3R5cGVzW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX3R5cGVzW2tleV07XG59KTtcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7ICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRyZXpvckNvbm5lY3QgPSB7XG4gIG1hbmlmZXN0OiBfbm9kZS5tYW5pZmVzdCxcbiAgaW5pdDogX25vZGUuaW5pdCxcbiAgZ2V0U2V0dGluZ3M6IF9ub2RlLmdldFNldHRpbmdzLFxuICBvbjogZnVuY3Rpb24gb24odHlwZSwgZm4pIHtcbiAgICBfbm9kZS5ldmVudEVtaXR0ZXIub24odHlwZSwgZm4pO1xuICB9LFxuICBvZmY6IGZ1bmN0aW9uIG9mZih0eXBlLCBmbikge1xuICAgIF9ub2RlLmV2ZW50RW1pdHRlci5yZW1vdmVMaXN0ZW5lcih0eXBlLCBmbik7XG4gIH0sXG4gIHJlbW92ZUFsbExpc3RlbmVyczogZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgIF9ub2RlLmV2ZW50RW1pdHRlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSxcbiAgdWlSZXNwb25zZTogX25vZGUudWlSZXNwb25zZSxcbiAgLy8gbWV0aG9kc1xuICBibG9ja2NoYWluR2V0QWNjb3VudEJhbGFuY2VIaXN0b3J5OiBmdW5jdGlvbiBibG9ja2NoYWluR2V0QWNjb3VudEJhbGFuY2VIaXN0b3J5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluR2V0QWNjb3VudEJhbGFuY2VIaXN0b3J5J1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluR2V0Q3VycmVudEZpYXRSYXRlczogZnVuY3Rpb24gYmxvY2tjaGFpbkdldEN1cnJlbnRGaWF0UmF0ZXMocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5HZXRDdXJyZW50RmlhdFJhdGVzJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluR2V0RmlhdFJhdGVzRm9yVGltZXN0YW1wczogZnVuY3Rpb24gYmxvY2tjaGFpbkdldEZpYXRSYXRlc0ZvclRpbWVzdGFtcHMocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5HZXRGaWF0UmF0ZXNGb3JUaW1lc3RhbXBzJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluRGlzY29ubmVjdDogZnVuY3Rpb24gYmxvY2tjaGFpbkRpc2Nvbm5lY3QocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5EaXNjb25uZWN0J1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluRXN0aW1hdGVGZWU6IGZ1bmN0aW9uIGJsb2NrY2hhaW5Fc3RpbWF0ZUZlZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpbkVzdGltYXRlRmVlJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluR2V0VHJhbnNhY3Rpb25zOiBmdW5jdGlvbiBibG9ja2NoYWluR2V0VHJhbnNhY3Rpb25zKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluR2V0VHJhbnNhY3Rpb25zJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluU2V0Q3VzdG9tQmFja2VuZDogZnVuY3Rpb24gYmxvY2tjaGFpblNldEN1c3RvbUJhY2tlbmQocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2Jsb2NrY2hhaW5TZXRDdXN0b21CYWNrZW5kJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluU3Vic2NyaWJlOiBmdW5jdGlvbiBibG9ja2NoYWluU3Vic2NyaWJlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluU3Vic2NyaWJlJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluU3Vic2NyaWJlRmlhdFJhdGVzOiBmdW5jdGlvbiBibG9ja2NoYWluU3Vic2NyaWJlRmlhdFJhdGVzKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdibG9ja2NoYWluU3Vic2NyaWJlRmlhdFJhdGVzJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluVW5zdWJzY3JpYmU6IGZ1bmN0aW9uIGJsb2NrY2hhaW5VbnN1YnNjcmliZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpblVuc3Vic2NyaWJlJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBibG9ja2NoYWluVW5zdWJzY3JpYmVGaWF0UmF0ZXM6IGZ1bmN0aW9uIGJsb2NrY2hhaW5VbnN1YnNjcmliZUZpYXRSYXRlcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmxvY2tjaGFpblVuc3Vic2NyaWJlRmlhdFJhdGVzJ1xuICAgIH0sIHBhcmFtcykpO1xuICB9LFxuICBjdXN0b21NZXNzYWdlOiBmdW5jdGlvbiBjdXN0b21NZXNzYWdlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY3VzdG9tTWVzc2FnZSkocGFyYW1zKTtcbiAgfSxcbiAgcmVxdWVzdExvZ2luOiBmdW5jdGlvbiByZXF1ZXN0TG9naW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5yZXF1ZXN0TG9naW4pKHBhcmFtcyk7XG4gIH0sXG4gIGNhcmRhbm9HZXRBZGRyZXNzOiBmdW5jdGlvbiBjYXJkYW5vR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2FyZGFub0dldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIGNhcmRhbm9HZXROYXRpdmVTY3JpcHRIYXNoOiBmdW5jdGlvbiBjYXJkYW5vR2V0TmF0aXZlU2NyaXB0SGFzaChwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2FyZGFub0dldE5hdGl2ZVNjcmlwdEhhc2gnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGNhcmRhbm9HZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIGNhcmRhbm9HZXRQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2NhcmRhbm9HZXRQdWJsaWNLZXknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGNhcmRhbm9TaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIGNhcmRhbm9TaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2NhcmRhbm9TaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGNpcGhlcktleVZhbHVlOiBmdW5jdGlvbiBjaXBoZXJLZXlWYWx1ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnY2lwaGVyS2V5VmFsdWUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGNvbXBvc2VUcmFuc2FjdGlvbjogZnVuY3Rpb24gY29tcG9zZVRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjb21wb3NlVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGV0aGVyZXVtR2V0QWRkcmVzczogZnVuY3Rpb24gZXRoZXJldW1HZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bUdldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIGV0aGVyZXVtR2V0UHVibGljS2V5OiBmdW5jdGlvbiBldGhlcmV1bUdldFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZXRoZXJldW1HZXRQdWJsaWNLZXknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGV0aGVyZXVtU2lnbk1lc3NhZ2U6IGZ1bmN0aW9uIGV0aGVyZXVtU2lnbk1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2V0aGVyZXVtU2lnbk1lc3NhZ2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGV0aGVyZXVtU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBldGhlcmV1bVNpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZXRoZXJldW1TaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGV0aGVyZXVtU2lnblR5cGVkRGF0YTogZnVuY3Rpb24gZXRoZXJldW1TaWduVHlwZWREYXRhKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bVNpZ25UeXBlZERhdGEnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGV0aGVyZXVtVmVyaWZ5TWVzc2FnZTogZnVuY3Rpb24gZXRoZXJldW1WZXJpZnlNZXNzYWdlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdldGhlcmV1bVZlcmlmeU1lc3NhZ2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGdldEFjY291bnRJbmZvOiBmdW5jdGlvbiBnZXRBY2NvdW50SW5mbyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZ2V0QWNjb3VudEluZm8nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGdldEFkZHJlc3M6IGZ1bmN0aW9uIGdldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2dldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIGdldERldmljZVN0YXRlOiBmdW5jdGlvbiBnZXREZXZpY2VTdGF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZ2V0RGV2aWNlU3RhdGUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGdldEZlYXR1cmVzOiBmdW5jdGlvbiBnZXRGZWF0dXJlcyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZ2V0RmVhdHVyZXMnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGdldFB1YmxpY0tleTogZnVuY3Rpb24gZ2V0UHVibGljS2V5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdnZXRQdWJsaWNLZXknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGxpc2tHZXRBZGRyZXNzOiBmdW5jdGlvbiBsaXNrR2V0QWRkcmVzcygpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKHtcbiAgICAgIG1ldGhvZDogJ2xpc2tEZXByZWNhdGVkJ1xuICAgIH0pO1xuICB9LFxuICBsaXNrR2V0UHVibGljS2V5OiBmdW5jdGlvbiBsaXNrR2V0UHVibGljS2V5KCkge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoe1xuICAgICAgbWV0aG9kOiAnbGlza0RlcHJlY2F0ZWQnXG4gICAgfSk7XG4gIH0sXG4gIGxpc2tTaWduTWVzc2FnZTogZnVuY3Rpb24gbGlza1NpZ25NZXNzYWdlKCkge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoe1xuICAgICAgbWV0aG9kOiAnbGlza0RlcHJlY2F0ZWQnXG4gICAgfSk7XG4gIH0sXG4gIGxpc2tTaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIGxpc2tTaWduVHJhbnNhY3Rpb24oKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKSh7XG4gICAgICBtZXRob2Q6ICdsaXNrRGVwcmVjYXRlZCdcbiAgICB9KTtcbiAgfSxcbiAgbGlza1ZlcmlmeU1lc3NhZ2U6IGZ1bmN0aW9uIGxpc2tWZXJpZnlNZXNzYWdlKCkge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoe1xuICAgICAgbWV0aG9kOiAnbGlza0RlcHJlY2F0ZWQnXG4gICAgfSk7XG4gIH0sXG4gIG5lbUdldEFkZHJlc3M6IGZ1bmN0aW9uIG5lbUdldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ25lbUdldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIG5lbVNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gbmVtU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICduZW1TaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHB1c2hUcmFuc2FjdGlvbjogZnVuY3Rpb24gcHVzaFRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdwdXNoVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHJpcHBsZUdldEFkZHJlc3M6IGZ1bmN0aW9uIHJpcHBsZUdldEFkZHJlc3MocGFyYW1zKSB7XG4gICAgdmFyIHVzZUV2ZW50TGlzdGVuZXIgPSBfbm9kZS5ldmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudChfY29uc3RhbnRzLlVJLkFERFJFU1NfVkFMSURBVElPTikgPiAwO1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3JpcHBsZUdldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIHJpcHBsZVNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gcmlwcGxlU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdyaXBwbGVTaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHNpZ25NZXNzYWdlOiBmdW5jdGlvbiBzaWduTWVzc2FnZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnc2lnbk1lc3NhZ2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHNpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdzaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHN0ZWxsYXJHZXRBZGRyZXNzOiBmdW5jdGlvbiBzdGVsbGFyR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnc3RlbGxhckdldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIHN0ZWxsYXJTaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIHN0ZWxsYXJTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3N0ZWxsYXJTaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHRlem9zR2V0QWRkcmVzczogZnVuY3Rpb24gdGV6b3NHZXRBZGRyZXNzKHBhcmFtcykge1xuICAgIHZhciB1c2VFdmVudExpc3RlbmVyID0gX25vZGUuZXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQoX2NvbnN0YW50cy5VSS5BRERSRVNTX1ZBTElEQVRJT04pID4gMDtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICd0ZXpvc0dldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIHRlem9zR2V0UHVibGljS2V5OiBmdW5jdGlvbiB0ZXpvc0dldFB1YmxpY0tleShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAndGV6b3NHZXRQdWJsaWNLZXknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHRlem9zU2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiB0ZXpvc1NpZ25UcmFuc2FjdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAndGV6b3NTaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGVvc0dldFB1YmxpY0tleTogZnVuY3Rpb24gZW9zR2V0UHVibGljS2V5KHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdlb3NHZXRQdWJsaWNLZXknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGVvc1NpZ25UcmFuc2FjdGlvbjogZnVuY3Rpb24gZW9zU2lnblRyYW5zYWN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdlb3NTaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJpbmFuY2VHZXRBZGRyZXNzOiBmdW5jdGlvbiBiaW5hbmNlR2V0QWRkcmVzcyhwYXJhbXMpIHtcbiAgICB2YXIgdXNlRXZlbnRMaXN0ZW5lciA9IF9ub2RlLmV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50KF9jb25zdGFudHMuVUkuQUREUkVTU19WQUxJREFUSU9OKSA+IDA7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnYmluYW5jZUdldEFkZHJlc3MnXG4gICAgfSwgcGFyYW1zKSwge30sIHtcbiAgICAgIHVzZUV2ZW50TGlzdGVuZXI6IHVzZUV2ZW50TGlzdGVuZXJcbiAgICB9KSk7XG4gIH0sXG4gIGJpbmFuY2VHZXRQdWJsaWNLZXk6IGZ1bmN0aW9uIGJpbmFuY2VHZXRQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2JpbmFuY2VHZXRQdWJsaWNLZXknXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJpbmFuY2VTaWduVHJhbnNhY3Rpb246IGZ1bmN0aW9uIGJpbmFuY2VTaWduVHJhbnNhY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2JpbmFuY2VTaWduVHJhbnNhY3Rpb24nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHZlcmlmeU1lc3NhZ2U6IGZ1bmN0aW9uIHZlcmlmeU1lc3NhZ2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3ZlcmlmeU1lc3NhZ2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHJlc2V0RGV2aWNlOiBmdW5jdGlvbiByZXNldERldmljZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAncmVzZXREZXZpY2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHdpcGVEZXZpY2U6IGZ1bmN0aW9uIHdpcGVEZXZpY2UocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ3dpcGVEZXZpY2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGFwcGx5RmxhZ3M6IGZ1bmN0aW9uIGFwcGx5RmxhZ3MocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2FwcGx5RmxhZ3MnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGFwcGx5U2V0dGluZ3M6IGZ1bmN0aW9uIGFwcGx5U2V0dGluZ3MocGFyYW1zKSB7XG4gICAgcmV0dXJuICgwLCBfbm9kZS5jYWxsKShfb2JqZWN0U3ByZWFkKHtcbiAgICAgIG1ldGhvZDogJ2FwcGx5U2V0dGluZ3MnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGJhY2t1cERldmljZTogZnVuY3Rpb24gYmFja3VwRGV2aWNlKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdiYWNrdXBEZXZpY2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGNoYW5nZVBpbjogZnVuY3Rpb24gY2hhbmdlUGluKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdjaGFuZ2VQaW4nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGZpcm13YXJlVXBkYXRlOiBmdW5jdGlvbiBmaXJtd2FyZVVwZGF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZmlybXdhcmVVcGRhdGUnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHJlY292ZXJ5RGV2aWNlOiBmdW5jdGlvbiByZWNvdmVyeURldmljZShwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAncmVjb3ZlcnlEZXZpY2UnXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGdldENvaW5JbmZvOiBmdW5jdGlvbiBnZXRDb2luSW5mbyhwYXJhbXMpIHtcbiAgICByZXR1cm4gKDAsIF9ub2RlLmNhbGwpKF9vYmplY3RTcHJlYWQoe1xuICAgICAgbWV0aG9kOiAnZ2V0Q29pbkluZm8nXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIHJlYm9vdFRvQm9vdGxvYWRlcjogZnVuY3Rpb24gcmVib290VG9Cb290bG9hZGVyKHBhcmFtcykge1xuICAgIHJldHVybiAoMCwgX25vZGUuY2FsbCkoX29iamVjdFNwcmVhZCh7XG4gICAgICBtZXRob2Q6ICdyZWJvb3RUb0Jvb3Rsb2FkZXInXG4gICAgfSwgcGFyYW1zKSk7XG4gIH0sXG4gIGRpc3Bvc2U6IF9ub2RlLmRpc3Bvc2UsXG4gIGNhbmNlbDogX25vZGUuY2FuY2VsLFxuICByZW5kZXJXZWJVU0JCdXR0b246IF9ub2RlLnJlbmRlcldlYlVTQkJ1dHRvbixcbiAgZGlzYWJsZVdlYlVTQjogX25vZGUuZGlzYWJsZVdlYlVTQlxufTtcbnZhciBfZGVmYXVsdCA9IFRyZXpvckNvbm5lY3Q7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQmxvY2tjaGFpbk1lc3NhZ2UgPSBleHBvcnRzLlJlc3BvbnNlTWVzc2FnZSA9IGV4cG9ydHMuVHJhbnNwb3J0TWVzc2FnZSA9IGV4cG9ydHMuRGV2aWNlTWVzc2FnZSA9IGV4cG9ydHMuVWlNZXNzYWdlID0gdm9pZCAwO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyAoMCwgX2RlZmluZVByb3BlcnR5MltcImRlZmF1bHRcIl0pKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBVaU1lc3NhZ2UgPSBmdW5jdGlvbiBVaU1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLlVJX0VWRU5ULFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9O1xufTtcblxuZXhwb3J0cy5VaU1lc3NhZ2UgPSBVaU1lc3NhZ2U7XG5cbnZhciBEZXZpY2VNZXNzYWdlID0gZnVuY3Rpb24gRGV2aWNlTWVzc2FnZSh0eXBlLCBwYXlsb2FkKSB7XG4gIHJldHVybiB7XG4gICAgZXZlbnQ6IF9jb25zdGFudHMuREVWSUNFX0VWRU5ULFxuICAgIHR5cGU6IHR5cGUsXG4gICAgcGF5bG9hZDogcGF5bG9hZFxuICB9O1xufTtcblxuZXhwb3J0cy5EZXZpY2VNZXNzYWdlID0gRGV2aWNlTWVzc2FnZTtcblxudmFyIFRyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlKHR5cGUsIHBheWxvYWQpIHtcbiAgcmV0dXJuIHtcbiAgICBldmVudDogX2NvbnN0YW50cy5UUkFOU1BPUlRfRVZFTlQsXG4gICAgdHlwZTogdHlwZSxcbiAgICAvLyBjb252ZXJ0IEVycm9yL1R5cGVFcnJvciBvYmplY3QgaW50byBwYXlsb2FkIGVycm9yIHR5cGUgKEVycm9yIG9iamVjdC9jbGFzcyBpcyBjb252ZXJ0ZWQgdG8gc3RyaW5nIHdoaWxlIHNlbnQgdmlhIHBvc3RNZXNzYWdlKVxuICAgIHBheWxvYWQ6IHBheWxvYWQuZXJyb3IgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHBheWxvYWQpLCB7fSwge1xuICAgICAgZXJyb3I6IHBheWxvYWQuZXJyb3IubWVzc2FnZSxcbiAgICAgIGNvZGU6IHBheWxvYWQuZXJyb3IuY29kZVxuICAgIH0pIDogcGF5bG9hZFxuICB9O1xufTtcblxuZXhwb3J0cy5UcmFuc3BvcnRNZXNzYWdlID0gVHJhbnNwb3J0TWVzc2FnZTtcblxudmFyIFJlc3BvbnNlTWVzc2FnZSA9IGZ1bmN0aW9uIFJlc3BvbnNlTWVzc2FnZShpZCwgc3VjY2VzcywgcGF5bG9hZCkge1xuICBpZiAocGF5bG9hZCA9PT0gdm9pZCAwKSB7XG4gICAgcGF5bG9hZCA9IG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLlJFU1BPTlNFX0VWRU5ULFxuICAgIHR5cGU6IF9jb25zdGFudHMuUkVTUE9OU0VfRVZFTlQsXG4gICAgaWQ6IGlkLFxuICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgLy8gY29udmVydCBFcnJvci9UeXBlRXJyb3Igb2JqZWN0IGludG8gcGF5bG9hZCBlcnJvciB0eXBlIChFcnJvciBvYmplY3QvY2xhc3MgaXMgY29udmVydGVkIHRvIHN0cmluZyB3aGlsZSBzZW50IHZpYSBwb3N0TWVzc2FnZSlcbiAgICBwYXlsb2FkOiBzdWNjZXNzID8gcGF5bG9hZCA6IHtcbiAgICAgIGVycm9yOiBwYXlsb2FkLmVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBwYXlsb2FkLmVycm9yLmNvZGVcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLlJlc3BvbnNlTWVzc2FnZSA9IFJlc3BvbnNlTWVzc2FnZTtcblxudmFyIEJsb2NrY2hhaW5NZXNzYWdlID0gZnVuY3Rpb24gQmxvY2tjaGFpbk1lc3NhZ2UodHlwZSwgcGF5bG9hZCkge1xuICByZXR1cm4ge1xuICAgIGV2ZW50OiBfY29uc3RhbnRzLkJMT0NLQ0hBSU5fRVZFTlQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwYXlsb2FkOiBwYXlsb2FkXG4gIH07XG59O1xuXG5leHBvcnRzLkJsb2NrY2hhaW5NZXNzYWdlID0gQmxvY2tjaGFpbk1lc3NhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmVycm9yTWVzc2FnZSA9IGV4cG9ydHMucGFyc2VNZXNzYWdlID0gdm9pZCAwO1xuXG4vLyBwYXJzZSBNZXNzYWdlRXZlbnQgLmRhdGEgaW50byBDb3JlTWVzc2FnZVxudmFyIHBhcnNlTWVzc2FnZSA9IGZ1bmN0aW9uIHBhcnNlTWVzc2FnZShtZXNzYWdlRGF0YSkge1xuICB2YXIgbWVzc2FnZSA9IHtcbiAgICBldmVudDogbWVzc2FnZURhdGEuZXZlbnQsXG4gICAgdHlwZTogbWVzc2FnZURhdGEudHlwZSxcbiAgICBwYXlsb2FkOiBtZXNzYWdlRGF0YS5wYXlsb2FkXG4gIH07XG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlRGF0YS5pZCA9PT0gJ251bWJlcicpIHtcbiAgICBtZXNzYWdlLmlkID0gbWVzc2FnZURhdGEuaWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG1lc3NhZ2VEYXRhLnN1Y2Nlc3MgPT09ICdib29sZWFuJykge1xuICAgIG1lc3NhZ2Uuc3VjY2VzcyA9IG1lc3NhZ2VEYXRhLnN1Y2Nlc3M7XG4gIH1cblxuICByZXR1cm4gbWVzc2FnZTtcbn07IC8vIGNvbW1vbiByZXNwb25zZSB1c2VkIHN0cmFpZ2h0IGZyb20gbnBtIGluZGV4IChub3QgZnJvbSBDb3JlKVxuXG5cbmV4cG9ydHMucGFyc2VNZXNzYWdlID0gcGFyc2VNZXNzYWdlO1xuXG52YXIgZXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gZXJyb3JNZXNzYWdlKGVycm9yKSB7XG4gIHJldHVybiB7XG4gICAgc3VjY2VzczogZmFsc2UsXG4gICAgcGF5bG9hZDoge1xuICAgICAgZXJyb3I6IGVycm9yLm1lc3NhZ2UsXG4gICAgICBjb2RlOiBlcnJvci5jb2RlXG4gICAgfVxuICB9O1xufTtcblxuZXhwb3J0cy5lcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHlcIikpO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbnZhciBzaWdVdGlsID0gcmVxdWlyZSgnQG1ldGFtYXNrL2V0aC1zaWctdXRpbCcpOyAvLyBTYW5pdGl6YXRpb24gaXMgdXNlZCBmb3IgVDEgYXMgZXRoLXNpZy11dGlsIGRvZXMgbm90IHN1cHBvcnQgQmlnSW50XG5cblxuZnVuY3Rpb24gc2FuaXRpemVEYXRhKGRhdGEpIHtcbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICBjYXNlICdbb2JqZWN0IE9iamVjdF0nOlxuICAgICAge1xuICAgICAgICB2YXIgZW50cmllcyA9IE9iamVjdC5rZXlzKGRhdGEpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBbaywgc2FuaXRpemVEYXRhKGRhdGFba10pXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZW50cmllcyk7XG4gICAgICB9XG5cbiAgICBjYXNlICdbb2JqZWN0IEFycmF5XSc6XG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgcmV0dXJuIHNhbml0aXplRGF0YSh2KTtcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnW29iamVjdCBCaWdJbnRdJzpcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGRhdGE7XG4gIH1cbn1cblxudmFyIHRyYW5zZm9ybVR5cGVkRGF0YSA9IGZ1bmN0aW9uIHRyYW5zZm9ybVR5cGVkRGF0YShkYXRhLCBtZXRhbWFza192NF9jb21wYXQpIHtcbiAgaWYgKCFtZXRhbWFza192NF9jb21wYXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyZXpvcjogT25seSB2ZXJzaW9uIDQgb2YgdHlwZWQgZGF0YSBzaWduaW5nIGlzIHN1cHBvcnRlZCcpO1xuICB9XG5cbiAgdmFyIHZlcnNpb24gPSBzaWdVdGlsLlNpZ25UeXBlZERhdGFWZXJzaW9uLlY0O1xuXG4gIHZhciBfc2lnVXRpbCRUeXBlZERhdGFVdGkgPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLnNhbml0aXplRGF0YShkYXRhKSxcbiAgICAgIHR5cGVzID0gX3NpZ1V0aWwkVHlwZWREYXRhVXRpLnR5cGVzLFxuICAgICAgcHJpbWFyeVR5cGUgPSBfc2lnVXRpbCRUeXBlZERhdGFVdGkucHJpbWFyeVR5cGUsXG4gICAgICBkb21haW4gPSBfc2lnVXRpbCRUeXBlZERhdGFVdGkuZG9tYWluLFxuICAgICAgbWVzc2FnZSA9IF9zaWdVdGlsJFR5cGVkRGF0YVV0aS5tZXNzYWdlO1xuXG4gIHZhciBkb21haW5TZXBhcmF0b3JIYXNoID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KCdFSVA3MTJEb21haW4nLCBzYW5pdGl6ZURhdGEoZG9tYWluKSwgdHlwZXMsIHZlcnNpb24pLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIG1lc3NhZ2VIYXNoID0gc2lnVXRpbC5UeXBlZERhdGFVdGlscy5oYXNoU3RydWN0KHByaW1hcnlUeXBlLCBzYW5pdGl6ZURhdGEobWVzc2FnZSksIHR5cGVzLCB2ZXJzaW9uKS50b1N0cmluZygnaGV4Jyk7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkKHtcbiAgICBkb21haW5fc2VwYXJhdG9yX2hhc2g6IGRvbWFpblNlcGFyYXRvckhhc2gsXG4gICAgbWVzc2FnZV9oYXNoOiBtZXNzYWdlSGFzaFxuICB9LCBkYXRhKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtVHlwZWREYXRhOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIikpO1xuXG52YXIgX2luaGVyaXRzTG9vc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0c0xvb3NlXCIpKTtcblxudmFyIF9kZWZpbmVQcm9wZXJ0eTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5XCIpKTtcblxudmFyIF9ldmVudHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJldmVudHNcIikpO1xuXG52YXIgUE9QVVAgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi4vY29uc3RhbnRzL3BvcHVwXCIpKTtcblxudmFyIElGUkFNRSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuLi9jb25zdGFudHMvaWZyYW1lXCIpKTtcblxudmFyIFVJID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL2NvbnN0YW50cy91aVwiKSk7XG5cbnZhciBfc2hvd1BvcHVwUmVxdWVzdCA9IHJlcXVpcmUoXCIuL3Nob3dQb3B1cFJlcXVlc3RcIik7XG5cbnZhciBfbmV0d29ya1V0aWxzID0gcmVxdWlyZShcIi4uL2Vudi9icm93c2VyL25ldHdvcmtVdGlsc1wiKTtcblxudmFyIF9kZWZlcnJlZCA9IHJlcXVpcmUoXCIuLi91dGlscy9kZWZlcnJlZFwiKTtcblxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKSB7IGlmICh0eXBlb2YgV2Vha01hcCAhPT0gXCJmdW5jdGlvblwiKSByZXR1cm4gbnVsbDsgdmFyIGNhY2hlQmFiZWxJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgdmFyIGNhY2hlTm9kZUludGVyb3AgPSBuZXcgV2Vha01hcCgpOyByZXR1cm4gKF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyByZXR1cm4gbm9kZUludGVyb3AgPyBjYWNoZU5vZGVJbnRlcm9wIDogY2FjaGVCYWJlbEludGVyb3A7IH0pKG5vZGVJbnRlcm9wKTsgfVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmosIG5vZGVJbnRlcm9wKSB7IGlmICghbm9kZUludGVyb3AgJiYgb2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmogIT09IFwiZnVuY3Rpb25cIikgeyByZXR1cm4geyBcImRlZmF1bHRcIjogb2JqIH07IH0gdmFyIGNhY2hlID0gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKG5vZGVJbnRlcm9wKTsgaWYgKGNhY2hlICYmIGNhY2hlLmhhcyhvYmopKSB7IHJldHVybiBjYWNoZS5nZXQob2JqKTsgfSB2YXIgbmV3T2JqID0ge307IHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjsgZm9yICh2YXIga2V5IGluIG9iaikgeyBpZiAoa2V5ICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7IHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsOyBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7IH0gZWxzZSB7IG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSB9IG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7IGlmIChjYWNoZSkgeyBjYWNoZS5zZXQob2JqLCBuZXdPYmopOyB9IHJldHVybiBuZXdPYmo7IH1cblxuLy8gY29uc3QgUE9QVVBfUkVRVUVTVF9USU1FT1VUID0gNjAyO1xudmFyIFBPUFVQX1JFUVVFU1RfVElNRU9VVCA9IDg1MDtcbnZhciBQT1BVUF9DTE9TRV9JTlRFUlZBTCA9IDUwMDtcbnZhciBQT1BVUF9PUEVOX1RJTUVPVVQgPSAzMDAwO1xuXG52YXIgUG9wdXBNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gICgwLCBfaW5oZXJpdHNMb29zZTJbXCJkZWZhdWx0XCJdKShQb3B1cE1hbmFnZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIC8vIFdpbmRvd1xuICBmdW5jdGlvbiBQb3B1cE1hbmFnZXIoc2V0dGluZ3MpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9FdmVudEVtaXR0ZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpLCBcInJlcXVlc3RUaW1lb3V0XCIsIDApO1xuICAgICgwLCBfZGVmaW5lUHJvcGVydHkyW1wiZGVmYXVsdFwiXSkoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpLCBcImNsb3NlSW50ZXJ2YWxcIiwgMCk7XG4gICAgKDAsIF9kZWZpbmVQcm9wZXJ0eTJbXCJkZWZhdWx0XCJdKSgoMCwgX2Fzc2VydFRoaXNJbml0aWFsaXplZDJbXCJkZWZhdWx0XCJdKShfdGhpcyksIFwiZXh0ZW5zaW9uVGFiSWRcIiwgMCk7XG4gICAgX3RoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICBfdGhpcy5vcmlnaW4gPSAoMCwgX25ldHdvcmtVdGlscy5nZXRPcmlnaW4pKHNldHRpbmdzLnBvcHVwU3JjKTtcbiAgICBfdGhpcy5oYW5kbGVNZXNzYWdlID0gX3RoaXMuaGFuZGxlTWVzc2FnZS5iaW5kKCgwLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkMltcImRlZmF1bHRcIl0pKF90aGlzKSk7XG4gICAgX3RoaXMuaWZyYW1lSGFuZHNoYWtlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKElGUkFNRS5MT0FERUQpO1xuXG4gICAgaWYgKF90aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicpIHtcbiAgICAgIF90aGlzLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QgPSBfdGhpcy5oYW5kbGVFeHRlbnNpb25Db25uZWN0LmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKTtcbiAgICAgIF90aGlzLmhhbmRsZUV4dGVuc2lvbk1lc3NhZ2UgPSBfdGhpcy5oYW5kbGVFeHRlbnNpb25NZXNzYWdlLmJpbmQoKDAsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQyW1wiZGVmYXVsdFwiXSkoX3RoaXMpKTsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgY2hyb21lLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKF90aGlzLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QpO1xuICAgIH1cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgX3RoaXMuaGFuZGxlTWVzc2FnZSwgZmFsc2UpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQb3B1cE1hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChsYXp5TG9hZCkge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgaWYgKGxhenlMb2FkID09PSB2b2lkIDApIHtcbiAgICAgIGxhenlMb2FkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gcG9wdXAgcmVxdWVzdFxuICAgIC8vIFRPRE86IGllIC0gb3BlbiBpbW1lZGlhdGVseSBhbmQgaGlkZSBpdCBidXQgcG9zdCBoYW5kc2hha2UgYWZ0ZXIgdGltZW91dFxuICAgIC8vIGJyaW5nIHBvcHVwIHdpbmRvdyB0byBmcm9udFxuICAgIGlmICh0aGlzLmxvY2tlZCkge1xuICAgICAgaWYgKHRoaXMuX3dpbmRvdykge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5lbnYgPT09ICd3ZWJleHRlbnNpb24nKSB7XG4gICAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgICBjaHJvbWUudGFicy51cGRhdGUodGhpcy5fd2luZG93LmlkLCB7XG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aW5kb3cuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9wZW5GbiA9IHRoaXMub3Blbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcblxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5zdXBwb3J0ZWRCcm93c2VyKSB7XG4gICAgICBvcGVuRm4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRpbWVvdXQgPSBsYXp5TG9hZCB8fCB0aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicgPyAxIDogUE9QVVBfUkVRVUVTVF9USU1FT1VUO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnJlcXVlc3RUaW1lb3V0ID0gMDtcbiAgICAgICAgb3BlbkZuKGxhenlMb2FkKTtcbiAgICAgIH0sIHRpbWVvdXQpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfTtcblxuICBfcHJvdG8udW5sb2NrID0gZnVuY3Rpb24gdW5sb2NrKCkge1xuICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLm9wZW4gPSBmdW5jdGlvbiBvcGVuKGxhenlMb2FkKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgc3JjID0gdGhpcy5zZXR0aW5ncy5wb3B1cFNyYztcblxuICAgIGlmICghdGhpcy5zZXR0aW5ncy5zdXBwb3J0ZWRCcm93c2VyKSB7XG4gICAgICB0aGlzLm9wZW5XcmFwcGVyKHNyYyArIFwiI3Vuc3VwcG9ydGVkXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucG9wdXBQcm9taXNlID0gKDAsIF9kZWZlcnJlZC5jcmVhdGUpKFBPUFVQLkxPQURFRCk7XG4gICAgdGhpcy5vcGVuV3JhcHBlcihsYXp5TG9hZCA/IHNyYyArIFwiI2xvYWRpbmdcIiA6IHNyYyk7XG4gICAgdGhpcy5jbG9zZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghX3RoaXMzLl93aW5kb3cpIHJldHVybjtcblxuICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbnYgPT09ICd3ZWJleHRlbnNpb24nKSB7XG4gICAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICAgIGNocm9tZS50YWJzLmdldChfdGhpczMuX3dpbmRvdy5pZCwgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgIGlmICghdGFiKSB7XG4gICAgICAgICAgICBfdGhpczMuY2xvc2UoKTtcblxuICAgICAgICAgICAgX3RoaXMzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChfdGhpczMuX3dpbmRvdy5jbG9zZWQpIHtcbiAgICAgICAgX3RoaXMzLmNsb3NlKCk7XG5cbiAgICAgICAgX3RoaXMzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgIH1cbiAgICB9LCBQT1BVUF9DTE9TRV9JTlRFUlZBTCk7IC8vIG9wZW4gdGltZW91dCB3aWxsIGJlIGNhbmNlbGxlZCBieSBQT1BVUC5CT09UU1RSQVAgbWVzc2FnZVxuXG4gICAgdGhpcy5vcGVuVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMy5jbG9zZSgpO1xuXG4gICAgICAoMCwgX3Nob3dQb3B1cFJlcXVlc3Quc2hvd1BvcHVwUmVxdWVzdCkoX3RoaXMzLm9wZW4uYmluZChfdGhpczMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5lbWl0KFBPUFVQLkNMT1NFRCk7XG4gICAgICB9KTtcbiAgICB9LCBQT1BVUF9PUEVOX1RJTUVPVVQpO1xuICB9O1xuXG4gIF9wcm90by5vcGVuV3JhcHBlciA9IGZ1bmN0aW9uIG9wZW5XcmFwcGVyKHVybCkge1xuICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuc2V0dGluZ3MuZW52ID09PSAnd2ViZXh0ZW5zaW9uJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgIGNocm9tZS53aW5kb3dzLmdldEN1cnJlbnQobnVsbCwgZnVuY3Rpb24gKGN1cnJlbnRXaW5kb3cpIHtcbiAgICAgICAgLy8gUmVxdWVzdCBjb21pbmcgZnJvbSBleHRlbnNpb24gcG9wdXAsXG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgd2luZG93IGFib3ZlIGluc3RlYWQgb2Ygb3BlbmluZyBuZXcgdGFiXG4gICAgICAgIGlmIChjdXJyZW50V2luZG93LnR5cGUgIT09ICdub3JtYWwnKSB7XG4gICAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgICBjaHJvbWUud2luZG93cy5jcmVhdGUoe1xuICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICB9LCBmdW5jdGlvbiAobmV3V2luZG93KSB7XG4gICAgICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICAgICAgY2hyb21lLnRhYnMucXVlcnkoe1xuICAgICAgICAgICAgICB3aW5kb3dJZDogbmV3V2luZG93LmlkLFxuICAgICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICh0YWJzKSB7XG4gICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItZGVzdHJ1Y3R1cmluZ1xuICAgICAgICAgICAgICBfdGhpczQuX3dpbmRvdyA9IHRhYnNbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgICAgIGNocm9tZS50YWJzLnF1ZXJ5KHtcbiAgICAgICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgICAgICAgICBhY3RpdmU6IHRydWVcbiAgICAgICAgICB9LCBmdW5jdGlvbiAodGFicykge1xuICAgICAgICAgICAgX3RoaXM0LmV4dGVuc2lvblRhYklkID0gdGFic1swXS5pZDsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgICAgICAgY2hyb21lLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgIGluZGV4OiB0YWJzWzBdLmluZGV4ICsgMVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHRhYikge1xuICAgICAgICAgICAgICBfdGhpczQuX3dpbmRvdyA9IHRhYjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2V0dGluZ3MuZW52ID09PSAnZWxlY3Ryb24nKSB7XG4gICAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3cub3Blbih1cmwsICdtb2RhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aW5kb3cgPSB3aW5kb3cub3BlbignJywgJ19ibGFuaycpO1xuXG4gICAgICBpZiAodGhpcy5fd2luZG93KSB7XG4gICAgICAgIHRoaXMuX3dpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsOyAvLyBvdGhlcndpc2UgYW5kcm9pZC9jaHJvbWUgbG9vc2Ugd2luZG93Lm9wZW5lciByZWZlcmVuY2VcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUV4dGVuc2lvbkNvbm5lY3QgPSBmdW5jdGlvbiBoYW5kbGVFeHRlbnNpb25Db25uZWN0KHBvcnQpIHtcbiAgICBpZiAocG9ydC5uYW1lICE9PSAndHJlem9yLWNvbm5lY3QnKSByZXR1cm47XG5cbiAgICBpZiAoIXRoaXMuX3dpbmRvdyB8fCB0aGlzLl93aW5kb3cgJiYgdGhpcy5fd2luZG93LmlkICE9PSBwb3J0LnNlbmRlci50YWIuaWQpIHtcbiAgICAgIHBvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gc2luY2UgUE9QVVAuQk9PVFNUUkFQIHdpbGwgbm90IGJlIGhhbmRsZWQgYnkgXCJoYW5kbGVNZXNzYWdlXCIgd2UgbmVlZCB0byB0aHJlYXQgXCJjb250ZW50LXNjcmlwdFwiIGNvbm5lY3Rpb24gYXMgdGhlIHNhbWUgZXZlbnRcbiAgICAvLyBwb3B1cCBpcyBvcGVuZWQgcHJvcGVybHksIG5vdyB3YWl0IGZvciBQT1BVUC5MT0FERUQgbWVzc2FnZSAoaW4gdGhpcyBjYXNlIGhhbmRsZWQgYnkgXCJoYW5kbGVFeHRlbnNpb25NZXNzYWdlXCIpXG5cblxuICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgdGhpcy5leHRlbnNpb25Qb3J0ID0gcG9ydDsgLy8gJEZsb3dJc3N1ZSBuZWVkIHRvIHVwZGF0ZSBDaHJvbWVQb3J0IGRlZmluaXRpb25cblxuICAgIHRoaXMuZXh0ZW5zaW9uUG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIodGhpcy5oYW5kbGVFeHRlbnNpb25NZXNzYWdlKTtcbiAgfTtcblxuICBfcHJvdG8uaGFuZGxlRXh0ZW5zaW9uTWVzc2FnZSA9IGZ1bmN0aW9uIGhhbmRsZUV4dGVuc2lvbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgaWYgKCF0aGlzLmV4dGVuc2lvblBvcnQpIHJldHVybjtcbiAgICB2YXIgcG9ydCA9IHRoaXMuZXh0ZW5zaW9uUG9ydDtcbiAgICB2YXIgZGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICBpZiAoIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnKSByZXR1cm47XG5cbiAgICBpZiAoZGF0YS50eXBlID09PSBQT1BVUC5FUlJPUikge1xuICAgICAgLy8gaGFuZGxlIHBvcHVwIGVycm9yXG4gICAgICB2YXIgZXJyb3JNZXNzYWdlID0gZGF0YS5wYXlsb2FkICYmIHR5cGVvZiBkYXRhLnBheWxvYWQuZXJyb3IgPT09ICdzdHJpbmcnID8gZGF0YS5wYXlsb2FkLmVycm9yIDogbnVsbDtcbiAgICAgIHRoaXMuZW1pdChQT1BVUC5DTE9TRUQsIGVycm9yTWVzc2FnZSA/IFwiUG9wdXAgZXJyb3I6IFwiICsgZXJyb3JNZXNzYWdlIDogbnVsbCk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkxPQURFRCkge1xuICAgICAgaWYgKHRoaXMucG9wdXBQcm9taXNlKSB7XG4gICAgICAgIHRoaXMucG9wdXBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pZnJhbWVIYW5kc2hha2UucHJvbWlzZS50aGVuKGZ1bmN0aW9uICh1c2VCcm9hZGNhc3RDaGFubmVsKSB7XG4gICAgICAgIHBvcnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFBPUFVQLklOSVQsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc2V0dGluZ3M6IF90aGlzNS5zZXR0aW5ncyxcbiAgICAgICAgICAgIHVzZUJyb2FkY2FzdENoYW5uZWw6IHVzZUJyb2FkY2FzdENoYW5uZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkVYVEVOU0lPTl9VU0JfUEVSTUlTU0lPTlMpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgY2hyb21lIG5vdCBkZWNsYXJlZCBvdXRzaWRlXG4gICAgICBjaHJvbWUudGFicy5xdWVyeSh7XG4gICAgICAgIGN1cnJlbnRXaW5kb3c6IHRydWUsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfSwgZnVuY3Rpb24gKHRhYnMpIHtcbiAgICAgICAgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcbiAgICAgICAgY2hyb21lLnRhYnMuY3JlYXRlKHtcbiAgICAgICAgICB1cmw6ICd0cmV6b3ItdXNiLXBlcm1pc3Npb25zLmh0bWwnLFxuICAgICAgICAgIGluZGV4OiB0YWJzWzBdLmluZGV4ICsgMVxuICAgICAgICB9LCBmdW5jdGlvbiAoX3RhYikgey8vIGRvIG5vdGhpbmdcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuQ0xPU0VfV0lORE9XKSB7XG4gICAgICB0aGlzLmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZU1lc3NhZ2UgPSBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgIC8vIGlnbm9yZSBtZXNzYWdlcyBmcm9tIGRvbWFpbiBvdGhlciB0aGVuIHBvcHVwIG9yaWdpbiBhbmQgd2l0aG91dCBkYXRhXG4gICAgLy8gY29uc3QgZGF0YTogQ29yZU1lc3NhZ2UgPSBtZXNzYWdlLmRhdGE7XG4gICAgdmFyIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgaWYgKCgwLCBfbmV0d29ya1V0aWxzLmdldE9yaWdpbikobWVzc2FnZS5vcmlnaW4pICE9PSB0aGlzLm9yaWdpbiB8fCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpIHJldHVybjtcblxuICAgIGlmIChkYXRhLnR5cGUgPT09IElGUkFNRS5MT0FERUQpIHtcbiAgICAgIHZhciB1c2VCcm9hZGNhc3RDaGFubmVsID0gZGF0YS5wYXlsb2FkICYmIHR5cGVvZiBkYXRhLnBheWxvYWQudXNlQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ2Jvb2xlYW4nID8gZGF0YS5wYXlsb2FkLnVzZUJyb2FkY2FzdENoYW5uZWwgOiBmYWxzZTtcbiAgICAgIHRoaXMuaWZyYW1lSGFuZHNoYWtlLnJlc29sdmUodXNlQnJvYWRjYXN0Q2hhbm5lbCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkJPT1RTVFJBUCkge1xuICAgICAgLy8gcG9wdXAgaXMgb3BlbmVkIHByb3Blcmx5LCBub3cgd2FpdCBmb3IgUE9QVVAuTE9BREVEIG1lc3NhZ2VcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5cGUgPT09IFBPUFVQLkVSUk9SICYmIHRoaXMuX3dpbmRvdykge1xuICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IGRhdGEucGF5bG9hZCAmJiB0eXBlb2YgZGF0YS5wYXlsb2FkLmVycm9yID09PSAnc3RyaW5nJyA/IGRhdGEucGF5bG9hZC5lcnJvciA6IG51bGw7XG4gICAgICB0aGlzLmVtaXQoUE9QVVAuQ0xPU0VELCBlcnJvck1lc3NhZ2UgPyBcIlBvcHVwIGVycm9yOiBcIiArIGVycm9yTWVzc2FnZSA6IG51bGwpO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eXBlID09PSBQT1BVUC5MT0FERUQpIHtcbiAgICAgIGlmICh0aGlzLnBvcHVwUHJvbWlzZSkge1xuICAgICAgICB0aGlzLnBvcHVwUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9IC8vIHBvcHVwIGlzIHN1Y2Nlc3NmdWxseSBsb2FkZWRcblxuXG4gICAgICB0aGlzLmlmcmFtZUhhbmRzaGFrZS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHVzZUJyb2FkY2FzdENoYW5uZWwpIHtcbiAgICAgICAgX3RoaXM2Ll93aW5kb3cucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHR5cGU6IFBPUFVQLklOSVQsXG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgc2V0dGluZ3M6IF90aGlzNi5zZXR0aW5ncyxcbiAgICAgICAgICAgIHVzZUJyb2FkY2FzdENoYW5uZWw6IHVzZUJyb2FkY2FzdENoYW5uZWxcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF90aGlzNi5vcmlnaW4pO1xuICAgICAgfSk7IC8vIHNlbmQgQ29ubmVjdFNldHRpbmdzIHRvIHBvcHVwXG4gICAgICAvLyBub3RlIHRoaXMgc2V0dGluZ3MgYW5kIGlmcmFtZS5Db25uZWN0U2V0dGluZ3MgY291bGQgYmUgZGlmZmVyZW50IChlc3BlY2lhbGx5OiBvcmlnaW4sIHBvcHVwLCB3ZWJ1c2IsIGRlYnVnKVxuICAgICAgLy8gbm93IHBvcHVwIGlzIGFibGUgdG8gbG9hZCBhc3NldHNcbiAgICB9IGVsc2UgaWYgKGRhdGEudHlwZSA9PT0gUE9QVVAuQ0FOQ0VMX1BPUFVQX1JFUVVFU1QgfHwgZGF0YS50eXBlID09PSBVSS5DTE9TRV9VSV9XSU5ET1cpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNsb3NlID0gZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgdGhpcy5sb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLnBvcHVwUHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLnJlcXVlc3RUaW1lb3V0KSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpO1xuICAgICAgdGhpcy5yZXF1ZXN0VGltZW91dCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMub3BlblRpbWVvdXQpIHtcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5vcGVuVGltZW91dCk7XG4gICAgICB0aGlzLm9wZW5UaW1lb3V0ID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbG9zZUludGVydmFsKSB7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmNsb3NlSW50ZXJ2YWwpO1xuICAgICAgdGhpcy5jbG9zZUludGVydmFsID0gMDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5leHRlbnNpb25Qb3J0KSB7XG4gICAgICB0aGlzLmV4dGVuc2lvblBvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5leHRlbnNpb25Qb3J0ID0gbnVsbDtcbiAgICB9IC8vIHN3aXRjaCB0byBwcmV2aW91c2x5IGZvY3VzZWQgdGFiXG5cblxuICAgIGlmICh0aGlzLmV4dGVuc2lvblRhYklkKSB7XG4gICAgICAvLyAkRmxvd0lzc3VlIGNocm9tZSBub3QgZGVjbGFyZWQgb3V0c2lkZVxuICAgICAgY2hyb21lLnRhYnMudXBkYXRlKHRoaXMuZXh0ZW5zaW9uVGFiSWQsIHtcbiAgICAgICAgYWN0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZXh0ZW5zaW9uVGFiSWQgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl93aW5kb3cpIHtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVudiA9PT0gJ3dlYmV4dGVuc2lvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgIHZhciBfZSA9IGNocm9tZS5ydW50aW1lLmxhc3RFcnJvcjsgLy8gJEZsb3dJc3N1ZSBjaHJvbWUgbm90IGRlY2xhcmVkIG91dHNpZGVcblxuICAgICAgICBjaHJvbWUudGFicy5yZW1vdmUodGhpcy5fd2luZG93LmlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICAgICAgX2UgPSBjaHJvbWUucnVudGltZS5sYXN0RXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fd2luZG93LmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dpbmRvdyA9IG51bGw7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wb3N0TWVzc2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wb3N0TWVzc2FnZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKG1lc3NhZ2UpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoISghdGhpcy5fd2luZG93ICYmIG1lc3NhZ2UudHlwZSAhPT0gVUkuUkVRVUVTVF9VSV9XSU5ET1cgJiYgdGhpcy5vcGVuVGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgKDAsIF9zaG93UG9wdXBSZXF1ZXN0LnNob3dQb3B1cFJlcXVlc3QpKHRoaXMub3Blbi5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXM3LmVtaXQoUE9QVVAuQ0xPU0VEKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLnBvcHVwUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcHVwUHJvbWlzZS5wcm9taXNlO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIC8vIHBvc3QgbWVzc2FnZSB0byBwb3B1cCB3aW5kb3dcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3dpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlLCB0aGlzLm9yaWdpbik7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgfSkpO1xuXG4gICAgZnVuY3Rpb24gcG9zdE1lc3NhZ2UoX3gpIHtcbiAgICAgIHJldHVybiBfcG9zdE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9zdE1lc3NhZ2U7XG4gIH0oKTtcblxuICByZXR1cm4gUG9wdXBNYW5hZ2VyO1xufShfZXZlbnRzW1wiZGVmYXVsdFwiXSk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUG9wdXBNYW5hZ2VyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5zaG93UG9wdXBSZXF1ZXN0ID0gdm9pZCAwO1xudmFyIExBWUVSX0lEID0gJ1RyZXpvckNvbm5lY3RJbnRlcmFjdGlvbkxheWVyJztcbnZhciBIVE1MID0gXCJcXG4gICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC1jb250YWluZXJcXFwiIGlkPVxcXCJcIiArIExBWUVSX0lEICsgXCJcXFwiPlxcbiAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC13aW5kb3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRyZXpvcmNvbm5lY3QtaGVhZFxcXCI+XFxuICAgICAgICAgICAgICAgIDxzdmcgY2xhc3M9XFxcInRyZXpvcmNvbm5lY3QtbG9nb1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNjMuNyA0MS45XFxcIiB3aWR0aD1cXFwiNzhweFxcXCIgaGVpZ2h0PVxcXCIyMHB4XFxcIiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPVxcXCJ4TWluWU1pbiBtZWV0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxwb2x5Z29uIHBvaW50cz1cXFwiMTAxLjEsMTIuOCAxMTguMiwxMi44IDExOC4yLDE3LjMgMTA4LjksMjkuOSAxMTguMiwyOS45IDExOC4yLDM1LjIgMTAxLjEsMzUuMiAxMDEuMSwzMC43IDExMC40LDE4LjEgMTAxLjEsMTguMVxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTE1OC44LDI2LjljMi4xLTAuOCw0LjMtMi45LDQuMy02LjZjMC00LjUtMy4xLTcuNC03LjctNy40aC0xMC41djIyLjNoNS44di03LjVoMi4ybDQuMSw3LjVoNi43TDE1OC44LDI2Ljl6IE0xNTQuNywyMi41IGgtNFYxOGg0YzEuNSwwLDIuNSwwLjksMi41LDIuMkMxNTcuMiwyMS42LDE1Ni4yLDIyLjUsMTU0LjcsMjIuNXpcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDxwYXRoIGQ9XFxcIk0xMzAuOCwxMi41Yy02LjgsMC0xMS42LDQuOS0xMS42LDExLjVzNC45LDExLjUsMTEuNiwxMS41czExLjctNC45LDExLjctMTEuNVMxMzcuNiwxMi41LDEzMC44LDEyLjV6IE0xMzAuOCwzMC4zIGMtMy40LDAtNS43LTIuNi01LjctNi4zYzAtMy44LDIuMy02LjMsNS43LTYuM2MzLjQsMCw1LjgsMi42LDUuOCw2LjNDMTM2LjYsMjcuNywxMzQuMiwzMC4zLDEzMC44LDMwLjN6XFxcIi8+XFxuICAgICAgICAgICAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XFxcIjgyLjEsMTIuOCA5OC4zLDEyLjggOTguMywxOCA4Ny45LDE4IDg3LjksMjEuMyA5OCwyMS4zIDk4LDI2LjQgODcuOSwyNi40IDg3LjksMzAgOTguMywzMCA5OC4zLDM1LjIgODIuMSwzNS4yIFxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTI0LjYsOS43QzI0LjYsNC40LDIwLDAsMTQuNCwwUzQuMiw0LjQsNC4yLDkuN3YzLjFIMHYyMi4zaDBsMTQuNCw2LjdsMTQuNC02LjdoMFYxMi45aC00LjJWOS43eiBNOS40LDkuNyBjMC0yLjUsMi4yLTQuNSw1LTQuNXM1LDIsNSw0LjV2My4xSDkuNFY5Ljd6IE0yMywzMS41bC04LjYsNGwtOC42LTRWMTguMUgyM1YzMS41elxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBhdGggZD1cXFwiTTc5LjQsMjAuM2MwLTQuNS0zLjEtNy40LTcuNy03LjRINjEuMnYyMi4zSDY3di03LjVoMi4ybDQuMSw3LjVIODBsLTQuOS04LjNDNzcuMiwyNi4xLDc5LjQsMjQsNzkuNCwyMC4zeiBNNzEsMjIuNWgtNFYxOCBoNGMxLjUsMCwyLjUsMC45LDIuNSwyLjJDNzMuNSwyMS42LDcyLjUsMjIuNSw3MSwyMi41elxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVxcXCI0MC41LDEyLjggNTguNiwxMi44IDU4LjYsMTguMSA1Mi40LDE4LjEgNTIuNCwzNS4yIDQ2LjYsMzUuMiA0Ni42LDE4LjEgNDAuNSwxOC4xIFxcXCIvPlxcbiAgICAgICAgICAgICAgICA8L3N2Zz5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwidHJlem9yY29ubmVjdC1jbG9zZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8c3ZnIHg9XFxcIjBweFxcXCIgeT1cXFwiMHB4XFxcIiB2aWV3Qm94PVxcXCIyNCAyNCA2MCA2MFxcXCIgd2lkdGg9XFxcIjI0cHhcXFwiIGhlaWdodD1cXFwiMjRweFxcXCIgcHJlc2VydmVBc3BlY3RSYXRpbz1cXFwieE1pbllNaW4gbWVldFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHBvbHlnb24gY2xhc3M9XFxcInN0MFxcXCIgcG9pbnRzPVxcXCI0MCw2Ny45IDQyLjEsNzAgNTUsNTcuMSA2Ny45LDcwIDcwLDY3LjkgNTcuMSw1NSA3MCw0Mi4xIDY3LjksNDAgNTUsNTIuOSA0Mi4xLDQwIDQwLDQyLjEgNTIuOSw1NSBcXFwiLz5cXG4gICAgICAgICAgICAgICAgICAgIDwvc3ZnPlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJ0cmV6b3Jjb25uZWN0LWJvZHlcXFwiPlxcbiAgICAgICAgICAgICAgICA8aDM+UG9wdXAgd2FzIGJsb2NrZWQ8L2gzPlxcbiAgICAgICAgICAgICAgICA8cD5QbGVhc2UgY2xpY2sgdG8gXFx1MjAxQ0NvbnRpbnVlXFx1MjAxRCB0byBvcGVuIHBvcHVwIG1hbnVhbGx5PC9wPlxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJ0cmV6b3Jjb25uZWN0LW9wZW5cXFwiPkNvbnRpbnVlPC9idXR0b24+XFxuICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICA8L2Rpdj5cXG4gICAgPC9kaXY+XFxuXCI7XG5cbnZhciBzaG93UG9wdXBSZXF1ZXN0ID0gZnVuY3Rpb24gc2hvd1BvcHVwUmVxdWVzdChvcGVuLCBjYW5jZWwpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKExBWUVSX0lEKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmlkID0gTEFZRVJfSUQ7XG4gIGRpdi5jbGFzc05hbWUgPSAndHJlem9yY29ubmVjdC1jb250YWluZXInO1xuICBkaXYuaW5uZXJIVE1MID0gSFRNTDtcblxuICBpZiAoZG9jdW1lbnQuYm9keSkge1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgfVxuXG4gIHZhciBidXR0b24gPSBkaXYuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgndHJlem9yY29ubmVjdC1vcGVuJylbMF07XG5cbiAgYnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgb3BlbigpO1xuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsb3NlID0gZGl2LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3RyZXpvcmNvbm5lY3QtY2xvc2UnKVswXTtcblxuICBjbG9zZS5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgIGNhbmNlbCgpO1xuXG4gICAgaWYgKGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICB9XG4gIH07XG59O1xuXG5leHBvcnRzLnNob3dQb3B1cFJlcXVlc3QgPSBzaG93UG9wdXBSZXF1ZXN0OyIsIlwidXNlIHN0cmljdFwiOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgQ09OU1RBTlRTID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKSk7XG5cbnZhciBQID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vcGFyYW1zXCIpKTtcblxudmFyIERldmljZSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3RyZXpvci9kZXZpY2VcIikpO1xuXG52YXIgTWdtbnQgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi90cmV6b3IvbWFuYWdlbWVudFwiKSk7XG5cbnZhciBQcm90b2J1ZiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL3RyZXpvci9wcm90b2J1ZlwiKSk7XG5cbnZhciBBY2NvdW50ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vYWNjb3VudFwiKSk7XG5cbnZhciBCaXRjb2luID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvYml0Y29pblwiKSk7XG5cbnZhciBCaW5hbmNlID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvYmluYW5jZVwiKSk7XG5cbnZhciBDYXJkYW5vID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbmV0d29ya3MvY2FyZGFub1wiKSk7XG5cbnZhciBDb2luSW5mbyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL2NvaW5JbmZvXCIpKTtcblxudmFyIEVPUyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL2Vvc1wiKSk7XG5cbnZhciBFdGhlcmV1bSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL2V0aGVyZXVtXCIpKTtcblxudmFyIE5FTSA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL25lbVwiKSk7XG5cbnZhciBSaXBwbGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy9yaXBwbGVcIikpO1xuXG52YXIgU3RlbGxhciA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL25ldHdvcmtzL3N0ZWxsYXJcIikpO1xuXG52YXIgVGV6b3MgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9uZXR3b3Jrcy90ZXpvc1wiKSk7XG5cbnZhciBNaXNjID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcIi4vbWlzY1wiKSk7XG5cbnZhciBFdmVudHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChyZXF1aXJlKFwiLi9ldmVudHNcIikpO1xuXG52YXIgQmxvY2tjaGFpbiA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKHJlcXVpcmUoXCIuL2JhY2tlbmQvYmxvY2tjaGFpblwiKSk7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCkgeyBpZiAodHlwZW9mIFdlYWtNYXAgIT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIG51bGw7IHZhciBjYWNoZUJhYmVsSW50ZXJvcCA9IG5ldyBXZWFrTWFwKCk7IHZhciBjYWNoZU5vZGVJbnRlcm9wID0gbmV3IFdlYWtNYXAoKTsgcmV0dXJuIChfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUgPSBmdW5jdGlvbiBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUobm9kZUludGVyb3ApIHsgcmV0dXJuIG5vZGVJbnRlcm9wID8gY2FjaGVOb2RlSW50ZXJvcCA6IGNhY2hlQmFiZWxJbnRlcm9wOyB9KShub2RlSW50ZXJvcCk7IH1cblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQob2JqLCBub2RlSW50ZXJvcCkgeyBpZiAoIW5vZGVJbnRlcm9wICYmIG9iaiAmJiBvYmouX19lc01vZHVsZSkgeyByZXR1cm4gb2JqOyB9IGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHsgcmV0dXJuIHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9IHZhciBjYWNoZSA9IF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZShub2RlSW50ZXJvcCk7IGlmIChjYWNoZSAmJiBjYWNoZS5oYXMob2JqKSkgeyByZXR1cm4gY2FjaGUuZ2V0KG9iaik7IH0gdmFyIG5ld09iaiA9IHt9OyB2YXIgaGFzUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKGtleSAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgeyB2YXIgZGVzYyA9IGhhc1Byb3BlcnR5RGVzY3JpcHRvciA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXkpIDogbnVsbDsgaWYgKGRlc2MgJiYgKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkobmV3T2JqLCBrZXksIGRlc2MpOyB9IGVsc2UgeyBuZXdPYmpba2V5XSA9IG9ialtrZXldOyB9IH0gfSBuZXdPYmpbXCJkZWZhdWx0XCJdID0gb2JqOyBpZiAoY2FjaGUpIHsgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTsgfSByZXR1cm4gbmV3T2JqOyB9IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpOyIsIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2FwaSA9IHJlcXVpcmUoXCIuL2FwaVwiKTtcblxuT2JqZWN0LmtleXMoX2FwaSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2FwaVtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9hcGlba2V5XTtcbn0pO1xuXG52YXIgX2V2ZW50cyA9IHJlcXVpcmUoXCIuL2V2ZW50c1wiKTtcblxuT2JqZWN0LmtleXMoX2V2ZW50cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2V2ZW50c1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9ldmVudHNba2V5XTtcbn0pO1xuXG52YXIgX21pc2MgPSByZXF1aXJlKFwiLi9taXNjXCIpO1xuXG5PYmplY3Qua2V5cyhfbWlzYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX21pc2Nba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfbWlzY1trZXldO1xufSk7XG5cbnZhciBfcGFyYW1zID0gcmVxdWlyZShcIi4vcGFyYW1zXCIpO1xuXG5PYmplY3Qua2V5cyhfcGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfcGFyYW1zW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX3BhcmFtc1trZXldO1xufSk7XG5cbnZhciBfYWNjb3VudCA9IHJlcXVpcmUoXCIuL2FjY291bnRcIik7XG5cbk9iamVjdC5rZXlzKF9hY2NvdW50KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfYWNjb3VudFtrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9hY2NvdW50W2tleV07XG59KTtcblxudmFyIF9kZXZpY2UgPSByZXF1aXJlKFwiLi90cmV6b3IvZGV2aWNlXCIpO1xuXG5PYmplY3Qua2V5cyhfZGV2aWNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfZGV2aWNlW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2RldmljZVtrZXldO1xufSk7XG5cbnZhciBfbWFuYWdlbWVudCA9IHJlcXVpcmUoXCIuL3RyZXpvci9tYW5hZ2VtZW50XCIpO1xuXG5PYmplY3Qua2V5cyhfbWFuYWdlbWVudCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX21hbmFnZW1lbnRba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfbWFuYWdlbWVudFtrZXldO1xufSk7XG5cbnZhciBfYml0Y29pbiA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL2JpdGNvaW5cIik7XG5cbk9iamVjdC5rZXlzKF9iaXRjb2luKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfYml0Y29pbltrZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9iaXRjb2luW2tleV07XG59KTtcblxudmFyIF9iaW5hbmNlID0gcmVxdWlyZShcIi4vbmV0d29ya3MvYmluYW5jZVwiKTtcblxuT2JqZWN0LmtleXMoX2JpbmFuY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9iaW5hbmNlW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2JpbmFuY2Vba2V5XTtcbn0pO1xuXG52YXIgX2NhcmRhbm8gPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9jYXJkYW5vXCIpO1xuXG5PYmplY3Qua2V5cyhfY2FyZGFubykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2NhcmRhbm9ba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfY2FyZGFub1trZXldO1xufSk7XG5cbnZhciBfY29pbkluZm8gPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9jb2luSW5mb1wiKTtcblxuT2JqZWN0LmtleXMoX2NvaW5JbmZvKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKGtleSA9PT0gXCJkZWZhdWx0XCIgfHwga2V5ID09PSBcIl9fZXNNb2R1bGVcIikgcmV0dXJuO1xuICBpZiAoa2V5IGluIGV4cG9ydHMgJiYgZXhwb3J0c1trZXldID09PSBfY29pbkluZm9ba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfY29pbkluZm9ba2V5XTtcbn0pO1xuXG52YXIgX2VvcyA9IHJlcXVpcmUoXCIuL25ldHdvcmtzL2Vvc1wiKTtcblxuT2JqZWN0LmtleXMoX2VvcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2Vvc1trZXldKSByZXR1cm47XG4gIGV4cG9ydHNba2V5XSA9IF9lb3Nba2V5XTtcbn0pO1xuXG52YXIgX2V0aGVyZXVtID0gcmVxdWlyZShcIi4vbmV0d29ya3MvZXRoZXJldW1cIik7XG5cbk9iamVjdC5rZXlzKF9ldGhlcmV1bSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2V0aGVyZXVtW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX2V0aGVyZXVtW2tleV07XG59KTtcblxudmFyIF9uZW0gPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9uZW1cIik7XG5cbk9iamVjdC5rZXlzKF9uZW0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9uZW1ba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfbmVtW2tleV07XG59KTtcblxudmFyIF9yaXBwbGUgPSByZXF1aXJlKFwiLi9uZXR3b3Jrcy9yaXBwbGVcIik7XG5cbk9iamVjdC5rZXlzKF9yaXBwbGUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9yaXBwbGVba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfcmlwcGxlW2tleV07XG59KTtcblxudmFyIF9zdGVsbGFyID0gcmVxdWlyZShcIi4vbmV0d29ya3Mvc3RlbGxhclwiKTtcblxuT2JqZWN0LmtleXMoX3N0ZWxsYXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF9zdGVsbGFyW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX3N0ZWxsYXJba2V5XTtcbn0pO1xuXG52YXIgX3Rlem9zID0gcmVxdWlyZShcIi4vbmV0d29ya3MvdGV6b3NcIik7XG5cbk9iamVjdC5rZXlzKF90ZXpvcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX3Rlem9zW2tleV0pIHJldHVybjtcbiAgZXhwb3J0c1trZXldID0gX3Rlem9zW2tleV07XG59KTtcblxudmFyIF9ibG9ja2NoYWluID0gcmVxdWlyZShcIi4vYmFja2VuZC9ibG9ja2NoYWluXCIpO1xuXG5PYmplY3Qua2V5cyhfYmxvY2tjaGFpbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gIGlmIChrZXkgPT09IFwiZGVmYXVsdFwiIHx8IGtleSA9PT0gXCJfX2VzTW9kdWxlXCIpIHJldHVybjtcbiAgaWYgKGtleSBpbiBleHBvcnRzICYmIGV4cG9ydHNba2V5XSA9PT0gX2Jsb2NrY2hhaW5ba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfYmxvY2tjaGFpbltrZXldO1xufSk7XG5cbnZhciBfdHJhbnNhY3Rpb25zID0gcmVxdWlyZShcIi4vYmFja2VuZC90cmFuc2FjdGlvbnNcIik7XG5cbk9iamVjdC5rZXlzKF90cmFuc2FjdGlvbnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICBpZiAoa2V5ID09PSBcImRlZmF1bHRcIiB8fCBrZXkgPT09IFwiX19lc01vZHVsZVwiKSByZXR1cm47XG4gIGlmIChrZXkgaW4gZXhwb3J0cyAmJiBleHBvcnRzW2tleV0gPT09IF90cmFuc2FjdGlvbnNba2V5XSkgcmV0dXJuO1xuICBleHBvcnRzW2tleV0gPSBfdHJhbnNhY3Rpb25zW2tleV07XG59KTsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuQ2FyZGFub1R4V2l0bmVzc1R5cGUgPSBleHBvcnRzLkNhcmRhbm9UeFNpZ25pbmdNb2RlID0gZXhwb3J0cy5DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IGV4cG9ydHMuQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gZXhwb3J0cy5DYXJkYW5vTmF0aXZlU2NyaXB0VHlwZSA9IGV4cG9ydHMuQ2FyZGFub0NlcnRpZmljYXRlVHlwZSA9IGV4cG9ydHMuQ2FyZGFub0FkZHJlc3NUeXBlID0gdm9pZCAwO1xuXG52YXIgX3Byb3RvYnVmID0gcmVxdWlyZShcIi4uL3RyZXpvci9wcm90b2J1ZlwiKTtcblxuZXhwb3J0cy5DYXJkYW5vQWRkcmVzc1R5cGUgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vQWRkcmVzc1R5cGU7XG5leHBvcnRzLkNhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vQ2VydGlmaWNhdGVUeXBlO1xuZXhwb3J0cy5DYXJkYW5vTmF0aXZlU2NyaXB0VHlwZSA9IF9wcm90b2J1Zi5FbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlO1xuZXhwb3J0cy5DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBfcHJvdG9idWYuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQ7XG5leHBvcnRzLkNhcmRhbm9Qb29sUmVsYXlUeXBlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGU7XG5leHBvcnRzLkNhcmRhbm9UeFNpZ25pbmdNb2RlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub1R4U2lnbmluZ01vZGU7XG5leHBvcnRzLkNhcmRhbm9UeFdpdG5lc3NUeXBlID0gX3Byb3RvYnVmLkVudW1fQ2FyZGFub1R4V2l0bmVzc1R5cGU7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTsiLCJcInVzZSBzdHJpY3RcIjsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuRW51bV9UZXpvc0JhbGxvdFR5cGUgPSBleHBvcnRzLkVudW1fVGV6b3NDb250cmFjdFR5cGUgPSBleHBvcnRzLkVudW1fU3RlbGxhclNpZ25lclR5cGUgPSBleHBvcnRzLkVudW1fU3RlbGxhck1lbW9UeXBlID0gZXhwb3J0cy5FbnVtX1N0ZWxsYXJBc3NldFR5cGUgPSBleHBvcnRzLkVudW1fTkVNSW1wb3J0YW5jZVRyYW5zZmVyTW9kZSA9IGV4cG9ydHMuRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlID0gZXhwb3J0cy5FbnVtX05FTVN1cHBseUNoYW5nZVR5cGUgPSBleHBvcnRzLkVudW1fTkVNTW9zYWljTGV2eSA9IGV4cG9ydHMuRW51bV9Xb3JkUmVxdWVzdFR5cGUgPSBleHBvcnRzLkVudW1fUmVjb3ZlcnlEZXZpY2VUeXBlID0gZXhwb3J0cy5FbnVtX1NkUHJvdGVjdE9wZXJhdGlvblR5cGUgPSBleHBvcnRzLkVudW1fQ2FwYWJpbGl0eSA9IGV4cG9ydHMuRW51bV9TYWZldHlDaGVja0xldmVsID0gZXhwb3J0cy5FbnVtX0JhY2t1cFR5cGUgPSBleHBvcnRzLkVudW1fRXRoZXJldW1EYXRhVHlwZSA9IGV4cG9ydHMuRW51bV9QaW5NYXRyaXhSZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9CdXR0b25SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9GYWlsdXJlVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub0NlcnRpZmljYXRlVHlwZSA9IGV4cG9ydHMuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBleHBvcnRzLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBleHBvcnRzLkVudW1fQ2FyZGFub0FkZHJlc3NUeXBlID0gZXhwb3J0cy5FbnVtX0NhcmRhbm9EZXJpdmF0aW9uVHlwZSA9IGV4cG9ydHMuRW51bV9SZXF1ZXN0VHlwZSA9IGV4cG9ydHMuRW51bV9BbW91bnRVbml0ID0gZXhwb3J0cy5FbnVtX0RlY3JlZFN0YWtpbmdTcGVuZFR5cGUgPSBleHBvcnRzLkVudW1fT3V0cHV0U2NyaXB0VHlwZSA9IGV4cG9ydHMuRW51bV9JbnB1dFNjcmlwdFR5cGUgPSBleHBvcnRzLkVudW1fQmluYW5jZVRpbWVJbkZvcmNlID0gZXhwb3J0cy5FbnVtX0JpbmFuY2VPcmRlclNpZGUgPSBleHBvcnRzLkVudW1fQmluYW5jZU9yZGVyVHlwZSA9IHZvaWQgMDtcbi8vIFRoaXMgZmlsZSBpcyBhdXRvIGdlbmVyYXRlZCBmcm9tIGRhdGEvbWVzc2FnZXMvbWVzc2FnZS5qc29uXG4vLyBjdXN0b20gdHlwZSB1aW50MzIvNjQgbWF5IGJlIHJlcHJlc2VudGVkIGFzIHN0cmluZ1xuLy8gQmluYW5jZUdldEFkZHJlc3Ncbi8vIEJpbmFuY2VBZGRyZXNzXG4vLyBCaW5hbmNlR2V0UHVibGljS2V5XG4vLyBCaW5hbmNlUHVibGljS2V5XG4vLyBCaW5hbmNlU2lnblR4XG4vLyBCaW5hbmNlVHhSZXF1ZXN0XG4vLyBCaW5hbmNlVHJhbnNmZXJNc2dcbnZhciBFbnVtX0JpbmFuY2VPcmRlclR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgT1RfVU5LTk9XTjogMCxcbiAgTUFSS0VUOiAxLFxuICBMSU1JVDogMixcbiAgT1RfUkVTRVJWRUQ6IDNcbn0pO1xuZXhwb3J0cy5FbnVtX0JpbmFuY2VPcmRlclR5cGUgPSBFbnVtX0JpbmFuY2VPcmRlclR5cGU7XG52YXIgRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFNJREVfVU5LTk9XTjogMCxcbiAgQlVZOiAxLFxuICBTRUxMOiAyXG59KTtcbmV4cG9ydHMuRW51bV9CaW5hbmNlT3JkZXJTaWRlID0gRW51bV9CaW5hbmNlT3JkZXJTaWRlO1xudmFyIEVudW1fQmluYW5jZVRpbWVJbkZvcmNlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFRJRl9VTktOT1dOOiAwLFxuICBHVEU6IDEsXG4gIFRJRl9SRVNFUlZFRDogMixcbiAgSU9DOiAzXG59KTtcbmV4cG9ydHMuRW51bV9CaW5hbmNlVGltZUluRm9yY2UgPSBFbnVtX0JpbmFuY2VUaW1lSW5Gb3JjZTtcbnZhciBFbnVtX0lucHV0U2NyaXB0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTUEVOREFERFJFU1M6IDAsXG4gIFNQRU5ETVVMVElTSUc6IDEsXG4gIEVYVEVSTkFMOiAyLFxuICBTUEVORFdJVE5FU1M6IDMsXG4gIFNQRU5EUDJTSFdJVE5FU1M6IDQsXG4gIFNQRU5EVEFQUk9PVDogNVxufSk7XG5leHBvcnRzLkVudW1fSW5wdXRTY3JpcHRUeXBlID0gRW51bV9JbnB1dFNjcmlwdFR5cGU7XG52YXIgRW51bV9PdXRwdXRTY3JpcHRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBBWVRPQUREUkVTUzogMCxcbiAgUEFZVE9TQ1JJUFRIQVNIOiAxLFxuICBQQVlUT01VTFRJU0lHOiAyLFxuICBQQVlUT09QUkVUVVJOOiAzLFxuICBQQVlUT1dJVE5FU1M6IDQsXG4gIFBBWVRPUDJTSFdJVE5FU1M6IDUsXG4gIFBBWVRPVEFQUk9PVDogNlxufSk7XG5leHBvcnRzLkVudW1fT3V0cHV0U2NyaXB0VHlwZSA9IEVudW1fT3V0cHV0U2NyaXB0VHlwZTtcbnZhciBFbnVtX0RlY3JlZFN0YWtpbmdTcGVuZFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU1NHZW46IDAsXG4gIFNTUlRYOiAxXG59KTtcbmV4cG9ydHMuRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlID0gRW51bV9EZWNyZWRTdGFraW5nU3BlbmRUeXBlO1xudmFyIEVudW1fQW1vdW50VW5pdCA9IE9iamVjdC5mcmVlemUoe1xuICBCSVRDT0lOOiAwLFxuICBNSUxMSUJJVENPSU46IDEsXG4gIE1JQ1JPQklUQ09JTjogMixcbiAgU0FUT1NISTogM1xufSk7XG5leHBvcnRzLkVudW1fQW1vdW50VW5pdCA9IEVudW1fQW1vdW50VW5pdDtcbnZhciBFbnVtX1JlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFRYSU5QVVQ6IDAsXG4gIFRYT1VUUFVUOiAxLFxuICBUWE1FVEE6IDIsXG4gIFRYRklOSVNIRUQ6IDMsXG4gIFRYRVhUUkFEQVRBOiA0LFxuICBUWE9SSUdJTlBVVDogNSxcbiAgVFhPUklHT1VUUFVUOiA2XG59KTtcbmV4cG9ydHMuRW51bV9SZXF1ZXN0VHlwZSA9IEVudW1fUmVxdWVzdFR5cGU7XG52YXIgRW51bV9DYXJkYW5vRGVyaXZhdGlvblR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgTEVER0VSOiAwLFxuICBJQ0FSVVM6IDEsXG4gIElDQVJVU19UUkVaT1I6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9EZXJpdmF0aW9uVHlwZSA9IEVudW1fQ2FyZGFub0Rlcml2YXRpb25UeXBlO1xudmFyIEVudW1fQ2FyZGFub0FkZHJlc3NUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJBU0U6IDAsXG4gIEJBU0VfU0NSSVBUX0tFWTogMSxcbiAgQkFTRV9LRVlfU0NSSVBUOiAyLFxuICBCQVNFX1NDUklQVF9TQ1JJUFQ6IDMsXG4gIFBPSU5URVI6IDQsXG4gIFBPSU5URVJfU0NSSVBUOiA1LFxuICBFTlRFUlBSSVNFOiA2LFxuICBFTlRFUlBSSVNFX1NDUklQVDogNyxcbiAgQllST046IDgsXG4gIFJFV0FSRDogMTQsXG4gIFJFV0FSRF9TQ1JJUFQ6IDE1XG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vQWRkcmVzc1R5cGUgPSBFbnVtX0NhcmRhbm9BZGRyZXNzVHlwZTtcbnZhciBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBVQl9LRVk6IDAsXG4gIEFMTDogMSxcbiAgQU5ZOiAyLFxuICBOX09GX0s6IDMsXG4gIElOVkFMSURfQkVGT1JFOiA0LFxuICBJTlZBTElEX0hFUkVBRlRFUjogNVxufSk7XG5leHBvcnRzLkVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdFR5cGUgPSBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRUeXBlO1xudmFyIEVudW1fQ2FyZGFub05hdGl2ZVNjcmlwdEhhc2hEaXNwbGF5Rm9ybWF0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEhJREU6IDAsXG4gIEJFQ0gzMjogMSxcbiAgUE9MSUNZX0lEOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vTmF0aXZlU2NyaXB0SGFzaERpc3BsYXlGb3JtYXQgPSBFbnVtX0NhcmRhbm9OYXRpdmVTY3JpcHRIYXNoRGlzcGxheUZvcm1hdDtcbnZhciBFbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU1RBS0VfUkVHSVNUUkFUSU9OOiAwLFxuICBTVEFLRV9ERVJFR0lTVFJBVElPTjogMSxcbiAgU1RBS0VfREVMRUdBVElPTjogMixcbiAgU1RBS0VfUE9PTF9SRUdJU1RSQVRJT046IDNcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGUgPSBFbnVtX0NhcmRhbm9DZXJ0aWZpY2F0ZVR5cGU7XG52YXIgRW51bV9DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBTSU5HTEVfSE9TVF9JUDogMCxcbiAgU0lOR0xFX0hPU1RfTkFNRTogMSxcbiAgTVVMVElQTEVfSE9TVF9OQU1FOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vUG9vbFJlbGF5VHlwZSA9IEVudW1fQ2FyZGFub1Bvb2xSZWxheVR5cGU7XG52YXIgRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgTk9ORTogMCxcbiAgQ0FUQUxZU1RfUkVHSVNUUkFUSU9OX1NJR05BVFVSRTogMVxufSk7XG5leHBvcnRzLkVudW1fQ2FyZGFub1R4QXV4aWxpYXJ5RGF0YVN1cHBsZW1lbnRUeXBlID0gRW51bV9DYXJkYW5vVHhBdXhpbGlhcnlEYXRhU3VwcGxlbWVudFR5cGU7XG52YXIgRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IE9iamVjdC5mcmVlemUoe1xuICBPUkRJTkFSWV9UUkFOU0FDVElPTjogMCxcbiAgUE9PTF9SRUdJU1RSQVRJT05fQVNfT1dORVI6IDEsXG4gIE1VTFRJU0lHX1RSQU5TQUNUSU9OOiAyXG59KTtcbmV4cG9ydHMuRW51bV9DYXJkYW5vVHhTaWduaW5nTW9kZSA9IEVudW1fQ2FyZGFub1R4U2lnbmluZ01vZGU7XG52YXIgRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBCWVJPTl9XSVRORVNTOiAwLFxuICBTSEVMTEVZX1dJVE5FU1M6IDFcbn0pO1xuZXhwb3J0cy5FbnVtX0NhcmRhbm9UeFdpdG5lc3NUeXBlID0gRW51bV9DYXJkYW5vVHhXaXRuZXNzVHlwZTtcbnZhciBFbnVtX0ZhaWx1cmVUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEZhaWx1cmVfVW5leHBlY3RlZE1lc3NhZ2U6IDEsXG4gIEZhaWx1cmVfQnV0dG9uRXhwZWN0ZWQ6IDIsXG4gIEZhaWx1cmVfRGF0YUVycm9yOiAzLFxuICBGYWlsdXJlX0FjdGlvbkNhbmNlbGxlZDogNCxcbiAgRmFpbHVyZV9QaW5FeHBlY3RlZDogNSxcbiAgRmFpbHVyZV9QaW5DYW5jZWxsZWQ6IDYsXG4gIEZhaWx1cmVfUGluSW52YWxpZDogNyxcbiAgRmFpbHVyZV9JbnZhbGlkU2lnbmF0dXJlOiA4LFxuICBGYWlsdXJlX1Byb2Nlc3NFcnJvcjogOSxcbiAgRmFpbHVyZV9Ob3RFbm91Z2hGdW5kczogMTAsXG4gIEZhaWx1cmVfTm90SW5pdGlhbGl6ZWQ6IDExLFxuICBGYWlsdXJlX1Bpbk1pc21hdGNoOiAxMixcbiAgRmFpbHVyZV9XaXBlQ29kZU1pc21hdGNoOiAxMyxcbiAgRmFpbHVyZV9JbnZhbGlkU2Vzc2lvbjogMTQsXG4gIEZhaWx1cmVfRmlybXdhcmVFcnJvcjogOTlcbn0pO1xuZXhwb3J0cy5FbnVtX0ZhaWx1cmVUeXBlID0gRW51bV9GYWlsdXJlVHlwZTtcbnZhciBFbnVtX0J1dHRvblJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEJ1dHRvblJlcXVlc3RfT3RoZXI6IDEsXG4gIEJ1dHRvblJlcXVlc3RfRmVlT3ZlclRocmVzaG9sZDogMixcbiAgQnV0dG9uUmVxdWVzdF9Db25maXJtT3V0cHV0OiAzLFxuICBCdXR0b25SZXF1ZXN0X1Jlc2V0RGV2aWNlOiA0LFxuICBCdXR0b25SZXF1ZXN0X0NvbmZpcm1Xb3JkOiA1LFxuICBCdXR0b25SZXF1ZXN0X1dpcGVEZXZpY2U6IDYsXG4gIEJ1dHRvblJlcXVlc3RfUHJvdGVjdENhbGw6IDcsXG4gIEJ1dHRvblJlcXVlc3RfU2lnblR4OiA4LFxuICBCdXR0b25SZXF1ZXN0X0Zpcm13YXJlQ2hlY2s6IDksXG4gIEJ1dHRvblJlcXVlc3RfQWRkcmVzczogMTAsXG4gIEJ1dHRvblJlcXVlc3RfUHVibGljS2V5OiAxMSxcbiAgQnV0dG9uUmVxdWVzdF9NbmVtb25pY1dvcmRDb3VudDogMTIsXG4gIEJ1dHRvblJlcXVlc3RfTW5lbW9uaWNJbnB1dDogMTMsXG4gIF9EZXByZWNhdGVkX0J1dHRvblJlcXVlc3RfUGFzc3BocmFzZVR5cGU6IDE0LFxuICBCdXR0b25SZXF1ZXN0X1Vua25vd25EZXJpdmF0aW9uUGF0aDogMTUsXG4gIEJ1dHRvblJlcXVlc3RfUmVjb3ZlcnlIb21lcGFnZTogMTYsXG4gIEJ1dHRvblJlcXVlc3RfU3VjY2VzczogMTcsXG4gIEJ1dHRvblJlcXVlc3RfV2FybmluZzogMTgsXG4gIEJ1dHRvblJlcXVlc3RfUGFzc3BocmFzZUVudHJ5OiAxOSxcbiAgQnV0dG9uUmVxdWVzdF9QaW5FbnRyeTogMjBcbn0pO1xuZXhwb3J0cy5FbnVtX0J1dHRvblJlcXVlc3RUeXBlID0gRW51bV9CdXR0b25SZXF1ZXN0VHlwZTtcbnZhciBFbnVtX1Bpbk1hdHJpeFJlcXVlc3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX0N1cnJlbnQ6IDEsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX05ld0ZpcnN0OiAyLFxuICBQaW5NYXRyaXhSZXF1ZXN0VHlwZV9OZXdTZWNvbmQ6IDMsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX1dpcGVDb2RlRmlyc3Q6IDQsXG4gIFBpbk1hdHJpeFJlcXVlc3RUeXBlX1dpcGVDb2RlU2Vjb25kOiA1XG59KTtcbmV4cG9ydHMuRW51bV9QaW5NYXRyaXhSZXF1ZXN0VHlwZSA9IEVudW1fUGluTWF0cml4UmVxdWVzdFR5cGU7XG52YXIgRW51bV9FdGhlcmV1bURhdGFUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFVJTlQ6IDEsXG4gIElOVDogMixcbiAgQllURVM6IDMsXG4gIFNUUklORzogNCxcbiAgQk9PTDogNSxcbiAgQUREUkVTUzogNixcbiAgQVJSQVk6IDcsXG4gIFNUUlVDVDogOFxufSk7XG5leHBvcnRzLkVudW1fRXRoZXJldW1EYXRhVHlwZSA9IEVudW1fRXRoZXJldW1EYXRhVHlwZTtcbnZhciBFbnVtX0JhY2t1cFR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgQmlwMzk6IDAsXG4gIFNsaXAzOV9CYXNpYzogMSxcbiAgU2xpcDM5X0FkdmFuY2VkOiAyXG59KTtcbmV4cG9ydHMuRW51bV9CYWNrdXBUeXBlID0gRW51bV9CYWNrdXBUeXBlO1xudmFyIEVudW1fU2FmZXR5Q2hlY2tMZXZlbCA9IE9iamVjdC5mcmVlemUoe1xuICBTdHJpY3Q6IDAsXG4gIFByb21wdEFsd2F5czogMSxcbiAgUHJvbXB0VGVtcG9yYXJpbHk6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX1NhZmV0eUNoZWNrTGV2ZWwgPSBFbnVtX1NhZmV0eUNoZWNrTGV2ZWw7XG52YXIgRW51bV9DYXBhYmlsaXR5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENhcGFiaWxpdHlfQml0Y29pbjogMSxcbiAgQ2FwYWJpbGl0eV9CaXRjb2luX2xpa2U6IDIsXG4gIENhcGFiaWxpdHlfQmluYW5jZTogMyxcbiAgQ2FwYWJpbGl0eV9DYXJkYW5vOiA0LFxuICBDYXBhYmlsaXR5X0NyeXB0bzogNSxcbiAgQ2FwYWJpbGl0eV9FT1M6IDYsXG4gIENhcGFiaWxpdHlfRXRoZXJldW06IDcsXG4gIENhcGFiaWxpdHlfTGlzazogOCxcbiAgQ2FwYWJpbGl0eV9Nb25lcm86IDksXG4gIENhcGFiaWxpdHlfTkVNOiAxMCxcbiAgQ2FwYWJpbGl0eV9SaXBwbGU6IDExLFxuICBDYXBhYmlsaXR5X1N0ZWxsYXI6IDEyLFxuICBDYXBhYmlsaXR5X1Rlem9zOiAxMyxcbiAgQ2FwYWJpbGl0eV9VMkY6IDE0LFxuICBDYXBhYmlsaXR5X1NoYW1pcjogMTUsXG4gIENhcGFiaWxpdHlfU2hhbWlyR3JvdXBzOiAxNixcbiAgQ2FwYWJpbGl0eV9QYXNzcGhyYXNlRW50cnk6IDE3XG59KTtcbmV4cG9ydHMuRW51bV9DYXBhYmlsaXR5ID0gRW51bV9DYXBhYmlsaXR5O1xudmFyIEVudW1fU2RQcm90ZWN0T3BlcmF0aW9uVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBESVNBQkxFOiAwLFxuICBFTkFCTEU6IDEsXG4gIFJFRlJFU0g6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX1NkUHJvdGVjdE9wZXJhdGlvblR5cGUgPSBFbnVtX1NkUHJvdGVjdE9wZXJhdGlvblR5cGU7XG52YXIgRW51bV9SZWNvdmVyeURldmljZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVjb3ZlcnlEZXZpY2VUeXBlX1NjcmFtYmxlZFdvcmRzOiAwLFxuICBSZWNvdmVyeURldmljZVR5cGVfTWF0cml4OiAxXG59KTtcbmV4cG9ydHMuRW51bV9SZWNvdmVyeURldmljZVR5cGUgPSBFbnVtX1JlY292ZXJ5RGV2aWNlVHlwZTtcbnZhciBFbnVtX1dvcmRSZXF1ZXN0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBXb3JkUmVxdWVzdFR5cGVfUGxhaW46IDAsXG4gIFdvcmRSZXF1ZXN0VHlwZV9NYXRyaXg5OiAxLFxuICBXb3JkUmVxdWVzdFR5cGVfTWF0cml4NjogMlxufSk7XG5leHBvcnRzLkVudW1fV29yZFJlcXVlc3RUeXBlID0gRW51bV9Xb3JkUmVxdWVzdFR5cGU7XG52YXIgRW51bV9ORU1Nb3NhaWNMZXZ5ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIE1vc2FpY0xldnlfQWJzb2x1dGU6IDEsXG4gIE1vc2FpY0xldnlfUGVyY2VudGlsZTogMlxufSk7XG5leHBvcnRzLkVudW1fTkVNTW9zYWljTGV2eSA9IEVudW1fTkVNTW9zYWljTGV2eTtcbnZhciBFbnVtX05FTVN1cHBseUNoYW5nZVR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgU3VwcGx5Q2hhbmdlX0luY3JlYXNlOiAxLFxuICBTdXBwbHlDaGFuZ2VfRGVjcmVhc2U6IDJcbn0pO1xuZXhwb3J0cy5FbnVtX05FTVN1cHBseUNoYW5nZVR5cGUgPSBFbnVtX05FTVN1cHBseUNoYW5nZVR5cGU7XG52YXIgRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENvc2lnbmF0b3J5TW9kaWZpY2F0aW9uX0FkZDogMSxcbiAgQ29zaWduYXRvcnlNb2RpZmljYXRpb25fRGVsZXRlOiAyXG59KTtcbmV4cG9ydHMuRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlID0gRW51bV9ORU1Nb2RpZmljYXRpb25UeXBlO1xudmFyIEVudW1fTkVNSW1wb3J0YW5jZVRyYW5zZmVyTW9kZSA9IE9iamVjdC5mcmVlemUoe1xuICBJbXBvcnRhbmNlVHJhbnNmZXJfQWN0aXZhdGU6IDEsXG4gIEltcG9ydGFuY2VUcmFuc2Zlcl9EZWFjdGl2YXRlOiAyXG59KTtcbmV4cG9ydHMuRW51bV9ORU1JbXBvcnRhbmNlVHJhbnNmZXJNb2RlID0gRW51bV9ORU1JbXBvcnRhbmNlVHJhbnNmZXJNb2RlO1xudmFyIEVudW1fU3RlbGxhckFzc2V0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBOQVRJVkU6IDAsXG4gIEFMUEhBTlVNNDogMSxcbiAgQUxQSEFOVU0xMjogMlxufSk7XG5leHBvcnRzLkVudW1fU3RlbGxhckFzc2V0VHlwZSA9IEVudW1fU3RlbGxhckFzc2V0VHlwZTtcbnZhciBFbnVtX1N0ZWxsYXJNZW1vVHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBOT05FOiAwLFxuICBURVhUOiAxLFxuICBJRDogMixcbiAgSEFTSDogMyxcbiAgUkVUVVJOOiA0XG59KTtcbmV4cG9ydHMuRW51bV9TdGVsbGFyTWVtb1R5cGUgPSBFbnVtX1N0ZWxsYXJNZW1vVHlwZTtcbnZhciBFbnVtX1N0ZWxsYXJTaWduZXJUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEFDQ09VTlQ6IDAsXG4gIFBSRV9BVVRIOiAxLFxuICBIQVNIOiAyXG59KTtcbmV4cG9ydHMuRW51bV9TdGVsbGFyU2lnbmVyVHlwZSA9IEVudW1fU3RlbGxhclNpZ25lclR5cGU7XG52YXIgRW51bV9UZXpvc0NvbnRyYWN0VHlwZSA9IE9iamVjdC5mcmVlemUoe1xuICBJbXBsaWNpdDogMCxcbiAgT3JpZ2luYXRlZDogMVxufSk7XG5leHBvcnRzLkVudW1fVGV6b3NDb250cmFjdFR5cGUgPSBFbnVtX1Rlem9zQ29udHJhY3RUeXBlO1xudmFyIEVudW1fVGV6b3NCYWxsb3RUeXBlID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFlheTogMCxcbiAgTmF5OiAxLFxuICBQYXNzOiAyXG59KTtcbmV4cG9ydHMuRW51bV9UZXpvc0JhbGxvdFR5cGUgPSBFbnVtX1Rlem9zQmFsbG90VHlwZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuZ2V0TG9nID0gZXhwb3J0cy5lbmFibGVMb2dCeVByZWZpeCA9IGV4cG9ydHMuZW5hYmxlTG9nID0gZXhwb3J0cy5pbml0TG9nID0gdm9pZCAwO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG52YXIgY29sb3JzID0ge1xuICAvLyBncmVlblxuICBEZXNjcmlwdG9yU3RyZWFtOiAnY29sb3I6ICM3N2FiNTknLFxuICBEZXZpY2VMaXN0OiAnY29sb3I6ICMzNjgwMmQnLFxuICBEZXZpY2U6ICdjb2xvcjogI2JhZGE1NScsXG4gIENvcmU6ICdjb2xvcjogI2M5ZGY4YScsXG4gIElGcmFtZTogJ2NvbG9yOiAjRkZGRkZGOyBiYWNrZ3JvdW5kOiAjZjRhNzQyOycsXG4gIFBvcHVwOiAnY29sb3I6ICNmNDhhMDAnXG59O1xudmFyIE1BWF9FTlRSSUVTID0gMTAwO1xuXG52YXIgTG9nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTG9nKHByZWZpeCwgZW5hYmxlZCkge1xuICAgIHRoaXMucHJlZml4ID0gcHJlZml4O1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMuY3NzID0gY29sb3JzW3ByZWZpeF0gfHwgJ2NvbG9yOiAjMDAwMDAwOyBiYWNrZ3JvdW5kOiAjRkZGRkZGOyc7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gTG9nLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkTWVzc2FnZSA9IGZ1bmN0aW9uIGFkZE1lc3NhZ2UobGV2ZWwsIHByZWZpeCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZXMucHVzaCh7XG4gICAgICBsZXZlbDogbGV2ZWwsXG4gICAgICBwcmVmaXg6IHByZWZpeCxcbiAgICAgIG1lc3NhZ2U6IGFyZ3MsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5tZXNzYWdlcy5sZW5ndGggPiBNQVhfRU5UUklFUykge1xuICAgICAgdGhpcy5tZXNzYWdlcy5zaGlmdCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ubG9nID0gZnVuY3Rpb24gbG9nKCkge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHRoaXMuYWRkTWVzc2FnZS5hcHBseSh0aGlzLCBbJ2xvZycsIHRoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdmFyIF9jb25zb2xlO1xuXG4gICAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIFt0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmVycm9yID0gZnVuY3Rpb24gZXJyb3IoKSB7XG4gICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgfVxuXG4gICAgdGhpcy5hZGRNZXNzYWdlLmFwcGx5KHRoaXMsIFsnZXJyb3InLCB0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHZhciBfY29uc29sZTI7XG5cbiAgICAgIChfY29uc29sZTIgPSBjb25zb2xlKS5lcnJvci5hcHBseShfY29uc29sZTIsIFt0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLndhcm4gPSBmdW5jdGlvbiB3YXJuKCkge1xuICAgIGZvciAodmFyIF9sZW40ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNCksIF9rZXk0ID0gMDsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgICAgYXJnc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgIH1cblxuICAgIHRoaXMuYWRkTWVzc2FnZS5hcHBseSh0aGlzLCBbJ3dhcm4nLCB0aGlzLnByZWZpeF0uY29uY2F0KGFyZ3MpKTtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHZhciBfY29uc29sZTM7XG5cbiAgICAgIChfY29uc29sZTMgPSBjb25zb2xlKS53YXJuLmFwcGx5KF9jb25zb2xlMywgW3RoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHtcbiAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgIGFyZ3NbX2tleTVdID0gYXJndW1lbnRzW19rZXk1XTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1lc3NhZ2UuYXBwbHkodGhpcywgWydkZWJ1ZycsIHRoaXMucHJlZml4XS5jb25jYXQoYXJncykpO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdmFyIF9jb25zb2xlNDtcblxuICAgICAgKF9jb25zb2xlNCA9IGNvbnNvbGUpLmxvZy5hcHBseShfY29uc29sZTQsIFtcIiVjXCIgKyB0aGlzLnByZWZpeCwgdGhpcy5jc3NdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBMb2c7XG59KCk7XG5cbnZhciBfbG9ncyA9IHt9O1xuXG52YXIgaW5pdExvZyA9IGZ1bmN0aW9uIGluaXRMb2cocHJlZml4LCBlbmFibGVkKSB7XG4gIHZhciBpbnN0YW5jZSA9IG5ldyBMb2cocHJlZml4LCAhIWVuYWJsZWQpO1xuICBfbG9nc1twcmVmaXhdID0gaW5zdGFuY2U7XG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbmV4cG9ydHMuaW5pdExvZyA9IGluaXRMb2c7XG5cbnZhciBlbmFibGVMb2cgPSBmdW5jdGlvbiBlbmFibGVMb2coZW5hYmxlZCkge1xuICBPYmplY3Qua2V5cyhfbG9ncykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgX2xvZ3Nba2V5XS5lbmFibGVkID0gZW5hYmxlZDtcbiAgfSk7XG59O1xuXG5leHBvcnRzLmVuYWJsZUxvZyA9IGVuYWJsZUxvZztcblxudmFyIGVuYWJsZUxvZ0J5UHJlZml4ID0gZnVuY3Rpb24gZW5hYmxlTG9nQnlQcmVmaXgocHJlZml4LCBlbmFibGVkKSB7XG4gIGlmIChfbG9nc1twcmVmaXhdKSB7XG4gICAgX2xvZ3NbcHJlZml4XS5lbmFibGVkID0gZW5hYmxlZDtcbiAgfVxufTtcblxuZXhwb3J0cy5lbmFibGVMb2dCeVByZWZpeCA9IGVuYWJsZUxvZ0J5UHJlZml4O1xuXG52YXIgZ2V0TG9nID0gZnVuY3Rpb24gZ2V0TG9nKCkge1xuICB2YXIgbG9ncyA9IFtdO1xuICBPYmplY3Qua2V5cyhfbG9ncykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgbG9ncyA9IGxvZ3MuY29uY2F0KF9sb2dzW2tleV0ubWVzc2FnZXMpO1xuICB9KTtcbiAgbG9ncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZXN0YW1wIC0gYi50aW1lc3RhbXA7XG4gIH0pO1xuICByZXR1cm4gbG9ncztcbn07XG5cbmV4cG9ydHMuZ2V0TG9nID0gZ2V0TG9nOyIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlID0gY3JlYXRlO1xuZXhwb3J0cy5jcmVhdGVBc3luYyA9IGNyZWF0ZUFzeW5jO1xuZXhwb3J0cy5yZXNvbHZlVGltZW91dFByb21pc2UgPSByZXNvbHZlVGltZW91dFByb21pc2U7XG5leHBvcnRzLnJlamVjdFRpbWVvdXRQcm9taXNlID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxuZnVuY3Rpb24gY3JlYXRlKGFyZywgZGV2aWNlKSB7XG4gIHZhciBsb2NhbFJlc29sdmUgPSBmdW5jdGlvbiBsb2NhbFJlc29sdmUoX3QpIHt9O1xuXG4gIHZhciBsb2NhbFJlamVjdCA9IGZ1bmN0aW9uIGxvY2FsUmVqZWN0KF9lKSB7fTtcblxuICB2YXIgaWQ7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG5cbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZiA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgbG9jYWxSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgbG9jYWxSZWplY3QgPSByZWplY3Q7XG5cbiAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMztcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiBhcmcoKTtcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA4O1xuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0W1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgICAgIHJlamVjdChfY29udGV4dC50MCk7XG5cbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykgaWQgPSBhcmc7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzMsIDhdXSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKSk7XG4gIHJldHVybiB7XG4gICAgaWQ6IGlkLFxuICAgIGRldmljZTogZGV2aWNlLFxuICAgIHJlc29sdmU6IGxvY2FsUmVzb2x2ZSxcbiAgICByZWplY3Q6IGxvY2FsUmVqZWN0LFxuICAgIHByb21pc2U6IHByb21pc2VcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQXN5bmMoaW5uZXJGbikge1xuICB2YXIgbG9jYWxSZXNvbHZlID0gZnVuY3Rpb24gbG9jYWxSZXNvbHZlKF90KSB7fTtcblxuICB2YXIgbG9jYWxSZWplY3QgPSBmdW5jdGlvbiBsb2NhbFJlamVjdChfZSkge307XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbG9jYWxSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICBsb2NhbFJlamVjdCA9IHJlamVjdDtcbiAgfSk7XG5cbiAgdmFyIGlubmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gaW5uZXJGbigpO1xuXG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTIpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbm5lcigpIHtcbiAgICAgIHJldHVybiBfcmVmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcblxuICByZXR1cm4ge1xuICAgIHJlc29sdmU6IGxvY2FsUmVzb2x2ZSxcbiAgICByZWplY3Q6IGxvY2FsUmVqZWN0LFxuICAgIHByb21pc2U6IHByb21pc2UsXG4gICAgcnVuOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBpbm5lcigpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVGltZW91dFByb21pc2UoZGVsYXksIHJlc3VsdCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICB9LCBkZWxheSk7XG4gIH0pO1xufVxuXG52YXIgcmVqZWN0VGltZW91dFByb21pc2UgPSBmdW5jdGlvbiByZWplY3RUaW1lb3V0UHJvbWlzZShkZWxheSwgZXJyb3IpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChlcnJvcik7XG4gICAgfSwgZGVsYXkpO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucmVqZWN0VGltZW91dFByb21pc2UgPSByZWplY3RUaW1lb3V0UHJvbWlzZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNsYXNzTmFtZSwgdXJsLCBvcmlnaW4pIHtcbiAgdmFyIHF1ZXJ5ID0gY2xhc3NOYW1lIHx8ICcudHJlem9yLXdlYnVzYi1idXR0b24nO1xuICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwocXVlcnkpO1xuICB2YXIgc3JjID0gdXJsICsgXCI/XCIgKyBEYXRlLm5vdygpO1xuICBidXR0b25zLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAoYi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaWZyYW1lJykubGVuZ3RoIDwgMSkge1xuICAgICAgdmFyIGJvdW5kcyA9IGIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgYnRuSWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBidG5JZnJhbWUuZnJhbWVCb3JkZXIgPSAnMCc7XG4gICAgICBidG5JZnJhbWUud2lkdGggPSBNYXRoLnJvdW5kKGJvdW5kcy53aWR0aCkgKyBcInB4XCI7XG4gICAgICBidG5JZnJhbWUuaGVpZ2h0ID0gTWF0aC5yb3VuZChib3VuZHMuaGVpZ2h0KSArIFwicHhcIjtcbiAgICAgIGJ0bklmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICBidG5JZnJhbWUuc3R5bGUudG9wID0gJzBweCc7XG4gICAgICBidG5JZnJhbWUuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgYnRuSWZyYW1lLnN0eWxlLnpJbmRleCA9ICcxJzsgLy8gYnRuSWZyYW1lLnN0eWxlLm9wYWNpdHkgPSAnMCc7IC8vIHRoaXMgbWFrZXMgY2xpY2sgaW1wb3NzaWJsZSBvbiBjcm9zcy1vcmlnaW5cblxuICAgICAgYnRuSWZyYW1lLnNldEF0dHJpYnV0ZSgnYWxsb3cnLCAndXNiJyk7XG4gICAgICBidG5JZnJhbWUuc2V0QXR0cmlidXRlKCdzY3JvbGxpbmcnLCAnbm8nKTtcblxuICAgICAgYnRuSWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYnRuSWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2Uoey8vIHN0eWxlOiBKU09OLnN0cmluZ2lmeSggd2luZG93LmdldENvbXB1dGVkU3R5bGUoYikgKSxcbiAgICAgICAgICAvLyBvdXRlcjogYi5vdXRlckhUTUwsXG4gICAgICAgICAgLy8gaW5uZXI6IGIuaW5uZXJIVE1MXG4gICAgICAgIH0sIG9yaWdpbik7XG4gICAgICB9O1xuXG4gICAgICBidG5JZnJhbWUuc3JjID0gc3JjOyAvLyBpbmplY3QgaWZyYW1lIGludG8gYnV0dG9uXG5cbiAgICAgIGIuYXBwZW5kKGJ0bklmcmFtZSk7XG4gICAgfVxuICB9KTtcbn07XG5cbnZhciBfZGVmYXVsdCA9IHJlbmRlcjtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gX2RlZmF1bHQ7IiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBVaW50OEFycmF5IGNyZWF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFzc2VkIEFycmF5TGlrZXNcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5TGlrZTxudW1iZXI+Pn0gYXJyYXlzXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aF1cbiAqL1xuZnVuY3Rpb24gY29uY2F0IChhcnJheXMsIGxlbmd0aCkge1xuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IGFycmF5cy5yZWR1Y2UoKGFjYywgY3VycikgPT4gYWNjICsgY3Vyci5sZW5ndGgsIDApXG4gIH1cblxuICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGxldCBvZmZzZXQgPSAwXG5cbiAgZm9yIChjb25zdCBhcnIgb2YgYXJyYXlzKSB7XG4gICAgb3V0cHV0LnNldChhcnIsIG9mZnNldClcbiAgICBvZmZzZXQgKz0gYXJyLmxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdFxuIiwiJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gcGFzc2VkIFVpbnQ4QXJyYXlzIGhhdmUgdGhlIHNhbWUgY29udGVudFxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBiXG4gKi9cbmZ1bmN0aW9uIGVxdWFscyAoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbHNcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGVuY29kaW5nOiBnZXRDb2RlYyB9ID0gcmVxdWlyZSgnbXVsdGliYXNlJylcbmNvbnN0IHV0ZjhFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKClcblxuLyoqXG4gKiBAdHlwZWRlZiB7X19pbXBvcnRfXygnbXVsdGliYXNlL3NyYy90eXBlcycpLkJhc2VOYW1lIHwgJ3V0ZjgnIHwgJ3V0Zi04JyB8ICdhc2NpaScgfCB1bmRlZmluZWR9IFN1cHBvcnRlZEVuY29kaW5nc1xuICovXG5cbi8qKlxuICogSW50ZXJwcmV0cyBlYWNoIGNoYXJhY3RlciBpbiBhIHN0cmluZyBhcyBhIGJ5dGUgYW5kXG4gKiByZXR1cm5zIGEgVWludDhBcnJheSBvZiB0aG9zZSBieXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIC0gVGhlIHN0cmluZyB0byB0dXJuIGludG8gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gYXNjaWlTdHJpbmdUb1VpbnQ4QXJyYXkgKHN0cmluZykge1xuICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICBhcnJheVtpXSA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG4gIH1cblxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgVWludDhBcnJheWAgZnJvbSB0aGUgcGFzc2VkIHN0cmluZ1xuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtTdXBwb3J0ZWRFbmNvZGluZ3N9IFtlbmNvZGluZz11dGY4XSAtIHV0ZjgsIGJhc2UxNiwgYmFzZTY0LCBiYXNlNjR1cmxwYWQsIGV0Y1xuICogQHJldHVybnMge1VpbnQ4QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcgPSAndXRmOCcpIHtcbiAgaWYgKGVuY29kaW5nID09PSAndXRmOCcgfHwgZW5jb2RpbmcgPT09ICd1dGYtOCcpIHtcbiAgICByZXR1cm4gdXRmOEVuY29kZXIuZW5jb2RlKHN0cmluZylcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiBhc2NpaVN0cmluZ1RvVWludDhBcnJheShzdHJpbmcpXG4gIH1cblxuICByZXR1cm4gZ2V0Q29kZWMoZW5jb2RpbmcpLmRlY29kZShzdHJpbmcpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnJvbVN0cmluZ1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgZW5jb2Rpbmc6IGdldENvZGVjIH0gPSByZXF1aXJlKCdtdWx0aWJhc2UnKVxuY29uc3QgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnKVxuXG4vKipcbiAqIEB0eXBlZGVmIHtfX2ltcG9ydF9fKCdtdWx0aWJhc2Uvc3JjL3R5cGVzJykuQmFzZU5hbWUgfCAndXRmOCcgfCAndXRmLTgnIHwgJ2FzY2lpJyB8IHVuZGVmaW5lZH0gU3VwcG9ydGVkRW5jb2RpbmdzXG4gKi9cblxuLyoqXG4gKiBUdXJucyBhIFVpbnQ4QXJyYXkgb2YgYnl0ZXMgaW50byBhIHN0cmluZyB3aXRoIGVhY2hcbiAqIGNoYXJhY3RlciBiZWluZyB0aGUgY2hhciBjb2RlIG9mIHRoZSBjb3JyZXNwb25kaW5nIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGFycmF5IC0gVGhlIGFycmF5IHRvIHR1cm4gaW50byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyAoYXJyYXkpIHtcbiAgbGV0IHN0cmluZyA9ICcnXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFycmF5W2ldKVxuICB9XG4gIHJldHVybiBzdHJpbmdcbn1cblxuLyoqXG4gKiBUdXJucyBhIGBVaW50OEFycmF5YCBpbnRvIGEgc3RyaW5nLlxuICpcbiAqIFN1cHBvcnRzIGB1dGY4YCwgYHV0Zi04YCBhbmQgYW55IGVuY29kaW5nIHN1cHBvcnRlZCBieSB0aGUgbXVsdGliYXNlIG1vZHVsZS5cbiAqXG4gKiBBbHNvIGBhc2NpaWAgd2hpY2ggaXMgc2ltaWxhciB0byBub2RlJ3MgJ2JpbmFyeScgZW5jb2RpbmcuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBhcnJheSAtIFRoZSBhcnJheSB0byB0dXJuIGludG8gYSBzdHJpbmdcbiAqIEBwYXJhbSB7U3VwcG9ydGVkRW5jb2RpbmdzfSBbZW5jb2Rpbmc9dXRmOF0gLSBUaGUgZW5jb2RpbmcgdG8gdXNlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZyAoYXJyYXksIGVuY29kaW5nID0gJ3V0ZjgnKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKSB7XG4gICAgcmV0dXJuIHV0ZjhEZWNvZGVyLmRlY29kZShhcnJheSlcbiAgfVxuXG4gIGlmIChlbmNvZGluZyA9PT0gJ2FzY2lpJykge1xuICAgIHJldHVybiB1aW50OEFycmF5VG9Bc2NpaVN0cmluZyhhcnJheSlcbiAgfVxuXG4gIHJldHVybiBnZXRDb2RlYyhlbmNvZGluZykuZW5jb2RlKGFycmF5KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlYWRcblxudmFyIE1TQiA9IDB4ODBcbiAgLCBSRVNUID0gMHg3RlxuXG5mdW5jdGlvbiByZWFkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciByZXMgICAgPSAwXG4gICAgLCBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgICwgc2hpZnQgID0gMFxuICAgICwgY291bnRlciA9IG9mZnNldFxuICAgICwgYlxuICAgICwgbCA9IGJ1Zi5sZW5ndGhcblxuICBkbyB7XG4gICAgaWYgKGNvdW50ZXIgPj0gbCkge1xuICAgICAgcmVhZC5ieXRlcyA9IDBcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdDb3VsZCBub3QgZGVjb2RlIHZhcmludCcpXG4gICAgfVxuICAgIGIgPSBidWZbY291bnRlcisrXVxuICAgIHJlcyArPSBzaGlmdCA8IDI4XG4gICAgICA/IChiICYgUkVTVCkgPDwgc2hpZnRcbiAgICAgIDogKGIgJiBSRVNUKSAqIE1hdGgucG93KDIsIHNoaWZ0KVxuICAgIHNoaWZ0ICs9IDdcbiAgfSB3aGlsZSAoYiA+PSBNU0IpXG5cbiAgcmVhZC5ieXRlcyA9IGNvdW50ZXIgLSBvZmZzZXRcblxuICByZXR1cm4gcmVzXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVuY29kZVxuXG52YXIgTVNCID0gMHg4MFxuICAsIFJFU1QgPSAweDdGXG4gICwgTVNCQUxMID0gflJFU1RcbiAgLCBJTlQgPSBNYXRoLnBvdygyLCAzMSlcblxuZnVuY3Rpb24gZW5jb2RlKG51bSwgb3V0LCBvZmZzZXQpIHtcbiAgb3V0ID0gb3V0IHx8IFtdXG4gIG9mZnNldCA9IG9mZnNldCB8fCAwXG4gIHZhciBvbGRPZmZzZXQgPSBvZmZzZXRcblxuICB3aGlsZShudW0gPj0gSU5UKSB7XG4gICAgb3V0W29mZnNldCsrXSA9IChudW0gJiAweEZGKSB8IE1TQlxuICAgIG51bSAvPSAxMjhcbiAgfVxuICB3aGlsZShudW0gJiBNU0JBTEwpIHtcbiAgICBvdXRbb2Zmc2V0KytdID0gKG51bSAmIDB4RkYpIHwgTVNCXG4gICAgbnVtID4+Pj0gN1xuICB9XG4gIG91dFtvZmZzZXRdID0gbnVtIHwgMFxuICBcbiAgZW5jb2RlLmJ5dGVzID0gb2Zmc2V0IC0gb2xkT2Zmc2V0ICsgMVxuICBcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZW5jb2RlOiByZXF1aXJlKCcuL2VuY29kZS5qcycpXG4gICwgZGVjb2RlOiByZXF1aXJlKCcuL2RlY29kZS5qcycpXG4gICwgZW5jb2RpbmdMZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoLmpzJylcbn1cbiIsIlxudmFyIE4xID0gTWF0aC5wb3coMiwgIDcpXG52YXIgTjIgPSBNYXRoLnBvdygyLCAxNClcbnZhciBOMyA9IE1hdGgucG93KDIsIDIxKVxudmFyIE40ID0gTWF0aC5wb3coMiwgMjgpXG52YXIgTjUgPSBNYXRoLnBvdygyLCAzNSlcbnZhciBONiA9IE1hdGgucG93KDIsIDQyKVxudmFyIE43ID0gTWF0aC5wb3coMiwgNDkpXG52YXIgTjggPSBNYXRoLnBvdygyLCA1NilcbnZhciBOOSA9IE1hdGgucG93KDIsIDYzKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gKFxuICAgIHZhbHVlIDwgTjEgPyAxXG4gIDogdmFsdWUgPCBOMiA/IDJcbiAgOiB2YWx1ZSA8IE4zID8gM1xuICA6IHZhbHVlIDwgTjQgPyA0XG4gIDogdmFsdWUgPCBONSA/IDVcbiAgOiB2YWx1ZSA8IE42ID8gNlxuICA6IHZhbHVlIDwgTjcgPyA3XG4gIDogdmFsdWUgPCBOOCA/IDhcbiAgOiB2YWx1ZSA8IE45ID8gOVxuICA6ICAgICAgICAgICAgICAxMFxuICApXG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5leHBvcnRzLlRleHRFbmNvZGVyID1cbiAgdHlwZW9mIFRleHRFbmNvZGVyICE9PSBcInVuZGVmaW5lZFwiID8gVGV4dEVuY29kZXIgOiByZXF1aXJlKFwidXRpbFwiKS5UZXh0RW5jb2RlclxuXG5leHBvcnRzLlRleHREZWNvZGVyID1cbiAgdHlwZW9mIFRleHREZWNvZGVyICE9PSBcInVuZGVmaW5lZFwiID8gVGV4dERlY29kZXIgOiByZXF1aXJlKFwidXRpbFwiKS5UZXh0RGVjb2RlclxuIiwiZXhwb3J0IGNvbnN0IEFVVE9fTE9DS19USU1FT1VUX0FMQVJNID0gJ0FVVE9fTE9DS19USU1FT1VUX0FMQVJNJztcbmV4cG9ydCBjb25zdCBNRVRBTUVUUklDU19GSU5BTElaRV9FVkVOVF9GUkFHTUVOVF9BTEFSTSA9XG4gICdNRVRBTUVUUklDU19GSU5BTElaRV9FVkVOVF9GUkFHTUVOVF9BTEFSTSc7XG4iLCJleHBvcnQgY29uc3QgUEhJU0hJTkdfTkVXX0lTU1VFX1VSTFMgPSB7XHJcbiAgTWV0YU1hc2s6ICdodHRwczovL2dpdGh1Yi5jb20vbWV0YW1hc2svZXRoLXBoaXNoaW5nLWRldGVjdC9pc3N1ZXMvbmV3JyxcclxuICBQaGlzaEZvcnQ6ICdodHRwczovL2dpdGh1Yi5jb20vcGhpc2hmb3J0L3BoaXNoZm9ydC1saXN0cy9pc3N1ZXMvbmV3JyxcclxufTtcclxuIiwiaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi90aW1lJztcclxuXHJcbmV4cG9ydCBjb25zdCBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTlNfUkVGUkVTSF9USU1FID0gU0VDT05EICogMTA7XHJcbmV4cG9ydCBjb25zdCBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTlNfREVBRExJTkUgPSAxODA7XHJcbmV4cG9ydCBjb25zdCBGQUxMQkFDS19TTUFSVF9UUkFOU0FDVElPTlNfTUFYX0ZFRV9NVUxUSVBMSUVSID0gMjtcclxuIiwiLyoqXG4gKiBAZmlsZSBUaGUgZW50cnkgcG9pbnQgZm9yIHRoZSB3ZWIgZXh0ZW5zaW9uIHNpbmdsZXRvbiBwcm9jZXNzLlxuICovXG5cbmltcG9ydCBlbmRPZlN0cmVhbSBmcm9tICdlbmQtb2Ytc3RyZWFtJztcbmltcG9ydCBwdW1wIGZyb20gJ3B1bXAnO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXN0cmVhbSc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCBicm93c2VyIGZyb20gJ3dlYmV4dGVuc2lvbi1wb2x5ZmlsbCc7XG5pbXBvcnQgeyBzdG9yZUFzU3RyZWFtIH0gZnJvbSAnQG1ldGFtYXNrL29icy1zdG9yZSc7XG5pbXBvcnQgUG9ydFN0cmVhbSBmcm9tICdleHRlbnNpb24tcG9ydC1zdHJlYW0nO1xuXG5pbXBvcnQgeyBldGhFcnJvcnMgfSBmcm9tICdldGgtcnBjLWVycm9ycyc7XG5pbXBvcnQge1xuICBFTlZJUk9OTUVOVF9UWVBFX1BPUFVQLFxuICBFTlZJUk9OTUVOVF9UWVBFX05PVElGSUNBVElPTixcbiAgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOLFxuICBQTEFURk9STV9GSVJFRk9YLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL2FwcCc7XG5pbXBvcnQgeyBTRUNPTkQgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHtcbiAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRSxcbiAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRV9TSUcsXG4gIEVWRU5ULFxuICBFVkVOVF9OQU1FUyxcbiAgVFJBSVRTLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL21ldGFtZXRyaWNzJztcbmltcG9ydCB7IGlzTWFuaWZlc3RWMyB9IGZyb20gJy4uLy4uL3NoYXJlZC9tb2R1bGVzL212My51dGlscyc7XG5pbXBvcnQgeyBtYXNrT2JqZWN0IH0gZnJvbSAnLi4vLi4vc2hhcmVkL21vZHVsZXMvb2JqZWN0LnV0aWxzJztcbmltcG9ydCBtaWdyYXRpb25zIGZyb20gJy4vbWlncmF0aW9ucyc7XG5pbXBvcnQgTWlncmF0b3IgZnJvbSAnLi9saWIvbWlncmF0b3InO1xuaW1wb3J0IEV4dGVuc2lvblBsYXRmb3JtIGZyb20gJy4vcGxhdGZvcm1zL2V4dGVuc2lvbic7XG5pbXBvcnQgTG9jYWxTdG9yZSBmcm9tICcuL2xpYi9sb2NhbC1zdG9yZSc7XG5pbXBvcnQgUmVhZE9ubHlOZXR3b3JrU3RvcmUgZnJvbSAnLi9saWIvbmV0d29yay1zdG9yZSc7XG5pbXBvcnQgeyBTRU5UUllfU1RBVEUgfSBmcm9tICcuL2xpYi9zZXR1cFNlbnRyeSc7XG5cbmltcG9ydCBjcmVhdGVTdHJlYW1TaW5rIGZyb20gJy4vbGliL2NyZWF0ZVN0cmVhbVNpbmsnO1xuaW1wb3J0IE5vdGlmaWNhdGlvbk1hbmFnZXIsIHtcbiAgTk9USUZJQ0FUSU9OX01BTkFHRVJfRVZFTlRTLFxufSBmcm9tICcuL2xpYi9ub3RpZmljYXRpb24tbWFuYWdlcic7XG5pbXBvcnQgTWV0YW1hc2tDb250cm9sbGVyLCB7XG4gIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLFxufSBmcm9tICcuL21ldGFtYXNrLWNvbnRyb2xsZXInO1xuaW1wb3J0IHJhd0ZpcnN0VGltZVN0YXRlIGZyb20gJy4vZmlyc3QtdGltZS1zdGF0ZSc7XG5pbXBvcnQgZ2V0Rmlyc3RQcmVmZXJyZWRMYW5nQ29kZSBmcm9tICcuL2xpYi9nZXQtZmlyc3QtcHJlZmVycmVkLWxhbmctY29kZSc7XG5pbXBvcnQgZ2V0T2JqU3RydWN0dXJlIGZyb20gJy4vbGliL2dldE9ialN0cnVjdHVyZSc7XG5pbXBvcnQgc2V0dXBFbnNJcGZzUmVzb2x2ZXIgZnJvbSAnLi9saWIvZW5zLWlwZnMvc2V0dXAnO1xuaW1wb3J0IHsgZ2V0UGxhdGZvcm0gfSBmcm9tICcuL2xpYi91dGlsJztcbi8qIGVzbGludC1lbmFibGUgaW1wb3J0L2ZpcnN0ICovXG5cbmNvbnN0IHsgc2VudHJ5IH0gPSBnbG9iYWw7XG5jb25zdCBmaXJzdFRpbWVTdGF0ZSA9IHsgLi4ucmF3Rmlyc3RUaW1lU3RhdGUgfTtcblxuY29uc3QgbWV0YW1hc2tJbnRlcm5hbFByb2Nlc3NIYXNoID0ge1xuICBbRU5WSVJPTk1FTlRfVFlQRV9QT1BVUF06IHRydWUsXG4gIFtFTlZJUk9OTUVOVF9UWVBFX05PVElGSUNBVElPTl06IHRydWUsXG4gIFtFTlZJUk9OTUVOVF9UWVBFX0ZVTExTQ1JFRU5dOiB0cnVlLFxufTtcblxuY29uc3QgbWV0YW1hc2tCbG9ja2VkUG9ydHMgPSBbJ3RyZXpvci1jb25uZWN0J107XG5cbmxvZy5zZXREZWZhdWx0TGV2ZWwocHJvY2Vzcy5lbnYuTUVUQU1BU0tfREVCVUcgPyAnZGVidWcnIDogJ2luZm8nKTtcblxuY29uc3QgcGxhdGZvcm0gPSBuZXcgRXh0ZW5zaW9uUGxhdGZvcm0oKTtcblxuY29uc3Qgbm90aWZpY2F0aW9uTWFuYWdlciA9IG5ldyBOb3RpZmljYXRpb25NYW5hZ2VyKCk7XG5nbG9iYWwuTUVUQU1BU0tfTk9USUZJRVIgPSBub3RpZmljYXRpb25NYW5hZ2VyO1xuXG5sZXQgcG9wdXBJc09wZW4gPSBmYWxzZTtcbmxldCBub3RpZmljYXRpb25Jc09wZW4gPSBmYWxzZTtcbmxldCB1aUlzVHJpZ2dlcmluZyA9IGZhbHNlO1xuY29uc3Qgb3Blbk1ldGFtYXNrVGFic0lEcyA9IHt9O1xuY29uc3QgcmVxdWVzdEFjY291bnRUYWJJZHMgPSB7fTtcbmxldCBjb250cm9sbGVyO1xuXG4vLyBzdGF0ZSBwZXJzaXN0ZW5jZVxuY29uc3QgaW5UZXN0ID0gcHJvY2Vzcy5lbnYuSU5fVEVTVDtcbmNvbnN0IGxvY2FsU3RvcmUgPSBpblRlc3QgPyBuZXcgUmVhZE9ubHlOZXR3b3JrU3RvcmUoKSA6IG5ldyBMb2NhbFN0b3JlKCk7XG5sZXQgdmVyc2lvbmVkRGF0YTtcblxuaWYgKGluVGVzdCB8fCBwcm9jZXNzLmVudi5NRVRBTUFTS19ERUJVRykge1xuICBnbG9iYWwubWV0YW1hc2tHZXRTdGF0ZSA9IGxvY2FsU3RvcmUuZ2V0LmJpbmQobG9jYWxTdG9yZSk7XG59XG5cbmNvbnN0IHBoaXNoaW5nUGFnZVVybCA9IG5ldyBVUkwocHJvY2Vzcy5lbnYuUEhJU0hJTkdfV0FSTklOR19QQUdFX1VSTCk7XG5cbmNvbnN0IE9ORV9TRUNPTkRfSU5fTUlMTElTRUNPTkRTID0gMV8wMDA7XG4vLyBUaW1lb3V0IGZvciBpbml0aWFsaXppbmcgcGhpc2hpbmcgd2FybmluZyBwYWdlLlxuY29uc3QgUEhJU0hJTkdfV0FSTklOR19QQUdFX1RJTUVPVVQgPSBPTkVfU0VDT05EX0lOX01JTExJU0VDT05EUztcblxuY29uc3QgQUNLX0tFRVBfQUxJVkVfTUVTU0FHRSA9ICdBQ0tfS0VFUF9BTElWRV9NRVNTQUdFJztcbmNvbnN0IFdPUktFUl9LRUVQX0FMSVZFX01FU1NBR0UgPSAnV09SS0VSX0tFRVBfQUxJVkVfTUVTU0FHRSc7XG5cbi8qKlxuICogSW4gY2FzZSBvZiBNVjMgd2UgYXR0YWNoIGEgXCJvbkNvbm5lY3RcIiBldmVudCBsaXN0ZW5lciBhcyBzb29uIGFzIHRoZSBhcHBsaWNhdGlvbiBpcyBpbml0aWFsaXNlZC5cbiAqIFJlYXNvbiBpcyB0aGF0IGluIGNhc2Ugb2YgTVYzIGEgZGVsYXkgaW4gZG9pbmcgdGhpcyB3YXMgcmVzdWx0aW5nIGluIG1pc3NpbmcgZmlyc3QgY29ubmVjdCBldmVudCBhZnRlciBzZXJ2aWNlIHdvcmtlciBpcyByZS1hY3RpdmF0ZWQuXG4gKi9cblxuY29uc3QgaW5pdEFwcCA9IGFzeW5jIChyZW1vdGVQb3J0KSA9PiB7XG4gIGJyb3dzZXIucnVudGltZS5vbkNvbm5lY3QucmVtb3ZlTGlzdGVuZXIoaW5pdEFwcCk7XG4gIGF3YWl0IGluaXRpYWxpemUocmVtb3RlUG9ydCk7XG4gIGxvZy5pbmZvKCdNZXRhTWFzayBpbml0aWFsaXphdGlvbiBjb21wbGV0ZS4nKTtcbn07XG5cbmlmIChpc01hbmlmZXN0VjMpIHtcbiAgYnJvd3Nlci5ydW50aW1lLm9uQ29ubmVjdC5hZGRMaXN0ZW5lcihpbml0QXBwKTtcbn0gZWxzZSB7XG4gIC8vIGluaXRpYWxpemF0aW9uIGZsb3dcbiAgaW5pdGlhbGl6ZSgpLmNhdGNoKGxvZy5lcnJvcik7XG59XG5cbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbicpLlRyYW5zYWN0aW9uTWV0YX0gVHJhbnNhY3Rpb25NZXRhXG4gKi9cblxuLyoqXG4gKiBUaGUgZGF0YSBlbWl0dGVkIGZyb20gdGhlIE1ldGFNYXNrQ29udHJvbGxlci5zdG9yZSBFdmVudEVtaXR0ZXIsIGFsc28gdXNlZCB0byBpbml0aWFsaXplIHRoZSBNZXRhTWFza0NvbnRyb2xsZXIuIEF2YWlsYWJsZSBpbiBVSSBvbiBSZWFjdCBzdGF0ZSBhcyBzdGF0ZS5tZXRhbWFzay5cbiAqXG4gKiBAdHlwZWRlZiBNZXRhTWFza1N0YXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSW5pdGlhbGl6ZWQgLSBXaGV0aGVyIHRoZSBmaXJzdCB2YXVsdCBoYXMgYmVlbiBjcmVhdGVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc1VubG9ja2VkIC0gV2hldGhlciB0aGUgdmF1bHQgaXMgY3VycmVudGx5IGRlY3J5cHRlZCBhbmQgYWNjb3VudHMgYXJlIGF2YWlsYWJsZSBmb3Igc2VsZWN0aW9uLlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0FjY291bnRNZW51T3BlbiAtIFJlcHJlc2VudHMgd2hldGhlciB0aGUgbWFpbiBhY2NvdW50IHNlbGVjdGlvbiBVSSBpcyBjdXJyZW50bHkgZGlzcGxheWVkLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGlkZW50aXRpZXMgLSBBbiBvYmplY3QgbWF0Y2hpbmcgbG93ZXItY2FzZSBoZXggYWRkcmVzc2VzIHRvIElkZW50aXR5IG9iamVjdHMgd2l0aCBcImFkZHJlc3NcIiBhbmQgXCJuYW1lXCIgKG5pY2tuYW1lKSBrZXlzLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHVuYXBwcm92ZWRUeHMgLSBBbiBvYmplY3QgbWFwcGluZyB0cmFuc2FjdGlvbiBoYXNoZXMgdG8gdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMuXG4gKiBAcHJvcGVydHkge0FycmF5fSBmcmVxdWVudFJwY0xpc3QgLSBBIGxpc3Qgb2YgZnJlcXVlbnRseSB1c2VkIFJQQ3MsIGluY2x1ZGluZyBjdXN0b20gdXNlci1wcm92aWRlZCBvbmVzLlxuICogQHByb3BlcnR5IHtBcnJheX0gYWRkcmVzc0Jvb2sgLSBBIGxpc3Qgb2YgcHJldmlvdXNseSBzZW50IHRvIGFkZHJlc3Nlcy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb250cmFjdEV4Y2hhbmdlUmF0ZXMgLSBJbmZvIGFib3V0IGN1cnJlbnQgdG9rZW4gcHJpY2VzLlxuICogQHByb3BlcnR5IHtBcnJheX0gdG9rZW5zIC0gVG9rZW5zIGhlbGQgYnkgdGhlIGN1cnJlbnQgdXNlciwgaW5jbHVkaW5nIHRoZWlyIGJhbGFuY2VzLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHNlbmQgLSBUT0RPOiBEb2N1bWVudFxuICogQHByb3BlcnR5IHtib29sZWFufSB1c2VCbG9ja2llIC0gSW5kaWNhdGVzIHByZWZlcnJlZCB1c2VyIGlkZW50aWNvbiBmb3JtYXQuIFRydWUgZm9yIGJsb2NraWUsIGZhbHNlIGZvciBKYXp6aWNvbi5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBmZWF0dXJlRmxhZ3MgLSBBbiBvYmplY3QgZm9yIG9wdGlvbmFsIGZlYXR1cmUgZmxhZ3MuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHdlbGNvbWVTY3JlZW4gLSBUcnVlIGlmIHdlbGNvbWUgc2NyZWVuIHNob3VsZCBiZSBzaG93bi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50TG9jYWxlIC0gQSBsb2NhbGUgc3RyaW5nIG1hdGNoaW5nIHRoZSB1c2VyJ3MgcHJlZmVycmVkIGRpc3BsYXkgbGFuZ3VhZ2UuXG4gKiBAcHJvcGVydHkge29iamVjdH0gcHJvdmlkZXIgLSBUaGUgY3VycmVudCBzZWxlY3RlZCBuZXR3b3JrIHByb3ZpZGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3ZpZGVyLnJwY1VybCAtIFRoZSBhZGRyZXNzIGZvciB0aGUgUlBDIEFQSSwgaWYgdXNpbmcgYW4gUlBDIEFQSS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBwcm92aWRlci50eXBlIC0gQW4gaWRlbnRpZmllciBmb3IgdGhlIHR5cGUgb2YgbmV0d29yayBzZWxlY3RlZCwgYWxsb3dzIE1ldGFNYXNrIHRvIHVzZSBjdXN0b20gcHJvdmlkZXIgc3RyYXRlZ2llcyBmb3Iga25vd24gbmV0d29ya3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmV0d29yayAtIEEgc3RyaW5naWZpZWQgbnVtYmVyIG9mIHRoZSBjdXJyZW50IG5ldHdvcmsgSUQuXG4gKiBAcHJvcGVydHkge29iamVjdH0gYWNjb3VudHMgLSBBbiBvYmplY3QgbWFwcGluZyBsb3dlci1jYXNlIGhleCBhZGRyZXNzZXMgdG8gb2JqZWN0cyB3aXRoIFwiYmFsYW5jZVwiIGFuZCBcImFkZHJlc3NcIiBrZXlzLCBib3RoIHN0b3JpbmcgaGV4IHN0cmluZyB2YWx1ZXMuXG4gKiBAcHJvcGVydHkge2hleH0gY3VycmVudEJsb2NrR2FzTGltaXQgLSBUaGUgbW9zdCByZWNlbnRseSBzZWVuIGJsb2NrIGdhcyBsaW1pdCwgaW4gYSBsb3dlciBjYXNlIGhleCBwcmVmaXhlZCBzdHJpbmcuXG4gKiBAcHJvcGVydHkge1RyYW5zYWN0aW9uTWV0YVtdfSBjdXJyZW50TmV0d29ya1R4TGlzdCAtIEFuIGFycmF5IG9mIHRyYW5zYWN0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBuZXR3b3JrLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHVuYXBwcm92ZWRNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZE1zZ0NvdW50IC0gVGhlIG51bWJlciBvZiBtZXNzYWdlcyBpbiB1bmFwcHJvdmVkTXNncy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB1bmFwcHJvdmVkUGVyc29uYWxNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZFBlcnNvbmFsTXNnQ291bnQgLSBUaGUgbnVtYmVyIG9mIG1lc3NhZ2VzIGluIHVuYXBwcm92ZWRQZXJzb25hbE1zZ3MuXG4gKiBAcHJvcGVydHkge29iamVjdH0gdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gRW5jcnlwdGlvblB1YmxpY0tleU1zZ3MuXG4gKiBAcHJvcGVydHkge29iamVjdH0gdW5hcHByb3ZlZERlY3J5cHRNc2dzIC0gQW4gb2JqZWN0IG9mIG1lc3NhZ2VzIHBlbmRpbmcgYXBwcm92YWwsIG1hcHBpbmcgYSB1bmlxdWUgSUQgdG8gdGhlIG9wdGlvbnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hcHByb3ZlZERlY3J5cHRNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gdW5hcHByb3ZlZERlY3J5cHRNc2dzLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHVuYXBwcm92ZWRUeXBlZE1zZ3MgLSBBbiBvYmplY3Qgb2YgbWVzc2FnZXMgcGVuZGluZyBhcHByb3ZhbCwgbWFwcGluZyBhIHVuaXF1ZSBJRCB0byB0aGUgb3B0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1bmFwcHJvdmVkVHlwZWRNc2dDb3VudCAtIFRoZSBudW1iZXIgb2YgbWVzc2FnZXMgaW4gdW5hcHByb3ZlZFR5cGVkTXNncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwZW5kaW5nQXBwcm92YWxDb3VudCAtIFRoZSBudW1iZXIgb2YgcGVuZGluZyByZXF1ZXN0IGluIHRoZSBhcHByb3ZhbCBjb250cm9sbGVyLlxuICogQHByb3BlcnR5IHtzdHJpbmdbXX0ga2V5cmluZ1R5cGVzIC0gQW4gYXJyYXkgb2YgdW5pcXVlIGtleXJpbmcgaWRlbnRpZnlpbmcgc3RyaW5ncywgcmVwcmVzZW50aW5nIGF2YWlsYWJsZSBzdHJhdGVnaWVzIGZvciBjcmVhdGluZyBhY2NvdW50cy5cbiAqIEBwcm9wZXJ0eSB7S2V5cmluZ1tdfSBrZXlyaW5ncyAtIEFuIGFycmF5IG9mIGtleXJpbmcgZGVzY3JpcHRpb25zLCBzdW1tYXJpemluZyB0aGUgYWNjb3VudHMgdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB1c2UsIGFuZCB3aGF0IGtleXJpbmdzIHRoZXkgYmVsb25nIHRvLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNlbGVjdGVkQWRkcmVzcyAtIEEgbG93ZXIgY2FzZSBoZXggc3RyaW5nIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50Q3VycmVuY3kgLSBBIHN0cmluZyBpZGVudGlmeWluZyB0aGUgdXNlcidzIHByZWZlcnJlZCBkaXNwbGF5IGN1cnJlbmN5LCBmb3IgdXNlIGluIHNob3dpbmcgY29udmVyc2lvbiByYXRlcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjb252ZXJzaW9uUmF0ZSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBleGNoYW5nZSByYXRlIGZyb20gdGhlIHVzZXIncyBwcmVmZXJyZWQgY3VycmVuY3kgdG8gRXRoZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gY29udmVyc2lvbkRhdGUgLSBBIHVuaXggZXBvY2ggZGF0ZSAobXMpIGZvciB0aGUgdGltZSB0aGUgY3VycmVudCBjb252ZXJzaW9uIHJhdGUgd2FzIGxhc3QgcmV0cmlldmVkLlxuICogQHByb3BlcnR5IHtib29sZWFufSBmb3Jnb3R0ZW5QYXNzd29yZCAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBoYXMgaW5pdGlhdGVkIHRoZSBwYXNzd29yZCByZWNvdmVyeSBzY3JlZW4sIGlzIHJlY292ZXJpbmcgZnJvbSBzZWVkIHBocmFzZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFZlcnNpb25lZERhdGFcbiAqIEBwcm9wZXJ0eSB7TWV0YU1hc2tTdGF0ZX0gZGF0YSAtIFRoZSBkYXRhIGVtaXR0ZWQgZnJvbSBNZXRhTWFzayBjb250cm9sbGVyLCBvciB1c2VkIHRvIGluaXRpYWxpemUgaXQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdmVyc2lvbiAtIFRoZSBsYXRlc3QgbWlncmF0aW9uIHZlcnNpb24gdGhhdCBoYXMgYmVlbiBydW4uXG4gKi9cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgTWV0YU1hc2sgY29udHJvbGxlciwgYW5kIHNldHMgdXAgYWxsIHBsYXRmb3JtIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBvcnQgLSByZW1vdGUgYXBwbGljYXRpb24gcG9ydCBjb25uZWN0aW5nIHRvIGV4dGVuc2lvbi5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSBTZXR1cCBjb21wbGV0ZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZShyZW1vdGVQb3J0KSB7XG4gIGNvbnN0IGluaXRTdGF0ZSA9IGF3YWl0IGxvYWRTdGF0ZUZyb21QZXJzaXN0ZW5jZSgpO1xuICBjb25zdCBpbml0TGFuZ0NvZGUgPSBhd2FpdCBnZXRGaXJzdFByZWZlcnJlZExhbmdDb2RlKCk7XG4gIHNldHVwQ29udHJvbGxlcihpbml0U3RhdGUsIGluaXRMYW5nQ29kZSwgcmVtb3RlUG9ydCk7XG4gIGlmICghaXNNYW5pZmVzdFYzKSB7XG4gICAgYXdhaXQgbG9hZFBoaXNoaW5nV2FybmluZ1BhZ2UoKTtcbiAgfVxuICBsb2cuaW5mbygnTWV0YU1hc2sgaW5pdGlhbGl6YXRpb24gY29tcGxldGUuJyk7XG59XG5cbi8qKlxuICogQW4gZXJyb3IgdGhyb3duIGlmIHRoZSBwaGlzaGluZyB3YXJuaW5nIHBhZ2UgdGFrZXMgdG9vIGxvbmcgdG8gbG9hZC5cbiAqL1xuY2xhc3MgUGhpc2hpbmdXYXJuaW5nUGFnZVRpbWVvdXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoJ1RpbWVvdXQgZmFpbGVkJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBMb2FkIHRoZSBwaGlzaGluZyB3YXJuaW5nIHBhZ2UgdGVtcG9yYXJpbHkgdG8gZW5zdXJlIHRoZSBzZXJ2aWNlXG4gKiB3b3JrZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCwgc28gdGhhdCB0aGUgd2FybmluZyBwYWdlIHdvcmtzIG9mZmxpbmUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRQaGlzaGluZ1dhcm5pbmdQYWdlKCkge1xuICBsZXQgaWZyYW1lO1xuICB0cnkge1xuICAgIGNvbnN0IGV4dGVuc2lvblN0YXJ0dXBQaGlzaGluZ1BhZ2VVcmwgPSBuZXcgVVJMKFxuICAgICAgcHJvY2Vzcy5lbnYuUEhJU0hJTkdfV0FSTklOR19QQUdFX1VSTCxcbiAgICApO1xuICAgIC8vIFRoZSBgZXh0ZW5zaW9uU3RhcnR1cGAgaGFzaCBzaWduYWxzIHRvIHRoZSBwaGlzaGluZyB3YXJuaW5nIHBhZ2UgdGhhdCBpdCBzaG91bGQgbm90IGJvdGhlclxuICAgIC8vIHNldHRpbmcgdXAgc3RyZWFtcyBmb3IgdXNlciBpbnRlcmFjdGlvbi4gT3RoZXJ3aXNlIHRoaXMgcGFnZSBsb2FkIHdvdWxkIGNhdXNlIGEgY29uc29sZVxuICAgIC8vIGVycm9yLlxuICAgIGV4dGVuc2lvblN0YXJ0dXBQaGlzaGluZ1BhZ2VVcmwuaGFzaCA9ICcjZXh0ZW5zaW9uU3RhcnR1cCc7XG5cbiAgICBpZnJhbWUgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnc3JjJywgZXh0ZW5zaW9uU3RhcnR1cFBoaXNoaW5nUGFnZVVybC5ocmVmKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzYW5kYm94JywgJ2FsbG93LXNjcmlwdHMgYWxsb3ctc2FtZS1vcmlnaW4nKTtcblxuICAgIC8vIENyZWF0ZSBcImRlZmVycmVkIFByb21pc2VcIiB0byBhbGxvdyBwYXNzaW5nIHJlc29sdmUvcmVqZWN0IHRvIGV2ZW50IGhhbmRsZXJzXG4gICAgbGV0IGRlZmVycmVkUmVzb2x2ZTtcbiAgICBsZXQgZGVmZXJyZWRSZWplY3Q7XG4gICAgY29uc3QgbG9hZENvbXBsZXRlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZGVmZXJyZWRSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIGRlZmVycmVkUmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuXG4gICAgLy8gVGhlIGxvYWQgZXZlbnQgaXMgZW1pdHRlZCBvbmNlIGxvYWRpbmcgaGFzIGNvbXBsZXRlZCwgZXZlbiBpZiB0aGUgbG9hZGluZyBmYWlsZWQuXG4gICAgLy8gSWYgbG9hZGluZyBmYWlsZWQgd2UgY2FuJ3QgZG8gYW55dGhpbmcgYWJvdXQgaXQsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2hlY2suXG4gICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkZWZlcnJlZFJlc29sdmUpO1xuXG4gICAgLy8gVGhpcyBzdGVwIGluaXRpYXRlcyB0aGUgcGFnZSBsb2FkaW5nLlxuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgICAvLyBUaGlzIHRpbWVvdXQgZW5zdXJlcyB0aGF0IHRoaXMgaWZyYW1lIGdldHMgY2xlYW5lZCB1cCBpbiBhIHJlYXNvbmFibGVcbiAgICAvLyB0aW1lZnJhbWUsIGFuZCBlbnN1cmVzIHRoYXQgdGhlIFwiaW5pdGlhbGl6YXRpb24gY29tcGxldGVcIiBtZXNzYWdlXG4gICAgLy8gZG9lc24ndCBnZXQgZGVsYXllZCB0b28gbG9uZy5cbiAgICBzZXRUaW1lb3V0KFxuICAgICAgKCkgPT4gZGVmZXJyZWRSZWplY3QobmV3IFBoaXNoaW5nV2FybmluZ1BhZ2VUaW1lb3V0RXJyb3IoKSksXG4gICAgICBQSElTSElOR19XQVJOSU5HX1BBR0VfVElNRU9VVCxcbiAgICApO1xuICAgIGF3YWl0IGxvYWRDb21wbGV0ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBQaGlzaGluZ1dhcm5pbmdQYWdlVGltZW91dEVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICdQaGlzaGluZyB3YXJuaW5nIHBhZ2UgdGltZW91dDsgcGFnZSBub3QgZ3VhcmFuZXRlZWQgdG8gd29yayBvZmZsaW5lLicsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gaW5pdGlhbGl6ZSBwaGlzaGluZyB3YXJuaW5nIHBhZ2UnLCBlcnJvcik7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIGlmIChpZnJhbWUpIHtcbiAgICAgIGlmcmFtZS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuLy9cbi8vIFN0YXRlIGFuZCBQZXJzaXN0ZW5jZVxuLy9cblxuLyoqXG4gKiBMb2FkcyBhbnkgc3RvcmVkIGRhdGEsIHByaW9yaXRpemluZyB0aGUgbGF0ZXN0IHN0b3JhZ2Ugc3RyYXRlZ3kuXG4gKiBNaWdyYXRlcyB0aGF0IGRhdGEgc2NoZW1hIGluIGNhc2UgaXQgd2FzIGxhc3QgbG9hZGVkIG9uIGFuIG9sZGVyIHZlcnNpb24uXG4gKlxuICogQHJldHVybnMge1Byb21pc2U8TWV0YU1hc2tTdGF0ZT59IExhc3QgZGF0YSBlbWl0dGVkIGZyb20gcHJldmlvdXMgaW5zdGFuY2Ugb2YgTWV0YU1hc2suXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvYWRTdGF0ZUZyb21QZXJzaXN0ZW5jZSgpIHtcbiAgLy8gbWlncmF0aW9uc1xuICBjb25zdCBtaWdyYXRvciA9IG5ldyBNaWdyYXRvcih7IG1pZ3JhdGlvbnMgfSk7XG4gIG1pZ3JhdG9yLm9uKCdlcnJvcicsIGNvbnNvbGUud2Fybik7XG5cbiAgLy8gcmVhZCBmcm9tIGRpc2tcbiAgLy8gZmlyc3QgZnJvbSBwcmVmZXJyZWQsIGFzeW5jIEFQSTpcbiAgdmVyc2lvbmVkRGF0YSA9XG4gICAgKGF3YWl0IGxvY2FsU3RvcmUuZ2V0KCkpIHx8IG1pZ3JhdG9yLmdlbmVyYXRlSW5pdGlhbFN0YXRlKGZpcnN0VGltZVN0YXRlKTtcblxuICAvLyBjaGVjayBpZiBzb21laG93IHN0YXRlIGlzIGVtcHR5XG4gIC8vIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiBidXQgbmV3IGVycm9yIHJlcG9ydGluZyBzdWdnZXN0cyB0aGF0IGl0IGhhc1xuICAvLyBmb3IgYSBzbWFsbCBudW1iZXIgb2YgdXNlcnNcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21ldGFtYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9pc3N1ZXMvMzkxOVxuICBpZiAodmVyc2lvbmVkRGF0YSAmJiAhdmVyc2lvbmVkRGF0YS5kYXRhKSB7XG4gICAgLy8gdW5hYmxlIHRvIHJlY292ZXIsIGNsZWFyIHN0YXRlXG4gICAgdmVyc2lvbmVkRGF0YSA9IG1pZ3JhdG9yLmdlbmVyYXRlSW5pdGlhbFN0YXRlKGZpcnN0VGltZVN0YXRlKTtcbiAgICBzZW50cnkuY2FwdHVyZU1lc3NhZ2UoJ01ldGFNYXNrIC0gRW1wdHkgdmF1bHQgZm91bmQgLSB1bmFibGUgdG8gcmVjb3ZlcicpO1xuICB9XG5cbiAgLy8gcmVwb3J0IG1pZ3JhdGlvbiBlcnJvcnMgdG8gc2VudHJ5XG4gIG1pZ3JhdG9yLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICAvLyBnZXQgdmF1bHQgc3RydWN0dXJlIHdpdGhvdXQgc2VjcmV0c1xuICAgIGNvbnN0IHZhdWx0U3RydWN0dXJlID0gZ2V0T2JqU3RydWN0dXJlKHZlcnNpb25lZERhdGEpO1xuICAgIHNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKGVyciwge1xuICAgICAgLy8gXCJleHRyYVwiIGtleSBpcyByZXF1aXJlZCBieSBTZW50cnlcbiAgICAgIGV4dHJhOiB7IHZhdWx0U3RydWN0dXJlIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIG1pZ3JhdGUgZGF0YVxuICB2ZXJzaW9uZWREYXRhID0gYXdhaXQgbWlncmF0b3IubWlncmF0ZURhdGEodmVyc2lvbmVkRGF0YSk7XG4gIGlmICghdmVyc2lvbmVkRGF0YSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTWV0YU1hc2sgLSBtaWdyYXRvciByZXR1cm5lZCB1bmRlZmluZWQnKTtcbiAgfVxuICAvLyB0aGlzIGluaXRpYWxpemVzIHRoZSBtZXRhL3ZlcnNpb24gZGF0YSBhcyBhIGNsYXNzIHZhcmlhYmxlIHRvIGJlIHVzZWQgZm9yIGZ1dHVyZSB3cml0ZXNcbiAgbG9jYWxTdG9yZS5zZXRNZXRhZGF0YSh2ZXJzaW9uZWREYXRhLm1ldGEpO1xuXG4gIC8vIHdyaXRlIHRvIGRpc2tcbiAgbG9jYWxTdG9yZS5zZXQodmVyc2lvbmVkRGF0YS5kYXRhKTtcblxuICAvLyByZXR1cm4ganVzdCB0aGUgZGF0YVxuICByZXR1cm4gdmVyc2lvbmVkRGF0YS5kYXRhO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRoZSBNZXRhTWFzayBDb250cm9sbGVyIHdpdGggYW55IGluaXRpYWwgc3RhdGUgYW5kIGRlZmF1bHQgbGFuZ3VhZ2UuXG4gKiBDb25maWd1cmVzIHBsYXRmb3JtLXNwZWNpZmljIGVycm9yIHJlcG9ydGluZyBzdHJhdGVneS5cbiAqIFN0cmVhbXMgZW1pdHRlZCBzdGF0ZSB1cGRhdGVzIHRvIHBsYXRmb3JtLXNwZWNpZmljIHN0b3JhZ2Ugc3RyYXRlZ3kuXG4gKiBDcmVhdGVzIHBsYXRmb3JtIGxpc3RlbmVycyBmb3IgbmV3IERhcHBzL0NvbnRleHRzLCBhbmQgc2V0cyB1cCB0aGVpciBkYXRhIGNvbm5lY3Rpb25zIHRvIHRoZSBjb250cm9sbGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbml0U3RhdGUgLSBUaGUgaW5pdGlhbCBzdGF0ZSB0byBzdGFydCB0aGUgY29udHJvbGxlciB3aXRoLCBtYXRjaGVzIHRoZSBzdGF0ZSB0aGF0IGlzIGVtaXR0ZWQgZnJvbSB0aGUgY29udHJvbGxlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpbml0TGFuZ0NvZGUgLSBUaGUgcmVnaW9uIGNvZGUgZm9yIHRoZSBsYW5ndWFnZSBwcmVmZXJyZWQgYnkgdGhlIGN1cnJlbnQgdXNlci5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVTb3VyY2VQb3J0IC0gcmVtb3RlIGFwcGxpY2F0aW9uIHBvcnQgY29ubmVjdGluZyB0byBleHRlbnNpb24uXG4gKi9cbmZ1bmN0aW9uIHNldHVwQ29udHJvbGxlcihpbml0U3RhdGUsIGluaXRMYW5nQ29kZSwgcmVtb3RlU291cmNlUG9ydCkge1xuICAvL1xuICAvLyBNZXRhTWFzayBDb250cm9sbGVyXG4gIC8vXG5cbiAgY29udHJvbGxlciA9IG5ldyBNZXRhbWFza0NvbnRyb2xsZXIoe1xuICAgIGluZnVyYVByb2plY3RJZDogcHJvY2Vzcy5lbnYuSU5GVVJBX1BST0pFQ1RfSUQsXG4gICAgLy8gVXNlciBjb25maXJtYXRpb24gY2FsbGJhY2tzOlxuICAgIHNob3dVc2VyQ29uZmlybWF0aW9uOiB0cmlnZ2VyVWksXG4gICAgb3BlblBvcHVwLFxuICAgIC8vIGluaXRpYWwgc3RhdGVcbiAgICBpbml0U3RhdGUsXG4gICAgLy8gaW5pdGlhbCBsb2NhbGUgY29kZVxuICAgIGluaXRMYW5nQ29kZSxcbiAgICAvLyBwbGF0Zm9ybSBzcGVjaWZpYyBhcGlcbiAgICBwbGF0Zm9ybSxcbiAgICBub3RpZmljYXRpb25NYW5hZ2VyLFxuICAgIGJyb3dzZXIsXG4gICAgZ2V0UmVxdWVzdEFjY291bnRUYWJJZHM6ICgpID0+IHtcbiAgICAgIHJldHVybiByZXF1ZXN0QWNjb3VudFRhYklkcztcbiAgICB9LFxuICAgIGdldE9wZW5NZXRhbWFza1RhYnNJZHM6ICgpID0+IHtcbiAgICAgIHJldHVybiBvcGVuTWV0YW1hc2tUYWJzSURzO1xuICAgIH0sXG4gICAgbG9jYWxTdG9yZSxcbiAgfSk7XG5cbiAgc2V0dXBFbnNJcGZzUmVzb2x2ZXIoe1xuICAgIGdldEN1cnJlbnRDaGFpbklkOiBjb250cm9sbGVyLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICBjb250cm9sbGVyLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICksXG4gICAgZ2V0SXBmc0dhdGV3YXk6IGNvbnRyb2xsZXIucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldElwZnNHYXRld2F5LmJpbmQoXG4gICAgICBjb250cm9sbGVyLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICApLFxuICAgIHByb3ZpZGVyOiBjb250cm9sbGVyLnByb3ZpZGVyLFxuICB9KTtcblxuICAvLyBzZXR1cCBzdGF0ZSBwZXJzaXN0ZW5jZVxuICBwdW1wKFxuICAgIHN0b3JlQXNTdHJlYW0oY29udHJvbGxlci5zdG9yZSksXG4gICAgZGVib3VuY2UoMTAwMCksXG4gICAgY3JlYXRlU3RyZWFtU2luaygoc3RhdGUpID0+IGxvY2FsU3RvcmUuc2V0KHN0YXRlKSksXG4gICAgKGVycm9yKSA9PiB7XG4gICAgICBsb2cuZXJyb3IoJ01ldGFNYXNrIC0gUGVyc2lzdGVuY2UgcGlwZWxpbmUgZmFpbGVkJywgZXJyb3IpO1xuICAgIH0sXG4gICk7XG5cbiAgc2V0dXBTZW50cnlHZXRTdGF0ZUdsb2JhbChjb250cm9sbGVyKTtcblxuICAvL1xuICAvLyBjb25uZWN0IHRvIG90aGVyIGNvbnRleHRzXG4gIC8vXG4gIGlmIChpc01hbmlmZXN0VjMgJiYgcmVtb3RlU291cmNlUG9ydCkge1xuICAgIGNvbm5lY3RSZW1vdGUocmVtb3RlU291cmNlUG9ydCk7XG4gIH1cblxuICBicm93c2VyLnJ1bnRpbWUub25Db25uZWN0LmFkZExpc3RlbmVyKGNvbm5lY3RSZW1vdGUpO1xuICBicm93c2VyLnJ1bnRpbWUub25Db25uZWN0RXh0ZXJuYWwuYWRkTGlzdGVuZXIoY29ubmVjdEV4dGVybmFsKTtcblxuICBjb25zdCBpc0NsaWVudE9wZW5TdGF0dXMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIChcbiAgICAgIHBvcHVwSXNPcGVuIHx8XG4gICAgICBCb29sZWFuKE9iamVjdC5rZXlzKG9wZW5NZXRhbWFza1RhYnNJRHMpLmxlbmd0aCkgfHxcbiAgICAgIG5vdGlmaWNhdGlvbklzT3BlblxuICAgICk7XG4gIH07XG5cbiAgY29uc3Qgb25DbG9zZUVudmlyb25tZW50SW5zdGFuY2VzID0gKGlzQ2xpZW50T3BlbiwgZW52aXJvbm1lbnRUeXBlKSA9PiB7XG4gICAgLy8gaWYgYWxsIGluc3RhbmNlcyBvZiBtZXRhbWFzayBhcmUgY2xvc2VkIHdlIGNhbGwgYSBtZXRob2Qgb24gdGhlIGNvbnRyb2xsZXIgdG8gc3RvcCBnYXNGZWVDb250cm9sbGVyIHBvbGxpbmdcbiAgICBpZiAoaXNDbGllbnRPcGVuID09PSBmYWxzZSkge1xuICAgICAgY29udHJvbGxlci5vbkNsaWVudENsb3NlZCgpO1xuICAgICAgLy8gb3RoZXJ3aXNlIHdlIHdhbnQgdG8gb25seSByZW1vdmUgdGhlIHBvbGxpbmcgdG9rZW5zIGZvciB0aGUgZW52aXJvbm1lbnQgdHlwZSB0aGF0IGhhcyBjbG9zZWRcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gdGhlIGNhc2Ugb2YgZnVsbHNjcmVlbiBlbnZpcm9ubWVudCBhIHVzZXIgbWlnaHQgaGF2ZSBtdWx0aXBsZSB0YWJzIG9wZW4gc28gd2UgZG9uJ3Qgd2FudCB0byBkaXNjb25uZWN0IGFsbCBvZlxuICAgICAgLy8gaXRzIGNvcnJlc3BvbmRpbmcgcG9sbGluZyB0b2tlbnMgdW5sZXNzIGFsbCB0YWJzIGFyZSBjbG9zZWQuXG4gICAgICBpZiAoXG4gICAgICAgIGVudmlyb25tZW50VHlwZSA9PT0gRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOICYmXG4gICAgICAgIEJvb2xlYW4oT2JqZWN0LmtleXMob3Blbk1ldGFtYXNrVGFic0lEcykubGVuZ3RoKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIub25FbnZpcm9ubWVudFR5cGVDbG9zZWQoZW52aXJvbm1lbnRUeXBlKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgcnVudGltZS5Qb3J0IG9iamVjdCwgYXMgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvQWRkLW9ucy9XZWJFeHRlbnNpb25zL0FQSS9ydW50aW1lL1BvcnRcbiAgICogQHR5cGVkZWYgUG9ydFxuICAgKiBAdHlwZSBPYmplY3RcbiAgICovXG5cbiAgLyoqXG4gICAqIENvbm5lY3RzIGEgUG9ydCB0byB0aGUgTWV0YU1hc2sgY29udHJvbGxlciB2aWEgYSBtdWx0aXBsZXhlZCBkdXBsZXggc3RyZWFtLlxuICAgKiBUaGlzIG1ldGhvZCBpZGVudGlmaWVzIHRydXN0ZWQgKE1ldGFNYXNrKSBpbnRlcmZhY2VzLCBhbmQgY29ubmVjdHMgdGhlbSBkaWZmZXJlbnRseSBmcm9tIHVudHJ1c3RlZCAod2ViIHBhZ2VzKS5cbiAgICpcbiAgICogQHBhcmFtIHtQb3J0fSByZW1vdGVQb3J0IC0gVGhlIHBvcnQgcHJvdmlkZWQgYnkgYSBuZXcgY29udGV4dC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvbm5lY3RSZW1vdGUocmVtb3RlUG9ydCkge1xuICAgIGNvbnN0IHByb2Nlc3NOYW1lID0gcmVtb3RlUG9ydC5uYW1lO1xuXG4gICAgaWYgKG1ldGFtYXNrQmxvY2tlZFBvcnRzLmluY2x1ZGVzKHJlbW90ZVBvcnQubmFtZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgaXNNZXRhTWFza0ludGVybmFsUHJvY2VzcyA9IGZhbHNlO1xuICAgIGNvbnN0IHNvdXJjZVBsYXRmb3JtID0gZ2V0UGxhdGZvcm0oKTtcblxuICAgIGlmIChzb3VyY2VQbGF0Zm9ybSA9PT0gUExBVEZPUk1fRklSRUZPWCkge1xuICAgICAgaXNNZXRhTWFza0ludGVybmFsUHJvY2VzcyA9IG1ldGFtYXNrSW50ZXJuYWxQcm9jZXNzSGFzaFtwcm9jZXNzTmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlzTWV0YU1hc2tJbnRlcm5hbFByb2Nlc3MgPVxuICAgICAgICByZW1vdGVQb3J0LnNlbmRlci5vcmlnaW4gPT09IGBjaHJvbWUtZXh0ZW5zaW9uOi8vJHticm93c2VyLnJ1bnRpbWUuaWR9YDtcbiAgICB9XG5cbiAgICBjb25zdCBzZW5kZXJVcmwgPSByZW1vdGVQb3J0LnNlbmRlcj8udXJsXG4gICAgICA/IG5ldyBVUkwocmVtb3RlUG9ydC5zZW5kZXIudXJsKVxuICAgICAgOiBudWxsO1xuXG4gICAgaWYgKGlzTWV0YU1hc2tJbnRlcm5hbFByb2Nlc3MpIHtcbiAgICAgIGNvbnN0IHBvcnRTdHJlYW0gPSBuZXcgUG9ydFN0cmVhbShyZW1vdGVQb3J0KTtcbiAgICAgIC8vIGNvbW11bmljYXRpb24gd2l0aCBwb3B1cFxuICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSB0cnVlO1xuICAgICAgY29udHJvbGxlci5zZXR1cFRydXN0ZWRDb21tdW5pY2F0aW9uKHBvcnRTdHJlYW0sIHJlbW90ZVBvcnQuc2VuZGVyKTtcblxuICAgICAgaWYgKGlzTWFuaWZlc3RWMykge1xuICAgICAgICAvLyBNZXNzYWdlIGJlbG93IGlmIGNhcHR1cmVkIGJ5IFVJIGNvZGUgaW4gYXBwL3NjcmlwdHMvdWkuanMgd2hpY2ggd2lsbCB0cmlnZ2VyIFVJIGluaXRpYWxpc2F0aW9uXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IFVJIGlzIGluaXRpYWxpc2VkIG9ubHkgYWZ0ZXIgYmFja2dyb3VuZCBpcyByZWFkeVxuICAgICAgICAvLyBJdCBmaXhlcyB0aGUgaXNzdWUgb2YgYmxhbmsgc2NyZWVuIGNvbWluZyB3aGVuIGV4dGVuc2lvbiBpcyBsb2FkZWQsIHRoZSBpc3N1ZSBpcyB2ZXJ5IGZyZXF1ZW50IGluIE1WM1xuICAgICAgICByZW1vdGVQb3J0LnBvc3RNZXNzYWdlKHsgbmFtZTogJ0NPTk5FQ1RJT05fUkVBRFknIH0pO1xuXG4gICAgICAgIC8vIElmIHdlIGdldCBhIFdPUktFUl9LRUVQX0FMSVZFIG1lc3NhZ2UsIHdlIHJlc3BvbmQgd2l0aCBhbiBBQ0tcbiAgICAgICAgcmVtb3RlUG9ydC5vbk1lc3NhZ2UuYWRkTGlzdGVuZXIoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBpZiAobWVzc2FnZS5uYW1lID09PSBXT1JLRVJfS0VFUF9BTElWRV9NRVNTQUdFKSB7XG4gICAgICAgICAgICAvLyBUbyB0ZXN0IHVuLWNvbW1lbnQgdGhpcyBsaW5lIGFuZCB3YWl0IGZvciAxIG1pbnV0ZS4gQW4gZXJyb3Igc2hvdWxkIGJlIHNob3duIG9uIE1ldGFNYXNrIFVJLlxuICAgICAgICAgICAgcmVtb3RlUG9ydC5wb3N0TWVzc2FnZSh7IG5hbWU6IEFDS19LRUVQX0FMSVZFX01FU1NBR0UgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByb2Nlc3NOYW1lID09PSBFTlZJUk9OTUVOVF9UWVBFX1BPUFVQKSB7XG4gICAgICAgIHBvcHVwSXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgZW5kT2ZTdHJlYW0ocG9ydFN0cmVhbSwgKCkgPT4ge1xuICAgICAgICAgIHBvcHVwSXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuU3RhdHVzKCk7XG4gICAgICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSBpc0NsaWVudE9wZW47XG4gICAgICAgICAgb25DbG9zZUVudmlyb25tZW50SW5zdGFuY2VzKGlzQ2xpZW50T3BlbiwgRU5WSVJPTk1FTlRfVFlQRV9QT1BVUCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzc05hbWUgPT09IEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OKSB7XG4gICAgICAgIG5vdGlmaWNhdGlvbklzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgZW5kT2ZTdHJlYW0ocG9ydFN0cmVhbSwgKCkgPT4ge1xuICAgICAgICAgIG5vdGlmaWNhdGlvbklzT3BlbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGlzQ2xpZW50T3BlbiA9IGlzQ2xpZW50T3BlblN0YXR1cygpO1xuICAgICAgICAgIGNvbnRyb2xsZXIuaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuO1xuICAgICAgICAgIG9uQ2xvc2VFbnZpcm9ubWVudEluc3RhbmNlcyhcbiAgICAgICAgICAgIGlzQ2xpZW50T3BlbixcbiAgICAgICAgICAgIEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzc05hbWUgPT09IEVOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTikge1xuICAgICAgICBjb25zdCB0YWJJZCA9IHJlbW90ZVBvcnQuc2VuZGVyLnRhYi5pZDtcbiAgICAgICAgb3Blbk1ldGFtYXNrVGFic0lEc1t0YWJJZF0gPSB0cnVlO1xuXG4gICAgICAgIGVuZE9mU3RyZWFtKHBvcnRTdHJlYW0sICgpID0+IHtcbiAgICAgICAgICBkZWxldGUgb3Blbk1ldGFtYXNrVGFic0lEc1t0YWJJZF07XG4gICAgICAgICAgY29uc3QgaXNDbGllbnRPcGVuID0gaXNDbGllbnRPcGVuU3RhdHVzKCk7XG4gICAgICAgICAgY29udHJvbGxlci5pc0NsaWVudE9wZW4gPSBpc0NsaWVudE9wZW47XG4gICAgICAgICAgb25DbG9zZUVudmlyb25tZW50SW5zdGFuY2VzKFxuICAgICAgICAgICAgaXNDbGllbnRPcGVuLFxuICAgICAgICAgICAgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBzZW5kZXJVcmwgJiZcbiAgICAgIHNlbmRlclVybC5vcmlnaW4gPT09IHBoaXNoaW5nUGFnZVVybC5vcmlnaW4gJiZcbiAgICAgIHNlbmRlclVybC5wYXRobmFtZSA9PT0gcGhpc2hpbmdQYWdlVXJsLnBhdGhuYW1lXG4gICAgKSB7XG4gICAgICBjb25zdCBwb3J0U3RyZWFtID0gbmV3IFBvcnRTdHJlYW0ocmVtb3RlUG9ydCk7XG4gICAgICBjb250cm9sbGVyLnNldHVwUGhpc2hpbmdDb21tdW5pY2F0aW9uKHtcbiAgICAgICAgY29ubmVjdGlvblN0cmVhbTogcG9ydFN0cmVhbSxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3RlUG9ydC5zZW5kZXIgJiYgcmVtb3RlUG9ydC5zZW5kZXIudGFiICYmIHJlbW90ZVBvcnQuc2VuZGVyLnVybCkge1xuICAgICAgICBjb25zdCB0YWJJZCA9IHJlbW90ZVBvcnQuc2VuZGVyLnRhYi5pZDtcbiAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZW1vdGVQb3J0LnNlbmRlci51cmwpO1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gdXJsO1xuXG4gICAgICAgIHJlbW90ZVBvcnQub25NZXNzYWdlLmFkZExpc3RlbmVyKChtc2cpID0+IHtcbiAgICAgICAgICBpZiAobXNnLmRhdGEgJiYgbXNnLmRhdGEubWV0aG9kID09PSAnZXRoX3JlcXVlc3RBY2NvdW50cycpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBY2NvdW50VGFiSWRzW29yaWdpbl0gPSB0YWJJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29ubmVjdEV4dGVybmFsKHJlbW90ZVBvcnQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbW11bmljYXRpb24gd2l0aCBwYWdlIG9yIG90aGVyIGV4dGVuc2lvblxuICBmdW5jdGlvbiBjb25uZWN0RXh0ZXJuYWwocmVtb3RlUG9ydCkge1xuICAgIGNvbnN0IHBvcnRTdHJlYW0gPSBuZXcgUG9ydFN0cmVhbShyZW1vdGVQb3J0KTtcbiAgICBjb250cm9sbGVyLnNldHVwVW50cnVzdGVkQ29tbXVuaWNhdGlvbih7XG4gICAgICBjb25uZWN0aW9uU3RyZWFtOiBwb3J0U3RyZWFtLFxuICAgICAgc2VuZGVyOiByZW1vdGVQb3J0LnNlbmRlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8vXG4gIC8vIFVzZXIgSW50ZXJmYWNlIHNldHVwXG4gIC8vXG5cbiAgdXBkYXRlQmFkZ2UoKTtcbiAgY29udHJvbGxlci50eENvbnRyb2xsZXIub24oXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuICBjb250cm9sbGVyLm1lc3NhZ2VNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci5kZWNyeXB0TWVzc2FnZU1hbmFnZXIub24oXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuICBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci50eXBlZE1lc3NhZ2VNYW5hZ2VyLm9uKFxuICAgIE1FVEFNQVNLX0NPTlRST0xMRVJfRVZFTlRTLlVQREFURV9CQURHRSxcbiAgICB1cGRhdGVCYWRnZSxcbiAgKTtcbiAgY29udHJvbGxlci5hcHBTdGF0ZUNvbnRyb2xsZXIub24oXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuVVBEQVRFX0JBREdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuXG4gIGNvbnRyb2xsZXIuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoXG4gICAgTUVUQU1BU0tfQ09OVFJPTExFUl9FVkVOVFMuQVBQUk9WQUxfU1RBVEVfQ0hBTkdFLFxuICAgIHVwZGF0ZUJhZGdlLFxuICApO1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBXZWIgRXh0ZW5zaW9uJ3MgXCJiYWRnZVwiIG51bWJlciwgb24gdGhlIGxpdHRsZSBmb3ggaW4gdGhlIHRvb2xiYXIuXG4gICAqIFRoZSBudW1iZXIgcmVmbGVjdHMgdGhlIGN1cnJlbnQgbnVtYmVyIG9mIHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIG1lc3NhZ2Ugc2lnbmF0dXJlcyBuZWVkaW5nIHVzZXIgYXBwcm92YWwuXG4gICAqL1xuICBmdW5jdGlvbiB1cGRhdGVCYWRnZSgpIHtcbiAgICBsZXQgbGFiZWwgPSAnJztcbiAgICBjb25zdCBjb3VudCA9IGdldFVuYXBwcm92ZWRUcmFuc2FjdGlvbkNvdW50KCk7XG4gICAgaWYgKGNvdW50KSB7XG4gICAgICBsYWJlbCA9IFN0cmluZyhjb3VudCk7XG4gICAgfVxuICAgIC8vIGJyb3dzZXJBY3Rpb24gaGFzIGJlZW4gcmVwbGFjZWQgYnkgYWN0aW9uIGluIE1WM1xuICAgIGlmIChpc01hbmlmZXN0VjMpIHtcbiAgICAgIGJyb3dzZXIuYWN0aW9uLnNldEJhZGdlVGV4dCh7IHRleHQ6IGxhYmVsIH0pO1xuICAgICAgYnJvd3Nlci5hY3Rpb24uc2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3IoeyBjb2xvcjogJyMwMzdERDYnIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBicm93c2VyLmJyb3dzZXJBY3Rpb24uc2V0QmFkZ2VUZXh0KHsgdGV4dDogbGFiZWwgfSk7XG4gICAgICBicm93c2VyLmJyb3dzZXJBY3Rpb24uc2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3IoeyBjb2xvcjogJyMwMzdERDYnIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVuYXBwcm92ZWRUcmFuc2FjdGlvbkNvdW50KCkge1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeENvdW50ID0gY29udHJvbGxlci50eENvbnRyb2xsZXIuZ2V0VW5hcHByb3ZlZFR4Q291bnQoKTtcbiAgICBjb25zdCB7IHVuYXBwcm92ZWRNc2dDb3VudCB9ID0gY29udHJvbGxlci5tZXNzYWdlTWFuYWdlcjtcbiAgICBjb25zdCB7IHVuYXBwcm92ZWRQZXJzb25hbE1zZ0NvdW50IH0gPSBjb250cm9sbGVyLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXI7XG4gICAgY29uc3QgeyB1bmFwcHJvdmVkRGVjcnlwdE1zZ0NvdW50IH0gPSBjb250cm9sbGVyLmRlY3J5cHRNZXNzYWdlTWFuYWdlcjtcbiAgICBjb25zdCB7IHVuYXBwcm92ZWRFbmNyeXB0aW9uUHVibGljS2V5TXNnQ291bnQgfSA9XG4gICAgICBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyO1xuICAgIGNvbnN0IHsgdW5hcHByb3ZlZFR5cGVkTWVzc2FnZXNDb3VudCB9ID0gY29udHJvbGxlci50eXBlZE1lc3NhZ2VNYW5hZ2VyO1xuICAgIGNvbnN0IHBlbmRpbmdBcHByb3ZhbENvdW50ID1cbiAgICAgIGNvbnRyb2xsZXIuYXBwcm92YWxDb250cm9sbGVyLmdldFRvdGFsQXBwcm92YWxDb3VudCgpO1xuICAgIGNvbnN0IHdhaXRpbmdGb3JVbmxvY2tDb3VudCA9XG4gICAgICBjb250cm9sbGVyLmFwcFN0YXRlQ29udHJvbGxlci53YWl0aW5nRm9yVW5sb2NrLmxlbmd0aDtcbiAgICByZXR1cm4gKFxuICAgICAgdW5hcHByb3ZlZFR4Q291bnQgK1xuICAgICAgdW5hcHByb3ZlZE1zZ0NvdW50ICtcbiAgICAgIHVuYXBwcm92ZWRQZXJzb25hbE1zZ0NvdW50ICtcbiAgICAgIHVuYXBwcm92ZWREZWNyeXB0TXNnQ291bnQgK1xuICAgICAgdW5hcHByb3ZlZEVuY3J5cHRpb25QdWJsaWNLZXlNc2dDb3VudCArXG4gICAgICB1bmFwcHJvdmVkVHlwZWRNZXNzYWdlc0NvdW50ICtcbiAgICAgIHBlbmRpbmdBcHByb3ZhbENvdW50ICtcbiAgICAgIHdhaXRpbmdGb3JVbmxvY2tDb3VudFxuICAgICk7XG4gIH1cblxuICBub3RpZmljYXRpb25NYW5hZ2VyLm9uKFxuICAgIE5PVElGSUNBVElPTl9NQU5BR0VSX0VWRU5UUy5QT1BVUF9DTE9TRUQsXG4gICAgKHsgYXV0b21hdGljYWxseUNsb3NlZCB9KSA9PiB7XG4gICAgICBpZiAoIWF1dG9tYXRpY2FsbHlDbG9zZWQpIHtcbiAgICAgICAgcmVqZWN0VW5hcHByb3ZlZE5vdGlmaWNhdGlvbnMoKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2V0VW5hcHByb3ZlZFRyYW5zYWN0aW9uQ291bnQoKSA+IDApIHtcbiAgICAgICAgdHJpZ2dlclVpKCk7XG4gICAgICB9XG4gICAgfSxcbiAgKTtcblxuICBmdW5jdGlvbiByZWplY3RVbmFwcHJvdmVkTm90aWZpY2F0aW9ucygpIHtcbiAgICBPYmplY3Qua2V5cyhcbiAgICAgIGNvbnRyb2xsZXIudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmdldFVuYXBwcm92ZWRUeExpc3QoKSxcbiAgICApLmZvckVhY2goKHR4SWQpID0+XG4gICAgICBjb250cm9sbGVyLnR4Q29udHJvbGxlci50eFN0YXRlTWFuYWdlci5zZXRUeFN0YXR1c1JlamVjdGVkKHR4SWQpLFxuICAgICk7XG4gICAgY29udHJvbGxlci5tZXNzYWdlTWFuYWdlci5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAuZm9yRWFjaCgodHgpID0+XG4gICAgICAgIGNvbnRyb2xsZXIubWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKFxuICAgICAgICAgIHR4LmlkLFxuICAgICAgICAgIFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICBjb250cm9sbGVyLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIubWVzc2FnZXNcbiAgICAgIC5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyA9PT0gJ3VuYXBwcm92ZWQnKVxuICAgICAgLmZvckVhY2goKHR4KSA9PlxuICAgICAgICBjb250cm9sbGVyLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKFxuICAgICAgICAgIHR4LmlkLFxuICAgICAgICAgIFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICBjb250cm9sbGVyLnR5cGVkTWVzc2FnZU1hbmFnZXIubWVzc2FnZXNcbiAgICAgIC5maWx0ZXIoKG1zZykgPT4gbXNnLnN0YXR1cyA9PT0gJ3VuYXBwcm92ZWQnKVxuICAgICAgLmZvckVhY2goKHR4KSA9PlxuICAgICAgICBjb250cm9sbGVyLnR5cGVkTWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKFxuICAgICAgICAgIHR4LmlkLFxuICAgICAgICAgIFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICBjb250cm9sbGVyLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5tZXNzYWdlc1xuICAgICAgLmZpbHRlcigobXNnKSA9PiBtc2cuc3RhdHVzID09PSAndW5hcHByb3ZlZCcpXG4gICAgICAuZm9yRWFjaCgodHgpID0+XG4gICAgICAgIGNvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLnJlamVjdE1zZyhcbiAgICAgICAgICB0eC5pZCxcbiAgICAgICAgICBSRUpFQ1RfTk9URklDSUFUSU9OX0NMT1NFLFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICBjb250cm9sbGVyLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLm1lc3NhZ2VzXG4gICAgICAuZmlsdGVyKChtc2cpID0+IG1zZy5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgIC5mb3JFYWNoKCh0eCkgPT5cbiAgICAgICAgY29udHJvbGxlci5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5yZWplY3RNc2coXG4gICAgICAgICAgdHguaWQsXG4gICAgICAgICAgUkVKRUNUX05PVEZJQ0lBVElPTl9DTE9TRSxcbiAgICAgICAgKSxcbiAgICAgICk7XG5cbiAgICAvLyBGaW5hbGx5LCByZWplY3QgYWxsIGFwcHJvdmFscyBtYW5hZ2VkIGJ5IHRoZSBBcHByb3ZhbENvbnRyb2xsZXJcbiAgICBjb250cm9sbGVyLmFwcHJvdmFsQ29udHJvbGxlci5jbGVhcihcbiAgICAgIGV0aEVycm9ycy5wcm92aWRlci51c2VyUmVqZWN0ZWRSZXF1ZXN0KCksXG4gICAgKTtcblxuICAgIHVwZGF0ZUJhZGdlKCk7XG4gIH1cbn1cblxuLy9cbi8vIEV0Yy4uLlxuLy9cblxuLyoqXG4gKiBPcGVucyB0aGUgYnJvd3NlciBwb3B1cCBmb3IgdXNlciBjb25maXJtYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdHJpZ2dlclVpKCkge1xuICBjb25zdCB0YWJzID0gYXdhaXQgcGxhdGZvcm0uZ2V0QWN0aXZlVGFicygpO1xuICBjb25zdCBjdXJyZW50bHlBY3RpdmVNZXRhbWFza1RhYiA9IEJvb2xlYW4oXG4gICAgdGFicy5maW5kKCh0YWIpID0+IG9wZW5NZXRhbWFza1RhYnNJRHNbdGFiLmlkXSksXG4gICk7XG4gIC8vIFZpdmFsZGkgaXMgbm90IGNsb3NpbmcgcG9ydCBjb25uZWN0aW9uIG9uIHBvcHVwIGNsb3NlLCBzbyBwb3B1cElzT3BlbiBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseVxuICAvLyBUbyBiZSByZXZpZXdlZCBpbiB0aGUgZnV0dXJlIGlmIHRoaXMgYmVoYXZpb3VyIGlzIGZpeGVkIC0gYWxzbyB0aGUgd2F5IHdlIGRldGVybWluZSBpc1ZpdmFsZGkgdmFyaWFibGUgbWlnaHQgY2hhbmdlIGF0IHNvbWUgcG9pbnRcbiAgY29uc3QgaXNWaXZhbGRpID1cbiAgICB0YWJzLmxlbmd0aCA+IDAgJiZcbiAgICB0YWJzWzBdLmV4dERhdGEgJiZcbiAgICB0YWJzWzBdLmV4dERhdGEuaW5kZXhPZigndml2YWxkaV90YWInKSA+IC0xO1xuICBpZiAoXG4gICAgIXVpSXNUcmlnZ2VyaW5nICYmXG4gICAgKGlzVml2YWxkaSB8fCAhcG9wdXBJc09wZW4pICYmXG4gICAgIWN1cnJlbnRseUFjdGl2ZU1ldGFtYXNrVGFiXG4gICkge1xuICAgIHVpSXNUcmlnZ2VyaW5nID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgbm90aWZpY2F0aW9uTWFuYWdlci5zaG93UG9wdXAoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdWlJc1RyaWdnZXJpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBPcGVucyB0aGUgYnJvd3NlciBwb3B1cCBmb3IgdXNlciBjb25maXJtYXRpb24gb2Ygd2F0Y2hBc3NldFxuICogdGhlbiBpdCB3YWl0cyB1bnRpbCB1c2VyIGludGVyYWN0IHdpdGggdGhlIFVJXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG9wZW5Qb3B1cCgpIHtcbiAgYXdhaXQgdHJpZ2dlclVpKCk7XG4gIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoIW5vdGlmaWNhdGlvbklzT3Blbikge1xuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfVxuICAgIH0sIFNFQ09ORCk7XG4gIH0pO1xufVxuXG4vLyBJdCBhZGRzIHRoZSBcIkFwcCBJbnN0YWxsZWRcIiBldmVudCBpbnRvIGEgcXVldWUgb2YgZXZlbnRzLCB3aGljaCB3aWxsIGJlIHRyYWNrZWQgb25seSBhZnRlciBhIHVzZXIgb3B0cyBpbnRvIG1ldHJpY3MuXG5jb25zdCBhZGRBcHBJbnN0YWxsZWRFdmVudCA9ICgpID0+IHtcbiAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICBjb250cm9sbGVyLm1ldGFNZXRyaWNzQ29udHJvbGxlci51cGRhdGVUcmFpdHMoe1xuICAgICAgW1RSQUlUUy5JTlNUQUxMX0RBVEVfRVhUXTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sIC8vIHl5eXktbW0tZGRcbiAgICB9KTtcbiAgICBjb250cm9sbGVyLm1ldGFNZXRyaWNzQ29udHJvbGxlci5hZGRFdmVudEJlZm9yZU1ldHJpY3NPcHRJbih7XG4gICAgICBjYXRlZ29yeTogRVZFTlQuQ0FURUdPUklFUy5BUFAsXG4gICAgICBldmVudDogRVZFTlRfTkFNRVMuQVBQX0lOU1RBTExFRCxcbiAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBJZiB0aGUgY29udHJvbGxlciBpcyBub3Qgc2V0IHlldCwgd2Ugd2FpdCBhbmQgdHJ5IHRvIGFkZCB0aGUgXCJBcHAgSW5zdGFsbGVkXCIgZXZlbnQgYWdhaW4uXG4gICAgYWRkQXBwSW5zdGFsbGVkRXZlbnQoKTtcbiAgfSwgMTAwMCk7XG59O1xuXG4vLyBPbiBmaXJzdCBpbnN0YWxsLCBvcGVuIGEgbmV3IHRhYiB3aXRoIE1ldGFNYXNrXG5icm93c2VyLnJ1bnRpbWUub25JbnN0YWxsZWQuYWRkTGlzdGVuZXIoKHsgcmVhc29uIH0pID0+IHtcbiAgaWYgKFxuICAgIHJlYXNvbiA9PT0gJ2luc3RhbGwnICYmXG4gICAgIShwcm9jZXNzLmVudi5NRVRBTUFTS19ERUJVRyB8fCBwcm9jZXNzLmVudi5JTl9URVNUKVxuICApIHtcbiAgICBhZGRBcHBJbnN0YWxsZWRFdmVudCgpO1xuICAgIHBsYXRmb3JtLm9wZW5FeHRlbnNpb25JbkJyb3dzZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHNldHVwU2VudHJ5R2V0U3RhdGVHbG9iYWwoc3RvcmUpIHtcbiAgZ2xvYmFsLnNlbnRyeUhvb2tzLmdldFNlbnRyeVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGZ1bGxTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZGVidWdTdGF0ZSA9IG1hc2tPYmplY3QoeyBtZXRhbWFzazogZnVsbFN0YXRlIH0sIFNFTlRSWV9TVEFURSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXI6IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LFxuICAgICAgc3RvcmU6IGRlYnVnU3RhdGUsXG4gICAgICB2ZXJzaW9uOiBwbGF0Zm9ybS5nZXRWZXJzaW9uKCksXG4gICAgfTtcbiAgfTtcbn1cbiJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5janMubWFwIn0=
