LavaPack.loadBundle([
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\metamask-controller.js", {"../../shared/constants/app":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts","../../shared/constants/hardware-wallets":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js","../../shared/constants/metametrics":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\metametrics.js","../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../../shared/constants/permissions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\permissions.ts","../../shared/constants/phishing":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\phishing.js","../../shared/constants/swaps":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js","../../shared/constants/time":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts","../../shared/constants/tokens":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\tokens.js","../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../../shared/lib/metamask-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js","../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","../../shared/modules/string-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js","../../shared/modules/transaction.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js","../../shared/notifications":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\notifications\\index.js","../../ui/helpers/utils/token-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\token-util.js","./account-import-strategies":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\account-import-strategies\\index.js","./controllers/alert":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\alert.js","./controllers/app-state":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\app-state.js","./controllers/backup":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\backup.js","./controllers/cached-balances":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\cached-balances.js","./controllers/detect-tokens":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\detect-tokens.js","./controllers/ens":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\ens\\index.js","./controllers/incoming-transactions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\incoming-transactions.js","./controllers/metametrics":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\metametrics.js","./controllers/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\network\\index.js","./controllers/onboarding":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\onboarding.js","./controllers/permissions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\permissions\\index.js","./controllers/preferences":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\preferences.js","./controllers/swaps":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\swaps.js","./controllers/transactions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\transactions\\index.js","./detect-multiple-instances":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\detect-multiple-instances.js","./lib/ComposableObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\ComposableObservableStore.js","./lib/account-tracker":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\account-tracker.js","./lib/createLoggerMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createLoggerMiddleware.js","./lib/createMetaRPCHandler":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createMetaRPCHandler.js","./lib/createOnboardingMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createOnboardingMiddleware.js","./lib/createOriginMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createOriginMiddleware.js","./lib/createRPCMethodTrackingMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createRPCMethodTrackingMiddleware.js","./lib/createTabIdMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\createTabIdMiddleware.js","./lib/decrypt-message-manager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\decrypt-message-manager.js","./lib/encryption-public-key-manager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\encryption-public-key-manager.js","./lib/message-manager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\message-manager.js","./lib/personal-message-manager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\personal-message-manager.js","./lib/rpc-method-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\rpc-method-middleware\\index.js","./lib/seed-phrase-verifier":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\seed-phrase-verifier.js","./lib/segment":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\segment\\index.js","./lib/stream-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\stream-utils.js","./lib/typed-message-manager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\typed-message-manager.js","@keystonehq/metamask-airgapped-keyring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js","@metamask/controllers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\controllers\\dist\\index.js","@metamask/eth-ledger-bridge-keyring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js","@metamask/obs-store":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\index.js","@metamask/obs-store/dist/asStream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","@metamask/smart-transactions-controller":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js","@sentry/browser":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@sentry\\browser\\dist\\index.js","_process":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js","await-semaphore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\await-semaphore\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-json-rpc-filters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-filters\\index.js","eth-json-rpc-filters/subscriptionManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js","eth-json-rpc-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","eth-keyring-controller":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-keyring-controller\\index.js","eth-lattice-keyring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-lattice-keyring\\index.js","eth-query":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-trezor-keyring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-trezor-keyring\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","json-rpc-middleware-stream/engineStream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-middleware-stream\\engineStream.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","nanoid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\nanoid\\index.browser.js","pump":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pump\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\metamask-controller.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.METAMASK_CONTROLLER_EVENTS = void 0;

var _events = _interopRequireDefault(require("events"));

var _pump = _interopRequireDefault(require("pump"));

var _obsStore = require("@metamask/obs-store");

var _asStream = require("@metamask/obs-store/dist/asStream");

var _jsonRpcEngine = require("json-rpc-engine");

var _lodash = require("lodash");

var _engineStream = _interopRequireDefault(require("json-rpc-middleware-stream/engineStream"));

var _ethJsonRpcFilters = _interopRequireDefault(require("eth-json-rpc-filters"));

var _subscriptionManager = _interopRequireDefault(require("eth-json-rpc-filters/subscriptionManager"));

var _ethJsonRpcMiddleware = require("eth-json-rpc-middleware");

var _ethKeyringController = _interopRequireDefault(require("eth-keyring-controller"));

var _ethRpcErrors = require("eth-rpc-errors");

var _awaitSemaphore = require("await-semaphore");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethTrezorKeyring = _interopRequireDefault(require("eth-trezor-keyring"));

var _ethLedgerBridgeKeyring = _interopRequireDefault(require("@metamask/eth-ledger-bridge-keyring"));

var _ethLatticeKeyring = _interopRequireDefault(require("eth-lattice-keyring"));

var _metamaskAirgappedKeyring = require("@keystonehq/metamask-airgapped-keyring");

var _ethQuery = _interopRequireDefault(require("eth-query"));

var _nanoid = _interopRequireDefault(require("nanoid"));

var _browser = require("@sentry/browser");

var _controllers = require("@metamask/controllers");

var _smartTransactionsController = _interopRequireDefault(require("@metamask/smart-transactions-controller"));

var _transaction = require("../../shared/constants/transaction");

var _phishing = require("../../shared/constants/phishing");

var _swaps = require("../../shared/constants/swaps");

var _network = require("../../shared/constants/network");

var _hardwareWallets = require("../../shared/constants/hardware-wallets");

var _permissions = require("../../shared/constants/permissions");

var _notifications = require("../../shared/notifications");

var _hexstringUtils = require("../../shared/modules/hexstring-utils");

var _time = require("../../shared/constants/time");

var _app = require("../../shared/constants/app");

var _metametrics = require("../../shared/constants/metametrics");

var _tokenUtil = require("../../ui/helpers/utils/token-util");

var _stringUtils = require("../../shared/modules/string-utils");

var _transaction2 = require("../../shared/modules/transaction.utils");

var _tokens = require("../../shared/constants/tokens");

var _metamaskControllerUtils = require("../../shared/lib/metamask-controller-utils");

var _detectMultipleInstances = require("./detect-multiple-instances");

var _ComposableObservableStore = _interopRequireDefault(require("./lib/ComposableObservableStore"));

var _accountTracker = _interopRequireDefault(require("./lib/account-tracker"));

var _createLoggerMiddleware = _interopRequireDefault(require("./lib/createLoggerMiddleware"));

var _rpcMethodMiddleware = require("./lib/rpc-method-middleware");

var _createOriginMiddleware = _interopRequireDefault(require("./lib/createOriginMiddleware"));

var _createTabIdMiddleware = _interopRequireDefault(require("./lib/createTabIdMiddleware"));

var _createOnboardingMiddleware = _interopRequireDefault(require("./lib/createOnboardingMiddleware"));

var _streamUtils = require("./lib/stream-utils");

var _ens = _interopRequireDefault(require("./controllers/ens"));

var _network2 = _interopRequireWildcard(require("./controllers/network"));

var _preferences = _interopRequireDefault(require("./controllers/preferences"));

var _appState = _interopRequireDefault(require("./controllers/app-state"));

var _cachedBalances = _interopRequireDefault(require("./controllers/cached-balances"));

var _alert = _interopRequireDefault(require("./controllers/alert"));

var _onboarding = _interopRequireDefault(require("./controllers/onboarding"));

var _backup = _interopRequireDefault(require("./controllers/backup"));

var _incomingTransactions = _interopRequireDefault(require("./controllers/incoming-transactions"));

var _messageManager = _interopRequireWildcard(require("./lib/message-manager"));

var _decryptMessageManager = _interopRequireDefault(require("./lib/decrypt-message-manager"));

var _encryptionPublicKeyManager = _interopRequireDefault(require("./lib/encryption-public-key-manager"));

var _personalMessageManager = _interopRequireDefault(require("./lib/personal-message-manager"));

var _typedMessageManager = _interopRequireDefault(require("./lib/typed-message-manager"));

var _transactions = _interopRequireDefault(require("./controllers/transactions"));

var _detectTokens = _interopRequireDefault(require("./controllers/detect-tokens"));

var _swaps2 = _interopRequireDefault(require("./controllers/swaps"));

var _accountImportStrategies = _interopRequireDefault(require("./account-import-strategies"));

var _seedPhraseVerifier = _interopRequireDefault(require("./lib/seed-phrase-verifier"));

var _metametrics2 = _interopRequireDefault(require("./controllers/metametrics"));

var _segment = require("./lib/segment");

var _createMetaRPCHandler = _interopRequireDefault(require("./lib/createMetaRPCHandler"));

var _permissions2 = require("./controllers/permissions");

var _createRPCMethodTrackingMiddleware = _interopRequireDefault(require("./lib/createRPCMethodTrackingMiddleware"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const METAMASK_CONTROLLER_EVENTS = {
  // Fired after state changes that impact the extension badge (unapproved msg count)
  // The process of updating the badge happens in app/scripts/background.js.
  UPDATE_BADGE: 'updateBadge',
  // TODO: Add this and similar enums to @metamask/controllers and export them
  APPROVAL_STATE_CHANGE: 'ApprovalController:stateChange'
}; // stream channels

exports.METAMASK_CONTROLLER_EVENTS = METAMASK_CONTROLLER_EVENTS;
const PHISHING_SAFELIST = 'metamask-phishing-safelist';

class MetamaskController extends _events.default {
  /**
   * @param {object} opts
   */
  constructor(opts) {
    var _process$env$CONF;

    super();

    _defineProperty(this, "removePermissionsFor", subjects => {
      try {
        this.permissionController.revokePermissions(subjects);
      } catch (exp) {
        if (!(exp instanceof _controllers.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });

    _defineProperty(this, "rejectPermissionsRequest", requestId => {
      try {
        this.permissionController.rejectPermissionsRequest(requestId);
      } catch (exp) {
        if (!(exp instanceof _controllers.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });

    _defineProperty(this, "acceptPermissionsRequest", request => {
      try {
        this.permissionController.acceptPermissionsRequest(request);
      } catch (exp) {
        if (!(exp instanceof _controllers.PermissionsRequestNotFoundError)) {
          throw exp;
        }
      }
    });

    _defineProperty(this, "resolvePendingApproval", (id, value) => {
      try {
        this.approvalController.accept(id, value);
      } catch (exp) {
        if (!(exp instanceof _controllers.ApprovalRequestNotFoundError)) {
          throw exp;
        }
      }
    });

    _defineProperty(this, "rejectPendingApproval", (id, error) => {
      try {
        this.approvalController.reject(id, new _ethRpcErrors.EthereumRpcError(error.code, error.message, error.data));
      } catch (exp) {
        if (!(exp instanceof _controllers.ApprovalRequestNotFoundError)) {
          throw exp;
        }
      }
    });

    this.defaultMaxListeners = 20;
    this.sendUpdate = (0, _lodash.debounce)(this.privateSendUpdate.bind(this), _time.MILLISECOND * 200);
    this.opts = opts;
    this.extension = opts.browser;
    this.platform = opts.platform;
    this.notificationManager = opts.notificationManager;
    const initState = opts.initState || {};
    const version = this.platform.getVersion();
    this.recordFirstTimeInfo(initState); // this keeps track of how many "controllerStream" connections are open
    // the only thing that uses controller connections are open metamask UI instances

    this.activeControllerConnections = 0;
    this.getRequestAccountTabIds = opts.getRequestAccountTabIds;
    this.getOpenMetamaskTabsIds = opts.getOpenMetamaskTabsIds;
    this.controllerMessenger = new _controllers.ControllerMessenger(); // instance of a class that wraps the extension's storage local API.

    this.localStoreApiWrapper = opts.localStore; // observable state store

    this.store = new _ComposableObservableStore.default({
      state: initState,
      controllerMessenger: this.controllerMessenger,
      persist: true
    }); // external connections by origin
    // Do not modify directly. Use the associated methods.

    this.connections = {}; // lock to ensure only one vault created at once

    this.createVaultMutex = new _awaitSemaphore.Mutex();
    this.extension.runtime.onInstalled.addListener(details => {
      if (details.reason === 'update' && version === '8.1.0') {
        this.platform.openExtensionInBrowser();
      }
    }); // next, we will initialize the controllers
    // controller initialization order matters

    this.approvalController = new _controllers.ApprovalController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'ApprovalController'
      }),
      showApprovalRequest: opts.showUserConfirmation
    });
    this.networkController = new _network2.default(initState.NetworkController);
    this.networkController.setInfuraProjectId(opts.infuraProjectId); // now we can initialize the RPC provider, which other controllers require

    this.initializeProvider();
    this.provider = this.networkController.getProviderAndBlockTracker().provider;
    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker;
    const tokenListMessenger = this.controllerMessenger.getRestricted({
      name: 'TokenListController'
    });
    this.tokenListController = new _controllers.TokenListController({
      chainId: (0, _metamaskControllerUtils.hexToDecimal)(this.networkController.getCurrentChainId()),
      preventPollingOnNetworkRestart: initState.TokenListController ? initState.TokenListController.preventPollingOnNetworkRestart : true,
      onNetworkStateChange: cb => {
        this.networkController.store.subscribe(networkState => {
          const modifiedNetworkState = { ...networkState,
            provider: { ...networkState.provider,
              chainId: (0, _metamaskControllerUtils.hexToDecimal)(networkState.provider.chainId)
            }
          };
          return cb(modifiedNetworkState);
        });
      },
      messenger: tokenListMessenger,
      state: initState.TokenListController
    });
    this.preferencesController = new _preferences.default({
      initState: initState.PreferencesController,
      initLangCode: opts.initLangCode,
      openPopup: opts.openPopup,
      network: this.networkController,
      tokenListController: this.tokenListController,
      provider: this.provider,
      migrateAddressBookState: this.migrateAddressBookState.bind(this)
    });
    this.tokensController = new _controllers.TokensController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      config: {
        provider: this.provider
      },
      state: initState.TokensController
    });
    this.assetsContractController = new _controllers.AssetsContractController({
      onPreferencesStateChange: listener => this.preferencesController.store.subscribe(listener),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = { ...networkState,
          provider: { ...networkState.provider,
            chainId: (0, _metamaskControllerUtils.hexToDecimal)(networkState.provider.chainId)
          }
        };
        return cb(modifiedNetworkState);
      })
    }, {
      provider: this.provider
    }, initState.AssetsContractController);
    this.collectiblesController = new _controllers.CollectiblesController({
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getERC721AssetName: this.assetsContractController.getERC721AssetName.bind(this.assetsContractController),
      getERC721AssetSymbol: this.assetsContractController.getERC721AssetSymbol.bind(this.assetsContractController),
      getERC721TokenURI: this.assetsContractController.getERC721TokenURI.bind(this.assetsContractController),
      getERC721OwnerOf: this.assetsContractController.getERC721OwnerOf.bind(this.assetsContractController),
      getERC1155BalanceOf: this.assetsContractController.getERC1155BalanceOf.bind(this.assetsContractController),
      getERC1155TokenURI: this.assetsContractController.getERC1155TokenURI.bind(this.assetsContractController),
      onCollectibleAdded: ({
        address,
        symbol,
        tokenId,
        standard,
        source
      }) => this.metaMetricsController.trackEvent({
        event: _metametrics.EVENT_NAMES.NFT_ADDED,
        category: _metametrics.EVENT.CATEGORIES.WALLET,
        properties: {
          token_contract_address: address,
          token_symbol: symbol,
          asset_type: _transaction.ASSET_TYPES.COLLECTIBLE,
          token_standard: standard,
          source
        },
        sensitiveProperties: {
          tokenId
        }
      })
    }, {}, initState.CollectiblesController);
    this.collectiblesController.setApiKey(process.env.OPENSEA_KEY);
    false && (this.collectibleDetectionController = new _controllers.CollectibleDetectionController({
      onCollectiblesStateChange: listener => this.collectiblesController.subscribe(listener),
      onPreferencesStateChange: this.preferencesController.store.subscribe.bind(this.preferencesController.store),
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getOpenSeaApiKey: () => this.collectiblesController.openSeaApiKey,
      getBalancesInSingleCall: this.assetsContractController.getBalancesInSingleCall.bind(this.assetsContractController),
      addCollectible: this.collectiblesController.addCollectible.bind(this.collectiblesController),
      getCollectiblesState: () => this.collectiblesController.state
    }));
    this.metaMetricsController = new _metametrics2.default({
      segment: _segment.segment,
      preferencesStore: this.preferencesController.store,
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getNetworkIdentifier: this.networkController.getNetworkIdentifier.bind(this.networkController),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      version: this.platform.getVersion(),
      environment: "development",
      extension: this.extension,
      initState: initState.MetaMetricsController,
      captureException: _browser.captureException
    });
    this.on('update', update => {
      this.metaMetricsController.handleMetaMaskStateUpdate(update);
    });
    const gasFeeMessenger = this.controllerMessenger.getRestricted({
      name: 'GasFeeController'
    });
    const gasApiBaseUrl = false ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
    this.gasFeeController = new _controllers.GasFeeController({
      interval: 10000,
      messenger: gasFeeMessenger,
      clientId: _swaps.SWAPS_CLIENT_ID,
      getProvider: () => this.networkController.getProviderAndBlockTracker().provider,
      onNetworkStateChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      legacyAPIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/gasPrices`,
      EIP1559APIEndpoint: `${gasApiBaseUrl}/networks/<chain_id>/suggestedGasFees`,
      getCurrentNetworkLegacyGasAPICompatibility: () => {
        const chainId = this.networkController.getCurrentChainId();
        return false || chainId === _network.CHAIN_IDS.MAINNET;
      },
      getChainId: () => {
        return false ? _network.CHAIN_IDS.MAINNET : this.networkController.getCurrentChainId();
      }
    });
    this.qrHardwareKeyring = new _metamaskAirgappedKeyring.MetaMaskKeyring();
    this.appStateController = new _appState.default({
      addUnlockListener: this.on.bind(this, 'unlock'),
      isUnlocked: this.isUnlocked.bind(this),
      initState: initState.AppStateController,
      onInactiveTimeout: () => this.setLocked(),
      showUnlockRequest: opts.showUserConfirmation,
      preferencesStore: this.preferencesController.store,
      qrHardwareStore: this.qrHardwareKeyring.getMemStore()
    });
    const currencyRateMessenger = this.controllerMessenger.getRestricted({
      name: 'CurrencyRateController'
    });
    this.currencyRateController = new _controllers.CurrencyRateController({
      includeUsdRate: true,
      messenger: currencyRateMessenger,
      state: { ...initState.CurrencyController,
        nativeCurrency: this.networkController.providerStore.getState().ticker
      }
    });
    this.phishingController = new _controllers.PhishingController();
    this.phishingController.updatePhishingLists();

    if (false) {
      this.phishingController.setRefreshInterval(5 * _time.SECOND);
    }

    this.announcementController = new _controllers.AnnouncementController({
      allAnnouncements: _notifications.UI_NOTIFICATIONS
    }, initState.AnnouncementController); // token exchange rate tracker

    this.tokenRatesController = new _controllers.TokenRatesController({
      onTokensStateChange: listener => this.tokensController.subscribe(listener),
      onCurrencyRateStateChange: listener => this.controllerMessenger.subscribe(`${this.currencyRateController.name}:stateChange`, listener),
      onNetworkStateChange: cb => this.networkController.store.subscribe(networkState => {
        const modifiedNetworkState = { ...networkState,
          provider: { ...networkState.provider,
            chainId: (0, _metamaskControllerUtils.hexToDecimal)(networkState.provider.chainId)
          }
        };
        return cb(modifiedNetworkState);
      })
    });
    this.ensController = new _ens.default({
      provider: this.provider,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE)
    });
    this.incomingTransactionsController = new _incomingTransactions.default({
      blockTracker: this.blockTracker,
      onNetworkDidChange: this.networkController.on.bind(this.networkController, _network2.NETWORK_EVENTS.NETWORK_DID_CHANGE),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      preferencesController: this.preferencesController,
      initState: initState.IncomingTransactionsController
    }); // account tracker watches balances, nonces, and any code at their address

    this.accountTracker = new _accountTracker.default({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      getNetworkIdentifier: this.networkController.getNetworkIdentifier.bind(this.networkController)
    }); // start and stop polling for balances based on activeControllerConnections

    this.on('controllerConnectionChanged', activeControllerConnections => {
      if (activeControllerConnections > 0) {
        this.accountTracker.start();
        this.incomingTransactionsController.start();
        this.currencyRateController.start();

        if (this.preferencesController.store.getState().useTokenDetection) {
          this.tokenListController.start();
        }
      } else {
        this.accountTracker.stop();
        this.incomingTransactionsController.stop();
        this.currencyRateController.stop();

        if (this.preferencesController.store.getState().useTokenDetection) {
          this.tokenListController.stop();
        }
      }
    });
    this.cachedBalancesController = new _cachedBalances.default({
      accountTracker: this.accountTracker,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      initState: initState.CachedBalancesController
    });
    this.onboardingController = new _onboarding.default({
      initState: initState.OnboardingController
    });
    this.tokensController.hub.on('pendingSuggestedAsset', async () => {
      await opts.openPopup();
    });
    const additionalKeyrings = [_ethTrezorKeyring.default, _ethLedgerBridgeKeyring.default, _ethLatticeKeyring.default, _metamaskAirgappedKeyring.MetaMaskKeyring];
    this.keyringController = new _ethKeyringController.default({
      keyringTypes: additionalKeyrings,
      initState: initState.KeyringController,
      encryptor: opts.encryptor || undefined
    });
    this.keyringController.memStore.subscribe(state => this._onKeyringControllerUpdate(state));
    this.keyringController.on('unlock', () => this._onUnlock());
    this.keyringController.on('lock', () => this._onLock());

    const getIdentities = () => this.preferencesController.store.getState().identities;

    this.permissionController = new _controllers.PermissionController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'PermissionController',
        allowedActions: [`${this.approvalController.name}:addRequest`, `${this.approvalController.name}:hasRequest`, `${this.approvalController.name}:acceptRequest`, `${this.approvalController.name}:rejectRequest`]
      }),
      state: initState.PermissionController,
      caveatSpecifications: (0, _permissions2.getCaveatSpecifications)({
        getIdentities
      }),
      permissionSpecifications: { ...(0, _permissions2.getPermissionSpecifications)({
          getIdentities,
          getAllAccounts: this.keyringController.getAccounts.bind(this.keyringController),
          captureKeyringTypesWithMissingIdentities: (identities = {}, accounts = []) => {
            const accountsMissingIdentities = accounts.filter(address => !identities[address]);
            const keyringTypesWithMissingIdentities = accountsMissingIdentities.map(address => {
              var _this$keyringControll;

              return (_this$keyringControll = this.keyringController.getKeyringForAccount(address)) === null || _this$keyringControll === void 0 ? void 0 : _this$keyringControll.type;
            });
            const identitiesCount = Object.keys(identities || {}).length;
            const accountTrackerCount = Object.keys(this.accountTracker.store.getState().accounts || {}).length;
            (0, _browser.captureException)(new Error(`Attempt to get permission specifications failed because their were ${accounts.length} accounts, but ${identitiesCount} identities, and the ${keyringTypesWithMissingIdentities} keyrings included accounts with missing identities. Meanwhile, there are ${accountTrackerCount} accounts in the account tracker.`));
          }
        })
      },
      unrestrictedMethods: _permissions2.unrestrictedMethods
    });
    this.permissionLogController = new _permissions2.PermissionLogController({
      restrictedMethods: new Set(Object.keys(_permissions.RestrictedMethods)),
      initState: initState.PermissionLogController
    });
    this.subjectMetadataController = new _controllers.SubjectMetadataController({
      messenger: this.controllerMessenger.getRestricted({
        name: 'SubjectMetadataController',
        allowedActions: [`${this.permissionController.name}:hasPermissions`]
      }),
      state: initState.SubjectMetadataController,
      subjectCacheLimit: 100
    });
    this.detectTokensController = new _detectTokens.default({
      preferences: this.preferencesController,
      tokensController: this.tokensController,
      assetsContractController: this.assetsContractController,
      network: this.networkController,
      keyringMemStore: this.keyringController.memStore,
      tokenList: this.tokenListController,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.addressBookController = new _controllers.AddressBookController(undefined, initState.AddressBookController);
    this.alertController = new _alert.default({
      initState: initState.AlertController,
      preferencesStore: this.preferencesController.store
    });
    this.backupController = new _backup.default({
      preferencesController: this.preferencesController,
      addressBookController: this.addressBookController,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.txController = new _transactions.default({
      initState: initState.TransactionController || initState.TransactionManager,
      getPermittedAccounts: this.getPermittedAccounts.bind(this),
      getProviderConfig: this.networkController.getProviderConfig.bind(this.networkController),
      getCurrentNetworkEIP1559Compatibility: this.networkController.getEIP1559Compatibility.bind(this.networkController),
      getCurrentAccountEIP1559Compatibility: this.getCurrentAccountEIP1559Compatibility.bind(this),
      networkStore: this.networkController.networkStore,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      preferencesStore: this.preferencesController.store,
      txHistoryLimit: 60,
      signTransaction: this.keyringController.signTransaction.bind(this.keyringController),
      provider: this.provider,
      blockTracker: this.blockTracker,
      createEventFragment: this.metaMetricsController.createEventFragment.bind(this.metaMetricsController),
      updateEventFragment: this.metaMetricsController.updateEventFragment.bind(this.metaMetricsController),
      finalizeEventFragment: this.metaMetricsController.finalizeEventFragment.bind(this.metaMetricsController),
      getEventFragmentById: this.metaMetricsController.getEventFragmentById.bind(this.metaMetricsController),
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getParticipateInMetrics: () => this.metaMetricsController.state.participateInMetaMetrics,
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController),
      getExternalPendingTransactions: this.getExternalPendingTransactions.bind(this),
      getAccountType: this.getAccountType.bind(this),
      getDeviceModel: this.getDeviceModel.bind(this),
      getTokenStandardAndDetails: this.assetsContractController.getTokenStandardAndDetails.bind(this.assetsContractController)
    });
    this.txController.on('newUnapprovedTx', () => opts.showUserConfirmation());
    this.txController.on(`tx:status-update`, async (txId, status) => {
      if (status === _transaction.TRANSACTION_STATUSES.CONFIRMED || status === _transaction.TRANSACTION_STATUSES.FAILED) {
        const txMeta = this.txController.txStateManager.getTransaction(txId);
        const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();
        let rpcPrefs = {};

        if (txMeta.chainId) {
          var _rpcSettings$rpcPrefs;

          const rpcSettings = frequentRpcListDetail.find(rpc => txMeta.chainId === rpc.chainId);
          rpcPrefs = (_rpcSettings$rpcPrefs = rpcSettings === null || rpcSettings === void 0 ? void 0 : rpcSettings.rpcPrefs) !== null && _rpcSettings$rpcPrefs !== void 0 ? _rpcSettings$rpcPrefs : {};
        }

        this.platform.showTransactionNotification(txMeta, rpcPrefs);
        const {
          txReceipt
        } = txMeta; // if this is a transferFrom method generated from within the app it may be a collectible transfer transaction
        // in which case we will want to check and update ownership status of the transferred collectible.

        if (txMeta.type === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM && txMeta.txParams !== undefined) {
          var _getTokenIdParam, _allCollectibles$user;

          const {
            data,
            to: contractAddress,
            from: userAddress
          } = txMeta.txParams;
          const {
            chainId
          } = txMeta;
          const transactionData = (0, _transaction2.parseStandardTokenTransactionData)(data); // Sometimes the tokenId value is parsed as "_value" param. Not seeing this often any more, but still occasionally:
          // i.e. call approve() on BAYC contract - https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#writeContract, and tokenId shows up as _value,
          // not sure why since it doesn't match the ERC721 ABI spec we use to parse these transactions - https://github.com/MetaMask/metamask-eth-abis/blob/d0474308a288f9252597b7c93a3a8deaad19e1b2/src/abis/abiERC721.ts#L62.

          const transactionDataTokenId = (_getTokenIdParam = (0, _tokenUtil.getTokenIdParam)(transactionData)) !== null && _getTokenIdParam !== void 0 ? _getTokenIdParam : (0, _metamaskControllerUtils.getTokenValueParam)(transactionData);
          const {
            allCollectibles
          } = this.collectiblesController.state; // check if its a known collectible

          const knownCollectible = allCollectibles === null || allCollectibles === void 0 ? void 0 : (_allCollectibles$user = allCollectibles[userAddress]) === null || _allCollectibles$user === void 0 ? void 0 : _allCollectibles$user[chainId].find(({
            address,
            tokenId
          }) => (0, _stringUtils.isEqualCaseInsensitive)(address, contractAddress) && tokenId === transactionDataTokenId); // if it is we check and update ownership status.

          if (knownCollectible) {
            this.collectiblesController.checkAndUpdateSingleCollectibleOwnershipStatus(knownCollectible, false, {
              userAddress,
              chainId
            });
          }
        }

        const metamaskState = await this.getState();

        if (txReceipt && txReceipt.status === '0x0') {
          var _txMeta$simulationFai;

          this.metaMetricsController.trackEvent({
            event: 'Tx Status Update: On-Chain Failure',
            category: _metametrics.EVENT.CATEGORIES.BACKGROUND,
            properties: {
              action: 'Transactions',
              errorMessage: (_txMeta$simulationFai = txMeta.simulationFails) === null || _txMeta$simulationFai === void 0 ? void 0 : _txMeta$simulationFai.reason,
              numberOfTokens: metamaskState.tokens.length,
              numberOfAccounts: Object.keys(metamaskState.accounts).length
            }
          }, {
            matomoEvent: true
          });
        }
      }
    });
    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_DID_CHANGE, async () => {
      const {
        ticker
      } = this.networkController.getProviderConfig();

      try {
        await this.currencyRateController.setNativeCurrency(ticker);
      } catch (error) {
        // TODO: Handle failure to get conversion rate more gracefully
        console.error(error);
      }
    });
    this.networkController.lookupNetwork();
    this.messageManager = new _messageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.personalMessageManager = new _personalMessageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.decryptMessageManager = new _decryptMessageManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.encryptionPublicKeyManager = new _encryptionPublicKeyManager.default({
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.typedMessageManager = new _typedMessageManager.default({
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      metricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    });
    this.swapsController = new _swaps2.default({
      getBufferedGasLimit: this.txController.txGasUtil.getBufferedGasLimit.bind(this.txController.txGasUtil),
      networkController: this.networkController,
      provider: this.provider,
      getProviderConfig: this.networkController.getProviderConfig.bind(this.networkController),
      getTokenRatesState: () => this.tokenRatesController.state,
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      getEIP1559GasFeeEstimates: this.gasFeeController.fetchGasFeeEstimates.bind(this.gasFeeController)
    });
    this.smartTransactionsController = new _smartTransactionsController.default({
      onNetworkStateChange: this.networkController.store.subscribe.bind(this.networkController.store),
      getNetwork: this.networkController.getNetworkState.bind(this.networkController),
      getNonceLock: this.txController.nonceTracker.getNonceLock.bind(this.txController.nonceTracker),
      confirmExternalTransaction: this.txController.confirmExternalTransaction.bind(this.txController),
      provider: this.provider,
      trackMetaMetricsEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController)
    }, {
      supportedChainIds: [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI]
    }, initState.SmartTransactionsController); // ensure accountTracker updates balances after network change

    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_DID_CHANGE, () => {
      this.accountTracker._updateAccounts();
    }); // clear unapproved transactions and messages when the network will change

    this.networkController.on(_network2.NETWORK_EVENTS.NETWORK_WILL_CHANGE, () => {
      this.txController.txStateManager.clearUnapprovedTxs();
      this.encryptionPublicKeyManager.clearUnapproved();
      this.personalMessageManager.clearUnapproved();
      this.typedMessageManager.clearUnapproved();
      this.decryptMessageManager.clearUnapproved();
      this.messageManager.clearUnapproved();
    }); // ensure isClientOpenAndUnlocked is updated when memState updates

    this.on('update', memState => this._onStateUpdate(memState));
    this.store.updateStructure({
      AppStateController: this.appStateController.store,
      TransactionController: this.txController.store,
      KeyringController: this.keyringController.store,
      PreferencesController: this.preferencesController.store,
      MetaMetricsController: this.metaMetricsController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      NetworkController: this.networkController.store,
      CachedBalancesController: this.cachedBalancesController.store,
      AlertController: this.alertController.store,
      OnboardingController: this.onboardingController.store,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      PermissionController: this.permissionController,
      PermissionLogController: this.permissionLogController.store,
      SubjectMetadataController: this.subjectMetadataController,
      BackupController: this.backupController,
      AnnouncementController: this.announcementController,
      GasFeeController: this.gasFeeController,
      TokenListController: this.tokenListController,
      TokensController: this.tokensController,
      SmartTransactionsController: this.smartTransactionsController,
      CollectiblesController: this.collectiblesController
    });
    this.memStore = new _ComposableObservableStore.default({
      config: {
        AppStateController: this.appStateController.store,
        NetworkController: this.networkController.store,
        AccountTracker: this.accountTracker.store,
        TxController: this.txController.memStore,
        CachedBalancesController: this.cachedBalancesController.store,
        TokenRatesController: this.tokenRatesController,
        MessageManager: this.messageManager.memStore,
        PersonalMessageManager: this.personalMessageManager.memStore,
        DecryptMessageManager: this.decryptMessageManager.memStore,
        EncryptionPublicKeyManager: this.encryptionPublicKeyManager.memStore,
        TypesMessageManager: this.typedMessageManager.memStore,
        KeyringController: this.keyringController.memStore,
        PreferencesController: this.preferencesController.store,
        MetaMetricsController: this.metaMetricsController.store,
        AddressBookController: this.addressBookController,
        CurrencyController: this.currencyRateController,
        AlertController: this.alertController.store,
        OnboardingController: this.onboardingController.store,
        IncomingTransactionsController: this.incomingTransactionsController.store,
        PermissionController: this.permissionController,
        PermissionLogController: this.permissionLogController.store,
        SubjectMetadataController: this.subjectMetadataController,
        BackupController: this.backupController,
        SwapsController: this.swapsController.store,
        EnsController: this.ensController.store,
        ApprovalController: this.approvalController,
        AnnouncementController: this.announcementController,
        GasFeeController: this.gasFeeController,
        TokenListController: this.tokenListController,
        TokensController: this.tokensController,
        SmartTransactionsController: this.smartTransactionsController,
        CollectiblesController: this.collectiblesController
      },
      controllerMessenger: this.controllerMessenger
    });
    this.memStore.subscribe(this.sendUpdate.bind(this));
    const password = (_process$env$CONF = {"PASSWORD":"METAMASK PASSWORD","INFURA_PROJECT_ID":"bde1e349aa3c4803a5c3a71f5623ecce","SEGMENT_WRITE_KEY":"","ONBOARDING_V2":"","SWAPS_USE_DEV_APIS":"","COLLECTIBLES_V1":"","PUBNUB_PUB_KEY":"","PUBNUB_SUB_KEY":"","TOKEN_ALLOWANCE_IMPROVEMENTS":"","PORTFOLIO_URL":"","SIWE_V1":"","PHISHING_WARNING_PAGE_URL":""}) === null || _process$env$CONF === void 0 ? void 0 : _process$env$CONF.PASSWORD;

    if (password && !this.isUnlocked() && this.onboardingController.store.getState().completedOnboarding) {
      this.submitPassword(password);
    } // Lazily update the store with the current extension environment


    this.extension.runtime.getPlatformInfo().then(({
      os
    }) => {
      this.appStateController.setBrowserEnvironment(os, // This method is presently only supported by Firefox
      this.extension.runtime.getBrowserInfo === undefined ? 'chrome' : 'firefox');
    });
    this.setupControllerEventSubscriptions(); // For more information about these legacy streams, see here:
    // https://github.com/MetaMask/metamask-extension/issues/15491
    // TODO:LegacyProvider: Delete

    this.publicConfigStore = this.createPublicConfigStore(); // Multiple MetaMask instances launched warning

    this.extension.runtime.onMessageExternal.addListener(_detectMultipleInstances.onMessageReceived); // Fire a ping message to check if other extensions are running

    (0, _detectMultipleInstances.checkForMultipleVersionsRunning)();
  }
  /**
   * Sets up BaseController V2 event subscriptions. Currently, this includes
   * the subscriptions necessary to notify permission subjects of account
   * changes.
   *
   * Some of the subscriptions in this method are ControllerMessenger selector
   * event subscriptions. See the relevant @metamask/controllers documentation
   * for more information.
   *
   * Note that account-related notifications emitted when the extension
   * becomes unlocked are handled in MetaMaskController._onUnlock.
   */


  setupControllerEventSubscriptions() {
    const handleAccountsChange = async (origin, newAccounts) => {
      if (this.isUnlocked()) {
        this.notifyConnections(origin, {
          method: _permissions2.NOTIFICATION_NAMES.accountsChanged,
          // This should be the same as the return value of `eth_accounts`,
          // namely an array of the current / most recently selected Ethereum
          // account.
          params: newAccounts.length < 2 ? // If the length is 1 or 0, the accounts are sorted by definition.
          newAccounts : // If the length is 2 or greater, we have to execute
          // `eth_accounts` vi this method.
          await this.getPermittedAccounts(origin)
        });
      }

      this.permissionLogController.updateAccountsHistory(origin, newAccounts);
    }; // This handles account changes whenever the selected address changes.


    let lastSelectedAddress;
    this.preferencesController.store.subscribe(async ({
      selectedAddress
    }) => {
      if (selectedAddress && selectedAddress !== lastSelectedAddress) {
        lastSelectedAddress = selectedAddress;
        const permittedAccountsMap = (0, _permissions2.getPermittedAccountsByOrigin)(this.permissionController.state);

        for (const [origin, accounts] of permittedAccountsMap.entries()) {
          if (accounts.includes(selectedAddress)) {
            handleAccountsChange(origin, accounts);
          }
        }
      }
    }); // This handles account changes every time relevant permission state
    // changes, for any reason.

    this.controllerMessenger.subscribe(`${this.permissionController.name}:stateChange`, async (currentValue, previousValue) => {
      const changedAccounts = (0, _permissions2.getChangedAccounts)(currentValue, previousValue);

      for (const [origin, accounts] of changedAccounts.entries()) {
        handleAccountsChange(origin, accounts);
      }
    }, _permissions2.getPermittedAccountsByOrigin);
  }
  /**
   * Constructor helper: initialize a provider.
   */


  initializeProvider() {
    const version = this.platform.getVersion();
    const providerOpts = {
      static: {
        eth_syncing: false,
        web3_clientVersion: `MetaMask/v${version}`
      },
      version,
      // account mgmt
      getAccounts: async ({
        origin
      }, {
        suppressUnauthorizedError = true
      } = {}) => {
        if (origin === _app.ORIGIN_METAMASK) {
          const selectedAddress = this.preferencesController.getSelectedAddress();
          return selectedAddress ? [selectedAddress] : [];
        } else if (this.isUnlocked()) {
          return await this.getPermittedAccounts(origin, {
            suppressUnauthorizedError
          });
        }

        return []; // changing this is a breaking change
      },
      // tx signing
      processTransaction: this.newUnapprovedTransaction.bind(this),
      // msg signing
      processEthSignMessage: this.newUnsignedMessage.bind(this),
      processTypedMessage: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV3: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV4: this.newUnsignedTypedMessage.bind(this),
      processPersonalMessage: this.newUnsignedPersonalMessage.bind(this),
      processDecryptMessage: this.newRequestDecryptMessage.bind(this),
      processEncryptionPublicKey: this.newRequestEncryptionPublicKey.bind(this),
      getPendingNonce: this.getPendingNonce.bind(this),
      getPendingTransactionByHash: hash => this.txController.getTransactions({
        searchCriteria: {
          hash,
          status: _transaction.TRANSACTION_STATUSES.SUBMITTED
        }
      })[0]
    };
    const providerProxy = this.networkController.initializeProvider(providerOpts);
    return providerProxy;
  }
  /**
   * TODO:LegacyProvider: Delete
   * Constructor helper: initialize a public config store.
   * This store is used to make some config info available to Dapps synchronously.
   */


  createPublicConfigStore() {
    // subset of state for metamask inpage provider
    const publicConfigStore = new _obsStore.ObservableStore();
    const {
      networkController
    } = this; // setup memStore subscription hooks

    this.on('update', updatePublicConfigStore);
    updatePublicConfigStore(this.getState());

    function updatePublicConfigStore(memState) {
      const chainId = networkController.getCurrentChainId();

      if (memState.network !== 'loading') {
        publicConfigStore.putState(selectPublicState(chainId, memState));
      }
    }

    function selectPublicState(chainId, {
      isUnlocked,
      network
    }) {
      return {
        isUnlocked,
        chainId,
        networkVersion: network
      };
    }

    return publicConfigStore;
  }
  /**
   * Gets relevant state for the provider of an external origin.
   *
   * @param {string} origin - The origin to get the provider state for.
   * @returns {Promise<{
   *  isUnlocked: boolean,
   *  networkVersion: string,
   *  chainId: string,
   *  accounts: string[],
   * }>} An object with relevant state properties.
   */


  async getProviderState(origin) {
    return {
      isUnlocked: this.isUnlocked(),
      ...this.getProviderNetworkState(),
      accounts: await this.getPermittedAccounts(origin)
    };
  }
  /**
   * Gets network state relevant for external providers.
   *
   * @param {object} [memState] - The MetaMask memState. If not provided,
   * this function will retrieve the most recent state.
   * @returns {object} An object with relevant network state properties.
   */


  getProviderNetworkState(memState) {
    const {
      network
    } = memState || this.getState();
    return {
      chainId: this.networkController.getCurrentChainId(),
      networkVersion: network
    };
  } //=============================================================================
  // EXPOSED TO THE UI SUBSYSTEM
  //=============================================================================

  /**
   * The metamask-state of the various controllers, made available to the UI
   *
   * @returns {object} status
   */


  getState() {
    const {
      vault
    } = this.keyringController.store.getState();
    const isInitialized = Boolean(vault);
    return {
      isInitialized,
      ...this.memStore.getFlatState()
    };
  }
  /**
   * Returns an Object containing API Callback Functions.
   * These functions are the interface for the UI.
   * The API object can be transmitted over a stream via JSON-RPC.
   *
   * @returns {object} Object containing API functions.
   */


  getApi() {
    const {
      addressBookController,
      alertController,
      appStateController,
      collectiblesController,
      collectibleDetectionController,
      currencyRateController,
      detectTokensController,
      ensController,
      gasFeeController,
      keyringController,
      metaMetricsController,
      networkController,
      announcementController,
      onboardingController,
      permissionController,
      preferencesController,
      qrHardwareKeyring,
      swapsController,
      tokensController,
      smartTransactionsController,
      txController,
      assetsContractController,
      backupController
    } = this;
    return {
      // etc
      getState: this.getState.bind(this),
      setCurrentCurrency: currencyRateController.setCurrentCurrency.bind(currencyRateController),
      setUseBlockie: preferencesController.setUseBlockie.bind(preferencesController),
      setUseNonceField: preferencesController.setUseNonceField.bind(preferencesController),
      setUsePhishDetect: preferencesController.setUsePhishDetect.bind(preferencesController),
      setUseTokenDetection: preferencesController.setUseTokenDetection.bind(preferencesController),
      setUseCollectibleDetection: preferencesController.setUseCollectibleDetection.bind(preferencesController),
      setOpenSeaEnabled: preferencesController.setOpenSeaEnabled.bind(preferencesController),
      setIpfsGateway: preferencesController.setIpfsGateway.bind(preferencesController),
      setParticipateInMetaMetrics: metaMetricsController.setParticipateInMetaMetrics.bind(metaMetricsController),
      setCurrentLocale: preferencesController.setCurrentLocale.bind(preferencesController),
      markPasswordForgotten: this.markPasswordForgotten.bind(this),
      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
      getRequestAccountTabIds: this.getRequestAccountTabIds,
      getOpenMetamaskTabsIds: this.getOpenMetamaskTabsIds,
      markNotificationPopupAsAutomaticallyClosed: () => this.notificationManager.markAsAutomaticallyClosed(),
      // primary HD keyring management
      addNewAccount: this.addNewAccount.bind(this),
      verifySeedPhrase: this.verifySeedPhrase.bind(this),
      resetAccount: this.resetAccount.bind(this),
      removeAccount: this.removeAccount.bind(this),
      importAccountWithStrategy: this.importAccountWithStrategy.bind(this),
      // hardware wallets
      connectHardware: this.connectHardware.bind(this),
      forgetDevice: this.forgetDevice.bind(this),
      checkHardwareStatus: this.checkHardwareStatus.bind(this),
      unlockHardwareWalletAccount: this.unlockHardwareWalletAccount.bind(this),
      setLedgerTransportPreference: this.setLedgerTransportPreference.bind(this),
      attemptLedgerTransportCreation: this.attemptLedgerTransportCreation.bind(this),
      establishLedgerTransportPreference: this.establishLedgerTransportPreference.bind(this),
      // qr hardware devices
      submitQRHardwareCryptoHDKey: qrHardwareKeyring.submitCryptoHDKey.bind(qrHardwareKeyring),
      submitQRHardwareCryptoAccount: qrHardwareKeyring.submitCryptoAccount.bind(qrHardwareKeyring),
      cancelSyncQRHardware: qrHardwareKeyring.cancelSync.bind(qrHardwareKeyring),
      submitQRHardwareSignature: qrHardwareKeyring.submitSignature.bind(qrHardwareKeyring),
      cancelQRHardwareSignRequest: qrHardwareKeyring.cancelSignRequest.bind(qrHardwareKeyring),
      // mobile
      fetchInfoToSync: this.fetchInfoToSync.bind(this),
      // vault management
      submitPassword: this.submitPassword.bind(this),
      verifyPassword: this.verifyPassword.bind(this),
      // network management
      setProviderType: networkController.setProviderType.bind(networkController),
      rollbackToPreviousProvider: networkController.rollbackToPreviousProvider.bind(networkController),
      setCustomRpc: this.setCustomRpc.bind(this),
      updateAndSetCustomRpc: this.updateAndSetCustomRpc.bind(this),
      delCustomRpc: this.delCustomRpc.bind(this),
      addCustomNetwork: this.addCustomNetwork.bind(this),
      requestAddNetworkApproval: this.requestAddNetworkApproval.bind(this),
      // PreferencesController
      setSelectedAddress: preferencesController.setSelectedAddress.bind(preferencesController),
      addToken: tokensController.addToken.bind(tokensController),
      rejectWatchAsset: tokensController.rejectWatchAsset.bind(tokensController),
      acceptWatchAsset: tokensController.acceptWatchAsset.bind(tokensController),
      updateTokenType: tokensController.updateTokenType.bind(tokensController),
      setAccountLabel: preferencesController.setAccountLabel.bind(preferencesController),
      setFeatureFlag: preferencesController.setFeatureFlag.bind(preferencesController),
      setPreference: preferencesController.setPreference.bind(preferencesController),
      addKnownMethodData: preferencesController.addKnownMethodData.bind(preferencesController),
      setDismissSeedBackUpReminder: preferencesController.setDismissSeedBackUpReminder.bind(preferencesController),
      setAdvancedGasFee: preferencesController.setAdvancedGasFee.bind(preferencesController),
      setEIP1559V2Enabled: preferencesController.setEIP1559V2Enabled.bind(preferencesController),
      setTheme: preferencesController.setTheme.bind(preferencesController),
      setImprovedTokenAllowanceEnabled: preferencesController.setImprovedTokenAllowanceEnabled.bind(preferencesController),
      // AssetsContractController
      getTokenStandardAndDetails: this.getTokenStandardAndDetails.bind(this),
      // CollectiblesController
      addCollectible: collectiblesController.addCollectible.bind(collectiblesController),
      addCollectibleVerifyOwnership: collectiblesController.addCollectibleVerifyOwnership.bind(collectiblesController),
      removeAndIgnoreCollectible: collectiblesController.removeAndIgnoreCollectible.bind(collectiblesController),
      removeCollectible: collectiblesController.removeCollectible.bind(collectiblesController),
      checkAndUpdateAllCollectiblesOwnershipStatus: collectiblesController.checkAndUpdateAllCollectiblesOwnershipStatus.bind(collectiblesController),
      checkAndUpdateSingleCollectibleOwnershipStatus: collectiblesController.checkAndUpdateSingleCollectibleOwnershipStatus.bind(collectiblesController),
      isCollectibleOwner: collectiblesController.isCollectibleOwner.bind(collectiblesController),
      // AddressController
      setAddressBook: addressBookController.set.bind(addressBookController),
      removeFromAddressBook: addressBookController.delete.bind(addressBookController),
      // AppStateController
      setLastActiveTime: appStateController.setLastActiveTime.bind(appStateController),
      setDefaultHomeActiveTabName: appStateController.setDefaultHomeActiveTabName.bind(appStateController),
      setConnectedStatusPopoverHasBeenShown: appStateController.setConnectedStatusPopoverHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderHasBeenShown: appStateController.setRecoveryPhraseReminderHasBeenShown.bind(appStateController),
      setRecoveryPhraseReminderLastShown: appStateController.setRecoveryPhraseReminderLastShown.bind(appStateController),
      setShowTestnetMessageInDropdown: appStateController.setShowTestnetMessageInDropdown.bind(appStateController),
      setShowPortfolioTooltip: appStateController.setShowPortfolioTooltip.bind(appStateController),
      setCollectiblesDetectionNoticeDismissed: appStateController.setCollectiblesDetectionNoticeDismissed.bind(appStateController),
      setEnableEIP1559V2NoticeDismissed: appStateController.setEnableEIP1559V2NoticeDismissed.bind(appStateController),
      updateCollectibleDropDownState: appStateController.updateCollectibleDropDownState.bind(appStateController),
      setFirstTimeUsedNetwork: appStateController.setFirstTimeUsedNetwork.bind(appStateController),
      // EnsController
      tryReverseResolveAddress: ensController.reverseResolveAddress.bind(ensController),
      // KeyringController
      setLocked: this.setLocked.bind(this),
      createNewVaultAndKeychain: this.createNewVaultAndKeychain.bind(this),
      createNewVaultAndRestore: this.createNewVaultAndRestore.bind(this),
      exportAccount: keyringController.exportAccount.bind(keyringController),
      // txController
      cancelTransaction: txController.cancelTransaction.bind(txController),
      updateTransaction: txController.updateTransaction.bind(txController),
      updateAndApproveTransaction: txController.updateAndApproveTransaction.bind(txController),
      approveTransactionsWithSameNonce: txController.approveTransactionsWithSameNonce.bind(txController),
      createCancelTransaction: this.createCancelTransaction.bind(this),
      createSpeedUpTransaction: this.createSpeedUpTransaction.bind(this),
      estimateGas: this.estimateGas.bind(this),
      getNextNonce: this.getNextNonce.bind(this),
      addUnapprovedTransaction: txController.addUnapprovedTransaction.bind(txController),
      createTransactionEventFragment: txController.createTransactionEventFragment.bind(txController),
      getTransactions: txController.getTransactions.bind(txController),
      updateEditableParams: txController.updateEditableParams.bind(txController),
      updateTransactionGasFees: txController.updateTransactionGasFees.bind(txController),
      updateTransactionSendFlowHistory: txController.updateTransactionSendFlowHistory.bind(txController),
      updateSwapApprovalTransaction: txController.updateSwapApprovalTransaction.bind(txController),
      updateSwapTransaction: txController.updateSwapTransaction.bind(txController),
      updatePreviousGasParams: txController.updatePreviousGasParams.bind(txController),
      // messageManager
      signMessage: this.signMessage.bind(this),
      cancelMessage: this.cancelMessage.bind(this),
      // personalMessageManager
      signPersonalMessage: this.signPersonalMessage.bind(this),
      cancelPersonalMessage: this.cancelPersonalMessage.bind(this),
      // typedMessageManager
      signTypedMessage: this.signTypedMessage.bind(this),
      cancelTypedMessage: this.cancelTypedMessage.bind(this),
      // decryptMessageManager
      decryptMessage: this.decryptMessage.bind(this),
      decryptMessageInline: this.decryptMessageInline.bind(this),
      cancelDecryptMessage: this.cancelDecryptMessage.bind(this),
      // EncryptionPublicKeyManager
      encryptionPublicKey: this.encryptionPublicKey.bind(this),
      cancelEncryptionPublicKey: this.cancelEncryptionPublicKey.bind(this),
      // onboarding controller
      setSeedPhraseBackedUp: onboardingController.setSeedPhraseBackedUp.bind(onboardingController),
      completeOnboarding: onboardingController.completeOnboarding.bind(onboardingController),
      setFirstTimeFlowType: onboardingController.setFirstTimeFlowType.bind(onboardingController),
      // alert controller
      setAlertEnabledness: alertController.setAlertEnabledness.bind(alertController),
      setUnconnectedAccountAlertShown: alertController.setUnconnectedAccountAlertShown.bind(alertController),
      setWeb3ShimUsageAlertDismissed: alertController.setWeb3ShimUsageAlertDismissed.bind(alertController),
      // permissions
      removePermissionsFor: this.removePermissionsFor,
      approvePermissionsRequest: this.acceptPermissionsRequest,
      rejectPermissionsRequest: this.rejectPermissionsRequest,
      ...(0, _permissions2.getPermissionBackgroundApiMethods)(permissionController),
      // swaps
      fetchAndSetQuotes: swapsController.fetchAndSetQuotes.bind(swapsController),
      setSelectedQuoteAggId: swapsController.setSelectedQuoteAggId.bind(swapsController),
      resetSwapsState: swapsController.resetSwapsState.bind(swapsController),
      setSwapsTokens: swapsController.setSwapsTokens.bind(swapsController),
      clearSwapsQuotes: swapsController.clearSwapsQuotes.bind(swapsController),
      setApproveTxId: swapsController.setApproveTxId.bind(swapsController),
      setTradeTxId: swapsController.setTradeTxId.bind(swapsController),
      setSwapsTxGasPrice: swapsController.setSwapsTxGasPrice.bind(swapsController),
      setSwapsTxGasLimit: swapsController.setSwapsTxGasLimit.bind(swapsController),
      setSwapsTxMaxFeePerGas: swapsController.setSwapsTxMaxFeePerGas.bind(swapsController),
      setSwapsTxMaxFeePriorityPerGas: swapsController.setSwapsTxMaxFeePriorityPerGas.bind(swapsController),
      safeRefetchQuotes: swapsController.safeRefetchQuotes.bind(swapsController),
      stopPollingForQuotes: swapsController.stopPollingForQuotes.bind(swapsController),
      setBackgroundSwapRouteState: swapsController.setBackgroundSwapRouteState.bind(swapsController),
      resetPostFetchState: swapsController.resetPostFetchState.bind(swapsController),
      setSwapsErrorKey: swapsController.setSwapsErrorKey.bind(swapsController),
      setInitialGasEstimate: swapsController.setInitialGasEstimate.bind(swapsController),
      setCustomApproveTxData: swapsController.setCustomApproveTxData.bind(swapsController),
      setSwapsLiveness: swapsController.setSwapsLiveness.bind(swapsController),
      setSwapsFeatureFlags: swapsController.setSwapsFeatureFlags.bind(swapsController),
      setSwapsUserFeeLevel: swapsController.setSwapsUserFeeLevel.bind(swapsController),
      setSwapsQuotesPollingLimitEnabled: swapsController.setSwapsQuotesPollingLimitEnabled.bind(swapsController),
      // Smart Transactions
      setSmartTransactionsOptInStatus: smartTransactionsController.setOptInState.bind(smartTransactionsController),
      fetchSmartTransactionFees: smartTransactionsController.getFees.bind(smartTransactionsController),
      clearSmartTransactionFees: smartTransactionsController.clearFees.bind(smartTransactionsController),
      submitSignedTransactions: smartTransactionsController.submitSignedTransactions.bind(smartTransactionsController),
      cancelSmartTransaction: smartTransactionsController.cancelSmartTransaction.bind(smartTransactionsController),
      fetchSmartTransactionsLiveness: smartTransactionsController.fetchLiveness.bind(smartTransactionsController),
      updateSmartTransaction: smartTransactionsController.updateSmartTransaction.bind(smartTransactionsController),
      setStatusRefreshInterval: smartTransactionsController.setStatusRefreshInterval.bind(smartTransactionsController),
      // MetaMetrics
      trackMetaMetricsEvent: metaMetricsController.trackEvent.bind(metaMetricsController),
      trackMetaMetricsPage: metaMetricsController.trackPage.bind(metaMetricsController),
      createEventFragment: metaMetricsController.createEventFragment.bind(metaMetricsController),
      updateEventFragment: metaMetricsController.updateEventFragment.bind(metaMetricsController),
      finalizeEventFragment: metaMetricsController.finalizeEventFragment.bind(metaMetricsController),
      // approval controller
      resolvePendingApproval: this.resolvePendingApproval,
      rejectPendingApproval: this.rejectPendingApproval,
      // Notifications
      updateViewedNotifications: announcementController.updateViewed.bind(announcementController),
      // GasFeeController
      getGasFeeEstimatesAndStartPolling: gasFeeController.getGasFeeEstimatesAndStartPolling.bind(gasFeeController),
      disconnectGasFeeEstimatePoller: gasFeeController.disconnectPoller.bind(gasFeeController),
      getGasFeeTimeEstimate: gasFeeController.getTimeEstimate.bind(gasFeeController),
      addPollingTokenToAppState: appStateController.addPollingToken.bind(appStateController),
      removePollingTokenFromAppState: appStateController.removePollingToken.bind(appStateController),
      // BackupController
      backupUserData: backupController.backupUserData.bind(backupController),
      restoreUserData: backupController.restoreUserData.bind(backupController),
      // DetectTokenController
      detectNewTokens: detectTokensController.detectNewTokens.bind(detectTokensController),
      // DetectCollectibleController
      detectCollectibles: false ? collectibleDetectionController.detectCollectibles.bind(collectibleDetectionController) : null,

      /** Token Detection V2 */
      addDetectedTokens: tokensController.addDetectedTokens.bind(tokensController),
      addImportedTokens: tokensController.addTokens.bind(tokensController),
      ignoreTokens: tokensController.ignoreTokens.bind(tokensController),
      getBalancesInSingleCall: assetsContractController.getBalancesInSingleCall.bind(assetsContractController)
    };
  }

  async getTokenStandardAndDetails(address, userAddress, tokenId) {
    var _details$decimals, _details$balance;

    const details = await this.assetsContractController.getTokenStandardAndDetails(address, userAddress, tokenId);
    return { ...details,
      decimals: details === null || details === void 0 ? void 0 : (_details$decimals = details.decimals) === null || _details$decimals === void 0 ? void 0 : _details$decimals.toString(10),
      balance: details === null || details === void 0 ? void 0 : (_details$balance = details.balance) === null || _details$balance === void 0 ? void 0 : _details$balance.toString(10)
    };
  } //=============================================================================
  // VAULT / KEYRING RELATED METHODS
  //=============================================================================

  /**
   * Creates a new Vault and create a new keychain.
   *
   * A vault, or KeyringController, is a controller that contains
   * many different account strategies, currently called Keyrings.
   * Creating it new means wiping all previous keyrings.
   *
   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.
   * For example, a mnemonic phrase can generate many accounts, and is a keyring.
   *
   * @param {string} password
   * @returns {object} vault
   */


  async createNewVaultAndKeychain(password) {
    const releaseLock = await this.createVaultMutex.acquire();

    try {
      let vault;
      const accounts = await this.keyringController.getAccounts();

      if (accounts.length > 0) {
        vault = await this.keyringController.fullUpdate();
      } else {
        vault = await this.keyringController.createNewVaultAndKeychain(password);
        const addresses = await this.keyringController.getAccounts();
        this.preferencesController.setAddresses(addresses);
        this.selectFirstIdentity();
      }

      return vault;
    } finally {
      releaseLock();
    }
  }

  async requestAddNetworkApproval(customRpc, originIsMetaMask) {
    try {
      await this.approvalController.addAndShowApprovalRequest({
        origin: 'metamask',
        type: 'wallet_addEthereumChain',
        requestData: {
          chainId: customRpc.chainId,
          blockExplorerUrl: customRpc.rpcPrefs.blockExplorerUrl,
          chainName: customRpc.nickname,
          rpcUrl: customRpc.rpcUrl,
          ticker: customRpc.ticker,
          imageUrl: customRpc.rpcPrefs.imageUrl
        }
      });
    } catch (error) {
      if (!(originIsMetaMask && error.message === 'User rejected the request.')) {
        throw error;
      }
    }
  }

  async addCustomNetwork(customRpc, actionId) {
    const {
      chainId,
      chainName,
      rpcUrl,
      ticker,
      blockExplorerUrl
    } = customRpc;
    await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, chainName, {
      blockExplorerUrl
    });
    let rpcUrlOrigin;

    try {
      rpcUrlOrigin = new URL(rpcUrl).origin;
    } catch {// ignore
    }

    this.metaMetricsController.trackEvent({
      event: 'Custom Network Added',
      category: _metametrics.EVENT.CATEGORIES.NETWORK,
      referrer: {
        url: rpcUrlOrigin
      },
      properties: {
        chain_id: chainId,
        network_name: chainName,
        network: rpcUrlOrigin,
        symbol: ticker,
        block_explorer_url: blockExplorerUrl,
        source: _metametrics.EVENT.SOURCE.NETWORK.POPULAR_NETWORK_LIST
      },
      sensitiveProperties: {
        rpc_url: rpcUrlOrigin
      },
      actionId
    });
  }
  /**
   * Create a new Vault and restore an existent keyring.
   *
   * @param {string} password
   * @param {number[]} encodedSeedPhrase - The seed phrase, encoded as an array
   * of UTF-8 bytes.
   */


  async createNewVaultAndRestore(password, encodedSeedPhrase) {
    const releaseLock = await this.createVaultMutex.acquire();

    try {
      let accounts, lastBalance;
      const seedPhraseAsBuffer = Buffer.from(encodedSeedPhrase);
      const {
        keyringController
      } = this; // clear known identities

      this.preferencesController.setAddresses([]); // clear permissions

      this.permissionController.clearState(); // clear accounts in accountTracker

      this.accountTracker.clearAccounts(); // clear cachedBalances

      this.cachedBalancesController.clearCachedBalances(); // clear unapproved transactions

      this.txController.txStateManager.clearUnapprovedTxs(); // create new vault

      const vault = await keyringController.createNewVaultAndRestore(password, seedPhraseAsBuffer);
      const ethQuery = new _ethQuery.default(this.provider);
      accounts = await keyringController.getAccounts();
      lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      const [primaryKeyring] = keyringController.getKeyringsByType('HD Key Tree');

      if (!primaryKeyring) {
        throw new Error('MetamaskController - No HD Key Tree found');
      } // seek out the first zero balance


      while (lastBalance !== '0x0') {
        await keyringController.addNewAccount(primaryKeyring);
        accounts = await keyringController.getAccounts();
        lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery);
      } // remove extra zero balance account potentially created from seeking ahead


      if (accounts.length > 1 && lastBalance === '0x0') {
        await this.removeAccount(accounts[accounts.length - 1]);
        accounts = await keyringController.getAccounts();
      } // This must be set as soon as possible to communicate to the
      // keyring's iframe and have the setting initialized properly
      // Optimistically called to not block MetaMask login due to
      // Ledger Keyring GitHub downtime


      const transportPreference = this.preferencesController.getLedgerTransportPreference();
      this.setLedgerTransportPreference(transportPreference); // set new identities

      this.preferencesController.setAddresses(accounts);
      this.selectFirstIdentity();
      return vault;
    } finally {
      releaseLock();
    }
  }
  /**
   * Get an account balance from the AccountTracker or request it directly from the network.
   *
   * @param {string} address - The account address
   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network
   */


  getBalance(address, ethQuery) {
    return new Promise((resolve, reject) => {
      const cached = this.accountTracker.store.getState().accounts[address];

      if (cached && cached.balance) {
        resolve(cached.balance);
      } else {
        ethQuery.getBalance(address, (error, balance) => {
          if (error) {
            reject(error);

            _loglevel.default.error(error);
          } else {
            resolve(balance || '0x0');
          }
        });
      }
    });
  }
  /**
   * Collects all the information that we want to share
   * with the mobile client for syncing purposes
   *
   * @returns {Promise<object>} Parts of the state that we want to syncx
   */


  async fetchInfoToSync() {
    // Preferences
    const {
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress,
      useTokenDetection
    } = this.preferencesController.store.getState();

    const isTokenDetectionInactiveInMainnet = !useTokenDetection && this.networkController.store.getState().provider.chainId === _network.CHAIN_IDS.MAINNET;

    const {
      tokenList
    } = this.tokenListController.state;
    const caseInSensitiveTokenList = isTokenDetectionInactiveInMainnet ? _tokens.STATIC_MAINNET_TOKEN_LIST : tokenList;
    const preferences = {
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress
    }; // Tokens

    const {
      allTokens,
      allIgnoredTokens
    } = this.tokensController.state; // Filter ERC20 tokens

    const allERC20Tokens = {};
    Object.keys(allTokens).forEach(chainId => {
      allERC20Tokens[chainId] = {};
      Object.keys(allTokens[chainId]).forEach(accountAddress => {
        const checksummedAccountAddress = (0, _hexstringUtils.toChecksumHexAddress)(accountAddress);
        allERC20Tokens[chainId][checksummedAccountAddress] = allTokens[chainId][checksummedAccountAddress].filter(asset => {
          if (asset.isERC721 === undefined) {
            var _asset$address;

            // the tokenList will be holding only erc20 tokens
            if (caseInSensitiveTokenList[(_asset$address = asset.address) === null || _asset$address === void 0 ? void 0 : _asset$address.toLowerCase()] !== undefined) {
              return true;
            }
          } else if (asset.isERC721 === false) {
            return true;
          }

          return false;
        });
      });
    }); // Accounts

    const [hdKeyring] = this.keyringController.getKeyringsByType('HD Key Tree');
    const simpleKeyPairKeyrings = this.keyringController.getKeyringsByType('Simple Key Pair');
    const hdAccounts = await hdKeyring.getAccounts();
    const simpleKeyPairKeyringAccounts = await Promise.all(simpleKeyPairKeyrings.map(keyring => keyring.getAccounts()));
    const simpleKeyPairAccounts = simpleKeyPairKeyringAccounts.reduce((acc, accounts) => [...acc, ...accounts], []);
    const accounts = {
      hd: hdAccounts.filter((item, pos) => hdAccounts.indexOf(item) === pos).map(address => (0, _hexstringUtils.toChecksumHexAddress)(address)),
      simpleKeyPair: simpleKeyPairAccounts.filter((item, pos) => simpleKeyPairAccounts.indexOf(item) === pos).map(address => (0, _hexstringUtils.toChecksumHexAddress)(address)),
      ledger: [],
      trezor: [],
      lattice: []
    }; // transactions

    let {
      transactions
    } = this.txController.store.getState(); // delete tx for other accounts that we're not importing

    transactions = Object.values(transactions).filter(tx => {
      const checksummedTxFrom = (0, _hexstringUtils.toChecksumHexAddress)(tx.txParams.from);
      return accounts.hd.includes(checksummedTxFrom);
    });
    return {
      accounts,
      preferences,
      transactions,
      tokens: {
        allTokens: allERC20Tokens,
        allIgnoredTokens
      },
      network: this.networkController.store.getState()
    };
  }
  /**
   * Submits the user's password and attempts to unlock the vault.
   * Also synchronizes the preferencesController, to ensure its schema
   * is up to date with known accounts once the vault is decrypted.
   *
   * @param {string} password - The user's password
   * @returns {Promise<object>} The keyringController update.
   */


  async submitPassword(password) {
    await this.keyringController.submitPassword(password);

    try {
      await this.blockTracker.checkForLatestBlock();
    } catch (error) {
      _loglevel.default.error('Error while unlocking extension.', error);
    } // This must be set as soon as possible to communicate to the
    // keyring's iframe and have the setting initialized properly
    // Optimistically called to not block MetaMask login due to
    // Ledger Keyring GitHub downtime


    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    this.setLedgerTransportPreference(transportPreference);
    return this.keyringController.fullUpdate();
  }
  /**
   * Submits a user's password to check its validity.
   *
   * @param {string} password - The user's password
   */


  async verifyPassword(password) {
    await this.keyringController.verifyPassword(password);
  }
  /**
   * @type Identity
   * @property {string} name - The account nickname.
   * @property {string} address - The account's ethereum address, in lower case.
   * receiving funds from our automatic Ropsten faucet.
   */

  /**
   * Sets the first address in the state to the selected address
   */


  selectFirstIdentity() {
    const {
      identities
    } = this.preferencesController.store.getState();
    const [address] = Object.keys(identities);
    this.preferencesController.setSelectedAddress(address);
  }
  /**
   * Gets the mnemonic of the user's primary keyring.
   */


  getPrimaryKeyringMnemonic() {
    const [keyring] = this.keyringController.getKeyringsByType('HD Key Tree');

    if (!keyring.mnemonic) {
      throw new Error('Primary keyring mnemonic unavailable.');
    }

    return keyring.mnemonic;
  } //
  // Hardware
  //


  async getKeyringForDevice(deviceName, hdPath = null) {
    let keyringName = null;

    switch (deviceName) {
      case _hardwareWallets.DEVICE_NAMES.TREZOR:
        keyringName = _ethTrezorKeyring.default.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.LEDGER:
        keyringName = _ethLedgerBridgeKeyring.default.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.QR:
        keyringName = _metamaskAirgappedKeyring.MetaMaskKeyring.type;
        break;

      case _hardwareWallets.DEVICE_NAMES.LATTICE:
        keyringName = _ethLatticeKeyring.default.type;
        break;

      default:
        throw new Error('MetamaskController:getKeyringForDevice - Unknown device');
    }

    let [keyring] = await this.keyringController.getKeyringsByType(keyringName);

    if (!keyring) {
      keyring = await this.keyringController.addNewKeyring(keyringName);
    }

    if (hdPath && keyring.setHdPath) {
      keyring.setHdPath(hdPath);
    }

    if (deviceName === _hardwareWallets.DEVICE_NAMES.LATTICE) {
      keyring.appName = 'MetaMask';
    }

    if (deviceName === _hardwareWallets.DEVICE_NAMES.TREZOR) {
      const model = keyring.getModel();
      this.appStateController.setTrezorModel(model);
    }

    keyring.network = this.networkController.getProviderConfig().type;
    return keyring;
  }

  async attemptLedgerTransportCreation() {
    const keyring = await this.getKeyringForDevice(_hardwareWallets.DEVICE_NAMES.LEDGER);
    return await keyring.attemptMakeApp();
  }

  async establishLedgerTransportPreference() {
    const transportPreference = this.preferencesController.getLedgerTransportPreference();
    return await this.setLedgerTransportPreference(transportPreference);
  }
  /**
   * Fetch account list from a trezor device.
   *
   * @param deviceName
   * @param page
   * @param hdPath
   * @returns [] accounts
   */


  async connectHardware(deviceName, page, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    let accounts = [];

    switch (page) {
      case -1:
        accounts = await keyring.getPreviousPage();
        break;

      case 1:
        accounts = await keyring.getNextPage();
        break;

      default:
        accounts = await keyring.getFirstPage();
    } // Merge with existing accounts
    // and make sure addresses are not repeated


    const oldAccounts = await this.keyringController.getAccounts();
    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))];
    this.accountTracker.syncWithAddresses(accountsToTrack);
    return accounts;
  }
  /**
   * Check if the device is unlocked
   *
   * @param deviceName
   * @param hdPath
   * @returns {Promise<boolean>}
   */


  async checkHardwareStatus(deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    return keyring.isUnlocked();
  }
  /**
   * Clear
   *
   * @param deviceName
   * @returns {Promise<boolean>}
   */


  async forgetDevice(deviceName) {
    const keyring = await this.getKeyringForDevice(deviceName);
    keyring.forgetDevice();
    return true;
  }
  /**
   * Retrieves the keyring for the selected address and using the .type returns
   * a subtype for the account. Either 'hardware', 'imported' or 'MetaMask'.
   *
   * @param {string} address - Address to retrieve keyring for
   * @returns {'hardware' | 'imported' | 'MetaMask'}
   */


  async getAccountType(address) {
    const keyring = await this.keyringController.getKeyringForAccount(address);

    switch (keyring.type) {
      case _hardwareWallets.KEYRING_TYPES.TREZOR:
      case _hardwareWallets.KEYRING_TYPES.LATTICE:
      case _hardwareWallets.KEYRING_TYPES.QR:
      case _hardwareWallets.KEYRING_TYPES.LEDGER:
        return 'hardware';

      case _hardwareWallets.KEYRING_TYPES.IMPORTED:
        return 'imported';

      default:
        return 'MetaMask';
    }
  }
  /**
   * Retrieves the keyring for the selected address and using the .type
   * determines if a more specific name for the device is available. Returns
   * 'N/A' for non hardware wallets.
   *
   * @param {string} address - Address to retrieve keyring for
   * @returns {'ledger' | 'lattice' | 'N/A' | string}
   */


  async getDeviceModel(address) {
    const keyring = await this.keyringController.getKeyringForAccount(address);

    switch (keyring.type) {
      case _hardwareWallets.KEYRING_TYPES.TREZOR:
        return keyring.getModel();

      case _hardwareWallets.KEYRING_TYPES.QR:
        return keyring.getName();

      case _hardwareWallets.KEYRING_TYPES.LEDGER:
        // TODO: get model after ledger keyring exposes method
        return _hardwareWallets.DEVICE_NAMES.LEDGER;

      case _hardwareWallets.KEYRING_TYPES.LATTICE:
        // TODO: get model after lattice keyring exposes method
        return _hardwareWallets.DEVICE_NAMES.LATTICE;

      default:
        return 'N/A';
    }
  }
  /**
   * get hardware account label
   *
   * @returns string label
   */


  getAccountLabel(name, index, hdPathDescription) {
    return `${name[0].toUpperCase()}${name.slice(1)} ${parseInt(index, 10) + 1} ${hdPathDescription || ''}`.trim();
  }
  /**
   * Imports an account from a Trezor or Ledger device.
   *
   * @param index
   * @param deviceName
   * @param hdPath
   * @param hdPathDescription
   * @returns {} keyState
   */


  async unlockHardwareWalletAccount(index, deviceName, hdPath, hdPathDescription) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath);
    keyring.setAccountToUnlock(index);
    const oldAccounts = await this.keyringController.getAccounts();
    const keyState = await this.keyringController.addNewAccount(keyring);
    const newAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(newAccounts);
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        const label = this.getAccountLabel(deviceName === _hardwareWallets.DEVICE_NAMES.QR ? keyring.getName() : deviceName, index, hdPathDescription); // Set the account label to Trezor 1 /  Ledger 1 / QR Hardware 1, etc

        this.preferencesController.setAccountLabel(address, label); // Select the account

        this.preferencesController.setSelectedAddress(address);
      }
    });
    const {
      identities
    } = this.preferencesController.store.getState();
    return { ...keyState,
      identities
    };
  } //
  // Account Management
  //

  /**
   * Adds a new account to the default (first) HD seed phrase Keyring.
   *
   * @param accountCount
   * @returns {} keyState
   */


  async addNewAccount(accountCount) {
    const [primaryKeyring] = this.keyringController.getKeyringsByType('HD Key Tree');

    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }

    const {
      keyringController
    } = this;
    const {
      identities: oldIdentities
    } = this.preferencesController.store.getState();

    if (Object.keys(oldIdentities).length === accountCount) {
      const oldAccounts = await keyringController.getAccounts();
      const keyState = await keyringController.addNewAccount(primaryKeyring);
      const newAccounts = await keyringController.getAccounts();
      await this.verifySeedPhrase();
      this.preferencesController.setAddresses(newAccounts);
      newAccounts.forEach(address => {
        if (!oldAccounts.includes(address)) {
          this.preferencesController.setSelectedAddress(address);
        }
      });
      const {
        identities
      } = this.preferencesController.store.getState();
      return { ...keyState,
        identities
      };
    }

    return { ...keyringController.memStore.getState(),
      identities: oldIdentities
    };
  }
  /**
   * Verifies the validity of the current vault's seed phrase.
   *
   * Validity: seed phrase restores the accounts belonging to the current vault.
   *
   * Called when the first account is created and on unlocking the vault.
   *
   * @returns {Promise<number[]>} The seed phrase to be confirmed by the user,
   * encoded as an array of UTF-8 bytes.
   */


  async verifySeedPhrase() {
    const [primaryKeyring] = this.keyringController.getKeyringsByType('HD Key Tree');

    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found');
    }

    const serialized = await primaryKeyring.serialize();
    const seedPhraseAsBuffer = Buffer.from(serialized.mnemonic);
    const accounts = await primaryKeyring.getAccounts();

    if (accounts.length < 1) {
      throw new Error('MetamaskController - No accounts found');
    }

    try {
      await _seedPhraseVerifier.default.verifyAccounts(accounts, seedPhraseAsBuffer);
      return Array.from(seedPhraseAsBuffer.values());
    } catch (err) {
      _loglevel.default.error(err.message);

      throw err;
    }
  }
  /**
   * Clears the transaction history, to allow users to force-reset their nonces.
   * Mostly used in development environments, when networks are restarted with
   * the same network ID.
   *
   * @returns {Promise<string>} The current selected address.
   */


  async resetAccount() {
    const selectedAddress = this.preferencesController.getSelectedAddress();
    this.txController.wipeTransactions(selectedAddress);
    this.networkController.resetConnection();
    return selectedAddress;
  }
  /**
   * Gets the permitted accounts for the specified origin. Returns an empty
   * array if no accounts are permitted.
   *
   * @param {string} origin - The origin whose exposed accounts to retrieve.
   * @param {boolean} [suppressUnauthorizedError] - Suppresses the unauthorized error.
   * @returns {Promise<string[]>} The origin's permitted accounts, or an empty
   * array.
   */


  async getPermittedAccounts(origin, {
    suppressUnauthorizedError = true
  } = {}) {
    try {
      return await this.permissionController.executeRestrictedMethod(origin, _permissions.RestrictedMethods.eth_accounts);
    } catch (error) {
      if (suppressUnauthorizedError && error.code === _ethRpcErrors.errorCodes.provider.unauthorized) {
        return [];
      }

      throw error;
    }
  }
  /**
   * Stops exposing the account with the specified address to all third parties.
   * Exposed accounts are stored in caveats of the eth_accounts permission. This
   * method uses `PermissionController.updatePermissionsByCaveat` to
   * remove the specified address from every eth_accounts permission. If a
   * permission only included this address, the permission is revoked entirely.
   *
   * @param {string} targetAccount - The address of the account to stop exposing
   * to third parties.
   */


  removeAllAccountPermissions(targetAccount) {
    this.permissionController.updatePermissionsByCaveat(_permissions.CaveatTypes.restrictReturnedAccounts, existingAccounts => _permissions2.CaveatMutatorFactories[_permissions.CaveatTypes.restrictReturnedAccounts].removeAccount(targetAccount, existingAccounts));
  }
  /**
   * Removes an account from state / storage.
   *
   * @param {string[]} address - A hex address
   */


  async removeAccount(address) {
    // Remove all associated permissions
    this.removeAllAccountPermissions(address); // Remove account from the preferences controller

    this.preferencesController.removeAddress(address); // Remove account from the account tracker controller

    this.accountTracker.removeAccount([address]);
    const keyring = await this.keyringController.getKeyringForAccount(address); // Remove account from the keyring

    await this.keyringController.removeAccount(address);
    const updatedKeyringAccounts = keyring ? await keyring.getAccounts() : {};

    if ((updatedKeyringAccounts === null || updatedKeyringAccounts === void 0 ? void 0 : updatedKeyringAccounts.length) === 0) {
      var _keyring$destroy;

      (_keyring$destroy = keyring.destroy) === null || _keyring$destroy === void 0 ? void 0 : _keyring$destroy.call(keyring);
    }

    return address;
  }
  /**
   * Imports an account with the specified import strategy.
   * These are defined in app/scripts/account-import-strategies
   * Each strategy represents a different way of serializing an Ethereum key pair.
   *
   * @param {string} strategy - A unique identifier for an account import strategy.
   * @param {any} args - The data required by that strategy to import an account.
   */


  async importAccountWithStrategy(strategy, args) {
    const privateKey = await _accountImportStrategies.default.importAccount(strategy, args);
    const keyring = await this.keyringController.addNewKeyring('Simple Key Pair', [privateKey]);
    const [firstAccount] = await keyring.getAccounts(); // update accounts in preferences controller

    const allAccounts = await this.keyringController.getAccounts();
    this.preferencesController.setAddresses(allAccounts); // set new account as selected

    await this.preferencesController.setSelectedAddress(firstAccount);
  } // ---------------------------------------------------------------------------
  // Identity Management (signature operations)

  /**
   * Called when a Dapp suggests a new tx to be signed.
   * this wrapper needs to exist so we can provide a reference to
   *  "newUnapprovedTransaction" before "txController" is instantiated
   *
   * @param {object} txParams - The transaction parameters.
   * @param {object} [req] - The original request, containing the origin.
   */


  async newUnapprovedTransaction(txParams, req) {
    return await this.txController.newUnapprovedTransaction(txParams, req);
  } // eth_sign methods:

  /**
   * Called when a Dapp uses the eth_sign method, to request user approval.
   * eth_sign is a pure signature of arbitrary data. It is on a deprecation
   * path, since this data can be a transaction, or can leak private key
   * information.
   *
   * @param {object} msgParams - The params passed to eth_sign.
   * @param {object} [req] - The original request, containing the origin.
   */


  async newUnsignedMessage(msgParams, req) {
    const data = (0, _messageManager.normalizeMsgData)(msgParams.data);
    let promise; // 64 hex + "0x" at the beginning
    // This is needed because Ethereum's EcSign works only on 32 byte numbers
    // For 67 length see: https://github.com/MetaMask/metamask-extension/pull/12679/files#r749479607

    if (data.length === 66 || data.length === 67) {
      promise = this.messageManager.addUnapprovedMessageAsync(msgParams, req);
      this.sendUpdate();
      this.opts.showUserConfirmation();
    } else {
      throw _ethRpcErrors.ethErrors.rpc.invalidParams('eth_sign requires 32 byte message hash');
    }

    return await promise;
  }
  /**
   * Signifies user intent to complete an eth_sign method.
   *
   * @param {object} msgParams - The params passed to eth_call.
   * @returns {Promise<object>} Full state update.
   */


  async signMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - signMessage');

    const msgId = msgParams.metamaskId;

    try {
      // sets the status op the message to 'approved'
      // and removes the metamaskId for signing
      const cleanMsgParams = await this.messageManager.approveMessage(msgParams);
      const rawSig = await this.keyringController.signMessage(cleanMsgParams);
      this.messageManager.setMsgStatusSigned(msgId, rawSig);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_sign failed', error);

      this.messageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a message submitted via eth_sign.
   *
   * @param {string} msgId - The id of the message to cancel.
   */


  cancelMessage(msgId) {
    const {
      messageManager
    } = this;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // personal_sign methods:

  /**
   * Called when a dapp uses the personal_sign method.
   * This is identical to the Geth eth_sign method, and may eventually replace
   * eth_sign.
   *
   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.
   *
   * @param {object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {object} [req] - The original request, containing the origin.
   */


  async newUnsignedPersonalMessage(msgParams, req) {
    const promise = this.personalMessageManager.addUnapprovedMessageAsync(msgParams, req);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * Signifies a user's approval to sign a personal_sign message in queue.
   * Triggers signing, and the callback function from newUnsignedPersonalMessage.
   *
   * @param {object} msgParams - The params of the message to sign & return to the Dapp.
   * @returns {Promise<object>} A full state update.
   */


  async signPersonalMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - signPersonalMessage');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for signing

    try {
      const cleanMsgParams = await this.personalMessageManager.approveMessage(msgParams);
      const rawSig = await this.keyringController.signPersonalMessage(cleanMsgParams); // tells the listener that the message has been signed
      // and can be returned to the dapp

      this.personalMessageManager.setMsgStatusSigned(msgId, rawSig);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_personalSign failed', error);

      this.personalMessageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a personal_sign type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelPersonalMessage(msgId) {
    const messageManager = this.personalMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_decrypt methods

  /**
   * Called when a dapp uses the eth_decrypt method.
   *
   * @param {object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {object} req - (optional) the original request, containing the origin
   * Passed back to the requesting Dapp.
   */


  async newRequestDecryptMessage(msgParams, req) {
    const promise = this.decryptMessageManager.addUnapprovedMessageAsync(msgParams, req);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * Only decrypt message and don't touch transaction state
   *
   * @param {object} msgParams - The params of the message to decrypt.
   * @returns {Promise<object>} A full state update.
   */


  async decryptMessageInline(msgParams) {
    _loglevel.default.info('MetaMaskController - decryptMessageInline'); // decrypt the message inline


    const msgId = msgParams.metamaskId;
    const msg = this.decryptMessageManager.getMsg(msgId);

    try {
      const stripped = (0, _hexstringUtils.stripHexPrefix)(msgParams.data);
      const buff = Buffer.from(stripped, 'hex');
      msgParams.data = JSON.parse(buff.toString('utf8'));
      msg.rawData = await this.keyringController.decryptMessage(msgParams);
    } catch (e) {
      msg.error = e.message;
    }

    this.decryptMessageManager._updateMsg(msg);

    return this.getState();
  }
  /**
   * Signifies a user's approval to decrypt a message in queue.
   * Triggers decrypt, and the callback function from newUnsignedDecryptMessage.
   *
   * @param {object} msgParams - The params of the message to decrypt & return to the Dapp.
   * @returns {Promise<object>} A full state update.
   */


  async decryptMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - decryptMessage');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for decryption

    try {
      const cleanMsgParams = await this.decryptMessageManager.approveMessage(msgParams);
      const stripped = (0, _hexstringUtils.stripHexPrefix)(cleanMsgParams.data);
      const buff = Buffer.from(stripped, 'hex');
      cleanMsgParams.data = JSON.parse(buff.toString('utf8')); // decrypt the message

      const rawMess = await this.keyringController.decryptMessage(cleanMsgParams); // tells the listener that the message has been decrypted and can be returned to the dapp

      this.decryptMessageManager.setMsgStatusDecrypted(msgId, rawMess);
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_decrypt failed.', error);

      this.decryptMessageManager.errorMessage(msgId, error);
    }

    return this.getState();
  }
  /**
   * Used to cancel a eth_decrypt type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelDecryptMessage(msgId) {
    const messageManager = this.decryptMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_getEncryptionPublicKey methods

  /**
   * Called when a dapp uses the eth_getEncryptionPublicKey method.
   *
   * @param {object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {object} req - (optional) the original request, containing the origin
   * Passed back to the requesting Dapp.
   */


  async newRequestEncryptionPublicKey(msgParams, req) {
    const address = msgParams;
    const keyring = await this.keyringController.getKeyringForAccount(address);

    switch (keyring.type) {
      case _hardwareWallets.KEYRING_TYPES.LEDGER:
        {
          return new Promise((_, reject) => {
            reject(new Error('Ledger does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.TREZOR:
        {
          return new Promise((_, reject) => {
            reject(new Error('Trezor does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.LATTICE:
        {
          return new Promise((_, reject) => {
            reject(new Error('Lattice does not support eth_getEncryptionPublicKey.'));
          });
        }

      case _hardwareWallets.KEYRING_TYPES.QR:
        {
          return Promise.reject(new Error('QR hardware does not support eth_getEncryptionPublicKey.'));
        }

      default:
        {
          const promise = this.encryptionPublicKeyManager.addUnapprovedMessageAsync(msgParams, req);
          this.sendUpdate();
          this.opts.showUserConfirmation();
          return promise;
        }
    }
  }
  /**
   * Signifies a user's approval to receiving encryption public key in queue.
   * Triggers receiving, and the callback function from newUnsignedEncryptionPublicKey.
   *
   * @param {object} msgParams - The params of the message to receive & return to the Dapp.
   * @returns {Promise<object>} A full state update.
   */


  async encryptionPublicKey(msgParams) {
    _loglevel.default.info('MetaMaskController - encryptionPublicKey');

    const msgId = msgParams.metamaskId; // sets the status op the message to 'approved'
    // and removes the metamaskId for decryption

    try {
      const params = await this.encryptionPublicKeyManager.approveMessage(msgParams); // EncryptionPublicKey message

      const publicKey = await this.keyringController.getEncryptionPublicKey(params.data); // tells the listener that the message has been processed
      // and can be returned to the dapp

      this.encryptionPublicKeyManager.setMsgStatusReceived(msgId, publicKey);
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_getEncryptionPublicKey failed.', error);

      this.encryptionPublicKeyManager.errorMessage(msgId, error);
    }

    return this.getState();
  }
  /**
   * Used to cancel a eth_getEncryptionPublicKey type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelEncryptionPublicKey(msgId) {
    const messageManager = this.encryptionPublicKeyManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  } // eth_signTypedData methods

  /**
   * Called when a dapp uses the eth_signTypedData method, per EIP 712.
   *
   * @param {object} msgParams - The params passed to eth_signTypedData.
   * @param {object} [req] - The original request, containing the origin.
   * @param version
   */


  newUnsignedTypedMessage(msgParams, req, version) {
    const promise = this.typedMessageManager.addUnapprovedMessageAsync(msgParams, req, version);
    this.sendUpdate();
    this.opts.showUserConfirmation();
    return promise;
  }
  /**
   * The method for a user approving a call to eth_signTypedData, per EIP 712.
   * Triggers the callback in newUnsignedTypedMessage.
   *
   * @param {object} msgParams - The params passed to eth_signTypedData.
   * @returns {object} Full state update.
   */


  async signTypedMessage(msgParams) {
    _loglevel.default.info('MetaMaskController - eth_signTypedData');

    const msgId = msgParams.metamaskId;
    const {
      version
    } = msgParams;

    try {
      const cleanMsgParams = await this.typedMessageManager.approveMessage(msgParams); // For some reason every version after V1 used stringified params.

      if (version !== 'V1') {
        // But we don't have to require that. We can stop suggesting it now:
        if (typeof cleanMsgParams.data === 'string') {
          cleanMsgParams.data = JSON.parse(cleanMsgParams.data);
        }
      }

      const signature = await this.keyringController.signTypedMessage(cleanMsgParams, {
        version
      });
      this.typedMessageManager.setMsgStatusSigned(msgId, signature);
      return this.getState();
    } catch (error) {
      _loglevel.default.info('MetaMaskController - eth_signTypedData failed.', error);

      this.typedMessageManager.errorMessage(msgId, error);
      throw error;
    }
  }
  /**
   * Used to cancel a eth_signTypedData type message.
   *
   * @param {string} msgId - The ID of the message to cancel.
   */


  cancelTypedMessage(msgId) {
    const messageManager = this.typedMessageManager;
    messageManager.rejectMsg(msgId);
    return this.getState();
  }
  /**
   * @returns {boolean} true if the keyring type supports EIP-1559
   */


  async getCurrentAccountEIP1559Compatibility() {
    return true;
  } //=============================================================================
  // END (VAULT / KEYRING RELATED METHODS)
  //=============================================================================

  /**
   * Allows a user to attempt to cancel a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to cancel
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param options
   * @returns {object} MetaMask state
   */


  async createCancelTransaction(originalTxId, customGasSettings, options) {
    await this.txController.createCancelTransaction(originalTxId, customGasSettings, options);
    const state = await this.getState();
    return state;
  }
  /**
   * Allows a user to attempt to speed up a previously submitted transaction
   * by creating a new transaction.
   *
   * @param {number} originalTxId - the id of the txMeta that you want to
   *  attempt to speed up
   * @param {__import__(
   *  './controllers/transactions'
   * ).CustomGasSettings} [customGasSettings] - overrides to use for gas params
   *  instead of allowing this method to generate them
   * @param options
   * @returns {object} MetaMask state
   */


  async createSpeedUpTransaction(originalTxId, customGasSettings, options) {
    await this.txController.createSpeedUpTransaction(originalTxId, customGasSettings, options);
    const state = await this.getState();
    return state;
  }

  estimateGas(estimateGasParams) {
    return new Promise((resolve, reject) => {
      return this.txController.txGasUtil.query.estimateGas(estimateGasParams, (err, res) => {
        if (err) {
          return reject(err);
        }

        return resolve(res.toString(16));
      });
    });
  } //=============================================================================
  // PASSWORD MANAGEMENT
  //=============================================================================

  /**
   * Allows a user to begin the seed phrase recovery process.
   */


  markPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(true);
    this.sendUpdate();
  }
  /**
   * Allows a user to end the seed phrase recovery process.
   */


  unMarkPasswordForgotten() {
    this.preferencesController.setPasswordForgotten(false);
    this.sendUpdate();
  } //=============================================================================
  // SETUP
  //=============================================================================

  /**
   * A runtime.MessageSender object, as provided by the browser:
   *
   * @see https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/runtime/MessageSender
   * @typedef {object} MessageSender
   * @property {string} - The URL of the page or frame hosting the script that sent the message.
   */

  /**
   * A Snap sender object.
   *
   * @typedef {object} SnapSender
   * @property {string} snapId - The ID of the snap.
   */

  /**
   * Used to create a multiplexed stream for connecting to an untrusted context
   * like a Dapp or other extension.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   * @param {MessageSender | SnapSender} options.sender - The sender of the messages on this stream.
   * @param {string} [options.subjectType] - The type of the sender, i.e. subject.
   */


  setupUntrustedCommunication({
    connectionStream,
    sender,
    subjectType
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();

    let _subjectType;

    if (subjectType) {
      _subjectType = subjectType;
    } else if (sender.id && sender.id !== this.extension.runtime.id) {
      _subjectType = _app.SUBJECT_TYPES.EXTENSION;
    } else {
      _subjectType = _app.SUBJECT_TYPES.WEBSITE;
    }

    if (sender.url) {
      const {
        hostname
      } = new URL(sender.url);
      const phishingListsAreOutOfDate = this.phishingController.isOutOfDate();

      if (phishingListsAreOutOfDate) {
        this.phishingController.updatePhishingLists();
      } // Check if new connection is blocked if phishing detection is on


      const phishingTestResponse = this.phishingController.test(hostname);

      if (usePhishDetect && phishingTestResponse !== null && phishingTestResponse !== void 0 && phishingTestResponse.result) {
        this.sendPhishingWarning(connectionStream, hostname, phishingTestResponse);
        return;
      }
    } // setup multiplexing


    const mux = (0, _streamUtils.setupMultiplex)(connectionStream); // messages between inpage and background

    this.setupProviderConnection(mux.createStream('metamask-provider'), sender, _subjectType); // TODO:LegacyProvider: Delete

    if (sender.url) {
      // legacy streams
      this.setupPublicConfig(mux.createStream('publicConfig'));
    }
  }
  /**
   * Used to create a multiplexed stream for connecting to a trusted context,
   * like our own user interfaces, which have the provider APIs, but also
   * receive the exported API from this controller, which includes trusted
   * functions, like the ability to approve transactions or sign messages.
   *
   * @param {*} connectionStream - The duplex stream to connect to.
   * @param {MessageSender} sender - The sender of the messages on this stream
   */


  setupTrustedCommunication(connectionStream, sender) {
    // setup multiplexing
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream); // connect features

    this.setupControllerConnection(mux.createStream('controller'));
    this.setupProviderConnection(mux.createStream('provider'), sender, _app.SUBJECT_TYPES.INTERNAL);
  }
  /**
   * Used to create a multiplexed stream for connecting to the phishing warning page.
   *
   * @param options - Options bag.
   * @param {ReadableStream} options.connectionStream - The Duplex stream to connect to.
   */


  setupPhishingCommunication({
    connectionStream
  }) {
    const {
      usePhishDetect
    } = this.preferencesController.store.getState();

    if (!usePhishDetect) {
      return;
    } // setup multiplexing


    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream(PHISHING_SAFELIST); // set up postStream transport

    phishingStream.on('data', (0, _createMetaRPCHandler.default)({
      safelistPhishingDomain: this.safelistPhishingDomain.bind(this)
    }, phishingStream));
  }
  /**
   * Called when we detect a suspicious domain. Requests the browser redirects
   * to our anti-phishing page.
   *
   * @private
   * @param {*} connectionStream - The duplex stream to the per-page script,
   * for sending the reload attempt to.
   * @param {string} hostname - The hostname that triggered the suspicion.
   * @param {object} phishingTestResponse - Result of calling `phishingController.test`,
   * which is the result of calling eth-phishing-detects detector.check method https://github.com/MetaMask/eth-phishing-detect/blob/master/src/detector.js#L55-L112
   */


  sendPhishingWarning(connectionStream, hostname, phishingTestResponse) {
    const newIssueUrl = _phishing.PHISHING_NEW_ISSUE_URLS[phishingTestResponse === null || phishingTestResponse === void 0 ? void 0 : phishingTestResponse.name];
    const mux = (0, _streamUtils.setupMultiplex)(connectionStream);
    const phishingStream = mux.createStream('phishing');
    phishingStream.write({
      hostname,
      newIssueUrl
    });
  }
  /**
   * A method for providing our API over a stream using JSON-RPC.
   *
   * @param {*} outStream - The stream to provide our API over.
   */


  setupControllerConnection(outStream) {
    const api = this.getApi(); // report new active controller connection

    this.activeControllerConnections += 1;
    this.emit('controllerConnectionChanged', this.activeControllerConnections); // set up postStream transport

    outStream.on('data', (0, _createMetaRPCHandler.default)(api, outStream, this.store, this.localStoreApiWrapper));

    const handleUpdate = update => {
      if (outStream._writableState.ended) {
        return;
      } // send notification to client-side


      outStream.write({
        jsonrpc: '2.0',
        method: 'sendUpdate',
        params: [update]
      });
    };

    this.on('update', handleUpdate);
    outStream.on('end', () => {
      this.activeControllerConnections -= 1;
      this.emit('controllerConnectionChanged', this.activeControllerConnections);
      this.removeListener('update', handleUpdate);
    });
  }
  /**
   * A method for serving our ethereum provider over a given stream.
   *
   * @param {*} outStream - The stream to provide over.
   * @param {MessageSender | SnapSender} sender - The sender of the messages on this stream
   * @param {string} subjectType - The type of the sender, i.e. subject.
   */


  setupProviderConnection(outStream, sender, subjectType) {
    let origin;

    if (subjectType === _app.SUBJECT_TYPES.INTERNAL) {
      origin = _app.ORIGIN_METAMASK;
    } else {
      origin = new URL(sender.url).origin;
    }

    if (sender.id && sender.id !== this.extension.runtime.id) {
      this.subjectMetadataController.addSubjectMetadata({
        origin,
        extensionId: sender.id,
        subjectType: _app.SUBJECT_TYPES.EXTENSION
      });
    }

    let tabId;

    if (sender.tab && sender.tab.id) {
      tabId = sender.tab.id;
    }

    const engine = this.setupProviderEngine({
      origin,
      sender,
      subjectType,
      tabId
    }); // setup connection

    const providerStream = (0, _engineStream.default)({
      engine
    });
    const connectionId = this.addConnection(origin, {
      engine
    });
    (0, _pump.default)(outStream, providerStream, outStream, err => {
      // handle any middleware cleanup
      engine._middleware.forEach(mid => {
        if (mid.destroy && typeof mid.destroy === 'function') {
          mid.destroy();
        }
      });

      connectionId && this.removeConnection(origin, connectionId);

      if (err) {
        _loglevel.default.error(err);
      }
    });
  }
  /**
   * A method for creating a provider that is safely restricted for the requesting subject.
   *
   * @param {object} options - Provider engine options
   * @param {string} options.origin - The origin of the sender
   * @param {MessageSender | SnapSender} options.sender - The sender object.
   * @param {string} options.subjectType - The type of the sender subject.
   * @param {tabId} [options.tabId] - The tab ID of the sender - if the sender is within a tab
   */


  setupProviderEngine({
    origin,
    subjectType,
    sender,
    tabId
  }) {
    // setup json rpc engine stack
    const engine = new _jsonRpcEngine.JsonRpcEngine();
    const {
      blockTracker,
      provider
    } = this; // create filter polyfill middleware

    const filterMiddleware = (0, _ethJsonRpcFilters.default)({
      provider,
      blockTracker
    }); // create subscription polyfill middleware

    const subscriptionManager = (0, _subscriptionManager.default)({
      provider,
      blockTracker
    });
    subscriptionManager.events.on('notification', message => engine.emit('notification', message)); // append origin to each request

    engine.push((0, _createOriginMiddleware.default)({
      origin
    })); // append tabId to each request if it exists

    if (tabId) {
      engine.push((0, _createTabIdMiddleware.default)({
        tabId
      }));
    } // logging


    engine.push((0, _createLoggerMiddleware.default)({
      origin
    }));
    engine.push(this.permissionLogController.createMiddleware());
    engine.push((0, _createRPCMethodTrackingMiddleware.default)({
      trackEvent: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      getMetricsState: this.metaMetricsController.store.getState.bind(this.metaMetricsController.store)
    })); // onboarding

    if (subjectType === _app.SUBJECT_TYPES.WEBSITE) {
      engine.push((0, _createOnboardingMiddleware.default)({
        location: sender.url,
        registerOnboarding: this.onboardingController.registerOnboarding
      }));
    } // Unrestricted/permissionless RPC method implementations


    engine.push((0, _rpcMethodMiddleware.createMethodMiddleware)({
      origin,
      subjectType,
      // Miscellaneous
      addSubjectMetadata: this.subjectMetadataController.addSubjectMetadata.bind(this.subjectMetadataController),
      getProviderState: this.getProviderState.bind(this),
      getUnlockPromise: this.appStateController.getUnlockPromise.bind(this.appStateController),
      handleWatchAssetRequest: this.tokensController.watchAsset.bind(this.tokensController),
      requestUserApproval: this.approvalController.addAndShowApprovalRequest.bind(this.approvalController),
      sendMetrics: this.metaMetricsController.trackEvent.bind(this.metaMetricsController),
      // Permission-related
      getAccounts: this.getPermittedAccounts.bind(this, origin),
      getPermissionsForOrigin: this.permissionController.getPermissions.bind(this.permissionController, origin),
      hasPermission: this.permissionController.hasPermission.bind(this.permissionController, origin),
      requestAccountsPermission: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }, {
        eth_accounts: {}
      }),
      requestPermissionsForOrigin: this.permissionController.requestPermissions.bind(this.permissionController, {
        origin
      }),
      // Custom RPC-related
      addCustomRpc: async ({
        chainId,
        blockExplorerUrl,
        ticker,
        chainName,
        rpcUrl
      } = {}) => {
        await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, chainName, {
          blockExplorerUrl
        });
      },
      findCustomRpcBy: this.findCustomRpcBy.bind(this),
      getCurrentChainId: this.networkController.getCurrentChainId.bind(this.networkController),
      getCurrentRpcUrl: this.networkController.getCurrentRpcUrl.bind(this.networkController),
      setProviderType: this.networkController.setProviderType.bind(this.networkController),
      updateRpcTarget: ({
        rpcUrl,
        chainId,
        ticker,
        nickname
      }) => {
        this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname);
      },
      // Web3 shim-related
      getWeb3ShimUsageState: this.alertController.getWeb3ShimUsageState.bind(this.alertController),
      setWeb3ShimUsageRecorded: this.alertController.setWeb3ShimUsageRecorded.bind(this.alertController)
    })); // filter and subscription polyfills

    engine.push(filterMiddleware);
    engine.push(subscriptionManager.middleware);

    if (subjectType !== _app.SUBJECT_TYPES.INTERNAL) {
      // permissions
      engine.push(this.permissionController.createPermissionMiddleware({
        origin
      }));
    } // forward to metamask primary provider


    engine.push((0, _ethJsonRpcMiddleware.providerAsMiddleware)(provider));
    return engine;
  }
  /**
   * TODO:LegacyProvider: Delete
   * A method for providing our public config info over a stream.
   * This includes info we like to be synchronous if possible, like
   * the current selected account, and network ID.
   *
   * Since synchronous methods have been deprecated in web3,
   * this is a good candidate for deprecation.
   *
   * @param {*} outStream - The stream to provide public config over.
   */


  setupPublicConfig(outStream) {
    const configStream = (0, _asStream.storeAsStream)(this.publicConfigStore);
    (0, _pump.default)(configStream, outStream, err => {
      configStream.destroy();

      if (err) {
        _loglevel.default.error(err);
      }
    });
  }
  /**
   * Adds a reference to a connection by origin. Ignores the 'metamask' origin.
   * Caller must ensure that the returned id is stored such that the reference
   * can be deleted later.
   *
   * @param {string} origin - The connection's origin string.
   * @param {object} options - Data associated with the connection
   * @param {object} options.engine - The connection's JSON Rpc Engine
   * @returns {string} The connection's id (so that it can be deleted later)
   */


  addConnection(origin, {
    engine
  }) {
    if (origin === _app.ORIGIN_METAMASK) {
      return null;
    }

    if (!this.connections[origin]) {
      this.connections[origin] = {};
    }

    const id = (0, _nanoid.default)();
    this.connections[origin][id] = {
      engine
    };
    return id;
  }
  /**
   * Deletes a reference to a connection, by origin and id.
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {string} id - The connection's id, as returned from addConnection.
   */


  removeConnection(origin, id) {
    const connections = this.connections[origin];

    if (!connections) {
      return;
    }

    delete connections[id];

    if (Object.keys(connections).length === 0) {
      delete this.connections[origin];
    }
  }
  /**
   * Closes all connections for the given origin, and removes the references
   * to them.
   * Ignores unknown origins.
   *
   * @param {string} origin - The origin string.
   */


  removeAllConnections(origin) {
    const connections = this.connections[origin];

    if (!connections) {
      return;
    }

    Object.keys(connections).forEach(id => {
      this.removeConnection(origin, id);
    });
  }
  /**
   * Causes the RPC engines associated with the connections to the given origin
   * to emit a notification event with the given payload.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * Ignores unknown origins.
   *
   * @param {string} origin - The connection's origin string.
   * @param {unknown} payload - The event payload.
   */


  notifyConnections(origin, payload) {
    const connections = this.connections[origin];

    if (connections) {
      Object.values(connections).forEach(conn => {
        if (conn.engine) {
          conn.engine.emit('notification', payload);
        }
      });
    }
  }
  /**
   * Causes the RPC engines associated with all connections to emit a
   * notification event with the given payload.
   *
   * If the "payload" parameter is a function, the payload for each connection
   * will be the return value of that function called with the connection's
   * origin.
   *
   * The caller is responsible for ensuring that only permitted notifications
   * are sent.
   *
   * @param {unknown} payload - The event payload, or payload getter function.
   */


  notifyAllConnections(payload) {
    const getPayload = typeof payload === 'function' ? origin => payload(origin) : () => payload;
    Object.keys(this.connections).forEach(origin => {
      Object.values(this.connections[origin]).forEach(async conn => {
        if (conn.engine) {
          conn.engine.emit('notification', await getPayload(origin));
        }
      });
    });
  } // handlers

  /**
   * Handle a KeyringController update
   *
   * @param {object} state - the KC state
   * @returns {Promise<void>}
   * @private
   */


  async _onKeyringControllerUpdate(state) {
    const {
      keyrings
    } = state;
    const addresses = keyrings.reduce((acc, {
      accounts
    }) => acc.concat(accounts), []);

    if (!addresses.length) {
      return;
    } // Ensure preferences + identities controller know about all addresses


    this.preferencesController.syncAddresses(addresses);
    this.accountTracker.syncWithAddresses(addresses);
  }
  /**
   * Handle global application unlock.
   * Notifies all connections that the extension is unlocked, and which
   * account(s) are currently accessible, if any.
   */


  _onUnlock() {
    this.notifyAllConnections(async origin => {
      return {
        method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
        params: {
          isUnlocked: true,
          accounts: await this.getPermittedAccounts(origin)
        }
      };
    }); // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'unlock'
    // event of the MetaMaskController itself.

    this.emit('unlock');
  }
  /**
   * Handle global application lock.
   * Notifies all connections that the extension is locked.
   */


  _onLock() {
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.unlockStateChanged,
      params: {
        isUnlocked: false
      }
    }); // In the current implementation, this handler is triggered by a
    // KeyringController event. Other controllers subscribe to the 'lock'
    // event of the MetaMaskController itself.

    this.emit('lock');
  }
  /**
   * Handle memory state updates.
   * - Ensure isClientOpenAndUnlocked is updated
   * - Notifies all connections with the new provider network state
   *   - The external providers handle diffing the state
   *
   * @param newState
   */


  _onStateUpdate(newState) {
    this.isClientOpenAndUnlocked = newState.isUnlocked && this._isClientOpen;
    this.notifyAllConnections({
      method: _permissions2.NOTIFICATION_NAMES.chainChanged,
      params: this.getProviderNetworkState(newState)
    });
  } // misc

  /**
   * A method for emitting the full MetaMask state to all registered listeners.
   *
   * @private
   */


  privateSendUpdate() {
    this.emit('update', this.getState());
  }
  /**
   * @returns {boolean} Whether the extension is unlocked.
   */


  isUnlocked() {
    return this.keyringController.memStore.getState().isUnlocked;
  } //=============================================================================
  // MISCELLANEOUS
  //=============================================================================


  getExternalPendingTransactions(address) {
    return this.smartTransactionsController.getTransactions({
      addressFrom: address,
      status: 'pending'
    });
  }
  /**
   * Returns the nonce that will be associated with a transaction once approved
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */


  async getPendingNonce(address) {
    const {
      nonceDetails,
      releaseLock
    } = await this.txController.nonceTracker.getNonceLock(address);
    const pendingNonce = nonceDetails.params.highestSuggested;
    releaseLock();
    return pendingNonce;
  }
  /**
   * Returns the next nonce according to the nonce-tracker
   *
   * @param {string} address - The hex string address for the transaction
   * @returns {Promise<number>}
   */


  async getNextNonce(address) {
    const nonceLock = await this.txController.nonceTracker.getNonceLock(address);
    nonceLock.releaseLock();
    return nonceLock.nextNonce;
  }
  /**
   * Migrate address book state from old to new chainId.
   *
   * Address book state is keyed by the `networkStore` state from the network controller. This value is set to the
   * `networkId` for our built-in Infura networks, but it's set to the `chainId` for custom networks.
   * When this `chainId` value is changed for custom RPC endpoints, we need to migrate any contacts stored under the
   * old key to the new key.
   *
   * The `duplicate` parameter is used to specify that the contacts under the old key should not be removed. This is
   * useful in the case where two RPC endpoints shared the same set of contacts, and we're not sure which one each
   * contact belongs under. Duplicating the contacts under both keys is the only way to ensure they are not lost.
   *
   * @param {string} oldChainId - The old chainId
   * @param {string} newChainId - The new chainId
   * @param {boolean} [duplicate] - Whether to duplicate the addresses on both chainIds (default: false)
   */


  async migrateAddressBookState(oldChainId, newChainId, duplicate = false) {
    const {
      addressBook
    } = this.addressBookController.state;

    if (!addressBook[oldChainId]) {
      return;
    }

    for (const address of Object.keys(addressBook[oldChainId])) {
      const entry = addressBook[oldChainId][address];
      this.addressBookController.set(address, entry.name, newChainId, entry.memo);

      if (!duplicate) {
        this.addressBookController.delete(oldChainId, address);
      }
    }
  } //=============================================================================
  // CONFIG
  //=============================================================================
  // Log blocks

  /**
   * A method for selecting a custom URL for an ethereum RPC provider and updating it
   *
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} [nickname] - Nickname of the selected network.
   * @param {object} [rpcPrefs] - RPC preferences.
   * @param {string} [rpcPrefs.blockExplorerUrl] - URL of block explorer for the chain.
   * @returns {Promise<string>} The RPC Target URL confirmed.
   */


  async updateAndSetCustomRpc(rpcUrl, chainId, ticker = 'ETH', nickname, rpcPrefs) {
    this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    await this.preferencesController.updateRpc({
      rpcUrl,
      chainId,
      ticker,
      nickname,
      rpcPrefs
    });
    return rpcUrl;
  }
  /**
   * A method for selecting a custom URL for an ethereum RPC provider.
   *
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {string} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} nickname - Optional nickname of the selected network.
   * @param rpcPrefs
   * @returns {Promise<string>} The RPC Target URL confirmed.
   */


  async setCustomRpc(rpcUrl, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();
    const rpcSettings = frequentRpcListDetail.find(rpc => rpcUrl === rpc.rpcUrl);

    if (rpcSettings) {
      this.networkController.setRpcTarget(rpcSettings.rpcUrl, rpcSettings.chainId, rpcSettings.ticker, rpcSettings.nickname, rpcPrefs);
    } else {
      this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs);
      await this.preferencesController.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs);
    }

    return rpcUrl;
  }
  /**
   * A method for deleting a selected custom URL.
   *
   * @param {string} rpcUrl - A RPC URL to delete.
   */


  async delCustomRpc(rpcUrl) {
    await this.preferencesController.removeFromFrequentRpcList(rpcUrl);
  }
  /**
   * Returns the first RPC info object that matches at least one field of the
   * provided search criteria. Returns null if no match is found
   *
   * @param {object} rpcInfo - The RPC endpoint properties and values to check.
   * @returns {object} rpcInfo found in the frequentRpcList
   */


  findCustomRpcBy(rpcInfo) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail();

    for (const existingRpcInfo of frequentRpcListDetail) {
      for (const key of Object.keys(rpcInfo)) {
        if (existingRpcInfo[key] === rpcInfo[key]) {
          return existingRpcInfo;
        }
      }
    }

    return null;
  }
  /**
   * Sets the Ledger Live preference to use for Ledger hardware wallet support
   *
   * @param {string} transportType - The Ledger transport type.
   */


  async setLedgerTransportPreference(transportType) {
    const currentValue = this.preferencesController.getLedgerTransportPreference();
    const newValue = this.preferencesController.setLedgerTransportPreference(transportType);
    const keyring = await this.getKeyringForDevice(_hardwareWallets.DEVICE_NAMES.LEDGER);

    if (keyring !== null && keyring !== void 0 && keyring.updateTransportMethod) {
      return keyring.updateTransportMethod(newValue).catch(e => {
        // If there was an error updating the transport, we should
        // fall back to the original value
        this.preferencesController.setLedgerTransportPreference(currentValue);
        throw e;
      });
    }

    return undefined;
  }
  /**
   * A method for initializing storage the first time.
   *
   * @param {object} initState - The default state to initialize with.
   * @private
   */


  recordFirstTimeInfo(initState) {
    if (!('firstTimeInfo' in initState)) {
      const version = this.platform.getVersion();
      initState.firstTimeInfo = {
        version,
        date: Date.now()
      };
    }
  } // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.

  /* eslint-disable accessor-pairs */

  /**
   * A method for recording whether the MetaMask user interface is open or not.
   *
   * @param {boolean} open
   */


  set isClientOpen(open) {
    this._isClientOpen = open;
    this.detectTokensController.isOpen = open;
  }
  /* eslint-enable accessor-pairs */

  /**
   * A method that is called by the background when all instances of metamask are closed.
   * Currently used to stop polling in the gasFeeController.
   */


  onClientClosed() {
    try {
      this.gasFeeController.stopPolling();
      this.appStateController.clearPollingTokens();
    } catch (error) {
      console.error(error);
    }
  }
  /**
   * A method that is called by the background when a particular environment type is closed (fullscreen, popup, notification).
   * Currently used to stop polling in the gasFeeController for only that environement type
   *
   * @param environmentType
   */


  onEnvironmentTypeClosed(environmentType) {
    const appStatePollingTokenType = _app.POLLING_TOKEN_ENVIRONMENT_TYPES[environmentType];
    const pollingTokensToDisconnect = this.appStateController.store.getState()[appStatePollingTokenType];
    pollingTokensToDisconnect.forEach(pollingToken => {
      this.gasFeeController.disconnectPoller(pollingToken);
      this.appStateController.removePollingToken(pollingToken, appStatePollingTokenType);
    });
  }
  /**
   * Adds a domain to the PhishingController safelist
   *
   * @param {string} hostname - the domain to safelist
   */


  safelistPhishingDomain(hostname) {
    return this.phishingController.bypass(hostname);
  }
  /**
   * Locks MetaMask
   */


  setLocked() {
    var _ledgerKeyring$destro;

    const [trezorKeyring] = this.keyringController.getKeyringsByType(_hardwareWallets.KEYRING_TYPES.TREZOR);

    if (trezorKeyring) {
      trezorKeyring.dispose();
    }

    const [ledgerKeyring] = this.keyringController.getKeyringsByType(_hardwareWallets.KEYRING_TYPES.LEDGER);
    ledgerKeyring === null || ledgerKeyring === void 0 ? void 0 : (_ledgerKeyring$destro = ledgerKeyring.destroy) === null || _ledgerKeyring$destro === void 0 ? void 0 : _ledgerKeyring$destro.call(ledgerKeyring);
    return this.keyringController.setLocked();
  }

}

exports.default = MetamaskController;


}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\002.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\002.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 2;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      if (versionedData.data.config.provider.type === 'etherscan') {
        versionedData.data.config.provider.type = 'rpc';
        versionedData.data.config.provider.rpcTarget = 'https://rpc.metamask.io/';
      }
    } catch (_) {// empty
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\003.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\003.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 3;
const oldTestRpc = 'https://rawtestrpc.metamask.io/';
const newTestRpc = 'https://testrpc.metamask.io/';
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      if (versionedData.data.config.provider.rpcTarget === oldTestRpc) {
        versionedData.data.config.provider.rpcTarget = newTestRpc;
      }
    } catch (_) {// empty
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\004.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\004.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 4;
var _default = {
  version,

  migrate(versionedData) {
    const safeVersionedData = (0, _lodash.cloneDeep)(versionedData);
    safeVersionedData.meta.version = version;

    try {
      if (safeVersionedData.data.config.provider.type !== 'rpc') {
        return Promise.resolve(safeVersionedData);
      }

      switch (safeVersionedData.data.config.provider.rpcTarget) {
        case 'https://testrpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'testnet'
          };
          break;

        case 'https://rpc.metamask.io/':
          safeVersionedData.data.config.provider = {
            type: 'mainnet'
          };
          break;
        // No default
      }
    } catch (_) {// empty
    }

    return Promise.resolve(safeVersionedData);
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\005.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\005.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration moves state from the flat state trie into KeyringController substate

*/
const version = 5;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = selectSubstateForKeyringController(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #5${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function selectSubstateForKeyringController(state) {
  const {
    config
  } = state;
  const newState = { ...state,
    KeyringController: {
      vault: state.vault,
      selectedAccount: config.selectedAccount,
      walletNicknames: state.walletNicknames
    }
  };
  delete newState.vault;
  delete newState.walletNicknames;
  delete newState.config.selectedAccount;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\006.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\006.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration moves KeyringController.selectedAddress to PreferencesController.selectedAddress

*/
const version = 6;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = migrateState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function migrateState(state) {
  const keyringSubstate = state.KeyringController; // add new state

  const newState = { ...state,
    PreferencesController: {
      selectedAddress: keyringSubstate.selectedAccount
    }
  }; // rm old state

  delete newState.KeyringController.selectedAccount;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\007.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\007.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the TransactionManager substate

*/
const version = 7;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = { ...state,
    TransactionManager: {
      transactions: state.transactions || [],
      gasMultiplier: state.gasMultiplier || 1
    }
  };
  delete newState.transactions;
  delete newState.gasMultiplier;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\008.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\008.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the NoticeController substate

*/
const version = 8;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = { ...state,
    NoticeController: {
      noticesList: state.noticesList || []
    }
  };
  delete newState.noticesList;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\009.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\009.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the CurrencyController substate

*/
const version = 9;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    CurrencyController: {
      currentCurrency: state.currentFiat || state.fiatCurrency || 'USD',
      conversionRate: state.conversionRate,
      conversionDate: state.conversionDate
    }
  });
  delete newState.currentFiat;
  delete newState.fiatCurrency;
  delete newState.conversionRate;
  delete newState.conversionDate;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\010.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\010.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration breaks out the ShapeShiftController substate

*/
const version = 10;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = (0, _lodash.merge)({}, state, {
    ShapeShiftController: {
      shapeShiftTxList: state.shapeShiftTxList || []
    }
  });
  delete newState.shapeShiftTxList;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\011.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\011.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes the discaimer state from our app, which was integrated into our notices.

*/
const version = 11;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  delete newState.TOSHash;
  delete newState.isDisclaimerConfirmed;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\012.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\012.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration modifies our notices to delete their body after being read.

*/
const version = 12;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  newState.NoticeController.noticesList.forEach(notice => {
    if (notice.read) {
      notice.body = '';
    }
  });
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\013.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\013.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration modifies the network config from ambiguous 'testnet' to explicit 'ropsten'

*/
const version = 13;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    config
  } = newState;

  if (config && config.provider) {
    if (config.provider.type === 'testnet') {
      newState.config.provider.type = 'ropsten';
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\014.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\014.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes provider from config and moves it too NetworkController.

*/
const version = 14;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  newState.NetworkController = {};
  newState.NetworkController.provider = newState.config.provider;
  delete newState.config.provider;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\015.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\015.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/
const version = 15;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      } else if (txMeta.err.message === 'Gave up submitting tx.') {
        txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\016.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\016.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions with the 'Gave up submitting tx.' err message
to a 'failed' stated

*/
const version = 16;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.err) {
        return txMeta;
      }

      if (txMeta.err === 'transaction with the same hash was already imported.') {
        txMeta.status = _transaction.TRANSACTION_STATUSES.SUBMITTED;
        delete txMeta.err;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\017.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\017.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions who were retried and marked as failed to submitted

*/
const version = 17;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!txMeta.status === _transaction.TRANSACTION_STATUSES.FAILED) {
        return txMeta;
      }

      if (txMeta.retryCount > 0 && txMeta.retryCount < 2) {
        txMeta.status = _transaction.TRANSACTION_STATUSES.SUBMITTED;
        delete txMeta.err;
      }

      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\018.js", {"../controllers/transactions/lib/tx-state-history-helpers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\controllers\\transactions\\lib\\tx-state-history-helpers.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\018.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _txStateHistoryHelpers = require("../controllers/transactions/lib/tx-state-history-helpers");

/*

This migration updates "transaction state history" to diffs style

*/
const version = 18;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      // no history: initialize
      if (!txMeta.history || txMeta.history.length === 0) {
        const snapshot = (0, _txStateHistoryHelpers.snapshotFromTxMeta)(txMeta);
        txMeta.history = [snapshot];
        return txMeta;
      } // has history: migrate


      const newHistory = (0, _txStateHistoryHelpers.migrateFromSnapshotsToDiffs)(txMeta.history) // remove empty diffs
      .filter(entry => {
        return !Array.isArray(entry) || entry.length > 0;
      });
      txMeta.history = newHistory;
      return txMeta;
    });
  }

  return newState;
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\019.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\019.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration sets transactions as failed
whos nonce is too high

*/
const version = 19;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map((txMeta, _, txList) => {
      if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED) {
        return txMeta;
      }

      const confirmedTxs = txList.filter(tx => tx.status === _transaction.TRANSACTION_STATUSES.CONFIRMED).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestConfirmedNonce = getHighestNonce(confirmedTxs);
      const pendingTxs = txList.filter(tx => tx.status === _transaction.TRANSACTION_STATUSES.SUBMITTED).filter(tx => tx.txParams.from === txMeta.txParams.from).filter(tx => tx.metamaskNetworkId.from === txMeta.metamaskNetworkId.from);
      const highestContinuousNonce = getHighestContinuousFrom(pendingTxs, highestConfirmedNonce);
      const maxNonce = Math.max(highestContinuousNonce, highestConfirmedNonce);

      if (parseInt(txMeta.txParams.nonce, 16) > maxNonce + 1) {
        txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
        txMeta.err = {
          message: 'nonce too high',
          note: 'migration 019 custom error'
        };
      }

      return txMeta;
    });
  }

  return newState;
}

function getHighestContinuousFrom(txList, startPoint) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce, 16);
  });
  let highest = startPoint;

  while (nonces.includes(highest)) {
    highest += 1;
  }

  return highest;
}

function getHighestNonce(txList) {
  const nonces = txList.map(txMeta => {
    const {
      nonce
    } = txMeta.txParams;
    return parseInt(nonce || '0x0', 16);
  });
  const highestNonce = Math.max.apply(null, nonces);
  return highestNonce;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\020.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\020.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration ensures previous installations
get a `firstTimeInfo` key on the metamask state,
so that we can version notices in the future.

*/
const version = 20;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if ('metamask' in newState && !('firstTimeInfo' in newState.metamask)) {
    newState.metamask.firstTimeInfo = {
      version: '3.12.0',
      date: Date.now()
    };
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\021.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\021.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration removes the BlackListController from disk state

*/
const version = 21;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  delete newState.BlacklistController;
  delete newState.RecentBlocks;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\022.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\022.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration adds submittedTime to the txMeta if it is not their

*/
const version = 22;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (txMeta.status !== _transaction.TRANSACTION_STATUSES.SUBMITTED || txMeta.submittedTime) {
        return txMeta;
      }

      txMeta.submittedTime = new Date().getTime();
      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\023.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\023.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration removes transactions that are no longer usefull down to 40 total

*/
const version = 23;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = newState.TransactionController;

    if (transactions.length <= 40) {
      return newState;
    }

    const reverseTxList = transactions.reverse();
    let stripping = true;

    while (reverseTxList.length > 40 && stripping) {
      const txIndex = reverseTxList.findIndex(txMeta => {
        return txMeta.status === _transaction.TRANSACTION_STATUSES.FAILED || txMeta.status === _transaction.TRANSACTION_STATUSES.REJECTED || txMeta.status === _transaction.TRANSACTION_STATUSES.CONFIRMED || txMeta.status === _transaction.TRANSACTION_STATUSES.DROPPED;
      });

      if (txIndex < 0) {
        stripping = false;
      } else {
        reverseTxList.splice(txIndex, 1);
      }
    }

    newState.TransactionController.transactions = reverseTxList.reverse();
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\024.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\024.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

/*

This migration ensures that the from address in txParams is to lower case for
all unapproved transactions

*/
const version = 24;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (!newState.TransactionController) {
    return newState;
  }

  const {
    transactions
  } = newState.TransactionController;
  newState.TransactionController.transactions = transactions.map((txMeta, _) => {
    if (txMeta.status === _transaction.TRANSACTION_STATUSES.UNAPPROVED && txMeta.txParams && txMeta.txParams.from) {
      txMeta.txParams.from = txMeta.txParams.from.toLowerCase();
    }

    return txMeta;
  });
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\025.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\025.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _util = require("../lib/util");

var _transaction = require("../../../shared/constants/transaction");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 25;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.map(txMeta => {
        if (txMeta.status !== _transaction.TRANSACTION_STATUSES.UNAPPROVED) {
          return txMeta;
        }

        txMeta.txParams = normalizeTxParams(txMeta.txParams);
        return txMeta;
      });
    }
  }

  return newState;
}

function normalizeTxParams(txParams) {
  // functions that handle normalizing of that key in txParams
  const whiteList = {
    from: from => (0, _util.addHexPrefix)(from).toLowerCase(),
    to: () => (0, _util.addHexPrefix)(txParams.to).toLowerCase(),
    nonce: nonce => (0, _util.addHexPrefix)(nonce),
    value: value => (0, _util.addHexPrefix)(value),
    data: data => (0, _util.addHexPrefix)(data),
    gas: gas => (0, _util.addHexPrefix)(gas),
    gasPrice: gasPrice => (0, _util.addHexPrefix)(gasPrice)
  }; // apply only keys in the whiteList

  const normalizedTxParams = {};
  Object.keys(whiteList).forEach(key => {
    if (txParams[key]) {
      normalizedTxParams[key] = whiteList[key](txParams[key]);
    }
  });
  return normalizedTxParams;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\026.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\026.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

/*

This migration moves the identities stored in the KeyringController
 into the PreferencesController

*/
const version = 26;
var _default = {
  version,

  migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      versionedData.data = transformState(state);
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
      return Promise.reject(err);
    }

    return Promise.resolve(versionedData);
  }

};
exports.default = _default;

function transformState(state) {
  if (!state.KeyringController || !state.PreferencesController) {
    return state;
  }

  if (!state.KeyringController.walletNicknames) {
    return state;
  }

  state.PreferencesController.identities = Object.keys(state.KeyringController.walletNicknames).reduce((identities, address) => {
    identities[address] = {
      name: state.KeyringController.walletNicknames[address],
      address
    };
    return identities;
  }, {});
  delete state.KeyringController.walletNicknames;
  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\027.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\027.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 27;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.TransactionController) {
    if (newState.TransactionController.transactions) {
      const {
        transactions
      } = newState.TransactionController;
      newState.TransactionController.transactions = transactions.filter(txMeta => txMeta.status !== _transaction.TRANSACTION_STATUSES.REJECTED);
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\028.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\028.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

normalizes txParams on unconfirmed txs

*/
const version = 28;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (newState.PreferencesController) {
    if (newState.PreferencesController.tokens && newState.PreferencesController.identities) {
      const {
        identities,
        tokens
      } = newState.PreferencesController;
      newState.PreferencesController.accountTokens = {};
      Object.keys(identities).forEach(identity => {
        newState.PreferencesController.accountTokens[identity] = {
          mainnet: tokens
        };
      });
      newState.PreferencesController.tokens = [];
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\029.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","./fail-tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\fail-tx.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\029.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _transaction = require("../../../shared/constants/transaction");

var _failTx = _interopRequireDefault(require("./fail-tx"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// next version number
const version = 29; // time

const seconds = 1000;
const minutes = 60 * seconds;
const hours = 60 * minutes;
const unacceptableDelay = 12 * hours;
/*

normalizes txParams on unconfirmed txs

*/

var _default = {
  version,
  migrate: (0, _failTx.default)(version, 'Stuck in approved state for too long.', txMeta => {
    const isApproved = txMeta.status === _transaction.TRANSACTION_STATUSES.APPROVED;
    const createdTime = txMeta.submittedTime;
    const now = Date.now();
    return isApproved && now - createdTime > unacceptableDelay;
  })
};
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\030.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\030.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

removes invalid chaids from preferences and networkController for custom rpcs

*/
const version = 30;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (state.PreferencesController) {
    const {
      frequentRpcListDetail
    } = newState.PreferencesController;

    if (frequentRpcListDetail) {
      frequentRpcListDetail.forEach((rpc, index) => {
        // eslint-disable-next-line radix
        if (Boolean(rpc.chainId) && Number.isNaN(parseInt(rpc.chainId))) {
          delete frequentRpcListDetail[index].chainId;
        }
      });
      newState.PreferencesController.frequentRpcListDetail = frequentRpcListDetail;
    }
  }

  if (state.NetworkController) {
    if (newState.NetworkController.network && // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.network))) {
      delete newState.NetworkController.network;
    }

    if (newState.NetworkController.provider && newState.NetworkController.provider.chainId && // eslint-disable-next-line radix
    Number.isNaN(parseInt(newState.NetworkController.provider.chainId))) {
      delete newState.NetworkController.provider.chainId;
    }
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\031.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\031.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number
const version = 31;
/*
 * The purpose of this migration is to properly set the completedOnboarding flag based on the state
 * of the KeyringController.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    KeyringController,
    PreferencesController
  } = state;

  if (KeyringController && PreferencesController) {
    const {
      vault
    } = KeyringController;
    PreferencesController.completedOnboarding = Boolean(vault);
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\032.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\032.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 32;
/**
 * The purpose of this migration is to set the {@code completedUiMigration} flag based on the user's UI preferences
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const {
      betaUI
    } = PreferencesController.featureFlags || {}; // Users who have been using the "beta" UI are considered to have completed the migration
    // as they'll see no difference in this version

    PreferencesController.completedUiMigration = betaUI;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\033.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\033.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

Cleans up notices and assocated notice controller code

*/
const version = 33;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state; // transform state here

  if (state.NoticeController) {
    delete newState.NoticeController;
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\034.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\034.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 34;
/**
 * The purpose of this migration is to enable the {@code privacyMode} feature flag and set the user as being migrated
 * if it was {@code false}.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};

    if (!featureFlags.privacyMode && typeof PreferencesController.migratedPrivacyMode === 'undefined') {
      // Mark the state has being migrated and enable Privacy Mode
      PreferencesController.migratedPrivacyMode = true;
      featureFlags.privacyMode = true;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\035.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\035.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

// next version number

/*

Removes the deprecated 'seedWords' state

*/
const version = 35;
var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    versionedData.data = transformState(versionedData.data);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.seedWords !== undefined) {
    delete state.PreferencesController.seedWords;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\036.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\036.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 36;
/**
 * The purpose of this migration is to remove the {@code privacyMode} feature flag.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const featureFlags = PreferencesController.featureFlags || {};

    if (typeof featureFlags.privacyMode !== 'undefined') {
      delete featureFlags.privacyMode;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\037.js", {"@metamask/controllers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\controllers\\dist\\index.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\037.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _controllers = require("@metamask/controllers");

const version = 37;
/**
 * The purpose of this migration is to update the address book state
 * to the new schema with chainId as a key.
 * and to add the isEns flag to all entries
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.AddressBookController) {
    const ab = state.AddressBookController.addressBook;
    const chainIds = new Set();
    const newAddressBook = {}; // add all of the chainIds to a set

    Object.values(ab).forEach(v => {
      chainIds.add(v.chainId);
    }); // fill the chainId object with the entries with the matching chainId

    for (const id of chainIds.values()) {
      // make an empty object entry for each chainId
      newAddressBook[id] = {};

      for (const address in ab) {
        if (ab[address].chainId === id) {
          ab[address].isEns = false;

          if (_controllers.util.normalizeEnsName(ab[address].name)) {
            ab[address].isEns = true;
          }

          newAddressBook[id][address] = ab[address];
        }
      }
    }

    state.AddressBookController.addressBook = newAddressBook;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\038.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\038.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 38;
/**
 * The purpose of this migration is to assign all users to a test group for the fullScreenVsPopup a/b test
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    ABTestController: ABTestControllerState = {}
  } = state;
  const {
    abTests = {}
  } = ABTestControllerState;

  if (abTests.fullScreenVsPopup) {
    return state;
  }

  return { ...state,
    ABTestController: { ...ABTestControllerState,
      abTests: { ...abTests,
        fullScreenVsPopup: 'control'
      }
    }
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\039.js", {"../../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\039.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

const version = 39;
const DAI_V1_CONTRACT_ADDRESS = '0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359';
const DAI_V1_TOKEN_SYMBOL = 'DAI';
const SAI_TOKEN_SYMBOL = 'SAI';

function isOldDai(token = {}) {
  return token && typeof token === 'object' && token.symbol === DAI_V1_TOKEN_SYMBOL && (0, _hexstringUtils.toChecksumHexAddress)(token.address) === DAI_V1_CONTRACT_ADDRESS;
}
/**
 * This migration renames the Dai token to Sai.
 *
 * As of 2019-11-18 Dai is now called Sai (refs https://git.io/JeooP) to facilitate
 * Maker's upgrade to Multi-Collateral Dai and this migration renames the token
 * at the old address.
 */


var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PreferencesController
  } = state;

  if (PreferencesController) {
    const tokens = PreferencesController.tokens || [];

    if (Array.isArray(tokens)) {
      for (const token of tokens) {
        if (isOldDai(token)) {
          token.symbol = SAI_TOKEN_SYMBOL;
        }
      }
    }

    const accountTokens = PreferencesController.accountTokens || {};

    if (accountTokens && typeof accountTokens === 'object') {
      for (const address of Object.keys(accountTokens)) {
        const networkTokens = accountTokens[address];

        if (networkTokens && typeof networkTokens === 'object') {
          for (const network of Object.keys(networkTokens)) {
            const tokensOnNetwork = networkTokens[network];

            if (Array.isArray(tokensOnNetwork)) {
              for (const token of tokensOnNetwork) {
                if (isOldDai(token)) {
                  token.symbol = SAI_TOKEN_SYMBOL;
                }
              }
            }
          }
        }
      }
    }
  }

  return state;
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\040.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\040.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 40;
/**
 * Site connections are now managed by the PermissionsController, and the
 * ProviderApprovalController is removed. This migration deletes all
 * ProviderApprovalController state.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  delete state.ProviderApprovalController;
  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\041.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\041.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 41;
/**
 * PreferencesController.autoLogoutTimeLimit -> autoLockTimeLimit
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController && state.PreferencesController.preferences) {
    state.PreferencesController.preferences.autoLockTimeLimit = state.PreferencesController.preferences.autoLogoutTimeLimit;
    delete state.PreferencesController.preferences.autoLogoutTimeLimit;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\042.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\042.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 42;
/**
 * Initialize `connectedStatusPopoverHasBeenShown` to `false` if it hasn't yet been set,
 * so that existing users are introduced to the new connected status indicator
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.AppStateController) {
    state.AppStateController.connectedStatusPopoverHasBeenShown = false;
  } else {
    state.AppStateController = {
      connectedStatusPopoverHasBeenShown: false
    };
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\043.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\043.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 43;
/**
 * Remove unused 'currentAccountTab' state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon;

  if (state !== null && state !== void 0 && (_state$PreferencesCon = state.PreferencesController) !== null && _state$PreferencesCon !== void 0 && _state$PreferencesCon.currentAccountTab) {
    delete state.PreferencesController.currentAccountTab;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\044.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\044.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 44;
/**
 * Remove unused 'mkrMigrationReminderTimestamp' state from the `AppStateController`
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$AppStateContro;

  if (typeof (state === null || state === void 0 ? void 0 : (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? void 0 : _state$AppStateContro.mkrMigrationReminderTimestamp) !== 'undefined') {
    delete state.AppStateController.mkrMigrationReminderTimestamp;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\045.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\045.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 45;
/**
 * Replaces {@code PreferencesController.ipfsGateway} with 'dweb.link' if set
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const outdatedGateways = ['ipfs.io', 'ipfs.dweb.link'];

function transformState(state) {
  var _state$PreferencesCon;

  if (outdatedGateways.includes(state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.ipfsGateway)) {
    state.PreferencesController.ipfsGateway = 'dweb.link';
  }

  return state;
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\046.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\046.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 46;
/**
 * Delete {@code ABTestController} state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (typeof (state === null || state === void 0 ? void 0 : state.ABTestController) !== 'undefined') {
    delete state.ABTestController;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\047.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\047.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 47;
/**
 * Stringify the `metamaskNetworkId` property of all transactions
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (typeof transaction.metamaskNetworkId === 'number') {
        transaction.metamaskNetworkId = transaction.metamaskNetworkId.toString();
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\048.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\048.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 48;
/**
 * 1.  Delete NetworkController.settings
 * 2a. Migrate NetworkController.provider to Rinkeby if set to type 'rpc' or
 *     'localhost'.
 * 2b. Re-key provider.rpcTarget to provider.rpcUrl
 * 3.  Add localhost network to frequentRpcListDetail.
 * 4.  Delete CachedBalancesController.cachedBalances
 * 5.  Convert transactions metamaskNetworkId to decimal if they are hex
 * 6.  Convert address book keys from decimal to hex
 * 7.  Delete localhost key in IncomingTransactionsController
 * 8.  Merge 'localhost' tokens into 'rpc' tokens
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const hexRegEx = /^0x[0-9a-f]+$/iu;
const chainIdRegEx = /^0x[1-9a-f]+[0-9a-f]*$/iu;

function transformState(state = {}) {
  var _state$NetworkControl, _state$NetworkControl2, _state$NetworkControl3, _state$CachedBalances, _state$TransactionCon, _state$AddressBookCon, _state$IncomingTransa, _state$IncomingTransa2, _state$PreferencesCon;

  // 1. Delete NetworkController.settings
  (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? true : delete _state$NetworkControl.settings; // 2. Migrate NetworkController.provider to Rinkeby or rename rpcTarget key

  const provider = ((_state$NetworkControl2 = state.NetworkController) === null || _state$NetworkControl2 === void 0 ? void 0 : _state$NetworkControl2.provider) || {};
  const isCustomRpcWithInvalidChainId = provider.type === 'rpc' && (typeof provider.chainId !== 'string' || !chainIdRegEx.test(provider.chainId));

  if (isCustomRpcWithInvalidChainId || provider.type === 'localhost') {
    state.NetworkController.provider = {
      type: 'rinkeby',
      rpcUrl: '',
      chainId: '0x4',
      nickname: '',
      rpcPrefs: {},
      ticker: 'ETH'
    };
  } else if ((_state$NetworkControl3 = state.NetworkController) !== null && _state$NetworkControl3 !== void 0 && _state$NetworkControl3.provider) {
    var _state$NetworkControl4, _state$NetworkControl5;

    if ('rpcTarget' in state.NetworkController.provider) {
      const rpcUrl = state.NetworkController.provider.rpcTarget;
      state.NetworkController.provider.rpcUrl = rpcUrl;
    }

    (_state$NetworkControl4 = state.NetworkController) === null || _state$NetworkControl4 === void 0 ? true : (_state$NetworkControl5 = _state$NetworkControl4.provider) === null || _state$NetworkControl5 === void 0 ? true : delete _state$NetworkControl5.rpcTarget;
  } // 3.  Add localhost network to frequentRpcListDetail.


  if (!state.PreferencesController) {
    state.PreferencesController = {};
  }

  if (!state.PreferencesController.frequentRpcListDetail) {
    state.PreferencesController.frequentRpcListDetail = [];
  }

  state.PreferencesController.frequentRpcListDetail.unshift({
    rpcUrl: 'http://localhost:8545',
    chainId: '0x539',
    ticker: 'ETH',
    nickname: 'Localhost 8545',
    rpcPrefs: {}
  }); // 4.  Delete CachedBalancesController.cachedBalances

  (_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? true : delete _state$CachedBalances.cachedBalances; // 5.  Convert transactions metamaskNetworkId to decimal if they are hex

  const transactions = (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      const metamaskNetworkId = transaction === null || transaction === void 0 ? void 0 : transaction.metamaskNetworkId;

      if (typeof metamaskNetworkId === 'string' && hexRegEx.test(metamaskNetworkId)) {
        transaction.metamaskNetworkId = parseInt(metamaskNetworkId, 16).toString(10);
      }
    });
  } // 6.  Convert address book keys from decimal to hex


  const addressBook = ((_state$AddressBookCon = state.AddressBookController) === null || _state$AddressBookCon === void 0 ? void 0 : _state$AddressBookCon.addressBook) || {};
  Object.keys(addressBook).forEach(networkKey => {
    if (/^\d+$/iu.test(networkKey)) {
      const chainId = `0x${parseInt(networkKey, 10).toString(16)}`;
      updateChainIds(addressBook[networkKey], chainId);

      if (addressBook[chainId]) {
        mergeAddressBookKeys(addressBook, networkKey, chainId);
      } else {
        addressBook[chainId] = addressBook[networkKey];
      }

      delete addressBook[networkKey];
    }
  }); // 7.  Delete localhost key in IncomingTransactionsController

  (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? true : (_state$IncomingTransa2 = _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) === null || _state$IncomingTransa2 === void 0 ? true : delete _state$IncomingTransa2.localhost; // 8.  Merge 'localhost' tokens into 'rpc' tokens

  const accountTokens = (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;

  if (accountTokens) {
    Object.keys(accountTokens).forEach(account => {
      var _accountTokens$accoun, _accountTokens$accoun2;

      const localhostTokens = ((_accountTokens$accoun = accountTokens[account]) === null || _accountTokens$accoun === void 0 ? void 0 : _accountTokens$accoun.localhost) || [];

      if (localhostTokens.length > 0) {
        const rpcTokens = accountTokens[account].rpc || [];

        if (rpcTokens.length > 0) {
          accountTokens[account].rpc = mergeTokenArrays(localhostTokens, rpcTokens);
        } else {
          accountTokens[account].rpc = localhostTokens;
        }
      }

      (_accountTokens$accoun2 = accountTokens[account]) === null || _accountTokens$accoun2 === void 0 ? true : delete _accountTokens$accoun2.localhost;
    });
  }

  return state;
}
/**
 * Merges the two given keys for the given address book in place.
 *
 * @param addressBook
 * @param networkKey
 * @param chainIdKey
 */


function mergeAddressBookKeys(addressBook, networkKey, chainIdKey) {
  const networkKeyEntries = addressBook[networkKey] || {}; // For the new entries, start by copying the existing entries for the chainId

  const newEntries = { ...addressBook[chainIdKey]
  }; // For each address of the old/networkId key entries

  Object.keys(networkKeyEntries).forEach(address => {
    if (newEntries[address] && typeof newEntries[address] === 'object') {
      const mergedEntry = {}; // Collect all keys from both entries and merge the corresponding chainId
      // entry with the networkId entry

      new Set([...Object.keys(newEntries[address]), ...Object.keys(networkKeyEntries[address] || {})]).forEach(key => {
        var _networkKeyEntries$ad;

        // Use non-empty value for the current key, if any
        mergedEntry[key] = newEntries[address][key] || ((_networkKeyEntries$ad = networkKeyEntries[address]) === null || _networkKeyEntries$ad === void 0 ? void 0 : _networkKeyEntries$ad[key]) || '';
      });
      newEntries[address] = mergedEntry;
    } else if (networkKeyEntries[address] && typeof networkKeyEntries[address] === 'object') {
      // If there is no corresponding chainId entry, just use the networkId entry
      // directly
      newEntries[address] = networkKeyEntries[address];
    }
  });
  addressBook[chainIdKey] = newEntries;
}
/**
 * Updates the chainId key values to the given chainId in place for all values
 * of the given networkEntries object.
 *
 * @param networkEntries
 * @param chainId
 */


function updateChainIds(networkEntries, chainId) {
  Object.values(networkEntries).forEach(entry => {
    if (entry && typeof entry === 'object') {
      entry.chainId = chainId;
    }
  });
}
/**
 * Merges the two given, non-empty arrays of token objects and returns a new
 * array.
 *
 * @param localhostTokens
 * @param rpcTokens
 * @returns {Array<object>}
 */


function mergeTokenArrays(localhostTokens, rpcTokens) {
  const localhostTokensMap = tokenArrayToMap(localhostTokens);
  const rpcTokensMap = tokenArrayToMap(rpcTokens);
  const mergedTokens = [];
  new Set([...Object.keys(localhostTokensMap), ...Object.keys(rpcTokensMap)]).forEach(tokenAddress => {
    mergedTokens.push({ ...localhostTokensMap[tokenAddress],
      ...rpcTokensMap[tokenAddress]
    });
  });
  return mergedTokens;

  function tokenArrayToMap(array) {
    return array.reduce((map, token) => {
      if (token !== null && token !== void 0 && token.address && typeof (token === null || token === void 0 ? void 0 : token.address) === 'string') {
        map[token.address] = token;
      }

      return map;
    }, {});
  }
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\049.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\049.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 49;
/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state = {}) {
  if (state.PreferencesController) {
    var _state$MetaMetricsCon;

    const {
      metaMetricsId,
      participateInMetaMetrics,
      metaMetricsSendCount
    } = state.PreferencesController;
    state.MetaMetricsController = (_state$MetaMetricsCon = state.MetaMetricsController) !== null && _state$MetaMetricsCon !== void 0 ? _state$MetaMetricsCon : {};

    if (metaMetricsId !== undefined) {
      state.MetaMetricsController.metaMetricsId = metaMetricsId;
      delete state.PreferencesController.metaMetricsId;
    }

    if (participateInMetaMetrics !== undefined) {
      state.MetaMetricsController.participateInMetaMetrics = participateInMetaMetrics;
      delete state.PreferencesController.participateInMetaMetrics;
    }

    if (metaMetricsSendCount !== undefined) {
      state.MetaMetricsController.metaMetricsSendCount = metaMetricsSendCount;
      delete state.PreferencesController.metaMetricsSendCount;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\050.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\050.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 50;
const LEGACY_LOCAL_STORAGE_KEYS = ['METASWAP_GAS_PRICE_ESTIMATES_LAST_RETRIEVED', 'METASWAP_GAS_PRICE_ESTIMATES', 'cachedFetch', 'BASIC_PRICE_ESTIMATES_LAST_RETRIEVED', 'BASIC_PRICE_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES', 'BASIC_GAS_AND_TIME_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES_LAST_RETRIEVED', 'GAS_API_ESTIMATES'];
/**
 * Migrate metaMetrics state to the new MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    LEGACY_LOCAL_STORAGE_KEYS.forEach(key => {
      var _window$localStorage;

      return (_window$localStorage = window.localStorage) === null || _window$localStorage === void 0 ? void 0 : _window$localStorage.removeItem(key);
    });
    return versionedData;
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\051.js", {"../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\051.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 51;
/**
 * Set the chainId in the Network Controller provider data for all infura networks
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$NetworkControl, _BUILT_IN_NETWORKS$ty;

  const {
    chainId,
    type
  } = (state === null || state === void 0 ? void 0 : (_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const enumChainId = (_BUILT_IN_NETWORKS$ty = _network.BUILT_IN_NETWORKS[type]) === null || _BUILT_IN_NETWORKS$ty === void 0 ? void 0 : _BUILT_IN_NETWORKS$ty.chainId;

  if (enumChainId && chainId !== enumChainId) {
    state.NetworkController.provider.chainId = enumChainId;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\052.js", {"../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\052.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 52;
/**
 * Migrate tokens in Preferences to be keyed by chainId instead of
 * providerType. To prevent breaking user's MetaMask and selected
 * tokens, this migration copies the RPC entry into *every* custom RPC
 * chainId.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state = {}) {
  if (state.PreferencesController) {
    const {
      accountTokens,
      accountHiddenTokens,
      frequentRpcListDetail
    } = state.PreferencesController;
    const newAccountTokens = {};
    const newAccountHiddenTokens = {};

    if (accountTokens && Object.keys(accountTokens).length > 0) {
      for (const address of Object.keys(accountTokens)) {
        newAccountTokens[address] = {};

        if (accountTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountTokens[address][detail.chainId] = accountTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }

        for (const providerType of Object.keys(accountTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountTokens[address][_network.CHAIN_IDS.MAINNET] = accountTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;

            case 'ropsten':
              newAccountTokens[address]['0x3'] = accountTokens[address].ropsten;
              break;

            case 'rinkeby':
              newAccountTokens[address]['0x4'] = accountTokens[address].rinkeby;
              break;

            case _network.NETWORK_TYPES.GOERLI:
              newAccountTokens[address][_network.CHAIN_IDS.GOERLI] = accountTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;

            case 'kovan':
              newAccountTokens[address]['0x2a'] = accountTokens[address].kovan;
              break;

            default:
              break;
          }
        }
      }

      state.PreferencesController.accountTokens = newAccountTokens;
    }

    if (accountHiddenTokens && Object.keys(accountHiddenTokens).length > 0) {
      for (const address of Object.keys(accountHiddenTokens)) {
        newAccountHiddenTokens[address] = {};

        if (accountHiddenTokens[address][_network.NETWORK_TYPES.RPC]) {
          frequentRpcListDetail.forEach(detail => {
            newAccountHiddenTokens[address][detail.chainId] = accountHiddenTokens[address][_network.NETWORK_TYPES.RPC];
          });
        }

        for (const providerType of Object.keys(accountHiddenTokens[address])) {
          switch (providerType) {
            case _network.NETWORK_TYPES.MAINNET:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.MAINNET] = accountHiddenTokens[address][_network.NETWORK_TYPES.MAINNET];
              break;

            case 'ropsten':
              newAccountHiddenTokens[address]['0x3'] = accountHiddenTokens[address].ropsten;
              break;

            case 'rinkeby':
              newAccountHiddenTokens[address]['0x4'] = accountHiddenTokens[address].rinkeby;
              break;

            case _network.NETWORK_TYPES.GOERLI:
              newAccountHiddenTokens[address][_network.CHAIN_IDS.GOERLI] = accountHiddenTokens[address][_network.NETWORK_TYPES.GOERLI];
              break;

            case 'kovan':
              newAccountHiddenTokens[address]['0x2a'] = accountHiddenTokens[address].kovan;
              break;

            default:
              break;
          }
        }
      }

      state.PreferencesController.accountHiddenTokens = newAccountHiddenTokens;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\053.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\053.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 53;
/**
 * Deprecate transactionCategory and consolidate on 'type'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$IncomingTransa;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;
  const incomingTransactions = state === null || state === void 0 ? void 0 : (_state$IncomingTransa = state.IncomingTransactionsController) === null || _state$IncomingTransa === void 0 ? void 0 : _state$IncomingTransa.incomingTransactions;

  if (Array.isArray(transactions)) {
    transactions.forEach(transaction => {
      if (transaction) {
        if (transaction.type !== _transaction.TRANSACTION_TYPES.RETRY && transaction.type !== _transaction.TRANSACTION_TYPES.CANCEL) {
          transaction.type = transaction.transactionCategory;
        }

        delete transaction.transactionCategory;
      }
    });
  }

  if (incomingTransactions) {
    const incomingTransactionsEntries = Object.entries(incomingTransactions);
    incomingTransactionsEntries.forEach(([key, transaction]) => {
      if (transaction) {
        delete transaction.transactionCategory;
        state.IncomingTransactionsController.incomingTransactions[key] = { ...transaction,
          type: _transaction.TRANSACTION_TYPES.INCOMING
        };
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\054.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\054.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 54;

function isValidDecimals(decimals) {
  return typeof decimals === 'number' || typeof decimals === 'string' && decimals.match(/^(0x)?\d+$/u);
}
/**
 * Migrates preference tokens with decimals typed as string to number.
 * It also removes any tokens with corrupted or inconvertible decimal values.
 */


var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const newState = state;

  if (!newState.PreferencesController) {
    return newState;
  }

  const tokens = newState.PreferencesController.tokens || []; // Filter out any tokens with corrupted decimal values

  const validTokens = tokens.filter(({
    decimals
  }) => isValidDecimals(decimals));

  for (const token of validTokens) {
    // In the case of a decimal value type string, convert to a number.
    if (typeof token.decimals === 'string') {
      // eslint-disable-next-line radix
      token.decimals = parseInt(token.decimals);
    }
  }

  newState.PreferencesController.tokens = validTokens;
  const {
    accountTokens
  } = newState.PreferencesController;

  if (accountTokens && typeof accountTokens === 'object') {
    for (const address of Object.keys(accountTokens)) {
      const networkTokens = accountTokens[address];

      if (networkTokens && typeof networkTokens === 'object') {
        for (const network of Object.keys(networkTokens)) {
          const tokensOnNetwork = networkTokens[network] || []; // Filter out any tokens with corrupted decimal values

          const validTokensOnNetwork = tokensOnNetwork.filter(({
            decimals
          }) => isValidDecimals(decimals)); // In the case of a decimal value type string, convert to a number.

          for (const token of validTokensOnNetwork) {
            if (typeof token.decimals === 'string') {
              // eslint-disable-next-line radix
              token.decimals = parseInt(token.decimals);
            }
          }

          networkTokens[network] = validTokensOnNetwork;
        }
      }
    }
  }

  newState.PreferencesController.accountTokens = accountTokens;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\055.js", {"../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\055.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _network = require("../../../shared/constants/network");

const version = 55;
/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;
const UNKNOWN_CHAIN_ID_KEY = 'UNKNOWN';
_network.BUILT_IN_NETWORKS.rinkeby = {
  networkId: '4',
  chainId: '0x4',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.ropsten = {
  networkId: '3',
  chainId: '0x3',
  ticker: 'ETH'
};
_network.BUILT_IN_NETWORKS.kovan = {
  networkId: '42',
  chainId: '0x2a',
  ticker: 'ETH'
};

function transformState(state) {
  var _state$IncomingTransa;

  if (state !== null && state !== void 0 && (_state$IncomingTransa = state.IncomingTransactionsController) !== null && _state$IncomingTransa !== void 0 && _state$IncomingTransa.incomingTxLastFetchedBlocksByNetwork) {
    state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId = (0, _lodash.mapKeys)(state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork, // using optional chaining in case user's state has fetched blocks for
    // RPC network types (which don't map to a single chainId). This should
    // not be possible, but it's safer
    (_, key) => {
      var _BUILT_IN_NETWORKS$ke, _BUILT_IN_NETWORKS$ke2;

      return (_BUILT_IN_NETWORKS$ke = (_BUILT_IN_NETWORKS$ke2 = _network.BUILT_IN_NETWORKS[key]) === null || _BUILT_IN_NETWORKS$ke2 === void 0 ? void 0 : _BUILT_IN_NETWORKS$ke2.chainId) !== null && _BUILT_IN_NETWORKS$ke !== void 0 ? _BUILT_IN_NETWORKS$ke : UNKNOWN_CHAIN_ID_KEY;
    }); // Now that mainnet and test net last fetched blocks are keyed by their
    // respective chainIds, we can safely delete anything we had for custom
    // networks. Any custom network that shares a chainId with one of the
    // aforementioned networks will use the value stored by chainId.

    delete state.IncomingTransactionsController.incomingTxLastFetchedBlockByChainId[UNKNOWN_CHAIN_ID_KEY];
    delete state.IncomingTransactionsController.incomingTxLastFetchedBlocksByNetwork;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\056.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\056.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 56;
/**
 * Remove tokens that don't have an address due to
 * lack of previous addToken validation.  Also removes
 * an unwanted, undefined image property
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const {
      PreferencesController
    } = versionedData.data;

    if (Array.isArray(PreferencesController === null || PreferencesController === void 0 ? void 0 : PreferencesController.tokens)) {
      PreferencesController.tokens = PreferencesController.tokens.filter(({
        address
      }) => address);
    }

    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.accountTokens && typeof PreferencesController.accountTokens === 'object') {
      Object.keys(PreferencesController.accountTokens).forEach(account => {
        const chains = Object.keys(PreferencesController.accountTokens[account]);
        chains.forEach(chain => {
          PreferencesController.accountTokens[account][chain] = PreferencesController.accountTokens[account][chain].filter(({
            address
          }) => address);
        });
      });
    }

    if (PreferencesController !== null && PreferencesController !== void 0 && PreferencesController.assetImages && 'undefined' in PreferencesController.assetImages) {
      delete PreferencesController.assetImages.undefined;
    }

    return versionedData;
  }

};
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\057.js", {"../../../shared/modules/random-id":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\random-id.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\057.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _randomId = _interopRequireDefault(require("../../../shared/modules/random-id"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const version = 57;
/**
 * replace 'incomingTxLastFetchedBlocksByNetwork' with 'incomingTxLastFetchedBlockByChainId'
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  if (state !== null && state !== void 0 && (_state$TransactionCon = state.TransactionController) !== null && _state$TransactionCon !== void 0 && _state$TransactionCon.transactions && Array.isArray(state.TransactionController.transactions) && !state.TransactionController.transactions.some(item => typeof item !== 'object' || typeof item.txParams === 'undefined')) {
    state.TransactionController.transactions = (0, _lodash.keyBy)(state.TransactionController.transactions, // In case for some reason any of a user's transactions do not have an id
    // generate a new one for the transaction.
    tx => {
      if (typeof tx.id === 'undefined' || tx.id === null) {
        // This mutates the item in the array, so will result in a change to
        // the state.
        tx.id = (0, _randomId.default)();
      }

      return tx.id;
    });
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\058.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\058.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 58;
/**
 * Deletes the swapsWelcomeMessageHasBeenShown property from state
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$AppStateContro;

  (_state$AppStateContro = state.AppStateController) === null || _state$AppStateContro === void 0 ? true : delete _state$AppStateContro.swapsWelcomeMessageHasBeenShown;
  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\059.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\059.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 59;
/**
 * Removes orphaned cancel and retry transactions that no longer have the
 * original transaction in state, which results in bugs.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    versionedData.data = transformState(state);
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if ((0, _lodash.isPlainObject)(transactions)) {
    const nonceNetworkGroupedObject = (0, _lodash.groupBy)(Object.values(transactions), tx => {
      var _tx$txParams, _tx$chainId;

      return `${(_tx$txParams = tx.txParams) === null || _tx$txParams === void 0 ? void 0 : _tx$txParams.nonce}-${(_tx$chainId = tx.chainId) !== null && _tx$chainId !== void 0 ? _tx$chainId : tx.metamaskNetworkId}`;
    });
    const withoutOrphans = (0, _lodash.pickBy)(nonceNetworkGroupedObject, group => {
      return group.some(tx => tx.type !== _transaction.TRANSACTION_TYPES.CANCEL && tx.type !== _transaction.TRANSACTION_TYPES.RETRY);
    });
    state.TransactionController.transactions = (0, _lodash.keyBy)((0, _lodash.concat)(...Object.values(withoutOrphans)), tx => tx.id);
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\060.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\060.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 60;
const SUPPORT_NOTIFICATION_KEY = 2;
const SUPPORT_NOTIFICATION_DATE = '2020-08-31';
/**
 * Removes the support survey notification
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$NotificationCo;

  const notifications = state === null || state === void 0 ? void 0 : (_state$NotificationCo = state.NotificationController) === null || _state$NotificationCo === void 0 ? void 0 : _state$NotificationCo.notifications;

  if ((0, _lodash.isPlainObject)(notifications)) {
    var _notifications$SUPPOR;

    if (((_notifications$SUPPOR = notifications[SUPPORT_NOTIFICATION_KEY]) === null || _notifications$SUPPOR === void 0 ? void 0 : _notifications$SUPPOR.date) === SUPPORT_NOTIFICATION_DATE) {
      delete state.NotificationController.notifications[SUPPORT_NOTIFICATION_KEY];
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\061.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\061.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 61;
/**
 * Initialize attributes related to recovery seed phrase reminder
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const currentTime = new Date().getTime();

  if (state.AppStateController) {
    state.AppStateController.recoveryPhraseReminderHasBeenShown = false;
    state.AppStateController.recoveryPhraseReminderLastShown = currentTime;
  } else {
    state.AppStateController = {
      recoveryPhraseReminderHasBeenShown: false,
      recoveryPhraseReminderLastShown: currentTime
    };
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\062.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\062.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 62;
/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.MetaMetricsController) {
    const {
      metaMetricsSendCount
    } = state.MetaMetricsController;

    if (metaMetricsSendCount !== undefined) {
      delete state.MetaMetricsController.metaMetricsSendCount;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\063.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\063.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 63;
/**
 * Moves token state from preferences controller to TokensController
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon, _state$PreferencesCon2, _state$PreferencesCon3, _state$PreferencesCon4, _state$PreferencesCon5, _state$PreferencesCon6, _state$PreferencesCon7, _state$PreferencesCon8;

  const accountTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.accountTokens;
  const accountHiddenTokens = state === null || state === void 0 ? void 0 : (_state$PreferencesCon2 = state.PreferencesController) === null || _state$PreferencesCon2 === void 0 ? void 0 : _state$PreferencesCon2.accountHiddenTokens;
  const newAllTokens = {};

  if (accountTokens) {
    Object.keys(accountTokens).forEach(accountAddress => {
      Object.keys(accountTokens[accountAddress]).forEach(chainId => {
        const tokensArray = accountTokens[accountAddress][chainId];

        if (newAllTokens[chainId] === undefined) {
          newAllTokens[chainId] = {
            [accountAddress]: tokensArray
          };
        } else {
          newAllTokens[chainId] = { ...newAllTokens[chainId],
            [accountAddress]: tokensArray
          };
        }
      });
    });
  }

  const newAllIgnoredTokens = {};

  if (accountHiddenTokens) {
    Object.keys(accountHiddenTokens).forEach(accountAddress => {
      Object.keys(accountHiddenTokens[accountAddress]).forEach(chainId => {
        const ignoredTokensArray = accountHiddenTokens[accountAddress][chainId];

        if (newAllIgnoredTokens[chainId] === undefined) {
          newAllIgnoredTokens[chainId] = {
            [accountAddress]: ignoredTokensArray
          };
        } else {
          newAllIgnoredTokens[chainId] = { ...newAllIgnoredTokens[chainId],
            [accountAddress]: ignoredTokensArray
          };
        }
      });
    });
  }

  if (state.TokensController) {
    state.TokensController.allTokens = newAllTokens;
    state.TokensController.allIgnoredTokens = newAllIgnoredTokens;
  } else {
    state.TokensController = {
      allTokens: newAllTokens,
      allIgnoredTokens: newAllIgnoredTokens
    };
  }

  state === null || state === void 0 ? true : (_state$PreferencesCon3 = state.PreferencesController) === null || _state$PreferencesCon3 === void 0 ? true : delete _state$PreferencesCon3.accountHiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon4 = state.PreferencesController) === null || _state$PreferencesCon4 === void 0 ? true : delete _state$PreferencesCon4.accountTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon5 = state.PreferencesController) === null || _state$PreferencesCon5 === void 0 ? true : delete _state$PreferencesCon5.assetImages;
  state === null || state === void 0 ? true : (_state$PreferencesCon6 = state.PreferencesController) === null || _state$PreferencesCon6 === void 0 ? true : delete _state$PreferencesCon6.hiddenTokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon7 = state.PreferencesController) === null || _state$PreferencesCon7 === void 0 ? true : delete _state$PreferencesCon7.tokens;
  state === null || state === void 0 ? true : (_state$PreferencesCon8 = state.PreferencesController) === null || _state$PreferencesCon8 === void 0 ? true : delete _state$PreferencesCon8.suggestedTokens;
  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\064.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\064.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

const version = 64;
const SENT_ETHER = 'sentEther'; // the legacy transaction type being replaced in this migration with TRANSACTION_TYPES.SIMPLE_SEND

/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon;

  const transactions = state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions;

  if ((0, _lodash.isPlainObject)(transactions)) {
    for (const tx of Object.values(transactions)) {
      if (tx.type === SENT_ETHER) {
        tx.type = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
      }

      if (tx.history) {
        tx.history.map(txEvent => {
          if (txEvent.type && txEvent.type === SENT_ETHER) {
            txEvent.type = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
          }

          return txEvent;
        });
      }
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\065.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\065.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 65;
/**
 * Removes metaMetricsSendCount from MetaMetrics controller
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.PreferencesController) {
    var _state$OnboardingCont;

    const {
      completedOnboarding,
      firstTimeFlowType
    } = state.PreferencesController;
    state.OnboardingController = (_state$OnboardingCont = state.OnboardingController) !== null && _state$OnboardingCont !== void 0 ? _state$OnboardingCont : {};

    if (completedOnboarding !== undefined) {
      state.OnboardingController.completedOnboarding = completedOnboarding;
      delete state.PreferencesController.completedOnboarding;
    }

    if (firstTimeFlowType !== undefined) {
      state.OnboardingController.firstTimeFlowType = firstTimeFlowType;
      delete state.PreferencesController.firstTimeFlowType;
    }
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\066.js", {"../../../shared/constants/hardware-wallets":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\066.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

const version = 66;
/**
 * Changes the useLedgerLive boolean property to the ledgerTransportType enum
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PreferencesCon;

  const defaultTransportType = window.navigator.hid ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.WEBHID : _hardwareWallets.LEDGER_TRANSPORT_TYPES.U2F;
  const useLedgerLive = Boolean((_state$PreferencesCon = state.PreferencesController) === null || _state$PreferencesCon === void 0 ? void 0 : _state$PreferencesCon.useLedgerLive);
  const newState = { ...state,
    PreferencesController: { ...(state === null || state === void 0 ? void 0 : state.PreferencesController),
      ledgerTransportType: useLedgerLive ? _hardwareWallets.LEDGER_TRANSPORT_TYPES.LIVE : defaultTransportType
    }
  };
  delete newState.PreferencesController.useLedgerLive;
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\067.js", {"../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\067.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _network = require("../../../shared/constants/network");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);

const version = 67;
/**
 * Sets the showTestNetworks property to true if it was false or undefined, and there is evidence
 * that the user has used a test net
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$NetworkControl, _state$CachedBalances;

  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};

  if (preferences.showTestNetworks) {
    return state;
  }

  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const provider = ((_state$NetworkControl = state.NetworkController) === null || _state$NetworkControl === void 0 ? void 0 : _state$NetworkControl.provider) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};

  const userIsCurrentlyOnATestNet = _network.TEST_CHAINS.includes(provider === null || provider === void 0 ? void 0 : provider.chainId);

  const userHasMadeATestNetTransaction = Object.values(transactions).some(({
    chainId
  }) => _network.TEST_CHAINS.includes(chainId));

  const userHasACachedBalanceOnATestnet = _network.TEST_CHAINS.some(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });

  const userHasUsedATestnet = userIsCurrentlyOnATestNet || userHasMadeATestNetTransaction || userHasACachedBalanceOnATestnet;
  const newState = { ...state,
    PreferencesController: { ...PreferencesController,
      preferences: { ...preferences,
        showTestNetworks: userHasUsedATestnet
      }
    }
  };
  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\068.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\068.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 68;
/**
 * Transforms the PermissionsController and PermissionsMetadata substates
 * to match the new permission system.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const {
    PermissionsController = {},
    PermissionsMetadata = {},
    ...remainingState
  } = state;
  const {
    domainMetadata = {},
    permissionsHistory = {},
    permissionsLog = []
  } = PermissionsMetadata;
  return { ...remainingState,
    PermissionController: getPermissionControllerState(PermissionsController),
    PermissionLogController: {
      permissionActivityLog: permissionsLog,
      permissionHistory: permissionsHistory
    },
    SubjectMetadataController: getSubjectMetadataControllerState(domainMetadata)
  };
}

function getPermissionControllerState(PermissionsController) {
  const {
    domains = {}
  } = PermissionsController;
  /**
   * Example existing domain entry. Every existing domain will have a single
   * eth_accounts permission, which simplifies the transform.
   *
   * 'https://metamask.github.io': {
   *   permissions: [
   *     {
   *       '@context': ['https://github.com/MetaMask/rpc-cap'],
   *       'caveats': [
   *         {
   *           name: 'primaryAccountOnly',
   *           type: 'limitResponseLength',
   *           value: 1,
   *         },
   *         {
   *           name: 'exposedAccounts',
   *           type: 'filterResponse',
   *           value: ['0x0c97a5c81e50a02ff8be73cc3f0a0569e61f4ed8'],
   *         },
   *       ],
   *       'date': 1616006369498,
   *       'id': '3d0bdc27-e8e4-4fb0-a24b-340d61f6a3fa',
   *       'invoker': 'https://metamask.github.io',
   *       'parentCapability': 'eth_accounts',
   *     },
   *   ],
   * },
   */

  const ETH_ACCOUNTS = 'eth_accounts';
  const NEW_CAVEAT_TYPE = 'restrictReturnedAccounts';
  const OLD_CAVEAT_NAME = 'exposedAccounts';
  const subjects = Object.entries(domains).reduce((transformed, [origin, domainEntry]) => {
    const {
      permissions: [ethAccountsPermission]
    } = domainEntry; // There are two caveats for each eth_accounts permission, but we only
    // need the value of one of them in the new permission system.

    const oldCaveat = ethAccountsPermission.caveats.find(caveat => caveat.name === OLD_CAVEAT_NAME);
    const newPermission = { ...ethAccountsPermission,
      caveats: [{
        type: NEW_CAVEAT_TYPE,
        value: oldCaveat.value
      }]
    }; // We never used this, and just omit it in the new system.

    delete newPermission['@context'];
    transformed[origin] = {
      origin,
      permissions: {
        [ETH_ACCOUNTS]: newPermission
      }
    };
    return transformed;
  }, {});
  return {
    subjects
  };
}

function getSubjectMetadataControllerState(domainMetadata) {
  /**
   * Example existing domainMetadata entry.
   *
   * "https://www.youtube.com": {
   *   "host": "www.youtube.com",
   *   "icon": null,
   *   "lastUpdated": 1637697914908,
   *   "name": "YouTube"
   * }
   */
  const subjectMetadata = Object.entries(domainMetadata).reduce((transformed, [origin, metadata]) => {
    const {
      name = null,
      icon = null,
      extensionId = null,
      ...other
    } = metadata; // We're getting rid of these.

    delete other.lastUpdated;
    delete other.host;

    if (origin) {
      transformed[origin] = {
        name,
        iconUrl: icon,
        extensionId,
        ...other,
        origin
      };
    }

    return transformed;
  }, {});
  return {
    subjectMetadata
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\069.js", {"../../../shared/constants/app":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\069.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _app = require("../../../shared/constants/app");

const version = 69;
/**
 * Adds the `subjectType` property to all subject metadata.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$SubjectMetadat;

  if (typeof (state === null || state === void 0 ? void 0 : (_state$SubjectMetadat = state.SubjectMetadataController) === null || _state$SubjectMetadat === void 0 ? void 0 : _state$SubjectMetadat.subjectMetadata) === 'object') {
    const {
      SubjectMetadataController: {
        subjectMetadata
      }
    } = state; // mutate SubjectMetadataController.subjectMetadata in place

    Object.values(subjectMetadata).forEach(metadata => {
      if (metadata && typeof metadata === 'object' && !Array.isArray(metadata)) {
        metadata.subjectType = metadata.extensionId ? _app.SUBJECT_TYPES.EXTENSION : _app.SUBJECT_TYPES.WEBSITE;
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\070.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\070.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 70;
/**
 * Removes the `request` and `response` properties from
 * `PermissionLogController.permissionActivityLog` objects.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$PermissionLogC;

  if (Array.isArray(state === null || state === void 0 ? void 0 : (_state$PermissionLogC = state.PermissionLogController) === null || _state$PermissionLogC === void 0 ? void 0 : _state$PermissionLogC.permissionActivityLog)) {
    const {
      PermissionLogController: {
        permissionActivityLog
      }
    } = state; // mutate activity log entries in place

    permissionActivityLog.forEach(logEntry => {
      if (logEntry && typeof logEntry === 'object' && !Array.isArray(logEntry)) {
        delete logEntry.request;
        delete logEntry.response;
      }
    });
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\071.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\071.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 71;
/**
 * Renames NotificationController to AnnouncementController
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  if (state.NotificationController) {
    state.AnnouncementController = {
      announcements: state.NotificationController.notifications
    };
    delete state.NotificationController;
  }

  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\072.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\072.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 72;
/**
 * Should empty the `knownMethodData` object in PreferencesController
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return { ...state,
    PreferencesController: { ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\073.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\073.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 73;
/**
 * Should empty the `knownMethodData` object in PreferencesController
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  return { ...state,
    PreferencesController: { ...PreferencesController,
      knownMethodData: {}
    }
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\074.js", {"../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\074.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _network = require("../../../shared/constants/network");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const version = 74;

const hexNumberIsGreaterThanZero = hexNumber => new _bignumber.default(hexNumber || '0x0', 16).gt(0);

const DEPRECATED_TEST_NET_CHAINIDS = ['0x3', '0x2a', '0x4'];
const DEPRECATED_TEST_NET_DETAILS = {
  '0x3': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'ropsten'
    }),
    nickname: 'Ropsten',
    ticker: 'RopstenETH'
  },
  '0x2a': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'kovan'
    }),
    nickname: 'Kovan',
    ticker: 'KovanETH'
  },
  '0x4': {
    rpcUrl: (0, _network.getRpcUrl)({
      network: 'rinkeby'
    }),
    nickname: 'Rinkeby',
    ticker: 'RinkebyETH'
  }
};
/**
 * Migrates the user default but deprecated testnet networks to custom networks, and
 * if the current network is one such network, updates the network provider details so that it
 * will work as a custom rpc
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  var _state$TransactionCon, _state$CachedBalances, _PreferencesControlle;

  const PreferencesController = (state === null || state === void 0 ? void 0 : state.PreferencesController) || {};
  const preferences = PreferencesController.preferences || {};
  const NetworkController = (state === null || state === void 0 ? void 0 : state.NetworkController) || {};
  const provider = (NetworkController === null || NetworkController === void 0 ? void 0 : NetworkController.provider) || {};
  const currentlyOnDeprecatedNetwork = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => chainId === (provider === null || provider === void 0 ? void 0 : provider.chainId)); // If the user does not want to see test networks, and if the the user is not on a deprecated test network, then
  // no need to migrate the test network data to a custom network

  if (!preferences.showTestNetworks && currentlyOnDeprecatedNetwork.length === 0) {
    return state;
  }

  const transactions = (state === null || state === void 0 ? void 0 : (_state$TransactionCon = state.TransactionController) === null || _state$TransactionCon === void 0 ? void 0 : _state$TransactionCon.transactions) || {};
  const cachedBalances = ((_state$CachedBalances = state.CachedBalancesController) === null || _state$CachedBalances === void 0 ? void 0 : _state$CachedBalances.cachedBalances) || {};
  const deprecatedTestnetsOnWhichTheUserHasMadeATransaction = Object.values(transactions).filter(({
    chainId
  }) => DEPRECATED_TEST_NET_CHAINIDS.includes(chainId)).map(({
    chainId
  }) => chainId);
  const deprecatedTestnetsOnWhichTheUserHasCachedBalance = DEPRECATED_TEST_NET_CHAINIDS.filter(chainId => {
    const cachedBalancesForChain = Object.values(cachedBalances[chainId] || {});
    const userHasABalanceGreaterThanZeroOnThisChain = cachedBalancesForChain.some(hexNumberIsGreaterThanZero);
    return userHasABalanceGreaterThanZeroOnThisChain;
  });
  const deprecatedTestnetsThatHaveBeenUsed = (0, _lodash.uniq)([...deprecatedTestnetsOnWhichTheUserHasCachedBalance, ...deprecatedTestnetsOnWhichTheUserHasMadeATransaction, ...currentlyOnDeprecatedNetwork]);
  const newFrequentRpcListDetail = (_PreferencesControlle = PreferencesController.frequentRpcListDetail) !== null && _PreferencesControlle !== void 0 ? _PreferencesControlle : [];
  deprecatedTestnetsThatHaveBeenUsed.forEach(chainId => {
    if (!newFrequentRpcListDetail.find(rpcDetails => rpcDetails.chainId === chainId)) {
      newFrequentRpcListDetail.unshift({
        rpcUrl: DEPRECATED_TEST_NET_DETAILS[chainId].rpcUrl,
        chainId,
        ticker: DEPRECATED_TEST_NET_DETAILS[chainId].ticker,
        nickname: DEPRECATED_TEST_NET_DETAILS[chainId].nickname,
        rpcPrefs: {}
      });
    }
  });

  if (newFrequentRpcListDetail.length) {
    PreferencesController.frequentRpcListDetail = newFrequentRpcListDetail;
  }

  if (currentlyOnDeprecatedNetwork.length) {
    const selectedNetworkChainId = currentlyOnDeprecatedNetwork[0];
    NetworkController.provider = { ...NetworkController.provider,
      type: 'rpc',
      rpcUrl: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].rpcUrl,
      chainId: selectedNetworkChainId,
      nickname: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].nickname,
      ticker: DEPRECATED_TEST_NET_DETAILS[selectedNetworkChainId].ticker
    };
  }

  return { ...state,
    PreferencesController: { ...PreferencesController
    },
    NetworkController: { ...NetworkController
    }
  };
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\075.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\075.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

const version = 75;
/**
 * Delete the ThreeBoxController.
 */

var _default = {
  version,

  async migrate(originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;
    const state = versionedData.data;
    const newState = transformState(state);
    versionedData.data = newState;
    return versionedData;
  }

};
exports.default = _default;

function transformState(state) {
  delete state.ThreeBoxController;
  return state;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\fail-tx.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\fail-tx.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = failTxsThat;

var _lodash = require("lodash");

var _transaction = require("../../../shared/constants/transaction");

function failTxsThat(version, reason, condition) {
  return function (originalVersionedData) {
    const versionedData = (0, _lodash.cloneDeep)(originalVersionedData);
    versionedData.meta.version = version;

    try {
      const state = versionedData.data;
      const newState = transformState(state, condition, reason);
      versionedData.data = newState;
    } catch (err) {
      console.warn(`MetaMask Migration #${version}${err.stack}`);
    }

    return Promise.resolve(versionedData);
  };
}

function transformState(state, condition, reason) {
  const newState = state;
  const {
    TransactionController
  } = newState;

  if (TransactionController && TransactionController.transactions) {
    const {
      transactions
    } = TransactionController;
    newState.TransactionController.transactions = transactions.map(txMeta => {
      if (!condition(txMeta)) {
        return txMeta;
      }

      txMeta.status = _transaction.TRANSACTION_STATUSES.FAILED;
      txMeta.err = {
        message: reason,
        note: `Tx automatically failed by migration because ${reason}`
      };
      return txMeta;
    });
  }

  return newState;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\index.js", {"./002":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\002.js","./003":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\003.js","./004":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\004.js","./005":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\005.js","./006":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\006.js","./007":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\007.js","./008":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\008.js","./009":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\009.js","./010":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\010.js","./011":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\011.js","./012":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\012.js","./013":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\013.js","./014":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\014.js","./015":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\015.js","./016":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\016.js","./017":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\017.js","./018":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\018.js","./019":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\019.js","./020":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\020.js","./021":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\021.js","./022":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\022.js","./023":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\023.js","./024":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\024.js","./025":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\025.js","./026":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\026.js","./027":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\027.js","./028":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\028.js","./029":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\029.js","./030":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\030.js","./031":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\031.js","./032":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\032.js","./033":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\033.js","./034":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\034.js","./035":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\035.js","./036":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\036.js","./037":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\037.js","./038":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\038.js","./039":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\039.js","./040":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\040.js","./041":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\041.js","./042":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\042.js","./043":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\043.js","./044":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\044.js","./045":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\045.js","./046":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\046.js","./047":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\047.js","./048":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\048.js","./049":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\049.js","./050":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\050.js","./051":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\051.js","./052":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\052.js","./053":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\053.js","./054":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\054.js","./055":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\055.js","./056":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\056.js","./057":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\057.js","./058":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\058.js","./059":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\059.js","./060":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\060.js","./061":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\061.js","./062":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\062.js","./063":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\063.js","./064":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\064.js","./065":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\065.js","./066":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\066.js","./067":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\067.js","./068":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\068.js","./069":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\069.js","./070":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\070.js","./071":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\071.js","./072":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\072.js","./073":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\073.js","./074":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\074.js","./075":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\migrations\\075.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\app\scripts\migrations\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ = _interopRequireDefault(require("./002"));

var _2 = _interopRequireDefault(require("./003"));

var _3 = _interopRequireDefault(require("./004"));

var _4 = _interopRequireDefault(require("./005"));

var _5 = _interopRequireDefault(require("./006"));

var _6 = _interopRequireDefault(require("./007"));

var _7 = _interopRequireDefault(require("./008"));

var _8 = _interopRequireDefault(require("./009"));

var _9 = _interopRequireDefault(require("./010"));

var _10 = _interopRequireDefault(require("./011"));

var _11 = _interopRequireDefault(require("./012"));

var _12 = _interopRequireDefault(require("./013"));

var _13 = _interopRequireDefault(require("./014"));

var _14 = _interopRequireDefault(require("./015"));

var _15 = _interopRequireDefault(require("./016"));

var _16 = _interopRequireDefault(require("./017"));

var _17 = _interopRequireDefault(require("./018"));

var _18 = _interopRequireDefault(require("./019"));

var _19 = _interopRequireDefault(require("./020"));

var _20 = _interopRequireDefault(require("./021"));

var _21 = _interopRequireDefault(require("./022"));

var _22 = _interopRequireDefault(require("./023"));

var _23 = _interopRequireDefault(require("./024"));

var _24 = _interopRequireDefault(require("./025"));

var _25 = _interopRequireDefault(require("./026"));

var _26 = _interopRequireDefault(require("./027"));

var _27 = _interopRequireDefault(require("./028"));

var _28 = _interopRequireDefault(require("./029"));

var _29 = _interopRequireDefault(require("./030"));

var _30 = _interopRequireDefault(require("./031"));

var _31 = _interopRequireDefault(require("./032"));

var _32 = _interopRequireDefault(require("./033"));

var _33 = _interopRequireDefault(require("./034"));

var _34 = _interopRequireDefault(require("./035"));

var _35 = _interopRequireDefault(require("./036"));

var _36 = _interopRequireDefault(require("./037"));

var _37 = _interopRequireDefault(require("./038"));

var _38 = _interopRequireDefault(require("./039"));

var _39 = _interopRequireDefault(require("./040"));

var _40 = _interopRequireDefault(require("./041"));

var _41 = _interopRequireDefault(require("./042"));

var _42 = _interopRequireDefault(require("./043"));

var _43 = _interopRequireDefault(require("./044"));

var _44 = _interopRequireDefault(require("./045"));

var _45 = _interopRequireDefault(require("./046"));

var _46 = _interopRequireDefault(require("./047"));

var _47 = _interopRequireDefault(require("./048"));

var _48 = _interopRequireDefault(require("./049"));

var _49 = _interopRequireDefault(require("./050"));

var _50 = _interopRequireDefault(require("./051"));

var _51 = _interopRequireDefault(require("./052"));

var _52 = _interopRequireDefault(require("./053"));

var _53 = _interopRequireDefault(require("./054"));

var _54 = _interopRequireDefault(require("./055"));

var _55 = _interopRequireDefault(require("./056"));

var _56 = _interopRequireDefault(require("./057"));

var _57 = _interopRequireDefault(require("./058"));

var _58 = _interopRequireDefault(require("./059"));

var _59 = _interopRequireDefault(require("./060"));

var _60 = _interopRequireDefault(require("./061"));

var _61 = _interopRequireDefault(require("./062"));

var _62 = _interopRequireDefault(require("./063"));

var _63 = _interopRequireDefault(require("./064"));

var _64 = _interopRequireDefault(require("./065"));

var _65 = _interopRequireDefault(require("./066"));

var _66 = _interopRequireDefault(require("./067"));

var _67 = _interopRequireDefault(require("./068"));

var _68 = _interopRequireDefault(require("./069"));

var _69 = _interopRequireDefault(require("./070"));

var _70 = _interopRequireDefault(require("./071"));

var _71 = _interopRequireDefault(require("./072"));

var _72 = _interopRequireDefault(require("./073"));

var _73 = _interopRequireDefault(require("./074"));

var _74 = _interopRequireDefault(require("./075"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Migrations must start at version 1 or later.
// They are objects with a `version` number
// and a `migrate` function.
//
// The `migrate` function receives the previous
// config data format, and returns the new one.
const migrations = [_.default, _2.default, _3.default, _4.default, _5.default, _6.default, _7.default, _8.default, _9.default, _10.default, _11.default, _12.default, _13.default, _14.default, _15.default, _16.default, _17.default, _18.default, _19.default, _20.default, _21.default, _22.default, _23.default, _24.default, _25.default, _26.default, _27.default, _28.default, _29.default, _30.default, _31.default, _32.default, _33.default, _34.default, _35.default, _36.default, _37.default, _38.default, _39.default, _40.default, _41.default, _42.default, _43.default, _44.default, _45.default, _46.default, _47.default, _48.default, _49.default, _50.default, _51.default, _52.default, _53.default, _54.default, _55.default, _56.default, _57.default, _58.default, _59.default, _60.default, _61.default, _62.default, _63.default, _64.default, _65.default, _66.default, _67.default, _68.default, _69.default, _70.default, _71.default, _72.default, _73.default, _74.default];
var _default = migrations;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\construct.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@babel\runtime\helpers\construct.js
      return function (require, module, exports) {
// All of MetaMask's supported browsers include `Reflect.construct` support, so
// we don't need this polyfill.

// This Proxy preseves the two properties that were added by `@babel/runtime`.
// I am not entire sure what these properties are for (maybe ES5/ES6
// interoperability?) but they have been preserved just in case.
const reflectProxy =  new Proxy(
  Reflect.construct,
  {
    get: function (target, property) {
      if (property === 'default') {
        return target;
      } else if (property === '__esModule') {
        return true;
      }
      return Reflect.get(...arguments);
    }
  }
);

module.exports = reflectProxy;
      };
    };
  }
}, {package:"@babel/runtime",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\isNativeFunction.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@babel\runtime\helpers\isNativeFunction.js
      return function (require, module, exports) {
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
      };
    };
  }
}, {package:"@babel/runtime",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\wrapNativeSuper.js", {"./construct.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\construct.js","./getPrototypeOf.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\getPrototypeOf.js","./isNativeFunction.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\isNativeFunction.js","./setPrototypeOf.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\setPrototypeOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@babel\runtime\helpers\wrapNativeSuper.js
      return function (require, module, exports) {
var getPrototypeOf = require("./getPrototypeOf.js");

var setPrototypeOf = require("./setPrototypeOf.js");

var isNativeFunction = require("./isNativeFunction.js");

var construct = require("./construct.js");

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return construct(Class, arguments, getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return setPrototypeOf(Wrapper, Class);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _wrapNativeSuper(Class);
}

module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
      };
    };
  }
}, {package:"@babel/runtime",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js", {"cids":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\cids\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@ensdomains\content-hash\src\helpers.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');

// Label's max length in DNS (https://tools.ietf.org/html/rfc1034#page-7)
const dnsLabelMaxLength = 63;

/**
 * Take any ipfsHash and convert it to DNS-compatible CID
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidForWeb = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
  let dnsLabel = cid.toString('base32');
  if (dnsLabel.length > dnsLabelMaxLength) {
    const b36 = cid.toString('base36');
    if (b36.length <= dnsLabelMaxLength) {
      return b36;
    }
    throw new TypeError ('CID is longer than DNS limit of 63 characters and is not compatible with public gateways');
  }
	return dnsLabel;
}

exports.cidForWeb = cidForWeb;


/**
 * Take any ipfsHash and convert it to a CID v1 encoded in base32.
 * @param {string} ipfsHash a regular ipfs hash either a cid v0 or v1 (v1 will remain unchanged)
 * @return {string} the resulting ipfs hash as a cid v1
 */
const cidV0ToV1Base32 = (ipfsHash) => {
	let cid = new CID(ipfsHash);
	if (cid.version === 0) {
		cid = cid.toV1();
	}
	return cid.toString('base32');
}

exports.cidV0ToV1Base32 = cidV0ToV1Base32;

      };
    };
  }
}, {package:"@ensdomains/content-hash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\index.js", {"./helpers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\helpers.js","./profiles":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js","multicodec":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multicodec\\src\\index.js","multihashes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@ensdomains\content-hash\src\index.js
      return function (require, module, exports) {
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const multiC = require('multicodec');
const multiH = require('multihashes');

const { hexStringToBuffer, profiles } = require('./profiles');
const { cidForWeb, cidV0ToV1Base32 } = require('./helpers');

module.exports = {

	//export some helpers functions
	helpers: {
		cidForWeb,
		cidV0ToV1Base32,
	},

	/**
	* Decode a Content Hash.
	* @param {string} hash an hex string containing a content hash
	* @return {string} the decoded content
	*/
	decode: function (contentHash) {
		const buffer = hexStringToBuffer(contentHash);
		const codec = multiC.getCodec(buffer);
		const value = multiC.rmPrefix(buffer);
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		return profile.decode(value);
	},

	/**
	* Encode an IPFS address into a content hash
	* @param {string} ipfsHash string containing an IPFS address
	* @return {string} the resulting content hash
	*/
	fromIpfs: function (ipfsHash) {
		return this.encode('ipfs-ns', ipfsHash);
	},

	/**
	* Encode a Skylink into a content hash
	* @param {string} skylink string containing a Skylink
	* @return {string} the resulting content hash
	*/
	fromSkylink: function (skylink) {
		return this.encode('skynet-ns', skylink);
	},

	/**
	* Encode a Swarm address into a content hash
	* @param {string} swarmHash string containing a Swarm address
	* @return {string} the resulting content hash
	*/
	fromSwarm: function (swarmHash) {
		return this.encode('swarm-ns', swarmHash);
	},

	/**
	* General purpose encoding function
  * @param {string} codec 
  * @param {string} value 
  */
	encode: function (codec, value) {
		let profile = profiles[codec];
		if (!profile) profile = profiles['default'];
		const encodedValue = profile.encode(value);
		return multiH.toHexString(multiC.addPrefix(codec, encodedValue))
	},

	/**
	* Extract the codec of a content hash
	* @param {string} hash hex string containing a content hash
	* @return {string} the extracted codec
	*/
	getCodec: function (hash) {
		let buffer = hexStringToBuffer(hash);
		return multiC.getCodec(buffer);
	},
}

      };
    };
  }
}, {package:"@ensdomains/content-hash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ensdomains\\content-hash\\src\\profiles.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","cids":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\cids\\src\\index.js","js-base64":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\js-base64\\base64.js","multihashes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multihashes\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@ensdomains\content-hash\src\profiles.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
	ISC License

	Copyright (c) 2019, Pierre-Louis Despaigne

	Permission to use, copy, modify, and/or distribute this software for any
	purpose with or without fee is hereby granted, provided that the above
	copyright notice and this permission notice appear in all copies.

	THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
	WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
	ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
	WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
	ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
	OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

const CID = require('cids');
const multiH = require('multihashes');
const base64 = require('js-base64')

/**
 * Convert an hexadecimal string to a Buffer, the string can start with or without '0x'
 * @param {string} hex an hexadecimal value
 * @return {Buffer} the resulting Buffer
 */
const hexStringToBuffer = (hex) => {
	let prefix = hex.slice(0, 2);
	let value = hex.slice(2);
	let res = '';
	if (prefix === '0x') res = value;
	else res = hex;
	return multiH.fromHexString(res);
}

/**
 * Validates IPNS identifier  to safeguard against insecure names.
 * @param {CID} name ised in ipns-ns
 * @return {bool}
 */
const isCryptographicIPNS =  (cid) => {
  try {
    const { multihash } = cid
    // Additional check for identifiers shorter
    // than what inlined ED25519 pubkey would be
    // https://github.com/ensdomains/ens-app/issues/849#issuecomment-777088950
    if (multihash.length < 38) {
      const mh = multiH.decode(multihash)
      // ED25519 pubkeys are inlined using identity hash function
      // and we should not see anything shorter than that
      if (mh.name === 'identity' && mh.length < 36) {
        // One can read inlined string value via:
        // console.log('ipns-ns id:', String(multiH.decode(new CID(value).multihash).digest))
        return false
      }
    }
    // ok, CID looks fine
    return true
  } catch (_) { return false }
  return false
}

/**
* list of known encoding,
* encoding should be a function that takes a `string` input,
* and return a `Buffer` result
*/
const encodes = {
  /**
  * @param {string} value
  * @return {Buffer}
  */
  skynet: (value) => {
    return base64.toUint8Array(value)
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  swarm: (value) => {
    const multihash = multiH.encode(hexStringToBuffer(value), 'keccak-256');
		return new CID(1, 'swarm-manifest', multihash).bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipfs: (value) => {
    return new CID(value).toV1().bytes;
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  ipns: (value) => {
    const cid = new CID(value)
    if (!isCryptographicIPNS(cid)) {
        throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    // Represent IPNS name as a CID with libp2p-key codec
    // https://github.com/libp2p/specs/blob/master/RFC/0001-text-peerid-cid.md
    return new CID(1, 'libp2p-key', cid.multihash).bytes
  },
  /**
  * @param {string} value
  * @return {Buffer}
  */
  utf8: (value) => {
    return Buffer.from(value, 'utf8');
  },
};

/** 
* list of known decoding,
* decoding should be a function that takes a `Buffer` input,
* and return a `string` result
*/
const decodes = {
  /**
  * @param {Buffer} value 
  */
  hexMultiHash: (value) => {
    const cid = new CID(value);
    return multiH.decode(cid.multihash).digest.toString('hex');
  },
  /**
  * @param {Buffer} value 
  */
  ipfs: (value) => {
    const cid = new CID(value).toV1();
    return cid.toString(cid.codec === 'libp2p-key' ? 'base36' : 'base32')
  },
  /**
  * @param {Buffer} value 
  */
  ipns: (value) => {
    const cid = new CID(value).toV1()
    if (!isCryptographicIPNS(cid)) {
        // Value is not a libp2p-key, return original string
        console.warn('[ensdomains/content-hash] use of non-cryptographic identifiers in ipns-ns is deprecated and will be removed, migrate to ED25519 libp2p-key')
        return String(multiH.decode(new CID(value).multihash).digest)
        // TODO: start throwing an error (after some deprecation period)
        // throw Error('ipns-ns allows only valid cryptographic libp2p-key identifiers, try using ED25519 pubkey instead')
    }
    return cid.toString('base36')
  },
  /**
  * @param {Buffer} value 
  */
  utf8: (value) => {
    return value.toString('utf8');
  },
  base64: (value) => {
    // `true` option makes it URL safe (replaces / and + with - and _ )
    return base64.fromUint8Array(value, true)
  }
};

/**
* list of known encoding/decoding for a given codec,
* `encode` should be chosen among the `encodes` functions
* `decode` should be chosen among the `decodes` functions
*/
const profiles = {
  'skynet-ns': {
    encode: encodes.skynet,
    decode: decodes.base64,
  },
  'swarm-ns': {
    encode: encodes.swarm,
    decode: decodes.hexMultiHash,
  },
  'ipfs-ns': {
    encode: encodes.ipfs,
    decode: decodes.ipfs,
  },
  'ipns-ns': {
    encode: encodes.ipns,
    decode: decodes.ipns,
  },
  'default': {
    encode: encodes.utf8,
    decode: decodes.utf8,
  },
};

exports.hexStringToBuffer = hexStringToBuffer;
exports.profiles = profiles;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@ensdomains/content-hash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js", {"@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@ethereumjs/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\base-eth-keyring\dist\base-eth-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var HDKey = _interopDefault(require('hdkey'));
var util = require('@ethereumjs/util');
var rlp = _interopDefault(require('rlp'));
var tx = require('@ethereumjs/tx');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');

const keyringType = "QR Hardware Wallet Device";
const pathBase = "m";
const MAX_INDEX = 1000;
const DEFAULT_CHILDREN_PATH = "0/*";
var KEYRING_MODE;

(function (KEYRING_MODE) {
  KEYRING_MODE["hd"] = "hd";
  KEYRING_MODE["pubkey"] = "pubkey";
})(KEYRING_MODE || (KEYRING_MODE = {}));

var KEYRING_ACCOUNT;

(function (KEYRING_ACCOUNT) {
  KEYRING_ACCOUNT["standard"] = "account.standard";
  KEYRING_ACCOUNT["ledger_live"] = "account.ledger_live";
  KEYRING_ACCOUNT["ledger_legacy"] = "account.ledger_legacy";
})(KEYRING_ACCOUNT || (KEYRING_ACCOUNT = {}));

class BaseKeyring {
  constructor(opts) {
    // @ts-ignore
    this.version = 1;

    this.getInteraction = () => {
      throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.");
    };

    this.type = keyringType;

    this.requestSignature = async (_requestId, signRequest, requestTitle, requestDescription) => {
      const ethSignature = await this.getInteraction().requestSignature(signRequest, requestTitle, requestDescription);
      const requestIdBuffer = ethSignature.getRequestId();
      const signature = ethSignature.getSignature();

      if (requestIdBuffer) {
        const requestId = uuid.stringify(requestIdBuffer);

        if (requestId !== _requestId) {
          throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");
        }
      }

      const r = signature.slice(0, 32);
      const s = signature.slice(32, 64);
      const v = signature.slice(64);
      return {
        r,
        s,
        v
      };
    };

    this.__readCryptoHDKey = cryptoHDKey => {
      var _cryptoHDKey$getOrigi, _cryptoHDKey$getChild;

      const hdPath = `m/${cryptoHDKey.getOrigin().getPath()}`;
      const xfp = (_cryptoHDKey$getOrigi = cryptoHDKey.getOrigin().getSourceFingerprint()) == null ? void 0 : _cryptoHDKey$getOrigi.toString("hex");
      const childrenPath = ((_cryptoHDKey$getChild = cryptoHDKey.getChildren()) == null ? void 0 : _cryptoHDKey$getChild.getPath()) || DEFAULT_CHILDREN_PATH;
      const name = cryptoHDKey.getName();

      if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.standard) {
        this.keyringAccount = KEYRING_ACCOUNT.standard;
      } else if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_legacy) {
        this.keyringAccount = KEYRING_ACCOUNT.ledger_legacy;
      }

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");
      }

      const xpub = cryptoHDKey.getBip32Key();
      this.xfp = xfp;
      this.xpub = xpub;
      this.hdPath = hdPath;
      this.childrenPath = childrenPath;

      if (name !== undefined && name !== "") {
        this.name = name;
      }

      this.initialized = true;
    };

    this.__readCryptoAccount = cryptoAccount => {
      var _cryptoAccount$getMas, _cryptoAccount$getOut;

      const xfp = (_cryptoAccount$getMas = cryptoAccount.getMasterFingerprint()) == null ? void 0 : _cryptoAccount$getMas.toString("hex");

      if (!xfp) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");
      }

      this.xfp = xfp;
      this.initialized = true;
      let changed = false;
      const outputs = cryptoAccount.getOutputDescriptors();

      if (!outputs || outputs.length === 0) {
        throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");
      }

      if (outputs.length % 5 !== 0) {
        throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");
      }

      (_cryptoAccount$getOut = cryptoAccount.getOutputDescriptors()) == null ? void 0 : _cryptoAccount$getOut.forEach(od => {
        try {
          const cryptoHDKey = od.getHDKey();

          if (cryptoHDKey) {
            const key = cryptoHDKey.getKey();
            const path = `M/${cryptoHDKey.getOrigin().getPath()}`;
            const address = "0x" + util.publicToAddress(key, true).toString("hex");
            this.name = cryptoHDKey.getName();

            if (cryptoHDKey.getNote() === KEYRING_ACCOUNT.ledger_live) {
              this.keyringAccount = KEYRING_ACCOUNT.ledger_live;
            }

            if (this.paths[util.toChecksumAddress(address)] === undefined) {
              changed = true;
            }

            this.paths[util.toChecksumAddress(address)] = path;
          }
        } catch (e) {
          throw new Error(`KeystoneError#invalid_data: ${e}`);
        }
      });
      return changed;
    }; // private __readLedgerLiveAccounts = async () => {
    //     const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    //     if (result.getRegistryType() === extend.RegistryTypes.CRYPTO_ACCOUNT) {
    //         const changed = this.__readCryptoAccount(result as CryptoAccount);
    //         if (!changed) {
    //             throw new Error(`#KeystoneError#pubkey_account.no_new_account`);
    //         }
    //     } else {
    //         throw new Error(`KeystoneError#pubkey_account.unexpected_urtype`);
    //     }
    // };


    this.getName = () => {
      return this.name;
    };

    this.setAccountToUnlock = index => {
      this.unlockedAccount = parseInt(index, 10);
    };

    this.__getNormalPage = async increment => {
      this.page += increment;

      if (this.page <= 0) {
        this.page = 1;
      }

      const from = (this.page - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
        this.indexes[util.toChecksumAddress(address)] = i;
      }

      return accounts;
    };

    this.__getLedgerLivePage = async increment => {
      const nextPage = this.page + increment;
      const from = (nextPage - 1) * this.perPage;
      const to = from + this.perPage;
      const accounts = [];

      for (let i = from; i < to; i++) {
        const address = await this.__addressFromIndex(pathBase, i);
        accounts.push({
          address,
          balance: null,
          index: i
        });
      }

      this.page += increment;
      return accounts;
    };

    this.__addressFromIndex = async (pb, i) => {
      if (this.keyringMode === KEYRING_MODE.hd) {
        this.checkKeyring();

        if (!this.hdk) {
          // @ts-ignore
          this.hdk = HDKey.fromExtendedKey(this.xpub);
        }

        const childrenPath = this.childrenPath.replace("*", String(i)).replace(/\*/g, "0");
        const dkey = this.hdk.derive(`${pb}/${childrenPath}`);
        const address = "0x" + util.publicToAddress(dkey.publicKey, true).toString("hex");
        return util.toChecksumAddress(address);
      } else {
        const result = Object.keys(this.paths)[i];

        if (result) {
          return util.toChecksumAddress(result);
        } else {
          throw new Error(`KeystoneError#pubkey_account.no_expected_account`);
        }
      }
    }; //common props


    this.page = 0;
    this.perPage = 5;
    this.accounts = [];
    this.currentAccount = 0;
    this.unlockedAccount = 0;
    this.name = "QR Hardware";
    this.keyringMode = KEYRING_MODE.hd;
    this.keyringAccount = KEYRING_ACCOUNT.standard;
    this.initialized = false; //hd props;

    this.xfp = "";
    this.xpub = "";
    this.hdPath = "";
    this.childrenPath = DEFAULT_CHILDREN_PATH;
    this.indexes = {}; //pubkey props;

    this.paths = {};
    this.deserialize(opts);
  } //initial read


  async readKeyring() {
    const result = await this.getInteraction().readCryptoHDKeyOrCryptoAccount();
    this.syncKeyring(result);
  }

  syncKeyring(data) {
    if (data.getRegistryType().getType() === bcUrRegistryEth.extend.RegistryTypes.CRYPTO_HDKEY.getType()) {
      this.keyringMode = KEYRING_MODE.hd;

      this.__readCryptoHDKey(data);
    } else {
      this.keyringMode = KEYRING_MODE.pubkey;

      this.__readCryptoAccount(data);
    }
  }

  checkKeyring() {
    if (!this.xfp || !this.xpub || !this.hdPath) {
      throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly");
    }
  }

  serialize() {
    return Promise.resolve({
      //common
      initialized: this.initialized,
      accounts: this.accounts,
      currentAccount: this.currentAccount,
      page: this.page,
      perPage: this.perPage,
      keyringAccount: this.keyringAccount,
      keyringMode: this.keyringMode,
      name: this.name,
      version: this.version,
      xfp: this.xfp,
      //hd
      xpub: this.xpub,
      hdPath: this.hdPath,
      childrenPath: this.childrenPath,
      indexes: this.indexes,
      //pubkey
      paths: this.paths
    });
  }

  deserialize(opts) {
    if (opts) {
      //common props;
      this.accounts = opts.accounts;
      this.currentAccount = opts.currentAccount;
      this.page = opts.page;
      this.perPage = opts.perPage;
      this.name = opts.name;
      this.initialized = opts.initialized;
      this.keyringMode = opts.keyringMode || KEYRING_MODE.hd;
      this.keyringAccount = opts.keyringAccount || KEYRING_ACCOUNT.standard;
      this.xfp = opts.xfp; //hd props;

      this.xpub = opts.xpub;
      this.hdPath = opts.hdPath;
      this.indexes = opts.indexes;
      this.paths = opts.paths;
      this.childrenPath = opts.childrenPath || DEFAULT_CHILDREN_PATH;
    }
  }

  setCurrentAccount(index) {
    this.currentAccount = index;
  }

  getCurrentAccount() {
    return this.currentAccount;
  }

  getCurrentAddress() {
    return this.accounts[this.currentAccount];
  }

  async addAccounts(n = 1) {
    const from = this.unlockedAccount;
    const to = from + n;
    const newAccounts = [];

    for (let i = from; i < to; i++) {
      const address = await this.__addressFromIndex(pathBase, i);
      newAccounts.push(address);
      this.page = 0;
      this.unlockedAccount++;
    }

    this.accounts = this.accounts.concat(newAccounts);
    return this.accounts;
  }

  getFirstPage() {
    this.page = 0;
    return this.__getPage(1);
  }

  getNextPage() {
    return this.__getPage(1);
  }

  getPreviousPage() {
    return this.__getPage(-1);
  }

  async __getPage(increment) {
    if (!this.initialized) {
      await this.readKeyring();
    }

    if (this.keyringMode === KEYRING_MODE.hd) {
      return this.__getNormalPage(increment);
    } else {
      return this.__getLedgerLivePage(increment);
    }
  }

  getAccounts() {
    return Promise.resolve(this.accounts);
  }

  removeAccount(address) {
    if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`);
    }

    this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = Buffer.from(rlp.encode(tx$1.getMessageToSign(false)));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    return tx.TransactionFactory.fromTxData({ ...tx$1.toJSON(),
      type: tx$1.type,
      r,
      s,
      v
    }, {
      common: tx$1.common
    });
  }

  signMessage(withAccount, data) {
    return this.signPersonalMessage(withAccount, data);
  }

  async signPersonalMessage(withAccount, messageHex) {
    const usignedHex = util.stripHexPrefix(messageHex);
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(usignedHex, "hex"), bcUrRegistryEth.DataType.personalMessage, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async signTypedData(withAccount, typedData) {
    const hdPath = await this._pathFromAddress(withAccount);
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(typedData), "utf-8"), bcUrRegistryEth.DataType.typedData, hdPath, this.xfp, requestId, undefined, withAccount);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');
    return "0x" + Buffer.concat([r, s, v]).toString("hex");
  }

  async _pathFromAddress(address) {
    if (this.keyringMode === KEYRING_MODE.hd) {
      const checksummedAddress = util.toChecksumAddress(address);
      let index = this.indexes[checksummedAddress];

      if (typeof index === "undefined") {
        for (let i = 0; i < MAX_INDEX; i++) {
          if (checksummedAddress === (await this.__addressFromIndex(pathBase, i))) {
            index = i;
            break;
          }
        }
      }

      if (typeof index === "undefined") {
        throw new Error("Unknown address");
      }

      return `${this.hdPath}/${this.childrenPath.replace("*", index.toString()).replace(/\*/g, "0")}`;
    } else {
      const checksummedAddress = util.toChecksumAddress(address);
      const path = this.paths[checksummedAddress];

      if (typeof path === "undefined") {
        throw new Error("Unknown address");
      }

      return path;
    }
  }

}
BaseKeyring.type = keyringType;

exports.BaseKeyring = BaseKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js", {"@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@ethereumjs/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\util\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","hdkey":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\hdkey\\lib\\hdkey.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\base-eth-keyring\dist\base-eth-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";function e(e){return e&&"object"==typeof e&&"default"in e?e.default:e}Object.defineProperty(exports,"__esModule",{value:!0});var t,r,i=e(require("hdkey")),s=require("@ethereumjs/util"),n=e(require("rlp")),a=require("@ethereumjs/tx"),o=require("@keystonehq/bc-ur-registry-eth"),h=require("uuid");!function(e){e.hd="hd",e.pubkey="pubkey"}(t||(t={})),function(e){e.standard="account.standard",e.ledger_live="account.ledger_live",e.ledger_legacy="account.ledger_legacy"}(r||(r={}));class c{constructor(e){this.version=1,this.getInteraction=()=>{throw new Error("KeystoneError#invalid_extends: method getInteraction not implemented, please extend BaseKeyring by overwriting this method.")},this.type="QR Hardware Wallet Device",this.requestSignature=async(e,t,r,i)=>{const s=await this.getInteraction().requestSignature(t,r,i),n=s.getRequestId(),a=s.getSignature();if(n&&h.stringify(n)!==e)throw new Error("KeystoneError#invalid_data: read signature error: mismatched requestId");return{r:a.slice(0,32),s:a.slice(32,64),v:a.slice(64)}},this.__readCryptoHDKey=e=>{var t,i;const s="m/"+e.getOrigin().getPath(),n=null==(t=e.getOrigin().getSourceFingerprint())?void 0:t.toString("hex"),a=(null==(i=e.getChildren())?void 0:i.getPath())||"0/*",o=e.getName();if(e.getNote()===r.standard?this.keyringAccount=r.standard:e.getNote()===r.ledger_legacy&&(this.keyringAccount=r.ledger_legacy),!n)throw new Error("KeystoneError#invalid_data: invalid crypto-hdkey, cannot get source fingerprint");const h=e.getBip32Key();this.xfp=n,this.xpub=h,this.hdPath=s,this.childrenPath=a,void 0!==o&&""!==o&&(this.name=o),this.initialized=!0},this.__readCryptoAccount=e=>{var t,i;const n=null==(t=e.getMasterFingerprint())?void 0:t.toString("hex");if(!n)throw new Error("KeystoneError#invalid_data: invalid crypto-account, cannot get master fingerprint");this.xfp=n,this.initialized=!0;let a=!1;const o=e.getOutputDescriptors();if(!o||0===o.length)throw new Error("KeystoneError#invalid_data: invalid crypto-account, no crypto output found");if(o.length%5!=0)throw new Error("KeystoneError#invalid_data: only support 5x pubkey accounts for now");return null==(i=e.getOutputDescriptors())||i.forEach(e=>{try{const t=e.getHDKey();if(t){const e=t.getKey(),i="M/"+t.getOrigin().getPath(),n="0x"+s.publicToAddress(e,!0).toString("hex");this.name=t.getName(),t.getNote()===r.ledger_live&&(this.keyringAccount=r.ledger_live),void 0===this.paths[s.toChecksumAddress(n)]&&(a=!0),this.paths[s.toChecksumAddress(n)]=i}}catch(e){throw new Error("KeystoneError#invalid_data: "+e)}}),a},this.getName=()=>this.name,this.setAccountToUnlock=e=>{this.unlockedAccount=parseInt(e,10)},this.__getNormalPage=async e=>{this.page+=e,this.page<=0&&(this.page=1);const t=(this.page-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e}),this.indexes[s.toChecksumAddress(t)]=e}return i},this.__getLedgerLivePage=async e=>{const t=(this.page+e-1)*this.perPage,r=t+this.perPage,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push({address:t,balance:null,index:e})}return this.page+=e,i},this.__addressFromIndex=async(e,r)=>{if(this.keyringMode===t.hd){this.checkKeyring(),this.hdk||(this.hdk=i.fromExtendedKey(this.xpub));const t=this.childrenPath.replace("*",String(r)).replace(/\*/g,"0"),n=this.hdk.derive(`${e}/${t}`),a="0x"+s.publicToAddress(n.publicKey,!0).toString("hex");return s.toChecksumAddress(a)}{const e=Object.keys(this.paths)[r];if(e)return s.toChecksumAddress(e);throw new Error("KeystoneError#pubkey_account.no_expected_account")}},this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.unlockedAccount=0,this.name="QR Hardware",this.keyringMode=t.hd,this.keyringAccount=r.standard,this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.childrenPath="0/*",this.indexes={},this.paths={},this.deserialize(e)}async readKeyring(){const e=await this.getInteraction().readCryptoHDKeyOrCryptoAccount();this.syncKeyring(e)}syncKeyring(e){e.getRegistryType().getType()===o.extend.RegistryTypes.CRYPTO_HDKEY.getType()?(this.keyringMode=t.hd,this.__readCryptoHDKey(e)):(this.keyringMode=t.pubkey,this.__readCryptoAccount(e))}checkKeyring(){if(!this.xfp||!this.xpub||!this.hdPath)throw new Error("KeystoneError#invalid_keyring: keyring not fulfilled, please call function `readKeyring` firstly")}serialize(){return Promise.resolve({initialized:this.initialized,accounts:this.accounts,currentAccount:this.currentAccount,page:this.page,perPage:this.perPage,keyringAccount:this.keyringAccount,keyringMode:this.keyringMode,name:this.name,version:this.version,xfp:this.xfp,xpub:this.xpub,hdPath:this.hdPath,childrenPath:this.childrenPath,indexes:this.indexes,paths:this.paths})}deserialize(e){e&&(this.accounts=e.accounts,this.currentAccount=e.currentAccount,this.page=e.page,this.perPage=e.perPage,this.name=e.name,this.initialized=e.initialized,this.keyringMode=e.keyringMode||t.hd,this.keyringAccount=e.keyringAccount||r.standard,this.xfp=e.xfp,this.xpub=e.xpub,this.hdPath=e.hdPath,this.indexes=e.indexes,this.paths=e.paths,this.childrenPath=e.childrenPath||"0/*")}setCurrentAccount(e){this.currentAccount=e}getCurrentAccount(){return this.currentAccount}getCurrentAddress(){return this.accounts[this.currentAccount]}async addAccounts(e=1){const t=this.unlockedAccount,r=t+e,i=[];for(let e=t;e<r;e++){const t=await this.__addressFromIndex("m",e);i.push(t),this.page=0,this.unlockedAccount++}return this.accounts=this.accounts.concat(i),this.accounts}getFirstPage(){return this.page=0,this.__getPage(1)}getNextPage(){return this.__getPage(1)}getPreviousPage(){return this.__getPage(-1)}async __getPage(e){return this.initialized||await this.readKeyring(),this.keyringMode===t.hd?this.__getNormalPage(e):this.__getLedgerLivePage(e)}getAccounts(){return Promise.resolve(this.accounts)}removeAccount(e){if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())}async signTransaction(e,t){const r=0===t.type?o.DataType.transaction:o.DataType.typedTransaction;let i;i=0===t.type?Buffer.from(n.encode(t.getMessageToSign(!1))):t.getMessageToSign(!1);const s=await this._pathFromAddress(e),c=t.common.chainId(),d=h.v4(),u=o.EthSignRequest.constructETHRequest(i,r,s,this.xfp,d,c),{r:g,s:y,v:p}=await this.requestSignature(d,u,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');return a.TransactionFactory.fromTxData({...t.toJSON(),type:t.type,r:g,s:y,v:p},{common:t.common})}signMessage(e,t){return this.signPersonalMessage(e,t)}async signPersonalMessage(e,t){const r=s.stripHexPrefix(t),i=await this._pathFromAddress(e),n=h.v4(),a=o.EthSignRequest.constructETHRequest(Buffer.from(r,"hex"),o.DataType.personalMessage,i,this.xfp,n,void 0,e),{r:c,s:d,v:u}=await this.requestSignature(n,a,"Scan with your Keystone",'After your Keystone has signed this message, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([c,d,u]).toString("hex")}async signTypedData(e,t){const r=await this._pathFromAddress(e),i=h.v4(),s=o.EthSignRequest.constructETHRequest(Buffer.from(JSON.stringify(t),"utf-8"),o.DataType.typedData,r,this.xfp,i,void 0,e),{r:n,s:a,v:c}=await this.requestSignature(i,s,"Scan with your Keystone",'After your Keystone has signed this data, click on "Scan Keystone" to receive the signature');return"0x"+Buffer.concat([n,a,c]).toString("hex")}async _pathFromAddress(e){if(this.keyringMode===t.hd){const t=s.toChecksumAddress(e);let r=this.indexes[t];if(void 0===r)for(let e=0;e<1e3;e++)if(t===await this.__addressFromIndex("m",e)){r=e;break}if(void 0===r)throw new Error("Unknown address");return`${this.hdPath}/${this.childrenPath.replace("*",r.toString()).replace(/\*/g,"0")}`}{const t=s.toChecksumAddress(e),r=this.paths[t];if(void 0===r)throw new Error("Unknown address");return r}}}c.type="QR Hardware Wallet Device",exports.BaseKeyring=c;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js", {"./base-eth-keyring.cjs.development.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.development.js","./base-eth-keyring.cjs.production.min.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\base-eth-keyring.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\base-eth-keyring\dist\index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./base-eth-keyring.cjs.production.min.js')
} else {
  module.exports = require('./base-eth-keyring.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\node_modules\\rlp\\dist\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\base-eth-keyring\node_modules\rlp\dist\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.utils = exports.decode = exports.encode = void 0;
/**
 * RLP Encoding based on https://eth.wiki/en/fundamentals/rlp
 * This function takes in data, converts it to Uint8Array if not,
 * and adds a length for recursion.
 * @param input Will be converted to Uint8Array
 * @returns Uint8Array of encoded data
 **/
function encode(input) {
    if (Array.isArray(input)) {
        const output = [];
        for (let i = 0; i < input.length; i++) {
            output.push(encode(input[i]));
        }
        const buf = concatBytes(...output);
        return concatBytes(encodeLength(buf.length, 192), buf);
    }
    const inputBuf = toBytes(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
        return inputBuf;
    }
    return concatBytes(encodeLength(inputBuf.length, 128), inputBuf);
}
exports.encode = encode;
/**
 * Slices a Uint8Array, throws if the slice goes out-of-bounds of the Uint8Array.
 * E.g. `safeSlice(hexToBytes('aa'), 1, 2)` will throw.
 * @param input
 * @param start
 * @param end
 */
function safeSlice(input, start, end) {
    if (end > input.length) {
        throw new Error('invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds');
    }
    return input.slice(start, end);
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 */
function decodeLength(v) {
    if (v[0] === 0) {
        throw new Error('invalid RLP: extra zeros');
    }
    return parseHexByte(bytesToHex(v));
}
function encodeLength(len, offset) {
    if (len < 56) {
        return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes(firstByte + hexLength));
}
function decode(input, stream = false) {
    if (!input || input.length === 0) {
        return Uint8Array.from([]);
    }
    const inputBytes = toBytes(input);
    const decoded = _decode(inputBytes);
    if (stream) {
        return decoded;
    }
    if (decoded.remainder.length !== 0) {
        throw new Error('invalid RLP: remainder must be zero');
    }
    return decoded.data;
}
exports.decode = decode;
/** Decode an input with RLP */
function _decode(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 0x7f) {
        // a single byte whose value is in the [0x00, 0x7f] range, that byte is its own RLP encoding.
        return {
            data: input.slice(0, 1),
            remainder: input.slice(1),
        };
    }
    else if (firstByte <= 0xb7) {
        // string is 0-55 bytes long. A single byte with value 0x80 plus the length of the string followed by the string
        // The range of the first byte is [0x80, 0xb7]
        length = firstByte - 0x7f;
        // set 0x80 null to 0
        if (firstByte === 0x80) {
            data = Uint8Array.from([]);
        }
        else {
            data = safeSlice(input, 1, length);
        }
        if (length === 2 && data[0] < 0x80) {
            throw new Error('invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed');
        }
        return {
            data: data,
            remainder: input.slice(length),
        };
    }
    else if (firstByte <= 0xbf) {
        // string is greater than 55 bytes long. A single byte with the value (0xb7 plus the length of the length),
        // followed by the length, followed by the string
        llength = firstByte - 0xb6;
        if (input.length - 1 < llength) {
            throw new Error('invalid RLP: not enough bytes for string length');
        }
        length = decodeLength(safeSlice(input, 1, llength));
        if (length <= 55) {
            throw new Error('invalid RLP: expected string length to be greater than 55');
        }
        data = safeSlice(input, llength, length + llength);
        return {
            data: data,
            remainder: input.slice(length + llength),
        };
    }
    else if (firstByte <= 0xf7) {
        // a list between 0-55 bytes long
        length = firstByte - 0xbf;
        innerRemainder = safeSlice(input, 1, length);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(length),
        };
    }
    else {
        // a list over 55 bytes long
        llength = firstByte - 0xf6;
        length = decodeLength(safeSlice(input, 1, llength));
        if (length < 56) {
            throw new Error('invalid RLP: encoded list too short');
        }
        const totalLength = llength + length;
        if (totalLength > input.length) {
            throw new Error('invalid RLP: total length is larger than the data');
        }
        innerRemainder = safeSlice(input, llength, totalLength);
        while (innerRemainder.length) {
            d = _decode(innerRemainder);
            decoded.push(d.data);
            innerRemainder = d.remainder;
        }
        return {
            data: decoded,
            remainder: input.slice(totalLength),
        };
    }
}
const cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, '0'));
function bytesToHex(uint8a) {
    // Pre-caching chars with `cachedHexes` speeds this up 6x
    let hex = '';
    for (let i = 0; i < uint8a.length; i++) {
        hex += cachedHexes[uint8a[i]];
    }
    return hex;
}
function parseHexByte(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
        throw new Error('Invalid byte sequence');
    return byte;
}
// Caching slows it down 2-3x
function hexToBytes(hex) {
    if (typeof hex !== 'string') {
        throw new TypeError('hexToBytes: expected string, got ' + typeof hex);
    }
    if (hex.length % 2)
        throw new Error('hexToBytes: received invalid unpadded hex');
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0; i < array.length; i++) {
        const j = i * 2;
        array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
}
/** Concatenates two Uint8Arrays into one. */
function concatBytes(...arrays) {
    if (arrays.length === 1)
        return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0; i < arrays.length; i++) {
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
function utf8ToBytes(utf) {
    return new TextEncoder().encode(utf);
}
/** Transform an integer into its hexadecimal value */
function numberToHex(integer) {
    if (integer < 0) {
        throw new Error('Invalid integer as argument, must be unsigned!');
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
}
/** Pad a string to be even */
function padToEven(a) {
    return a.length % 2 ? `0${a}` : a;
}
/** Check if a string is prefixed by 0x */
function isHexPrefixed(str) {
    return str.length >= 2 && str[0] === '0' && str[1] === 'x';
}
/** Removes 0x from a given String */
function stripHexPrefix(str) {
    if (typeof str !== 'string') {
        return str;
    }
    return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform anything into a Uint8Array */
function toBytes(v) {
    if (v instanceof Uint8Array) {
        return v;
    }
    if (typeof v === 'string') {
        if (isHexPrefixed(v)) {
            return hexToBytes(padToEven(stripHexPrefix(v)));
        }
        return utf8ToBytes(v);
    }
    if (typeof v === 'number' || typeof v === 'bigint') {
        if (!v) {
            return Uint8Array.from([]);
        }
        return hexToBytes(numberToHex(v));
    }
    if (v === null || v === undefined) {
        return Uint8Array.from([]);
    }
    throw new Error('toBytes: received unsupported type ' + typeof v);
}
exports.utils = {
    bytesToHex,
    concatBytes,
    hexToBytes,
    utf8ToBytes,
};
const RLP = { encode, decode };
exports.default = RLP;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@keystonehq/base-eth-keyring>rlp",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\index.js", {"./metamask-airgapped-keyring.cjs.development.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js","./metamask-airgapped-keyring.cjs.production.min.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\dist\index.js
      return function (require, module, exports) {

'use strict'

if ("development" === 'production') {
  module.exports = require('./metamask-airgapped-keyring.cjs.production.min.js')
} else {
  module.exports = require('./metamask-airgapped-keyring.cjs.development.js')
}

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.development.js", {"@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@keystonehq/base-eth-keyring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\dist\metamask-airgapped-keyring.cjs.development.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var baseEthKeyring = require('@keystonehq/base-eth-keyring');
var events = require('events');
var obsStore = require('@metamask/obs-store');
var bcUrRegistryEth = require('@keystonehq/bc-ur-registry-eth');
var uuid = require('uuid');
var tx = require('@ethereumjs/tx');
var rlp = _interopDefault(require('rlp'));

class MetamaskInteractionProvider extends events.EventEmitter {
  constructor() {
    super();

    this.cleanSyncListeners = () => {
      this.removeAllListeners("keystone-sync_success-hdkey");
      this.removeAllListeners("keystone-sync_success-account");
      this.removeAllListeners("keystone-sync_cancel");
    };

    this.cleanSignListeners = requestId => {
      this.removeAllListeners(`${requestId}-signed`);
      this.removeAllListeners(`${requestId}-canceled`);
    };

    this.readCryptoHDKeyOrCryptoAccount = () => {
      return new Promise((resolve, reject) => {
        this.memStore.updateState({
          sync: {
            reading: true
          }
        });
        this.on("keystone-sync_success-hdkey", cbor => {
          const cryptoHDKey = bcUrRegistryEth.CryptoHDKey.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoHDKey);
        });
        this.on("keystone-sync_success-account", cbor => {
          const cryptoAccount = bcUrRegistryEth.CryptoAccount.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(cryptoAccount);
        });
        this.on("keystone-sync_cancel", () => {
          this.resetState();
          reject(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"));
        });
      });
    };

    this.submitCryptoHDKey = cbor => {
      this.emit("keystone-sync_success-hdkey", cbor);
    };

    this.submitCryptoAccount = cbor => {
      this.emit("keystone-sync_success-account", cbor);
    };

    this.cancelSync = () => {
      this.emit("keystone-sync_cancel");
    };

    this.requestSignature = (signRequest, requestTitle, requestDescription) => {
      return new Promise((resolve, reject) => {
        const ur = signRequest.toUR();
        const requestIdBuffer = signRequest.getRequestId();
        const requestId = uuid.stringify(requestIdBuffer);
        const signPayload = {
          requestId,
          payload: {
            type: ur.type,
            cbor: ur.cbor.toString("hex")
          },
          title: requestTitle,
          description: requestDescription
        };
        this.memStore.updateState({
          sign: {
            request: signPayload
          }
        });
        this.once(`${requestId}-signed`, cbor => {
          const ethSignature = bcUrRegistryEth.ETHSignature.fromCBOR(Buffer.from(cbor, "hex"));
          this.resetState();
          resolve(ethSignature);
        });
        this.once(`${requestId}-canceled`, () => {
          this.resetState();
          reject(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"));
        });
      });
    };

    this.submitSignature = (requestId, cbor) => {
      this.emit(`${requestId}-signed`, cbor);
    };

    this.cancelRequestSignature = () => {
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.memStore.updateState({
          sign: {}
        });
        this.emit(`${requestId}-canceled`);
      }
    };

    this.reset = () => {
      this.cleanSyncListeners();
      const signPayload = this.memStore.getState().sign.request;

      if (signPayload) {
        const {
          requestId
        } = signPayload;
        this.cleanSignListeners(requestId);
      }

      this.resetState();
    };

    this.resetState = () => {
      this.memStore.updateState({
        sync: {
          reading: false
        },
        sign: {}
      });
    };

    if (MetamaskInteractionProvider.instance) {
      return MetamaskInteractionProvider.instance;
    }

    this.memStore = new obsStore.ObservableStore({
      sync: {
        reading: false
      },
      sign: {},
      _version: 1
    });
    MetamaskInteractionProvider.instance = this;
  }

}

class MetaMaskKeyring extends baseEthKeyring.BaseKeyring {
  constructor(opts) {
    super(opts);

    this.getInteraction = () => {
      return new MetamaskInteractionProvider();
    };

    this.resetStore = () => {
      this.getInteraction().reset();
    };

    this.getMemStore = () => {
      return this.getInteraction().memStore;
    };

    this.removeAccount = address => {
      if (!this.accounts.map(a => a.toLowerCase()).includes(address.toLowerCase())) {
        throw new Error(`Address ${address} not found in this keyring`);
      }

      this.accounts = this.accounts.filter(a => a.toLowerCase() !== address.toLowerCase());
    };

    this.forgetDevice = () => {
      //common props
      this.page = 0;
      this.perPage = 5;
      this.accounts = [];
      this.currentAccount = 0;
      this.name = "QR Hardware";
      this.initialized = false; //hd props;

      this.xfp = "";
      this.xpub = "";
      this.hdPath = "";
      this.indexes = {};
      this.hdk = undefined; //pubkey props;

      this.paths = {};
    };

    this.submitCryptoHDKey = this.getInteraction().submitCryptoHDKey;
    this.submitCryptoAccount = this.getInteraction().submitCryptoAccount;
    this.submitSignature = this.getInteraction().submitSignature;
    this.cancelSync = this.getInteraction().cancelSync;
    this.cancelSignRequest = this.getInteraction().cancelRequestSignature;

    if (MetaMaskKeyring.instance) {
      MetaMaskKeyring.instance.deserialize(opts);
      return MetaMaskKeyring.instance;
    }

    MetaMaskKeyring.instance = this;
  }

  async signTransaction(address, tx$1) {
    const dataType = tx$1.type === 0 ? bcUrRegistryEth.DataType.transaction : bcUrRegistryEth.DataType.typedTransaction;
    let messageToSign;

    if (tx$1.type === 0) {
      messageToSign = rlp.encode(tx$1.getMessageToSign(false));
    } else {
      messageToSign = tx$1.getMessageToSign(false);
    }

    const hdPath = await this._pathFromAddress(address);
    const chainId = tx$1.common.chainId();
    const requestId = uuid.v4();
    const ethSignRequest = bcUrRegistryEth.EthSignRequest.constructETHRequest(messageToSign, dataType, hdPath, this.xfp, requestId, chainId, address);
    const {
      r,
      s,
      v
    } = await this.requestSignature(requestId, ethSignRequest, "Scan with your Keystone", 'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature');
    const txJson = tx$1.toJSON();
    txJson.v = v;
    txJson.s = s;
    txJson.r = r;
    txJson.type = tx$1.type;
    const transaction = tx.TransactionFactory.fromTxData(txJson, {
      common: tx$1.common
    });
    return transaction;
  }

}
MetaMaskKeyring.type = baseEthKeyring.BaseKeyring.type;

exports.MetaMaskKeyring = MetaMaskKeyring;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\dist\\metamask-airgapped-keyring.cjs.production.min.js", {"@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","@keystonehq/base-eth-keyring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\base-eth-keyring\\dist\\index.js","@keystonehq/bc-ur-registry-eth":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\bc-ur-registry-eth\\dist\\index.js","@metamask/obs-store":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\dist\metamask-airgapped-keyring.cjs.production.min.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e,t=require("@keystonehq/base-eth-keyring"),s=require("events"),n=require("@metamask/obs-store"),i=require("@keystonehq/bc-ur-registry-eth"),r=require("uuid"),c=require("@ethereumjs/tx"),o=(e=require("rlp"))&&"object"==typeof e&&"default"in e?e.default:e;class a extends s.EventEmitter{constructor(){if(super(),this.cleanSyncListeners=()=>{this.removeAllListeners("keystone-sync_success-hdkey"),this.removeAllListeners("keystone-sync_success-account"),this.removeAllListeners("keystone-sync_cancel")},this.cleanSignListeners=e=>{this.removeAllListeners(e+"-signed"),this.removeAllListeners(e+"-canceled")},this.readCryptoHDKeyOrCryptoAccount=()=>new Promise((e,t)=>{this.memStore.updateState({sync:{reading:!0}}),this.on("keystone-sync_success-hdkey",t=>{const s=i.CryptoHDKey.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_success-account",t=>{const s=i.CryptoAccount.fromCBOR(Buffer.from(t,"hex"));this.resetState(),e(s)}),this.on("keystone-sync_cancel",()=>{this.resetState(),t(new Error("KeystoneError#sync_cancel. Sync process canceled, please retry"))})}),this.submitCryptoHDKey=e=>{this.emit("keystone-sync_success-hdkey",e)},this.submitCryptoAccount=e=>{this.emit("keystone-sync_success-account",e)},this.cancelSync=()=>{this.emit("keystone-sync_cancel")},this.requestSignature=(e,t,s)=>new Promise((n,c)=>{const o=e.toUR(),a=e.getRequestId(),h=r.stringify(a),u={requestId:h,payload:{type:o.type,cbor:o.cbor.toString("hex")},title:t,description:s};this.memStore.updateState({sign:{request:u}}),this.once(h+"-signed",e=>{const t=i.ETHSignature.fromCBOR(Buffer.from(e,"hex"));this.resetState(),n(t)}),this.once(h+"-canceled",()=>{this.resetState(),c(new Error("KeystoneError#Tx_canceled. Signing canceled, please retry"))})}),this.submitSignature=(e,t)=>{this.emit(e+"-signed",t)},this.cancelRequestSignature=()=>{const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.memStore.updateState({sign:{}}),this.emit(t+"-canceled")}},this.reset=()=>{this.cleanSyncListeners();const e=this.memStore.getState().sign.request;if(e){const{requestId:t}=e;this.cleanSignListeners(t)}this.resetState()},this.resetState=()=>{this.memStore.updateState({sync:{reading:!1},sign:{}})},a.instance)return a.instance;this.memStore=new n.ObservableStore({sync:{reading:!1},sign:{},_version:1}),a.instance=this}}class h extends t.BaseKeyring{constructor(e){if(super(e),this.getInteraction=()=>new a,this.resetStore=()=>{this.getInteraction().reset()},this.getMemStore=()=>this.getInteraction().memStore,this.removeAccount=e=>{if(!this.accounts.map(e=>e.toLowerCase()).includes(e.toLowerCase()))throw new Error(`Address ${e} not found in this keyring`);this.accounts=this.accounts.filter(t=>t.toLowerCase()!==e.toLowerCase())},this.forgetDevice=()=>{this.page=0,this.perPage=5,this.accounts=[],this.currentAccount=0,this.name="QR Hardware",this.initialized=!1,this.xfp="",this.xpub="",this.hdPath="",this.indexes={},this.hdk=void 0,this.paths={}},this.submitCryptoHDKey=this.getInteraction().submitCryptoHDKey,this.submitCryptoAccount=this.getInteraction().submitCryptoAccount,this.submitSignature=this.getInteraction().submitSignature,this.cancelSync=this.getInteraction().cancelSync,this.cancelSignRequest=this.getInteraction().cancelRequestSignature,h.instance)return h.instance.deserialize(e),h.instance;h.instance=this}async signTransaction(e,t){const s=0===t.type?i.DataType.transaction:i.DataType.typedTransaction;let n;n=0===t.type?o.encode(t.getMessageToSign(!1)):t.getMessageToSign(!1);const a=await this._pathFromAddress(e),h=t.common.chainId(),u=r.v4(),y=i.EthSignRequest.constructETHRequest(n,s,a,this.xfp,u,h,e),{r:m,s:g,v:d}=await this.requestSignature(u,y,"Scan with your Keystone",'After your Keystone has signed the transaction, click on "Scan Keystone" to receive the signature'),S=t.toJSON();return S.v=d,S.s=g,S.r=m,S.type=t.type,c.TransactionFactory.fromTxData(S,{common:t.common})}}h.type=t.BaseKeyring.type,exports.MetaMaskKeyring=h;


}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        // Typecast: Preserve existing behavior
        super({});
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        // Typecast: Preserve existing behavior
        super({});
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState) {
        super();
        if (initState) {
            this._state = initState;
        }
        else {
            // Typecast/default state: Preserve existing behavior
            this._state = {};
        }
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            this.putState(Object.assign(Object.assign({}, state), partialState));
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./MergedStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\@metamask\obs-store\dist\transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@keystonehq\\metamask-airgapped-keyring\\node_modules\\through2\\through2.js", {"_process":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js","readable-stream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\readable-stream\\readable-browser.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@keystonehq\metamask-airgapped-keyring\node_modules\through2\through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"@keystonehq/metamask-airgapped-keyring>@metamask/obs-store>through2",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js", {"./fetch-config-from-req":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js","./logging-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\node-fetch\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\dist\create-infura-middleware.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInfuraMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const node_fetch_1 = __importDefault(require("node-fetch"));
const fetch_config_from_req_1 = require("./fetch-config-from-req");
const logging_utils_1 = require("./logging-utils");
const log = (0, logging_utils_1.createModuleLogger)(logging_utils_1.projectLogger, 'create-infura-middleware');
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    'ECONNRESET',
    // ignore server sent html error pages
    // or truncated json responses
    'SyntaxError',
];
/**
 * Builds [`json-rpc-engine`](https://github.com/MetaMask/json-rpc-engine)-compatible middleware designed
 * for interfacing with Infura's JSON-RPC endpoints.
 *
 * @param opts - The options.
 * @param opts.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io` (default: 'mainnet').
 * @param opts.maxAttempts - The number of times a request to Infura should be
 * retried in the case of failure (default: 5).
 * @param opts.source - A descriptor for the entity making the request; tracked
 * by Infura for analytics purposes.
 * @param opts.projectId - The Infura project id.
 * @param opts.headers - Extra headers that will be used to make the request.
 * @returns The `json-rpc-engine`-compatible middleware.
 */
function createInfuraMiddleware({ network = 'mainnet', maxAttempts = 5, source, projectId, headers = {}, }) {
    // validate options
    if (!projectId || typeof projectId !== 'string') {
        throw new Error(`Invalid value for 'projectId': "${projectId}"`);
    }
    if (!headers || typeof headers !== 'object') {
        throw new Error(`Invalid value for 'headers': "${headers}"`);
    }
    if (!maxAttempts) {
        throw new Error(`Invalid value for 'maxAttempts': "${maxAttempts}" (${typeof maxAttempts})`);
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res) => {
        // retry MAX_ATTEMPTS times, if error matches filter
        for (let attempt = 1; attempt <= maxAttempts; attempt++) {
            try {
                // attempt request
                log('Attempting request to Infura. network = %o, projectId = %s, headers = %o, req = %o', network, projectId, headers, req);
                await performFetch(network, projectId, headers, req, res, source);
                // request was successful
                break;
            }
            catch (err) {
                // an error was caught while performing the request
                // if not retriable, resolve with the encountered error
                if (!isRetriableError(err)) {
                    // abort with error
                    log('Non-retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                    throw err;
                }
                // if no more attempts remaining, throw an error
                const remainingAttempts = maxAttempts - attempt;
                if (!remainingAttempts) {
                    log('Retriable request error encountered, but exceeded max attempts. req = %o, res = %o, error = %o', req, res, err);
                    const errMsg = `InfuraProvider - cannot complete request. All retries exhausted.\nOriginal Error:\n${err.toString()}\n\n`;
                    const retriesExhaustedErr = new Error(errMsg);
                    throw retriesExhaustedErr;
                }
                // otherwise, ignore error and retry again after timeout
                log('Retriable request error encountered. req = %o, res = %o, error = %o', req, res, err);
                log('Waiting 1 second to try again...');
                await timeout(1000);
            }
        }
        // request was handled correctly, end
    });
}
exports.createInfuraMiddleware = createInfuraMiddleware;
/**
 * Makes a request to Infura, updating the given response object if the response
 * has a "successful" status code or throwing an error otherwise.
 *
 * @param network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param projectId - The Infura project id.
 * @param extraHeaders - Extra headers that will be used to make the request.
 * @param req - The original request object obtained via the middleware stack.
 * @param res - The original response object obtained via the middleware stack.
 * @param source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @throws an error with a detailed message if the HTTP status code is anywhere
 * outside 2xx, and especially if it is 405, 429, 503, or 504.
 */
async function performFetch(network, projectId, extraHeaders, req, res, source) {
    const { fetchUrl, fetchParams } = (0, fetch_config_from_req_1.fetchConfigFromReq)({
        network,
        projectId,
        extraHeaders,
        req,
        source,
    });
    const response = await (0, node_fetch_1.default)(fetchUrl, fetchParams);
    const rawData = await response.text();
    // handle errors
    if (!response.ok) {
        switch (response.status) {
            case 405:
                throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
            case 429:
                throw createRatelimitError();
            case 503:
            case 504:
                throw createTimeoutError();
            default:
                throw createInternalError(rawData);
        }
    }
    // special case for now
    if (req.method === 'eth_getBlockByNumber' && rawData === 'Not Found') {
        res.result = null;
        return;
    }
    // parse JSON
    const data = JSON.parse(rawData);
    // finally return result
    res.result = data.result;
    res.error = data.error;
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a rate-limiting
 * error.
 *
 * @returns The error object.
 */
function createRatelimitError() {
    const msg = `Request is being rate limited.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object describing a timeout error.
 *
 * @returns The error object.
 */
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return createInternalError(msg);
}
/**
 * Builds a JSON-RPC 2.0 internal error object.
 *
 * @param msg - The message.
 * @returns The error object.
 */
function createInternalError(msg) {
    return eth_rpc_errors_1.ethErrors.rpc.internal(msg);
}
/**
 * Upon making a request, we may get an error that is temporary and
 * intermittent. In these cases we can attempt the request again with the
 * assumption that the error is unlikely to occur again. Here we determine if we
 * have received such an error.
 *
 * @param err - The error object.
 * @returns Whether the request that produced the error can be retried.
 */
function isRetriableError(err) {
    const errMessage = err.toString();
    return RETRIABLE_ERRORS.some((phrase) => errMessage.includes(phrase));
}
/**
 * A utility function that promisifies `setTimeout`.
 *
 * @param length - The number of milliseconds to wait.
 * @returns A promise that resolves after the given time has elapsed.
 */
function timeout(length) {
    return new Promise((resolve) => {
        setTimeout(resolve, length);
    });
}
//# sourceMappingURL=create-infura-middleware.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js", {"./create-infura-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","eth-json-rpc-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\dist\create-provider.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProvider = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_json_rpc_middleware_1 = require("eth-json-rpc-middleware");
const create_infura_middleware_1 = require("./create-infura-middleware");
/**
 * Creates a provider (as defined in
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)
 * which is preloaded with middleware specialized for interfacing with Infura
 * JSON-RPC endpoints.
 *
 * @param opts - Options to {@link createInfuraMiddleware}.
 * @returns The provider as returned by `providerFromEngine` (a part of
 * [`eth-json-rpc-middleware`](https://github.com/MetaMask/eth-json-rpc-middleware)).
 */
function createProvider(opts) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push((0, create_infura_middleware_1.createInfuraMiddleware)(opts));
    return (0, eth_json_rpc_middleware_1.providerFromEngine)(engine);
}
exports.createProvider = createProvider;
//# sourceMappingURL=create-provider.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\dist\fetch-config-from-req.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchConfigFromReq = void 0;
/**
 * Determines the arguments to feed into `fetch` in order to make a request to
 * Infura.
 *
 * @param options - The options.
 * @param options.network - A network that Infura supports; plugs into
 * `https://${network}.infura.io`.
 * @param options.projectId - The Infura project id.
 * @param options.extraHeaders - Extra headers that will be used to make the
 * request.
 * @param options.req - The original request object obtained via the
 * middleware stack.
 * @param options.source - A descriptor for the entity making the request;
 * tracked by Infura for analytics purposes.
 * @returns An object containing the URL and a bag of options, both of which
 * will be passed to `fetch`.
 */
function fetchConfigFromReq({ network, projectId, extraHeaders = {}, req, source, }) {
    const requestOrigin = req.origin || 'internal';
    const headers = Object.assign({}, extraHeaders, {
        Accept: 'application/json',
        'Content-Type': 'application/json',
    });
    if (source) {
        headers['Infura-Source'] = `${source}/${requestOrigin}`;
    }
    return {
        fetchUrl: `https://${network}.infura.io/v3/${projectId}`,
        fetchParams: {
            method: 'POST',
            headers,
            body: JSON.stringify(normalizeReq(req)),
        },
    };
}
exports.fetchConfigFromReq = fetchConfigFromReq;
/**
 * Strips out extra keys from a request object that could be rejected by strict
 * nodes like parity.
 *
 * @param req - The original request object obtained via the middleware stack.
 * @returns An object that describes a JSON-RPC request.
 */
function normalizeReq(req) {
    return {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
}
//# sourceMappingURL=fetch-config-from-req.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\index.js", {"./create-infura-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-infura-middleware.js","./create-provider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\create-provider.js","./fetch-config-from-req":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\fetch-config-from-req.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./create-infura-middleware"), exports);
__exportStar(require("./fetch-config-from-req"), exports);
__exportStar(require("./create-provider"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\dist\\logging-utils.js", {"@metamask/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\utils\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\dist\logging-utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createModuleLogger = exports.projectLogger = void 0;
const utils_1 = require("@metamask/utils");
Object.defineProperty(exports, "createModuleLogger", { enumerable: true, get: function () { return utils_1.createModuleLogger; } });
exports.projectLogger = (0, utils_1.createProjectLogger)('eth-json-rpc-infura');
//# sourceMappingURL=logging-utils.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js", {"./utils/cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\block-cache.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockCacheMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e'];
//
// Cache Strategies
//
class BlockCacheStrategy {
    constructor() {
        this.cache = {};
    }
    getBlockCacheForPayload(_payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        // create new cache if necesary
        if (!blockCache) {
            const newCache = {};
            this.cache[blockNumber] = newCache;
            blockCache = newCache;
        }
        return blockCache;
    }
    async get(payload, requestedBlockNumber) {
        // lookup block cache
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        // lookup payload in block cache
        const identifier = (0, cache_1.cacheIdentifierForPayload)(payload, true);
        return identifier ? blockCache[identifier] : undefined;
    }
    async set(payload, requestedBlockNumber, result) {
        // check if we can cached this result
        const canCacheResult = this.canCacheResult(payload, result);
        if (!canCacheResult) {
            return;
        }
        // set the value in the cache
        const identifier = (0, cache_1.cacheIdentifierForPayload)(payload, true);
        if (!identifier) {
            return;
        }
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        blockCache[identifier] = result;
    }
    canCacheRequest(payload) {
        // check request method
        if (!(0, cache_1.canCache)(payload)) {
            return false;
        }
        // check blockTag
        const blockTag = (0, cache_1.blockTagForPayload)(payload);
        if (blockTag === 'pending') {
            return false;
        }
        // can be cached
        return true;
    }
    canCacheResult(payload, result) {
        // never cache empty values (e.g. undefined)
        if (emptyValues.includes(result)) {
            return false;
        }
        // check if transactions have block reference before caching
        if (payload.method &&
            ['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
            if (!result ||
                !result.blockHash ||
                result.blockHash ===
                    '0x0000000000000000000000000000000000000000000000000000000000000000') {
                return false;
            }
        }
        // otherwise true
        return true;
    }
    // removes all block caches with block number lower than `oldBlockHex`
    clearBefore(oldBlockHex) {
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        // clear old caches
        Object.keys(this.cache)
            .map(Number)
            .filter((num) => num < oldBlockNumber)
            .forEach((num) => delete this.cache[num]);
    }
}
function createBlockCacheMiddleware({ blockTracker, } = {}) {
    // validate options
    if (!blockTracker) {
        throw new Error('createBlockCacheMiddleware - No PollingBlockTracker specified');
    }
    // create caching strategies
    const blockCache = new BlockCacheStrategy();
    const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache,
    };
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // check type and matching strategy
        const type = (0, cache_1.cacheTypeForPayload)(req);
        const strategy = strategies[type];
        // If there's no strategy in place, pass it down the chain.
        if (!strategy) {
            return next();
        }
        // If the strategy can't cache this request, ignore it.
        if (!strategy.canCacheRequest(req)) {
            return next();
        }
        // get block reference (number or keyword)
        let blockTag = (0, cache_1.blockTagForPayload)(req);
        if (!blockTag) {
            blockTag = 'latest';
        }
        // get exact block number
        let requestedBlockNumber;
        if (blockTag === 'earliest') {
            // this just exists for symmetry with "latest"
            requestedBlockNumber = '0x00';
        }
        else if (blockTag === 'latest') {
            // fetch latest block number
            const latestBlockNumber = await blockTracker.getLatestBlock();
            // clear all cache before latest block
            blockCache.clearBefore(latestBlockNumber);
            requestedBlockNumber = latestBlockNumber;
        }
        else {
            // We have a hex number
            requestedBlockNumber = blockTag;
        }
        // end on a hit, continue on a miss
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === undefined) {
            // cache miss
            // wait for other middleware to handle request
            // eslint-disable-next-line node/callback-return
            await next();
            // add result to cache
            // it's safe to cast res.result as Block, due to runtime type checks
            // performed when strategy.set is called
            await strategy.set(req, requestedBlockNumber, res.result);
        }
        else {
            // fill in result from cache
            res.result = cacheResult;
        }
        return undefined;
    });
}
exports.createBlockCacheMiddleware = createBlockCacheMiddleware;
//# sourceMappingURL=block-cache.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js", {"./utils/cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\block-ref-rewrite.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefRewriteMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createBlockRefRewriteMiddleware({ blockTracker, } = {}) {
    if (!blockTracker) {
        throw Error('BlockRefRewriteMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, _res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // rewrite blockRef to block-tracker's block number
        const latestBlockNumber = await blockTracker.getLatestBlock();
        if (req.params) {
            // eslint-disable-next-line require-atomic-updates
            req.params[blockRefIndex] = latestBlockNumber;
        }
        return next();
    });
}
exports.createBlockRefRewriteMiddleware = createBlockRefRewriteMiddleware;
//# sourceMappingURL=block-ref-rewrite.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js", {"./utils/cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\block-ref.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockRefMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const clone_1 = __importDefault(require("clone"));
const pify_1 = __importDefault(require("pify"));
const cache_1 = require("./utils/cache");
function createBlockRefMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('BlockRefMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('BlockRefMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not "latest"
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        if (blockRef !== 'latest') {
            return next();
        }
        // lookup latest block
        const latestBlockNumber = await blockTracker.getLatestBlock();
        // create child request with specific block-ref
        const childRequest = (0, clone_1.default)(req);
        if (childRequest.params) {
            childRequest.params[blockRefIndex] = latestBlockNumber;
        }
        // perform child request
        const childRes = await (0, pify_1.default)(provider.sendAsync).call(provider, childRequest);
        // copy child response onto original response
        res.result = childRes.result;
        res.error = childRes.error;
        return next();
    });
}
exports.createBlockRefMiddleware = createBlockRefMiddleware;
//# sourceMappingURL=block-ref.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js", {"json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\block-tracker-inspector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBlockTrackerInspectorMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const futureBlockRefRequests = [
    'eth_getTransactionByHash',
    'eth_getTransactionReceipt',
];
// inspect if response contains a block ref higher than our latest block
function createBlockTrackerInspectorMiddleware({ blockTracker, }) {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        if (!futureBlockRefRequests.includes(req.method)) {
            return next();
        }
        // eslint-disable-next-line node/callback-return
        await next();
        // abort if no result or no block number
        if (!((_a = res.result) === null || _a === void 0 ? void 0 : _a.blockNumber)) {
            return undefined;
        }
        if (typeof res.result.blockNumber === 'string') {
            // if number is higher, suggest block-tracker check for a new block
            const blockNumber = Number.parseInt(res.result.blockNumber, 16);
            // Typecast: If getCurrentBlock returns null, currentBlockNumber will be NaN, which is fine.
            const currentBlockNumber = Number.parseInt(blockTracker.getCurrentBlock(), 16);
            if (blockNumber > currentBlockNumber) {
                await blockTracker.checkForLatestBlock();
            }
        }
        return undefined;
    });
}
exports.createBlockTrackerInspectorMiddleware = createBlockTrackerInspectorMiddleware;
//# sourceMappingURL=block-tracker-inspector.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js", {"btoa":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","node-fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\fetch.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFetchConfigFromReq = exports.createFetchMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const eth_rpc_errors_1 = require("eth-rpc-errors");
/* eslint-disable node/global-require,@typescript-eslint/no-require-imports */
const fetch = global.fetch || require('node-fetch');
const btoa = global.btoa || require('btoa');
/* eslint-enable node/global-require,@typescript-eslint/no-require-imports */
const RETRIABLE_ERRORS = [
    // ignore server overload errors
    'Gateway timeout',
    'ETIMEDOUT',
    // ignore server sent html error pages
    // or truncated json responses
    'failed to parse response body',
    // ignore errors where http req failed to establish
    'Failed to fetch',
];
function createFetchMiddleware({ rpcUrl, originHttpHeaderKey, }) {
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, _next) => {
        const { fetchUrl, fetchParams } = createFetchConfigFromReq({
            req,
            rpcUrl,
            originHttpHeaderKey,
        });
        // attempt request multiple times
        const maxAttempts = 5;
        const retryInterval = 1000;
        for (let attempt = 0; attempt < maxAttempts; attempt++) {
            try {
                const fetchRes = await fetch(fetchUrl, fetchParams);
                // check for http errrors
                checkForHttpErrors(fetchRes);
                // parse response body
                const rawBody = await fetchRes.text();
                let fetchBody;
                try {
                    fetchBody = JSON.parse(rawBody);
                }
                catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`);
                }
                const result = parseResponse(fetchRes, fetchBody);
                // set result and exit retry loop
                res.result = result;
                return;
            }
            catch (err) {
                const errMsg = err.toString();
                const isRetriable = RETRIABLE_ERRORS.some((phrase) => errMsg.includes(phrase));
                // re-throw error if not retriable
                if (!isRetriable) {
                    throw err;
                }
            }
            // delay before retrying
            await timeout(retryInterval);
        }
    });
}
exports.createFetchMiddleware = createFetchMiddleware;
function checkForHttpErrors(fetchRes) {
    // check for errors
    switch (fetchRes.status) {
        case 405:
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotFound();
        case 418:
            throw createRatelimitError();
        case 503:
        case 504:
            throw createTimeoutError();
        default:
            break;
    }
}
function parseResponse(fetchRes, body) {
    // check for error code
    if (fetchRes.status !== 200) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            message: `Non-200 status code: '${fetchRes.status}'`,
            data: body,
        });
    }
    // check for rpc error
    if (body.error) {
        throw eth_rpc_errors_1.ethErrors.rpc.internal({
            data: body.error,
        });
    }
    // return successful result
    return body.result;
}
function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey, }) {
    const parsedUrl = new URL(rpcUrl);
    const fetchUrl = normalizeUrlFromParsed(parsedUrl);
    // prepare payload
    // copy only canonical json rpc properties
    const payload = {
        id: req.id,
        jsonrpc: req.jsonrpc,
        method: req.method,
        params: req.params,
    };
    // extract 'origin' parameter from request
    const originDomain = req.origin;
    // serialize request body
    const serializedPayload = JSON.stringify(payload);
    // configure fetch params
    const fetchParams = {
        method: 'POST',
        headers: {
            Accept: 'application/json',
            'Content-Type': 'application/json',
        },
        body: serializedPayload,
    };
    // encoded auth details as header (not allowed in fetch url)
    if (parsedUrl.username && parsedUrl.password) {
        const authString = `${parsedUrl.username}:${parsedUrl.password}`;
        const encodedAuth = btoa(authString);
        fetchParams.headers.Authorization = `Basic ${encodedAuth}`;
    }
    // optional: add request origin as header
    if (originHttpHeaderKey && originDomain) {
        fetchParams.headers[originHttpHeaderKey] = originDomain;
    }
    return { fetchUrl, fetchParams };
}
exports.createFetchConfigFromReq = createFetchConfigFromReq;
function normalizeUrlFromParsed(parsedUrl) {
    let result = '';
    result += parsedUrl.protocol;
    result += `//${parsedUrl.hostname}`;
    if (parsedUrl.port) {
        result += `:${parsedUrl.port}`;
    }
    result += `${parsedUrl.pathname}`;
    result += `${parsedUrl.search}`;
    return result;
}
function createRatelimitError() {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: `Request is being rate limited.` });
}
function createTimeoutError() {
    let msg = `Gateway timeout. The request took too long to process. `;
    msg += `This can happen when querying logs over too wide a block range.`;
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message: msg });
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=fetch.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\index.js", {"./block-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-cache.js","./block-ref":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref.js","./block-ref-rewrite":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-ref-rewrite.js","./block-tracker-inspector":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\block-tracker-inspector.js","./fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\fetch.js","./inflight-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js","./providerAsMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js","./providerFromEngine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","./providerFromMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js","./retryOnEmpty":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js","./wallet":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./block-cache"), exports);
__exportStar(require("./block-ref-rewrite"), exports);
__exportStar(require("./block-ref"), exports);
__exportStar(require("./block-tracker-inspector"), exports);
__exportStar(require("./fetch"), exports);
__exportStar(require("./inflight-cache"), exports);
__exportStar(require("./providerAsMiddleware"), exports);
__exportStar(require("./providerFromEngine"), exports);
__exportStar(require("./providerFromMiddleware"), exports);
__exportStar(require("./retryOnEmpty"), exports);
__exportStar(require("./wallet"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\inflight-cache.js", {"./utils/cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\inflight-cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createInflightCacheMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const cache_1 = require("./utils/cache");
function createInflightCacheMiddleware() {
    const inflightRequests = {};
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        // allow cach to be skipped if so specified
        if (req.skipCache) {
            return next();
        }
        // get cacheId, if cacheable
        const cacheId = (0, cache_1.cacheIdentifierForPayload)(req);
        // if not cacheable, skip
        if (!cacheId) {
            return next();
        }
        // check for matching requests
        let activeRequestHandlers = inflightRequests[cacheId];
        // if found, wait for the active request to be handled
        if (activeRequestHandlers) {
            // setup the response listener and wait for it to be called
            // it will handle copying the result and request fields
            await createActiveRequestHandler(res, activeRequestHandlers);
            return undefined;
        }
        // setup response handler array for subsequent requests
        activeRequestHandlers = [];
        inflightRequests[cacheId] = activeRequestHandlers;
        // allow request to be handled normally
        // eslint-disable-next-line node/callback-return
        await next();
        // clear inflight requests
        delete inflightRequests[cacheId];
        // schedule activeRequestHandlers to be handled
        handleActiveRequest(res, activeRequestHandlers);
        // complete
        return undefined;
    });
    function createActiveRequestHandler(res, activeRequestHandlers) {
        const { resolve, promise } = deferredPromise();
        activeRequestHandlers.push((handledRes) => {
            // append a copy of the result and error to the response
            res.result = (0, clone_1.default)(handledRes.result);
            res.error = (0, clone_1.default)(handledRes.error);
            resolve();
        });
        return promise;
    }
    function handleActiveRequest(res, activeRequestHandlers) {
        // use setTimeout so we can resolve our original request first
        setTimeout(() => {
            activeRequestHandlers.forEach((handler) => {
                try {
                    handler(res);
                }
                catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err);
                }
            });
        });
    }
}
exports.createInflightCacheMiddleware = createInflightCacheMiddleware;
function deferredPromise() {
    let resolve;
    const promise = new Promise((_resolve) => {
        resolve = _resolve;
    });
    return { resolve, promise };
}
//# sourceMappingURL=inflight-cache.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerAsMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\providerAsMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ethersProviderAsMiddleware = exports.providerAsMiddleware = void 0;
function providerAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.sendAsync(req, (err, providerRes) => {
            // forward any error
            if (err instanceof Error) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.providerAsMiddleware = providerAsMiddleware;
function ethersProviderAsMiddleware(provider) {
    return (req, res, _next, end) => {
        // send request to provider
        provider.send(req, (err, providerRes) => {
            // forward any error
            if (err) {
                return end(err);
            }
            // copy provider response onto original response
            Object.assign(res, providerRes);
            return end();
        });
    };
}
exports.ethersProviderAsMiddleware = ethersProviderAsMiddleware;
//# sourceMappingURL=providerAsMiddleware.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js", {"@metamask/safe-event-emitter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\providerFromEngine.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromEngine = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
function providerFromEngine(engine) {
    const provider = new safe_event_emitter_1.default();
    // handle both rpc send methods
    provider.sendAsync = (req, cb) => {
        engine.handle(req, cb);
    };
    provider.send = (req, callback) => {
        if (typeof callback !== 'function') {
            throw new Error('Must provide callback to "send" method.');
        }
        engine.handle(req, callback);
    };
    // forward notifications
    if (engine.on) {
        engine.on('notification', (message) => {
            provider.emit('data', null, message);
        });
    }
    return provider;
}
exports.providerFromEngine = providerFromEngine;
//# sourceMappingURL=providerFromEngine.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromMiddleware.js", {"./providerFromEngine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\providerFromEngine.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\providerFromMiddleware.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.providerFromMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const providerFromEngine_1 = require("./providerFromEngine");
function providerFromMiddleware(middleware) {
    const engine = new json_rpc_engine_1.JsonRpcEngine();
    engine.push(middleware);
    const provider = (0, providerFromEngine_1.providerFromEngine)(engine);
    return provider;
}
exports.providerFromMiddleware = providerFromMiddleware;
//# sourceMappingURL=providerFromMiddleware.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\retryOnEmpty.js", {"./utils/cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js","clone":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js","pify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\retryOnEmpty.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRetryOnEmptyMiddleware = void 0;
const clone_1 = __importDefault(require("clone"));
const json_rpc_engine_1 = require("json-rpc-engine");
const pify_1 = __importDefault(require("pify"));
const cache_1 = require("./utils/cache");
//
// RetryOnEmptyMiddleware will retry any request with an empty response that has
// a numbered block reference at or lower than the blockTracker's latest block.
// Its useful for dealing with load-balanced ethereum JSON RPC
// nodes that are not always in sync with each other.
//
// empty values used to determine if a request should be retried
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [
    undefined,
    null,
    '\u003cnil\u003e',
];
function createRetryOnEmptyMiddleware({ provider, blockTracker, } = {}) {
    if (!provider) {
        throw Error('RetryOnEmptyMiddleware - mandatory "provider" option is missing.');
    }
    if (!blockTracker) {
        throw Error('RetryOnEmptyMiddleware - mandatory "blockTracker" option is missing.');
    }
    return (0, json_rpc_engine_1.createAsyncMiddleware)(async (req, res, next) => {
        var _a;
        const blockRefIndex = (0, cache_1.blockTagParamIndex)(req);
        // skip if method does not include blockRef
        if (blockRefIndex === undefined) {
            return next();
        }
        // skip if not exact block references
        let blockRef = (_a = req.params) === null || _a === void 0 ? void 0 : _a[blockRefIndex];
        // omitted blockRef implies "latest"
        if (blockRef === undefined) {
            blockRef = 'latest';
        }
        // skip if non-number block reference
        if (['latest', 'pending'].includes(blockRef)) {
            return next();
        }
        // skip if block refernce is not a valid number
        const blockRefNumber = Number.parseInt(blockRef.slice(2), 16);
        if (Number.isNaN(blockRefNumber)) {
            return next();
        }
        // lookup latest block
        const latestBlockNumberHex = await blockTracker.getLatestBlock();
        const latestBlockNumber = Number.parseInt(latestBlockNumberHex.slice(2), 16);
        // skip if request block number is higher than current
        if (blockRefNumber > latestBlockNumber) {
            return next();
        }
        // create child request with specific block-ref
        const childRequest = (0, clone_1.default)(req);
        // attempt child request until non-empty response is received
        const childResponse = await retry(10, async () => {
            const attemptResponse = await (0, pify_1.default)(provider.sendAsync).call(provider, childRequest);
            // verify result
            if (emptyValues.includes(attemptResponse)) {
                throw new Error(`RetryOnEmptyMiddleware - empty response "${JSON.stringify(attemptResponse)}" for request "${JSON.stringify(childRequest)}"`);
            }
            return attemptResponse;
        });
        // copy child response onto original response
        res.result = childResponse.result;
        res.error = childResponse.error;
        return next();
    });
}
exports.createRetryOnEmptyMiddleware = createRetryOnEmptyMiddleware;
async function retry(maxRetries, asyncFn) {
    for (let index = 0; index < maxRetries; index++) {
        try {
            return await asyncFn();
        }
        catch (err) {
            await timeout(1000);
        }
    }
    throw new Error('RetryOnEmptyMiddleware - retries exhausted');
}
function timeout(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}
//# sourceMappingURL=retryOnEmpty.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\utils\\cache.js", {"json-stable-stringify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\utils\cache.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cacheTypeForPayload = exports.blockTagParamIndex = exports.paramsWithoutBlockTag = exports.blockTagForPayload = exports.canCache = exports.cacheIdentifierForPayload = void 0;
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
function cacheIdentifierForPayload(payload, skipBlockRef) {
    var _a;
    const simpleParams = skipBlockRef
        ? paramsWithoutBlockTag(payload)
        : (_a = payload.params) !== null && _a !== void 0 ? _a : [];
    if (canCache(payload)) {
        return `${payload.method}:${(0, json_stable_stringify_1.default)(simpleParams)}`;
    }
    return null;
}
exports.cacheIdentifierForPayload = cacheIdentifierForPayload;
function canCache(payload) {
    return cacheTypeForPayload(payload) !== 'never';
}
exports.canCache = canCache;
function blockTagForPayload(payload) {
    if (!payload.params) {
        return undefined;
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return undefined;
    }
    return payload.params[index];
}
exports.blockTagForPayload = blockTagForPayload;
function paramsWithoutBlockTag(payload) {
    if (!payload.params) {
        return [];
    }
    const index = blockTagParamIndex(payload);
    // Block tag param not passed.
    if (index === undefined || index >= payload.params.length) {
        return payload.params;
    }
    // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
    if (payload.method === 'eth_getBlockByNumber') {
        return payload.params.slice(1);
    }
    return payload.params.slice(0, index);
}
exports.paramsWithoutBlockTag = paramsWithoutBlockTag;
function blockTagParamIndex(payload) {
    switch (payload.method) {
        // blockTag is at index 2
        case 'eth_getStorageAt':
            return 2;
        // blockTag is at index 1
        case 'eth_getBalance':
        case 'eth_getCode':
        case 'eth_getTransactionCount':
        case 'eth_call':
            return 1;
        // blockTag is at index 0
        case 'eth_getBlockByNumber':
            return 0;
        // there is no blockTag
        default:
            return undefined;
    }
}
exports.blockTagParamIndex = blockTagParamIndex;
function cacheTypeForPayload(payload) {
    switch (payload.method) {
        // cache permanently
        case 'web3_clientVersion':
        case 'web3_sha3':
        case 'eth_protocolVersion':
        case 'eth_getBlockTransactionCountByHash':
        case 'eth_getUncleCountByBlockHash':
        case 'eth_getCode':
        case 'eth_getBlockByHash':
        case 'eth_getTransactionByHash':
        case 'eth_getTransactionByBlockHashAndIndex':
        case 'eth_getTransactionReceipt':
        case 'eth_getUncleByBlockHashAndIndex':
        case 'eth_getCompilers':
        case 'eth_compileLLL':
        case 'eth_compileSolidity':
        case 'eth_compileSerpent':
        case 'shh_version':
        case 'test_permaCache':
            return 'perma';
        // cache until fork
        case 'eth_getBlockByNumber':
        case 'eth_getBlockTransactionCountByNumber':
        case 'eth_getUncleCountByBlockNumber':
        case 'eth_getTransactionByBlockNumberAndIndex':
        case 'eth_getUncleByBlockNumberAndIndex':
        case 'test_forkCache':
            return 'fork';
        // cache for block
        case 'eth_gasPrice':
        case 'eth_blockNumber':
        case 'eth_getBalance':
        case 'eth_getStorageAt':
        case 'eth_getTransactionCount':
        case 'eth_call':
        case 'eth_estimateGas':
        case 'eth_getFilterLogs':
        case 'eth_getLogs':
        case 'test_blockCache':
            return 'block';
        // never cache
        default:
            return 'never';
    }
}
exports.cacheTypeForPayload = cacheTypeForPayload;
//# sourceMappingURL=cache.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-json-rpc-middleware\\dist\\wallet.js", {"eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-sig-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-sig-util\\index.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-json-rpc-middleware\dist\wallet.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createWalletMiddleware = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const sigUtil = __importStar(require("eth-sig-util"));
const eth_rpc_errors_1 = require("eth-rpc-errors");
function createWalletMiddleware({ getAccounts, processDecryptMessage, processEncryptionPublicKey, processEthSignMessage, processPersonalMessage, processTransaction, processSignTransaction, processTypedMessage, processTypedMessageV3, processTypedMessageV4, }) {
    if (!getAccounts) {
        throw new Error('opts.getAccounts is required');
    }
    return (0, json_rpc_engine_1.createScaffoldMiddleware)({
        // account lookups
        eth_accounts: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupAccounts),
        eth_coinbase: (0, json_rpc_engine_1.createAsyncMiddleware)(lookupDefaultAccount),
        // tx signatures
        eth_sendTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(sendTransaction),
        eth_signTransaction: (0, json_rpc_engine_1.createAsyncMiddleware)(signTransaction),
        // message signatures
        eth_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(ethSign),
        eth_signTypedData: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedData),
        eth_signTypedData_v3: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV3),
        eth_signTypedData_v4: (0, json_rpc_engine_1.createAsyncMiddleware)(signTypedDataV4),
        personal_sign: (0, json_rpc_engine_1.createAsyncMiddleware)(personalSign),
        eth_getEncryptionPublicKey: (0, json_rpc_engine_1.createAsyncMiddleware)(encryptionPublicKey),
        eth_decrypt: (0, json_rpc_engine_1.createAsyncMiddleware)(decryptMessage),
        personal_ecRecover: (0, json_rpc_engine_1.createAsyncMiddleware)(personalRecover),
    });
    //
    // account lookups
    //
    async function lookupAccounts(req, res) {
        res.result = await getAccounts(req);
    }
    async function lookupDefaultAccount(req, res) {
        const accounts = await getAccounts(req);
        res.result = accounts[0] || null;
    }
    //
    // transaction signatures
    //
    async function sendTransaction(req, res) {
        if (!processTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processTransaction(txParams, req);
    }
    async function signTransaction(req, res) {
        if (!processSignTransaction) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const txParams = req.params[0] || {};
        txParams.from = await validateAndNormalizeKeyholder(txParams.from, req);
        res.result = await processSignTransaction(txParams, req);
    }
    //
    // message signatures
    //
    async function ethSign(req, res) {
        if (!processEthSignMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processEthSignMessage(msgParams, req);
    }
    async function signTypedData(req, res) {
        if (!processTypedMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const message = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const version = 'V1';
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        res.result = await processTypedMessage(msgParams, req, version);
    }
    async function signTypedDataV3(req, res) {
        if (!processTypedMessageV3) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V3';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV3(msgParams, req, version);
    }
    async function signTypedDataV4(req, res) {
        if (!processTypedMessageV4) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        const message = req.params[1];
        const version = 'V4';
        const msgParams = {
            data: message,
            from: address,
            version,
        };
        res.result = await processTypedMessageV4(msgParams, req, version);
    }
    async function personalSign(req, res) {
        if (!processPersonalMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        // process normally
        const firstParam = req.params[0];
        const secondParam = req.params[1];
        // non-standard "extraParams" to be appended to our "msgParams" obj
        const extraParams = req.params[2] || {};
        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        let address, message;
        if (resemblesAddress(firstParam) && !resemblesAddress(secondParam)) {
            let warning = `The eth_personalSign method requires params ordered `;
            warning += `[message, address]. This was previously handled incorrectly, `;
            warning += `and has been corrected automatically. `;
            warning += `Please switch this param order for smooth behavior in the future.`;
            res.warning = warning;
            address = firstParam;
            message = secondParam;
        }
        else {
            message = firstParam;
            address = secondParam;
        }
        address = await validateAndNormalizeKeyholder(address, req);
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: message });
        // eslint-disable-next-line require-atomic-updates
        res.result = await processPersonalMessage(msgParams, req);
    }
    async function personalRecover(req, res) {
        const message = req.params[0];
        const signature = req.params[1];
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { sig: signature, data: message });
        const signerAddress = sigUtil.recoverPersonalSignature(msgParams);
        res.result = signerAddress;
    }
    async function encryptionPublicKey(req, res) {
        if (!processEncryptionPublicKey) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const address = await validateAndNormalizeKeyholder(req.params[0], req);
        res.result = await processEncryptionPublicKey(address, req);
    }
    async function decryptMessage(req, res) {
        if (!processDecryptMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.methodNotSupported();
        }
        const ciphertext = req.params[0];
        const address = await validateAndNormalizeKeyholder(req.params[1], req);
        const extraParams = req.params[2] || {};
        const msgParams = Object.assign(Object.assign({}, extraParams), { from: address, data: ciphertext });
        res.result = await processDecryptMessage(msgParams, req);
    }
    //
    // utility
    //
    /**
     * Validates the keyholder address, and returns a normalized (i.e. lowercase)
     * copy of it.
     *
     * @param {string} address - The address to validate and normalize.
     * @param {Object} req - The request object.
     * @returns {string} - The normalized address, if valid. Otherwise, throws
     * an error
     */
    async function validateAndNormalizeKeyholder(address, req) {
        if (typeof address === 'string' &&
            address.length > 0 &&
            resemblesAddress(address)) {
            // ensure address is included in provided accounts. `suppressUnauthorized: false` is passed to `getAccounts`
            // so that an "unauthorized" error is thrown if the requester does not have the `eth_accounts`
            // permission.
            const accounts = await getAccounts(req, {
                suppressUnauthorized: false,
            });
            const normalizedAccounts = accounts.map((_address) => _address.toLowerCase());
            const normalizedAddress = address.toLowerCase();
            if (normalizedAccounts.includes(normalizedAddress)) {
                return normalizedAddress;
            }
            throw eth_rpc_errors_1.ethErrors.provider.unauthorized();
        }
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams({
            message: `Invalid parameters: must provide an Ethereum address.`,
        });
    }
}
exports.createWalletMiddleware = createWalletMiddleware;
function resemblesAddress(str) {
    // hex prefix 2 + 20 bytes
    return str.length === 2 + 20 * 2;
}
//# sourceMappingURL=wallet.js.map
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\eth-sig-util\\index.js", {"ethereumjs-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\eth-sig-util\index.js
      return function (require, module, exports) {
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')

module.exports = {

  concatSig: function (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize: function (input) {
    if (!input) return

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ' received ' + (typeof input) + ': ' + input
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign: function (privateKey, msgParams) {
    var message = ethUtil.toBuffer(msgParams.data)
    var msgHash = ethUtil.hashPersonalMessage(message)
    var sig = ethUtil.ecsign(msgHash, privateKey)
    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return '0x' + publicKey.toString('hex')
  },

  typedSignatureHash: function (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedData: function (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature: function (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  }

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data)
    ]
  )
}

function recoverPublicKey(hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  var myString = '' + number
  while (myString.length < length) {
    myString = '0' + myString
  }
  return myString
}

      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>eth-sig-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\assert\\assert.js","bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethjs-util\\lib\\index.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\ethereumjs-util\dist\secp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

var secp256k1v3 = require('./secp256k1-lib/index');
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\ethereumjs-util\dist\secp256k1-lib\der.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", {"bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\ethereumjs-util\dist\secp256k1-lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>eth-sig-util>ethereumjs-util>ethjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-json-rpc-infura\\node_modules\\pify\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-json-rpc-infura\node_modules\pify\index.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
}, {package:"@metamask/eth-json-rpc-infura>eth-json-rpc-middleware>pify",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\index.js", {"@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-sig-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","hdkey":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const { EventEmitter } = require('events')
const HDKey = require('hdkey')
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const { TransactionFactory } = require('@ethereumjs/tx')

const pathBase = 'm'
const hdPathString = `${pathBase}/44'/60'/0'`
const type = 'Ledger Hardware'

const BRIDGE_URL = 'https://metamask.github.io/eth-ledger-bridge-keyring'

const MAX_INDEX = 1000
const NETWORK_API_URLS = {
  ropsten: 'http://api-ropsten.etherscan.io',
  kovan: 'http://api-kovan.etherscan.io',
  rinkeby: 'https://api-rinkeby.etherscan.io',
  mainnet: 'https://api.etherscan.io',
}

const CONNECTION_EVENT = 'ledger-connection-change'

class LedgerBridgeKeyring extends EventEmitter {
  constructor (opts = {}) {
    super()
    this.accountDetails = {}
    this.bridgeUrl = null
    this.type = type
    this.page = 0
    this.perPage = 5
    this.unlockedAccount = 0
    this.hdk = new HDKey()
    this.paths = {}
    this.iframe = null
    this.network = 'mainnet'
    this.implementFullBIP44 = false
    this.deserialize(opts)

    this.iframeLoaded = false
    this._setupIframe()

    this.currentMessageId = 0
    this.messageCallbacks = {}
    this._setupListener()
  }

  serialize () {
    return Promise.resolve({
      hdPath: this.hdPath,
      accounts: this.accounts,
      accountDetails: this.accountDetails,
      bridgeUrl: this.bridgeUrl,
      implementFullBIP44: false,
    })
  }

  deserialize (opts = {}) {
    this.hdPath = opts.hdPath || hdPathString
    this.bridgeUrl = opts.bridgeUrl || BRIDGE_URL
    this.accounts = opts.accounts || []
    this.accountDetails = opts.accountDetails || {}
    if (!opts.accountDetails) {
      this._migrateAccountDetails(opts)
    }

    this.implementFullBIP44 = opts.implementFullBIP44 || false

    // Remove accounts that don't have corresponding account details
    this.accounts = this.accounts
      .filter((account) => Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))

    return Promise.resolve()
  }

  _migrateAccountDetails (opts) {
    if (this._isLedgerLiveHdPath() && opts.accountIndexes) {
      for (const account of Object.keys(opts.accountIndexes)) {
        this.accountDetails[account] = {
          bip44: true,
          hdPath: this._getPathForIndex(opts.accountIndexes[account]),
        }
      }
    }

    // try to migrate non-LedgerLive accounts too
    if (!this._isLedgerLiveHdPath()) {
      this.accounts
        .filter((account) => !Object.keys(this.accountDetails).includes(ethUtil.toChecksumAddress(account)))
        .forEach((account) => {
          try {
            this.accountDetails[ethUtil.toChecksumAddress(account)] = {
              bip44: false,
              hdPath: this._pathFromAddress(account),
            }
          } catch (e) {
            console.log(`failed to migrate account ${account}`)
          }
        })
    }
  }

  isUnlocked () {
    return Boolean(this.hdk && this.hdk.publicKey)
  }

  isConnected () {
    return this.isDeviceConnected
  }

  setAccountToUnlock (index) {
    this.unlockedAccount = parseInt(index, 10)
  }

  setHdPath (hdPath) {
    // Reset HDKey if the path changes
    if (this.hdPath !== hdPath) {
      this.hdk = new HDKey()
    }
    this.hdPath = hdPath
  }

  unlock (hdPath, updateHdk = true) {
    if (this.isUnlocked() && !hdPath) {
      return Promise.resolve('already unlocked')
    }
    const path = hdPath ? this._toLedgerPath(hdPath) : this.hdPath
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-unlock',
        params: {
          hdPath: path,
        },
      },
      ({ success, payload }) => {
        if (success) {
          if (updateHdk) {
            this.hdk.publicKey = Buffer.from(payload.publicKey, 'hex')
            this.hdk.chainCode = Buffer.from(payload.chainCode, 'hex')
          }
          resolve(payload.address)
        } else {
          reject(payload.error || new Error('Unknown error'))
        }
      })
    })
  }

  addAccounts (n = 1) {

    return new Promise((resolve, reject) => {
      this.unlock()
        .then(async (_) => {
          const from = this.unlockedAccount
          const to = from + n
          for (let i = from; i < to; i++) {
            const path = this._getPathForIndex(i)
            let address
            if (this._isLedgerLiveHdPath()) {
              address = await this.unlock(path)
            } else {
              address = this._addressFromIndex(pathBase, i)
            }
            this.accountDetails[ethUtil.toChecksumAddress(address)] = {
              // TODO: consider renaming this property, as the current name is misleading
              // It's currently used to represent whether an account uses the Ledger Live path.
              bip44: this._isLedgerLiveHdPath(),
              hdPath: path,
            }

            if (!this.accounts.includes(address)) {
              this.accounts.push(address)
            }
            this.page = 0
          }
          resolve(this.accounts)
        })
        .catch(reject)
    })
  }

  getFirstPage () {
    this.page = 0
    return this.__getPage(1)
  }

  getNextPage () {
    return this.__getPage(1)
  }

  getPreviousPage () {
    return this.__getPage(-1)
  }

  getAccounts () {
    return Promise.resolve(this.accounts.slice())
  }

  removeAccount (address) {
    if (!this.accounts.map((a) => a.toLowerCase()).includes(address.toLowerCase())) {
      throw new Error(`Address ${address} not found in this keyring`)
    }
    this.accounts = this.accounts.filter((a) => a.toLowerCase() !== address.toLowerCase())
    delete this.accountDetails[ethUtil.toChecksumAddress(address)]
  }

  attemptMakeApp () {
    return new Promise((resolve, reject) => {
      this._sendMessage({
        action: 'ledger-make-app',
      }, ({ success, error }) => {
        if (success) {
          resolve(true)
        } else {
          reject(error)
        }
      })
    })
  }

  updateTransportMethod (transportType) {
    return new Promise((resolve, reject) => {
      // If the iframe isn't loaded yet, let's store the desired transportType value and
      // optimistically return a successful promise
      if (!this.iframeLoaded) {
        this.delayedPromise = {
          resolve,
          reject,
          transportType,
        }
        return
      }

      this._sendMessage({
        action: 'ledger-update-transport',
        params: { transportType },
      }, ({ success }) => {
        if (success) {
          resolve(true)
        } else {
          reject(new Error('Ledger transport could not be updated'))
        }
      })
    })
  }

  // tx is an instance of the ethereumjs-transaction class.
  signTransaction (address, tx) {
    let rawTxHex
    // transactions built with older versions of ethereumjs-tx have a
    // getChainId method that newer versions do not. Older versions are mutable
    // while newer versions default to being immutable. Expected shape and type
    // of data for v, r and s differ (Buffer (old) vs BN (new))
    if (typeof tx.getChainId === 'function') {
      // In this version of ethereumjs-tx we must add the chainId in hex format
      // to the initial v value. The chainId must be included in the serialized
      // transaction which is only communicated to ethereumjs-tx in this
      // value. In newer versions the chainId is communicated via the 'Common'
      // object.
      tx.v = ethUtil.bufferToHex(tx.getChainId())
      tx.r = '0x00'
      tx.s = '0x00'

      rawTxHex = tx.serialize().toString('hex')

      return this._signTransaction(address, rawTxHex, (payload) => {
        tx.v = Buffer.from(payload.v, 'hex')
        tx.r = Buffer.from(payload.r, 'hex')
        tx.s = Buffer.from(payload.s, 'hex')
        return tx
      })
    }

    // The below `encode` call is only necessary for legacy transactions, as `getMessageToSign`
    // calls `rlp.encode` internally for non-legacy transactions. As per the "Transaction Execution"
    // section of the ethereum yellow paper, transactions need to be "well-formed RLP, with no additional
    // trailing bytes".

    // Note also that `getMessageToSign` will return valid RLP for all transaction types, whereas the
    // `serialize` method will not for any transaction type except legacy. This is because `serialize` includes
    // empty r, s and v values in the encoded rlp. This is why we use `getMessageToSign` here instead of `serialize`.
    const messageToSign = tx.getMessageToSign(false)

    rawTxHex = Buffer.isBuffer(messageToSign)
      ? messageToSign.toString('hex')
      : ethUtil.rlp.encode(messageToSign).toString('hex')

    return this._signTransaction(address, rawTxHex, (payload) => {
      // Because tx will be immutable, first get a plain javascript object that
      // represents the transaction. Using txData here as it aligns with the
      // nomenclature of ethereumjs/tx.
      const txData = tx.toJSON()
      // The fromTxData utility expects a type to support transactions with a type other than 0
      txData.type = tx.type
      // The fromTxData utility expects v,r and s to be hex prefixed
      txData.v = ethUtil.addHexPrefix(payload.v)
      txData.r = ethUtil.addHexPrefix(payload.r)
      txData.s = ethUtil.addHexPrefix(payload.s)
      // Adopt the 'common' option from the original transaction and set the
      // returned object to be frozen if the original is frozen.
      return TransactionFactory.fromTxData(txData, { common: tx.common, freeze: Object.isFrozen(tx) })
    })
  }

  _signTransaction (address, rawTxHex, handleSigning) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(address)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-transaction',
            params: {
              tx: rawTxHex,
              hdPath,
            },
          },
          ({ success, payload }) => {
            if (success) {

              const newOrMutatedTx = handleSigning(payload)
              const valid = newOrMutatedTx.verifySignature()
              if (valid) {
                resolve(newOrMutatedTx)
              } else {
                reject(new Error('Ledger: The transaction signature is not valid'))
              }
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing transaction'))
            }
          })
        })
        .catch(reject)
    })
  }

  signMessage (withAccount, data) {
    return this.signPersonalMessage(withAccount, data)
  }

  // For personal_sign, we need to prefix the message:
  signPersonalMessage (withAccount, message) {
    return new Promise((resolve, reject) => {
      this.unlockAccountByAddress(withAccount)
        .then((hdPath) => {
          this._sendMessage({
            action: 'ledger-sign-personal-message',
            params: {
              hdPath,
              message: ethUtil.stripHexPrefix(message),
            },
          },
          ({ success, payload }) => {
            if (success) {
              let v = payload.v - 27
              v = v.toString(16)
              if (v.length < 2) {
                v = `0${v}`
              }
              const signature = `0x${payload.r}${payload.s}${v}`
              const addressSignedWith = sigUtil.recoverPersonalSignature({ data: message, sig: signature })
              if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
                reject(new Error('Ledger: The signature doesnt match the right address'))
              }
              resolve(signature)
            } else {
              reject(payload.error || new Error('Ledger: Unknown error while signing message'))
            }
          })
        })
        .catch(reject)
    })
  }

  async unlockAccountByAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    if (!Object.keys(this.accountDetails).includes(checksummedAddress)) {
      throw new Error(`Ledger: Account for address '${checksummedAddress}' not found`)
    }
    const { hdPath } = this.accountDetails[checksummedAddress]
    const unlockedAddress = await this.unlock(hdPath, false)

    // unlock resolves to the address for the given hdPath as reported by the ledger device
    // if that address is not the requested address, then this account belongs to a different device or seed
    if (unlockedAddress.toLowerCase() !== address.toLowerCase()) {
      throw new Error(`Ledger: Account ${address} does not belong to the connected device`)
    }
    return hdPath
  }

  async signTypedData (withAccount, data, options = {}) {
    const isV4 = options.version === 'V4'
    if (!isV4) {
      throw new Error('Ledger: Only version 4 of typed data signing is supported')
    }

    const {
      domain,
      types,
      primaryType,
      message,
    } = sigUtil.TypedDataUtils.sanitizeData(data)
    const domainSeparatorHex = sigUtil.TypedDataUtils.hashStruct('EIP712Domain', domain, types, isV4).toString('hex')
    const hashStructMessageHex = sigUtil.TypedDataUtils.hashStruct(primaryType, message, types, isV4).toString('hex')

    const hdPath = await this.unlockAccountByAddress(withAccount)
    const { success, payload } = await new Promise((resolve) => {
      this._sendMessage({
        action: 'ledger-sign-typed-data',
        params: {
          hdPath,
          domainSeparatorHex,
          hashStructMessageHex,
        },
      },
      (result) => resolve(result))
    })

    if (success) {
      let v = payload.v - 27
      v = v.toString(16)
      if (v.length < 2) {
        v = `0${v}`
      }
      const signature = `0x${payload.r}${payload.s}${v}`
      const addressSignedWith = sigUtil.recoverTypedSignature_v4({
        data,
        sig: signature,
      })
      if (ethUtil.toChecksumAddress(addressSignedWith) !== ethUtil.toChecksumAddress(withAccount)) {
        throw new Error('Ledger: The signature doesnt match the right address')
      }
      return signature
    }
    throw payload.error || new Error('Ledger: Unknown error while signing message')
  }

  exportAccount () {
    throw new Error('Not supported on this device')
  }

  forgetDevice () {
    this.accounts = []
    this.page = 0
    this.unlockedAccount = 0
    this.paths = {}
    this.accountDetails = {}
    this.hdk = new HDKey()
  }

  /* PRIVATE METHODS */

  _setupIframe () {
    this.iframe = document.createElement('iframe')
    this.iframe.src = this.bridgeUrl
    this.iframe.allow = `hid 'src'`
    this.iframe.onload = async () => {
      // If the ledger live preference was set before the iframe is loaded,
      // set it after the iframe has loaded
      this.iframeLoaded = true
      if (this.delayedPromise) {
        try {
          const result = await this.updateTransportMethod(
            this.delayedPromise.transportType,
          )
          this.delayedPromise.resolve(result)
        } catch (e) {
          this.delayedPromise.reject(e)
        } finally {
          delete this.delayedPromise
        }
      }
    }
    document.head.appendChild(this.iframe)
  }

  _getOrigin () {
    const tmp = this.bridgeUrl.split('/')
    tmp.splice(-1, 1)
    return tmp.join('/')
  }

  _sendMessage (msg, cb) {
    msg.target = 'LEDGER-IFRAME'

    this.currentMessageId += 1
    msg.messageId = this.currentMessageId

    this.messageCallbacks[this.currentMessageId] = cb
    this.iframe.contentWindow.postMessage(msg, '*')
  }

  _setupListener () {
    this._eventListener = ({ origin, data }) => {
      if (origin !== this._getOrigin()) {
        return false
      }

      if (data) {
        if (this.messageCallbacks[data.messageId]) {
          this.messageCallbacks[data.messageId](data)
        } else if (data.action === CONNECTION_EVENT) {
          this.isDeviceConnected = data.payload.connected
        }
      }

      return undefined
    }
    window.addEventListener('message', this._eventListener)
  }

  destroy () {
    window.removeEventListener('message', this._eventListener)
  }

  async __getPage (increment) {

    this.page += increment

    if (this.page <= 0) {
      this.page = 1
    }
    const from = (this.page - 1) * this.perPage
    const to = from + this.perPage

    await this.unlock()
    let accounts
    if (this._isLedgerLiveHdPath()) {
      accounts = await this._getAccountsBIP44(from, to)
    } else {
      accounts = this._getAccountsLegacy(from, to)
    }
    return accounts
  }

  async _getAccountsBIP44 (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const path = this._getPathForIndex(i)
      const address = await this.unlock(path)
      const valid = this.implementFullBIP44 ? await this._hasPreviousTransactions(address) : true
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      // PER BIP44
      // "Software should prevent a creation of an account if
      // a previous account does not have a transaction history
      // (meaning none of its addresses have been used before)."
      if (!valid) {
        break
      }
    }
    return accounts
  }

  _getAccountsLegacy (from, to) {
    const accounts = []

    for (let i = from; i < to; i++) {
      const address = this._addressFromIndex(pathBase, i)
      accounts.push({
        address,
        balance: null,
        index: i,
      })
      this.paths[ethUtil.toChecksumAddress(address)] = i
    }
    return accounts
  }

  _padLeftEven (hex) {
    return hex.length % 2 === 0 ? hex : `0${hex}`
  }

  _normalize (buf) {
    return this._padLeftEven(ethUtil.bufferToHex(buf).toLowerCase())
  }

  // eslint-disable-next-line no-shadow
  _addressFromIndex (pathBase, i) {
    const dkey = this.hdk.derive(`${pathBase}/${i}`)
    const address = ethUtil
      .publicToAddress(dkey.publicKey, true)
      .toString('hex')
    return ethUtil.toChecksumAddress(`0x${address}`)
  }

  _pathFromAddress (address) {
    const checksummedAddress = ethUtil.toChecksumAddress(address)
    let index = this.paths[checksummedAddress]
    if (typeof index === 'undefined') {
      for (let i = 0; i < MAX_INDEX; i++) {
        if (checksummedAddress === this._addressFromIndex(pathBase, i)) {
          index = i
          break
        }
      }
    }

    if (typeof index === 'undefined') {
      throw new Error('Unknown address')
    }
    return this._getPathForIndex(index)
  }

  _toAscii (hex) {
    let str = ''
    let i = 0
    const l = hex.length
    if (hex.substring(0, 2) === '0x') {
      i = 2
    }
    for (; i < l; i += 2) {
      const code = parseInt(hex.substr(i, 2), 16)
      str += String.fromCharCode(code)
    }

    return str
  }

  _getPathForIndex (index) {
    // Check if the path is BIP 44 (Ledger Live)
    return this._isLedgerLiveHdPath() ? `m/44'/60'/${index}'/0/0` : `${this.hdPath}/${index}`
  }

  _isLedgerLiveHdPath () {
    return this.hdPath === `m/44'/60'/0'/0/0`
  }

  _toLedgerPath (path) {
    return path.toString().replace('m/', '')
  }

  async _hasPreviousTransactions (address) {
    const apiUrl = this._getApiUrl()
    const response = await window.fetch(`${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1&offset=1`)
    const parsedResponse = await response.json()
    if (parsedResponse.status !== '0' && parsedResponse.result.length > 0) {
      return true
    }
    return false
  }

  _getApiUrl () {
    return NETWORK_API_URLS[this.network] || NETWORK_API_URLS.mainnet
  }

}

LedgerBridgeKeyring.type = type
module.exports = LedgerBridgeKeyring

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\index.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js","tweetnacl":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\tweetnacl\\nacl-fast.js","tweetnacl-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\tweetnacl-util\\nacl-util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\index.js
      return function (require, module, exports) {
const { Buffer } = require('buffer')
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')
const nacl = require('tweetnacl')
nacl.util = require('tweetnacl-util')

const TYPED_MESSAGE_SCHEMA = {
  type: 'object',
  properties: {
    types: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: { type: 'string' },
            type: { type: 'string' },
          },
          required: ['name', 'type'],
        },
      },
    },
    primaryType: { type: 'string' },
    domain: { type: 'object' },
    message: { type: 'object' },
  },
  required: ['types', 'primaryType', 'domain', 'message'],
}

/**
 * A collection of utility functions used for signing typed data
 */
const TypedDataUtils = {

  /**
   * Encodes an object by encoding and concatenating each of its members
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of an object
   */
  encodeData (primaryType, data, types, useV4 = true) {
    const encodedTypes = ['bytes32']
    const encodedValues = [this.hashType(primaryType, types)]

    if (useV4) {
      const encodeField = (name, type, value) => {
        if (types[type] !== undefined) {
          return ['bytes32', value === null || value === undefined ?
            '0x0000000000000000000000000000000000000000000000000000000000000000' :
            ethUtil.keccak(this.encodeData(type, value, types, useV4))]
        }

        if (value === undefined) {
          throw new Error(`missing value for field ${name} of type ${type}`)
        }

        if (type === 'bytes') {
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type === 'string') {
          // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
          if (typeof value === 'string') {
            value = Buffer.from(value, 'utf8')
          }
          return ['bytes32', ethUtil.keccak(value)]
        }

        if (type.lastIndexOf(']') === type.length - 1) {
          const parsedType = type.slice(0, type.lastIndexOf('['))
          const typeValuePairs = value.map((item) => encodeField(name, parsedType, item))
          return ['bytes32', ethUtil.keccak(ethAbi.rawEncode(
            typeValuePairs.map(([_type]) => _type),
            typeValuePairs.map(([, _value]) => _value),
          ))]
        }

        return [type, value]
      }

      for (const field of types[primaryType]) {
        const [type, value] = encodeField(field.name, field.type, data[field.name])
        encodedTypes.push(type)
        encodedValues.push(value)
      }
    } else {
      for (const field of types[primaryType]) {
        let value = data[field.name]
        if (value !== undefined) {
          if (field.type === 'bytes') {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (field.type === 'string') {
            encodedTypes.push('bytes32')
            // convert string to buffer - prevents ethUtil from interpreting strings like '0xabcd' as hex
            if (typeof value === 'string') {
              value = Buffer.from(value, 'utf8')
            }
            value = ethUtil.keccak(value)
            encodedValues.push(value)
          } else if (types[field.type] !== undefined) {
            encodedTypes.push('bytes32')
            value = ethUtil.keccak(this.encodeData(field.type, value, types, useV4))
            encodedValues.push(value)
          } else if (field.type.lastIndexOf(']') === field.type.length - 1) {
            throw new Error('Arrays currently unimplemented in encodeData')
          } else {
            encodedTypes.push(field.type)
            encodedValues.push(value)
          }
        }
      }
    }

    return ethAbi.rawEncode(encodedTypes, encodedValues)
  },

  /**
   * Encodes the type of an object by encoding a comma delimited list of its members
   *
   * @param {string} primaryType - Root type to encode
   * @param {Object} types - Type definitions
   * @returns {string} - Encoded representation of the type of an object
   */
  encodeType (primaryType, types) {
    let result = ''
    let deps = this.findTypeDependencies(primaryType, types).filter((dep) => dep !== primaryType)
    deps = [primaryType].concat(deps.sort())
    for (const type of deps) {
      const children = types[type]
      if (!children) {
        throw new Error(`No type definition specified: ${type}`)
      }
      result += `${type}(${types[type].map(({ name, type: _type }) => `${_type} ${name}`).join(',')})`
    }
    return result
  },

  /**
   * Finds all types within a type defintion object
   *
   * @param {string} primaryType - Root type
   * @param {Object} types - Type definitions
   * @param {Array} results - current set of accumulated types
   * @returns {Array} - Set of all types found in the type definition
   */
  findTypeDependencies (primaryType, types, results = []) {
    const [firstWord] = primaryType.match(/^\w*/u)
    primaryType = firstWord
    if (results.includes(primaryType) || types[primaryType] === undefined) {
      return results
    }
    results.push(primaryType)
    for (const field of types[primaryType]) {
      for (const dep of this.findTypeDependencies(field.type, types, results)) {
        !results.includes(dep) && results.push(dep)
      }
    }
    return results
  },

  /**
   * Hashes an object
   *
   * @param {string} primaryType - Root type
   * @param {Object} data - Object to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashStruct (primaryType, data, types, useV4 = true) {
    return ethUtil.keccak(this.encodeData(primaryType, data, types, useV4))
  },

  /**
   * Hashes the type of an object
   *
   * @param {string} primaryType - Root type to hash
   * @param {Object} types - Type definitions
   * @returns {string} - Hash of an object
   */
  hashType (primaryType, types) {
    return ethUtil.keccak(this.encodeType(primaryType, types))
  },

  /**
   * Removes properties from a message object that are not defined per EIP-712
   *
   * @param {Object} data - typed message object
   * @returns {Object} - typed message object with only allowed fields
   */
  sanitizeData (data) {
    const sanitizedData = {}
    for (const key of Object.keys(TYPED_MESSAGE_SCHEMA.properties)) {
      data[key] && (sanitizedData[key] = data[key])
    }
    if (sanitizedData.types) {
      sanitizedData.types = { EIP712Domain: [], ...sanitizedData.types }
    }
    return sanitizedData
  },

  /**
   * Signs a typed message as per EIP-712 and returns its keccak hash
   *
   * @param {Object} typedData - Types message data to sign
   * @returns {string} - keccak hash of the resulting signed message
   */
  sign (typedData, useV4 = true) {
    const sanitizedData = this.sanitizeData(typedData)
    const parts = [Buffer.from('1901', 'hex')]
    parts.push(this.hashStruct('EIP712Domain', sanitizedData.domain, sanitizedData.types, useV4))
    if (sanitizedData.primaryType !== 'EIP712Domain') {
      parts.push(this.hashStruct(sanitizedData.primaryType, sanitizedData.message, sanitizedData.types, useV4))
    }
    return ethUtil.keccak(Buffer.concat(parts))
  },
}

module.exports = {
  TYPED_MESSAGE_SCHEMA,
  TypedDataUtils,

  concatSig (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize (input) {
    if (!input) {
      return undefined
    }

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      let msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ` received ${typeof input}: ${input}`
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign (privateKey, msgParams) {
    const message = ethUtil.toBuffer(msgParams.data)
    const msgHash = ethUtil.hashPersonalMessage(message)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    const serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return `0x${publicKey.toString('hex')}`
  },

  typedSignatureHash (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedDataLegacy (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignatureLegacy (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  encrypt (receiverPublicKey, msgParams, version) {

    switch (version) {
      case 'x25519-xsalsa20-poly1305': {
        if (typeof msgParams.data === 'undefined') {
          throw new Error('Cannot detect secret message, message params should be of the form {data: "secret message"} ')
        }
        // generate ephemeral keypair
        const ephemeralKeyPair = nacl.box.keyPair()

        // assemble encryption parameters - from string to UInt8
        let pubKeyUInt8Array
        try {
          pubKeyUInt8Array = nacl.util.decodeBase64(receiverPublicKey)
        } catch (err) {
          throw new Error('Bad public key')
        }

        const msgParamsUInt8Array = nacl.util.decodeUTF8(msgParams.data)
        const nonce = nacl.randomBytes(nacl.box.nonceLength)

        // encrypt
        const encryptedMessage = nacl.box(msgParamsUInt8Array, nonce, pubKeyUInt8Array, ephemeralKeyPair.secretKey)

        // handle encrypted data
        const output = {
          version: 'x25519-xsalsa20-poly1305',
          nonce: nacl.util.encodeBase64(nonce),
          ephemPublicKey: nacl.util.encodeBase64(ephemeralKeyPair.publicKey),
          ciphertext: nacl.util.encodeBase64(encryptedMessage),
        }
        // return encrypted msg data
        return output
      }
      default:
        throw new Error('Encryption type/version not supported')

    }
  },

  encryptSafely (receiverPublicKey, msgParams, version) {

    const DEFAULT_PADDING_LENGTH = (2 ** 11)
    const NACL_EXTRA_BYTES = 16

    const { data } = msgParams
    if (!data) {
      throw new Error('Cannot encrypt empty msg.data')
    }

    if (typeof data === 'object' && data.toJSON) {
      // remove toJSON attack vector
      // TODO, check all possible children
      throw new Error('Cannot encrypt with toJSON property.  Please remove toJSON property')
    }

    // add padding
    const dataWithPadding = {
      data,
      padding: '',
    }

    // calculate padding
    const dataLength = Buffer.byteLength(JSON.stringify(dataWithPadding), 'utf-8')
    const modVal = (dataLength % DEFAULT_PADDING_LENGTH)
    let padLength = 0
    // Only pad if necessary
    if (modVal > 0) {
      padLength = (DEFAULT_PADDING_LENGTH - modVal) - NACL_EXTRA_BYTES // nacl extra bytes
    }
    dataWithPadding.padding = '0'.repeat(padLength)

    const paddedMsgParams = { data: JSON.stringify(dataWithPadding) }
    return this.encrypt(receiverPublicKey, paddedMsgParams, version)
  },

  decrypt (encryptedData, receiverPrivateKey) {

    switch (encryptedData.version) {
      case 'x25519-xsalsa20-poly1305': {
        // string to buffer to UInt8Array
        const recieverPrivateKeyUint8Array = nacl_decodeHex(receiverPrivateKey)
        const recieverEncryptionPrivateKey = nacl.box.keyPair.fromSecretKey(recieverPrivateKeyUint8Array).secretKey

        // assemble decryption parameters
        const nonce = nacl.util.decodeBase64(encryptedData.nonce)
        const ciphertext = nacl.util.decodeBase64(encryptedData.ciphertext)
        const ephemPublicKey = nacl.util.decodeBase64(encryptedData.ephemPublicKey)

        // decrypt
        const decryptedMessage = nacl.box.open(ciphertext, nonce, ephemPublicKey, recieverEncryptionPrivateKey)

        // return decrypted msg data
        let output
        try {
          output = nacl.util.encodeUTF8(decryptedMessage)
        } catch (err) {
          throw new Error('Decryption failed.')
        }

        if (output) {
          return output
        }
        throw new Error('Decryption failed.')
      }

      default:
        throw new Error('Encryption type/version not supported.')
    }
  },

  decryptSafely (encryptedData, receiverPrivateKey) {
    const dataWithPadding = JSON.parse(this.decrypt(encryptedData, receiverPrivateKey))
    return dataWithPadding.data
  },


  getEncryptionPublicKey (privateKey) {
    const privateKeyUint8Array = nacl_decodeHex(privateKey)
    const encryptionPublicKey = nacl.box.keyPair.fromSecretKey(privateKeyUint8Array).publicKey
    return nacl.util.encodeBase64(encryptionPublicKey)
  },


  /**
   * A generic entry point for all typed data methods to be passed, includes a version parameter.
   */
  signTypedMessage (privateKey, msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.signTypedDataLegacy(privateKey, msgParams)
      case 'V3':
        return this.signTypedData(privateKey, msgParams)
      case 'V4':
      default:
        return this.signTypedData_v4(privateKey, msgParams)
    }
  },

  recoverTypedMessage (msgParams, version = 'V4') {
    switch (version) {
      case 'V1':
        return this.recoverTypedSignatureLegacy(msgParams)
      case 'V3':
        return this.recoverTypedSignature(msgParams)
      case 'V4':
      default:
        return this.recoverTypedSignature_v4(msgParams)
    }
  },

  signTypedData (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  signTypedData_v4 (privateKey, msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const sig = ethUtil.ecsign(message, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data, false)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

  recoverTypedSignature_v4 (msgParams) {
    const message = TypedDataUtils.sign(msgParams.data)
    const publicKey = recoverPublicKey(message, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  },

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash (typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) {
    throw error
  }

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) {
    return e.type
  })
  const schema = typedData.map(function (e) {
    if (!e.name) {
      throw error
    }
    return `${e.type} ${e.name}`
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data),
    ],
  )
}

function recoverPublicKey (hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  let myString = `${number}`
  while (myString.length < length) {
    myString = `0${myString}`
  }
  return myString
}

// converts hex strings to the Uint8Array format used by nacl
function nacl_decodeHex (msgHex) {
  const msgBase64 = (Buffer.from(msgHex, 'hex')).toString('base64')
  return nacl.util.decodeBase64(msgBase64)
}



      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\assert\\assert.js","bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\node_modules\ethereumjs-util\dist\secp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

var secp256k1v3 = require('./secp256k1-lib/index');
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\node_modules\ethereumjs-util\dist\secp256k1-lib\der.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\eth-sig-util\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", {"bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\eth-sig-util\node_modules\ethereumjs-util\dist\secp256k1-lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>eth-sig-util>ethereumjs-util>ethjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\hdkey\\lib\\hdkey.js", {"assert":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\assert\\assert.js","coinstring":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\coinstring\\lib\\coinstring.js","crypto":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-browserify\\index.js","safe-buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js","secp256k1":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\hdkey\lib\hdkey.js
      return function (require, module, exports) {
var assert = require('assert')
var Buffer = require('safe-buffer').Buffer
var crypto = require('crypto')
var cs = require('coinstring')
var secp256k1 = require('secp256k1')

var MASTER_SECRET = Buffer.from('Bitcoin seed', 'utf8')
var HARDENED_OFFSET = 0x80000000
var LEN = 78

// Bitcoin hardcoded by default, can use package `coininfo` for others
var BITCOIN_VERSIONS = {private: 0x0488ADE4, public: 0x0488B21E}

function HDKey (versions) {
  this.versions = versions || BITCOIN_VERSIONS
  this.depth = 0
  this.index = 0
  this._privateKey = null
  this._publicKey = null
  this.chainCode = null
  this._fingerprint = 0
  this.parentFingerprint = 0
}

Object.defineProperty(HDKey.prototype, 'fingerprint', { get: function () { return this._fingerprint } })
Object.defineProperty(HDKey.prototype, 'identifier', { get: function () { return this._identifier } })
Object.defineProperty(HDKey.prototype, 'pubKeyHash', { get: function () { return this.identifier } })

Object.defineProperty(HDKey.prototype, 'privateKey', {
  get: function () {
    return this._privateKey
  },
  set: function (value) {
    assert.equal(value.length, 32, 'Private key must be 32 bytes.')
    assert(secp256k1.privateKeyVerify(value) === true, 'Invalid private key')

    this._privateKey = value
    this._publicKey = secp256k1.publicKeyCreate(value, true)
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
  }
})

Object.defineProperty(HDKey.prototype, 'publicKey', {
  get: function () {
    return this._publicKey
  },
  set: function (value) {
    assert(value.length === 33 || value.length === 65, 'Public key must be 33 or 65 bytes.')
    assert(secp256k1.publicKeyVerify(value) === true, 'Invalid public key')

    this._publicKey = secp256k1.publicKeyConvert(value, true) // force compressed point
    this._identifier = hash160(this.publicKey)
    this._fingerprint = this._identifier.slice(0, 4).readUInt32BE(0)
    this._privateKey = null
  }
})

Object.defineProperty(HDKey.prototype, 'privateExtendedKey', {
  get: function () {
    if (this._privateKey) return cs.encode(serialize(this, this.versions.private, Buffer.concat([Buffer.alloc(1, 0), this.privateKey])))
    else return null
  }
})

Object.defineProperty(HDKey.prototype, 'publicExtendedKey', {
  get: function () {
    return cs.encode(serialize(this, this.versions.public, this.publicKey))
  }
})

HDKey.prototype.derive = function (path) {
  if (path === 'm' || path === 'M' || path === "m'" || path === "M'") {
    return this
  }

  var entries = path.split('/')
  var hdkey = this
  entries.forEach(function (c, i) {
    if (i === 0) {
      assert(c, 'm', 'Invalid path')
      return
    }

    var hardened = (c.length > 1) && (c[c.length - 1] === "'")
    var childIndex = parseInt(c, 10) // & (HARDENED_OFFSET - 1)
    assert(childIndex < HARDENED_OFFSET, 'Invalid index')
    if (hardened) childIndex += HARDENED_OFFSET

    hdkey = hdkey.deriveChild(childIndex)
  })

  return hdkey
}

HDKey.prototype.deriveChild = function (index) {
  var isHardened = index >= HARDENED_OFFSET
  var indexBuffer = Buffer.allocUnsafe(4)
  indexBuffer.writeUInt32BE(index, 0)

  var data

  if (isHardened) { // Hardened child
    assert(this.privateKey, 'Could not derive hardened child key')

    var pk = this.privateKey
    var zb = Buffer.alloc(1, 0)
    pk = Buffer.concat([zb, pk])

    // data = 0x00 || ser256(kpar) || ser32(index)
    data = Buffer.concat([pk, indexBuffer])
  } else { // Normal child
    // data = serP(point(kpar)) || ser32(index)
    //      = serP(Kpar) || ser32(index)
    data = Buffer.concat([this.publicKey, indexBuffer])
  }

  var I = crypto.createHmac('sha512', this.chainCode).update(data).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hd = new HDKey(this.versions)

  // Private parent key -> private child key
  if (this.privateKey) {
    // ki = parse256(IL) + kpar (mod n)
    try {
      hd.privateKey = secp256k1.privateKeyTweakAdd(this.privateKey, IL)
      // throw if IL >= n || (privateKey + IL) === 0
    } catch (err) {
      // In case parse256(IL) >= n or ki == 0, one should proceed with the next value for i
      return this.derive(index + 1)
    }
  // Public parent key -> public child key
  } else {
    // Ki = point(parse256(IL)) + Kpar
    //    = G*IL + Kpar
    try {
      hd.publicKey = secp256k1.publicKeyTweakAdd(this.publicKey, IL, true)
      // throw if IL >= n || (g**IL + publicKey) is infinity
    } catch (err) {
      // In case parse256(IL) >= n or Ki is the point at infinity, one should proceed with the next value for i
      return this.derive(index + 1, isHardened)
    }
  }

  hd.chainCode = IR
  hd.depth = this.depth + 1
  hd.parentFingerprint = this.fingerprint// .readUInt32BE(0)
  hd.index = index

  return hd
}

HDKey.prototype.sign = function (hash) {
  return secp256k1.sign(hash, this.privateKey).signature
}

HDKey.prototype.verify = function (hash, signature) {
  return secp256k1.verify(hash, signature, this.publicKey)
}

HDKey.prototype.toJSON = function () {
  return {
    xpriv: this.privateExtendedKey,
    xpub: this.publicExtendedKey
  }
}

HDKey.fromMasterSeed = function (seedBuffer, versions) {
  var I = crypto.createHmac('sha512', MASTER_SECRET).update(seedBuffer).digest()
  var IL = I.slice(0, 32)
  var IR = I.slice(32)

  var hdkey = new HDKey(versions)
  hdkey.chainCode = IR
  hdkey.privateKey = IL

  return hdkey
}

HDKey.fromExtendedKey = function (base58key, versions) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  versions = versions || BITCOIN_VERSIONS
  var hdkey = new HDKey(versions)

  var keyBuffer = cs.decode(base58key)

  var version = keyBuffer.readUInt32BE(0)
  assert(version === versions.private || version === versions.public, 'Version mismatch: does not match private or public')

  hdkey.depth = keyBuffer.readUInt8(4)
  hdkey.parentFingerprint = keyBuffer.readUInt32BE(5)
  hdkey.index = keyBuffer.readUInt32BE(9)
  hdkey.chainCode = keyBuffer.slice(13, 45)

  var key = keyBuffer.slice(45)
  if (key.readUInt8(0) === 0) { // private
    assert(version === versions.private, 'Version mismatch: version does not match private')
    hdkey.privateKey = key.slice(1) // cut off first 0x0 byte
  } else {
    assert(version === versions.public, 'Version mismatch: version does not match public')
    hdkey.publicKey = key
  }

  return hdkey
}

HDKey.fromJSON = function (obj) {
  return HDKey.fromExtendedKey(obj.xpriv)
}

function serialize (hdkey, version, key) {
  // => version(4) || depth(1) || fingerprint(4) || index(4) || chain(32) || key(33)
  var buffer = Buffer.allocUnsafe(LEN)

  buffer.writeUInt32BE(version, 0)
  buffer.writeUInt8(hdkey.depth, 4)

  var fingerprint = hdkey.depth ? hdkey.parentFingerprint : 0x00000000
  buffer.writeUInt32BE(fingerprint, 5)
  buffer.writeUInt32BE(hdkey.index, 9)

  hdkey.chainCode.copy(buffer, 13)
  key.copy(buffer, 45)

  return buffer
}

function hash160 (buf) {
  var sha = crypto.createHash('sha256').update(buf).digest()
  return crypto.createHash('rmd160').update(sha).digest()
}

HDKey.HARDENED_OFFSET = HARDENED_OFFSET
module.exports = HDKey

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\elliptic.js", {"./lib":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js","./lib/elliptic":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\elliptic.js
      return function (require, module, exports) {
'use strict'
module.exports = require('./lib')(require('./lib/elliptic'))

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js", {"../../../../../is-buffer/index.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\assert.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'
var toString = Object.prototype.toString

// TypeError
exports.isArray = function (value, message) {
  if (!Array.isArray(value)) throw TypeError(message)
}

exports.isBoolean = function (value, message) {
  if (toString.call(value) !== '[object Boolean]') throw TypeError(message)
}

exports.isBuffer = function (value, message) {
  if (!Buffer.isBuffer(value)) throw TypeError(message)
}

exports.isFunction = function (value, message) {
  if (toString.call(value) !== '[object Function]') throw TypeError(message)
}

exports.isNumber = function (value, message) {
  if (toString.call(value) !== '[object Number]') throw TypeError(message)
}

exports.isObject = function (value, message) {
  if (toString.call(value) !== '[object Object]') throw TypeError(message)
}

// RangeError
exports.isBufferLength = function (buffer, length, message) {
  if (buffer.length !== length) throw RangeError(message)
}

exports.isBufferLength2 = function (buffer, length1, length2, message) {
  if (buffer.length !== length1 && buffer.length !== length2) throw RangeError(message)
}

exports.isLengthGTZero = function (value, message) {
  if (value.length === 0) throw RangeError(message)
}

exports.isNumberInInterval = function (number, x, y, message) {
  if (number <= x || number >= y) throw RangeError(message)
}

}).call(this)}).call(this,{"isBuffer":require("../../../../../is-buffer/index.js")})

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js", {"bip66":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bip66\\index.js","safe-buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\der.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var bip66 = require('bip66')

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
  // begin
  0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x21, 0x02, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
  // begin
  0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
  // private key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  // middle
  0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48,
  0xcE, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xfE, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04,
  0x41, 0x04, 0x79, 0xbE, 0x66, 0x7E, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xcE, 0x87,
  0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xcE, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8,
  0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0E, 0x11,
  0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10,
  0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
  0xff, 0xff, 0xff, 0xff, 0xfE, 0xba, 0xaE, 0xdc, 0xE6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5E,
  0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
  // public key
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00
])

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED)
  privateKey.copy(result, compressed ? 8 : 9)
  publicKey.copy(result, compressed ? 181 : 214)
  return result
}

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length

  // sequence header
  var index = 0
  if (length < index + 1 || privateKey[index] !== 0x30) return
  index += 1

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return

  var lenb = privateKey[index] & 0x7f
  index += 1
  if (lenb < 1 || lenb > 2) return
  if (length < index + lenb) return

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0)
  index += lenb
  if (length < index + len) return

  // sequence element 0: version number (=1)
  if (length < index + 3 ||
      privateKey[index] !== 0x02 ||
      privateKey[index + 1] !== 0x01 ||
      privateKey[index + 2] !== 0x01) {
    return
  }
  index += 3

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 ||
      privateKey[index] !== 0x04 ||
      privateKey[index + 1] > 0x20 ||
      length < index + 2 + privateKey[index + 1]) {
    return
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1])
}

exports.signatureExport = function (sigObj) {
  var r = Buffer.concat([Buffer.from([0]), sigObj.r])
  for (var lenR = 33, posR = 0; lenR > 1 && r[posR] === 0x00 && !(r[posR + 1] & 0x80); --lenR, ++posR);

  var s = Buffer.concat([Buffer.from([0]), sigObj.s])
  for (var lenS = 33, posS = 0; lenS > 1 && s[posS] === 0x00 && !(s[posS + 1] & 0x80); --lenS, ++posS);

  return bip66.encode(r.slice(posR), s.slice(posS))
}

exports.signatureImport = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  try {
    var sigObj = bip66.decode(sig)
    if (sigObj.r.length === 33 && sigObj.r[0] === 0x00) sigObj.r = sigObj.r.slice(1)
    if (sigObj.r.length > 32) throw new Error('R length is too long')
    if (sigObj.s.length === 33 && sigObj.s[0] === 0x00) sigObj.s = sigObj.s.slice(1)
    if (sigObj.s.length > 32) throw new Error('S length is too long')
  } catch (err) {
    return
  }

  sigObj.r.copy(r, 32 - sigObj.r.length)
  sigObj.s.copy(s, 32 - sigObj.s.length)

  return { r: r, s: s }
}

exports.signatureImportLax = function (sig) {
  var r = Buffer.alloc(32, 0)
  var s = Buffer.alloc(32, 0)

  var length = sig.length
  var index = 0

  // sequence tag byte
  if (sig[index++] !== 0x30) return

  // sequence length byte
  var lenbyte = sig[index++]
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80
    if (index > length) return
  }

  // sequence tag byte for r
  if (sig[index++] !== 0x02) return

  // length for r
  var rlen = sig[index++]
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) rlen = (rlen << 8) + sig[index]
  }
  if (rlen > length - index) return
  var rindex = index
  index += rlen

  // sequence tag byte for s
  if (sig[index++] !== 0x02) return

  // length for s
  var slen = sig[index++]
  if (slen & 0x80) {
    lenbyte = slen - 0x80
    if (index + lenbyte > length) return
    for (; lenbyte > 0 && sig[index] === 0x00; index += 1, lenbyte -= 1);
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) slen = (slen << 8) + sig[index]
  }
  if (slen > length - index) return
  var sindex = index
  index += slen

  // ignore leading zeros in r
  for (; rlen > 0 && sig[rindex] === 0x00; rlen -= 1, rindex += 1);
  // copy r value
  if (rlen > 32) return
  var rvalue = sig.slice(rindex, rindex + rlen)
  rvalue.copy(r, 32 - rvalue.length)

  // ignore leading zeros in s
  for (; slen > 0 && sig[sindex] === 0x00; slen -= 1, sindex += 1);
  // copy s value
  if (slen > 32) return
  var svalue = sig.slice(sindex, sindex + slen)
  svalue.copy(s, 32 - svalue.length)

  return { r: r, s: s }
}

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\elliptic\\index.js", {"../messages.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json","bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\create-hash\\browser.js","elliptic":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js","safe-buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\elliptic\index.js
      return function (require, module, exports) {
'use strict'
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var BN = require('bn.js')
var EC = require('elliptic').ec

var messages = require('../messages.json')

var ec = new EC('secp256k1')
var ecparams = ec.curve

function loadCompressedPublicKey (first, xBuffer) {
  var x = new BN(xBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0) return null
  x = x.toRed(ecparams.red)

  // compute corresponding Y
  var y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt()
  if ((first === 0x03) !== y.isOdd()) y = y.redNeg()

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadUncompressedPublicKey (first, xBuffer, yBuffer) {
  var x = new BN(xBuffer)
  var y = new BN(yBuffer)

  // overflow
  if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0) return null

  x = x.toRed(ecparams.red)
  y = y.toRed(ecparams.red)

  // is odd flag
  if ((first === 0x06 || first === 0x07) && y.isOdd() !== (first === 0x07)) return null

  // x*x*x + b = y*y
  var x3 = x.redSqr().redIMul(x)
  if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero()) return null

  return ec.keyPair({ pub: { x: x, y: y } })
}

function loadPublicKey (publicKey) {
  var first = publicKey[0]
  switch (first) {
    case 0x02:
    case 0x03:
      if (publicKey.length !== 33) return null
      return loadCompressedPublicKey(first, publicKey.slice(1, 33))
    case 0x04:
    case 0x06:
    case 0x07:
      if (publicKey.length !== 65) return null
      return loadUncompressedPublicKey(first, publicKey.slice(1, 33), publicKey.slice(33, 65))
    default:
      return null
  }
}

exports.privateKeyVerify = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.cmp(ecparams.n) < 0 && !bn.isZero()
}

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PRIVATE_KEY_EXPORT_DER_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.privateKeyNegate = function (privateKey) {
  var bn = new BN(privateKey)
  return bn.isZero() ? Buffer.alloc(32) : ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_RANGE_INVALID)

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakAdd = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  bn.iadd(new BN(privateKey))
  if (bn.cmp(ecparams.n) >= 0) bn.isub(ecparams.n)
  if (bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_ADD_FAIL)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.privateKeyTweakMul = function (privateKey, tweak) {
  var bn = new BN(tweak)
  if (bn.cmp(ecparams.n) >= 0 || bn.isZero()) throw new Error(messages.EC_PRIVATE_KEY_TWEAK_MUL_FAIL)

  bn.imul(new BN(privateKey))
  if (bn.cmp(ecparams.n)) bn = bn.umod(ecparams.n)

  return bn.toArrayLike(Buffer, 'be', 32)
}

exports.publicKeyCreate = function (privateKey, compressed) {
  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.EC_PUBLIC_KEY_CREATE_FAIL)

  return Buffer.from(ec.keyFromPrivate(privateKey).getPublic(compressed, true))
}

exports.publicKeyConvert = function (publicKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return Buffer.from(pair.getPublic(compressed, true))
}

exports.publicKeyVerify = function (publicKey) {
  return loadPublicKey(publicKey) !== null
}

exports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  var point = ecparams.g.mul(tweak).add(pair.pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_ADD_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.publicKeyTweakMul = function (publicKey, tweak, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  tweak = new BN(tweak)
  if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero()) throw new Error(messages.EC_PUBLIC_KEY_TWEAK_MUL_FAIL)

  return Buffer.from(pair.pub.mul(tweak).encode(true, compressed))
}

exports.publicKeyCombine = function (publicKeys, compressed) {
  var pairs = new Array(publicKeys.length)
  for (var i = 0; i < publicKeys.length; ++i) {
    pairs[i] = loadPublicKey(publicKeys[i])
    if (pairs[i] === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)
  }

  var point = pairs[0].pub
  for (var j = 1; j < pairs.length; ++j) point = point.add(pairs[j].pub)
  if (point.isInfinity()) throw new Error(messages.EC_PUBLIC_KEY_COMBINE_FAIL)

  return Buffer.from(point.encode(true, compressed))
}

exports.signatureNormalize = function (signature) {
  var r = new BN(signature.slice(0, 32))
  var s = new BN(signature.slice(32, 64))
  if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  var result = Buffer.from(signature)
  if (s.cmp(ec.nh) === 1) ecparams.n.sub(s).toArrayLike(Buffer, 'be', 32).copy(result, 32)

  return result
}

exports.signatureExport = function (signature) {
  var r = signature.slice(0, 32)
  var s = signature.slice(32, 64)
  if (new BN(r).cmp(ecparams.n) >= 0 || new BN(s).cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  return { r: r, s: s }
}

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r)
  if (r.cmp(ecparams.n) >= 0) r = new BN(0)

  var s = new BN(sigObj.s)
  if (s.cmp(ecparams.n) >= 0) s = new BN(0)

  return Buffer.concat([
    r.toArrayLike(Buffer, 'be', 32),
    s.toArrayLike(Buffer, 'be', 32)
  ])
}

exports.sign = function (message, privateKey, noncefn, data) {
  if (typeof noncefn === 'function') {
    var getNonce = noncefn
    noncefn = function (counter) {
      var nonce = getNonce(message, privateKey, null, data, counter)
      if (!Buffer.isBuffer(nonce) || nonce.length !== 32) throw new Error(messages.ECDSA_SIGN_FAIL)

      return new BN(nonce)
    }
  }

  var d = new BN(privateKey)
  if (d.cmp(ecparams.n) >= 0 || d.isZero()) throw new Error(messages.ECDSA_SIGN_FAIL)

  var result = ec.sign(message, privateKey, { canonical: true, k: noncefn, pers: data })
  return {
    signature: Buffer.concat([
      result.r.toArrayLike(Buffer, 'be', 32),
      result.s.toArrayLike(Buffer, 'be', 32)
    ]),
    recovery: result.recoveryParam
  }
}

exports.verify = function (message, signature, publicKey) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)
  if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero()) return false

  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  return ec.verify(message, sigObj, { x: pair.pub.x, y: pair.pub.y })
}

exports.recover = function (message, signature, recovery, compressed) {
  var sigObj = { r: signature.slice(0, 32), s: signature.slice(32, 64) }

  var sigr = new BN(sigObj.r)
  var sigs = new BN(sigObj.s)
  if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0) throw new Error(messages.ECDSA_SIGNATURE_PARSE_FAIL)

  try {
    if (sigr.isZero() || sigs.isZero()) throw new Error()

    var point = ec.recoverPubKey(message, sigObj, recovery)
    return Buffer.from(point.encode(true, compressed))
  } catch (err) {
    throw new Error(messages.ECDSA_RECOVER_FAIL)
  }
}

exports.ecdh = function (publicKey, privateKey) {
  var shared = exports.ecdhUnsafe(publicKey, privateKey, true)
  return createHash('sha256').update(shared).digest()
}

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var pair = loadPublicKey(publicKey)
  if (pair === null) throw new Error(messages.EC_PUBLIC_KEY_PARSE_FAIL)

  var scalar = new BN(privateKey)
  if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero()) throw new Error(messages.ECDH_FAIL)

  return Buffer.from(pair.pub.mul(scalar).encode(true, compressed))
}

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\index.js", {"./assert":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\assert.js","./der":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\der.js","./messages.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\index.js
      return function (require, module, exports) {
'use strict'
var assert = require('./assert')
var der = require('./der')
var messages = require('./messages.json')

function initCompressedValue (value, defaultValue) {
  if (value === undefined) return defaultValue

  assert.isBoolean(value, messages.COMPRESSED_TYPE_INVALID)
  return value
}

module.exports = function (secp256k1) {
  return {
    privateKeyVerify: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      return privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)
    },

    privateKeyExport: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)
      var publicKey = secp256k1.privateKeyExport(privateKey, compressed)

      return der.privateKeyExport(privateKey, publicKey, compressed)
    },

    privateKeyImport: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)

      privateKey = der.privateKeyImport(privateKey)
      if (privateKey && privateKey.length === 32 && secp256k1.privateKeyVerify(privateKey)) return privateKey

      throw new Error(messages.EC_PRIVATE_KEY_IMPORT_DER_FAIL)
    },

    privateKeyNegate: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyNegate(privateKey)
    },

    privateKeyModInverse: function (privateKey) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.privateKeyModInverse(privateKey)
    },

    privateKeyTweakAdd: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakAdd(privateKey, tweak)
    },

    privateKeyTweakMul: function (privateKey, tweak) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      return secp256k1.privateKeyTweakMul(privateKey, tweak)
    },

    publicKeyCreate: function (privateKey, compressed) {
      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCreate(privateKey, compressed)
    },

    publicKeyConvert: function (publicKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyConvert(publicKey, compressed)
    },

    publicKeyVerify: function (publicKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      return secp256k1.publicKeyVerify(publicKey)
    },

    publicKeyTweakAdd: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakAdd(publicKey, tweak, compressed)
    },

    publicKeyTweakMul: function (publicKey, tweak, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(tweak, messages.TWEAK_TYPE_INVALID)
      assert.isBufferLength(tweak, 32, messages.TWEAK_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyTweakMul(publicKey, tweak, compressed)
    },

    publicKeyCombine: function (publicKeys, compressed) {
      assert.isArray(publicKeys, messages.EC_PUBLIC_KEYS_TYPE_INVALID)
      assert.isLengthGTZero(publicKeys, messages.EC_PUBLIC_KEYS_LENGTH_INVALID)
      for (var i = 0; i < publicKeys.length; ++i) {
        assert.isBuffer(publicKeys[i], messages.EC_PUBLIC_KEY_TYPE_INVALID)
        assert.isBufferLength2(publicKeys[i], 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)
      }

      compressed = initCompressedValue(compressed, true)

      return secp256k1.publicKeyCombine(publicKeys, compressed)
    },

    signatureNormalize: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      return secp256k1.signatureNormalize(signature)
    },

    signatureExport: function (signature) {
      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = secp256k1.signatureExport(signature)
      return der.signatureExport(sigObj)
    },

    signatureImport: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImport(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    signatureImportLax: function (sig) {
      assert.isBuffer(sig, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isLengthGTZero(sig, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      var sigObj = der.signatureImportLax(sig)
      if (sigObj) return secp256k1.signatureImport(sigObj)

      throw new Error(messages.ECDSA_SIGNATURE_PARSE_DER_FAIL)
    },

    sign: function (message, privateKey, options) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      var data = null
      var noncefn = null
      if (options !== undefined) {
        assert.isObject(options, messages.OPTIONS_TYPE_INVALID)

        if (options.data !== undefined) {
          assert.isBuffer(options.data, messages.OPTIONS_DATA_TYPE_INVALID)
          assert.isBufferLength(options.data, 32, messages.OPTIONS_DATA_LENGTH_INVALID)
          data = options.data
        }

        if (options.noncefn !== undefined) {
          assert.isFunction(options.noncefn, messages.OPTIONS_NONCEFN_TYPE_INVALID)
          noncefn = options.noncefn
        }
      }

      return secp256k1.sign(message, privateKey, noncefn, data)
    },

    verify: function (message, signature, publicKey) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      return secp256k1.verify(message, signature, publicKey)
    },

    recover: function (message, signature, recovery, compressed) {
      assert.isBuffer(message, messages.MSG32_TYPE_INVALID)
      assert.isBufferLength(message, 32, messages.MSG32_LENGTH_INVALID)

      assert.isBuffer(signature, messages.ECDSA_SIGNATURE_TYPE_INVALID)
      assert.isBufferLength(signature, 64, messages.ECDSA_SIGNATURE_LENGTH_INVALID)

      assert.isNumber(recovery, messages.RECOVERY_ID_TYPE_INVALID)
      assert.isNumberInInterval(recovery, -1, 4, messages.RECOVERY_ID_VALUE_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.recover(message, signature, recovery, compressed)
    },

    ecdh: function (publicKey, privateKey) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      return secp256k1.ecdh(publicKey, privateKey)
    },

    ecdhUnsafe: function (publicKey, privateKey, compressed) {
      assert.isBuffer(publicKey, messages.EC_PUBLIC_KEY_TYPE_INVALID)
      assert.isBufferLength2(publicKey, 33, 65, messages.EC_PUBLIC_KEY_LENGTH_INVALID)

      assert.isBuffer(privateKey, messages.EC_PRIVATE_KEY_TYPE_INVALID)
      assert.isBufferLength(privateKey, 32, messages.EC_PRIVATE_KEY_LENGTH_INVALID)

      compressed = initCompressedValue(compressed, true)

      return secp256k1.ecdhUnsafe(publicKey, privateKey, compressed)
    }
  }
}

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\eth-ledger-bridge-keyring\\node_modules\\secp256k1\\lib\\messages.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\eth-ledger-bridge-keyring\node_modules\secp256k1\lib\messages.json
      return function (require, module, exports) {
module.exports={
  "COMPRESSED_TYPE_INVALID": "compressed should be a boolean",
  "EC_PRIVATE_KEY_TYPE_INVALID": "private key should be a Buffer",
  "EC_PRIVATE_KEY_LENGTH_INVALID": "private key length is invalid",
  "EC_PRIVATE_KEY_RANGE_INVALID": "private key range is invalid",
  "EC_PRIVATE_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting private key is invalid",
  "EC_PRIVATE_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PRIVATE_KEY_EXPORT_DER_FAIL": "couldn't export to DER format",
  "EC_PRIVATE_KEY_IMPORT_DER_FAIL": "couldn't import from DER format",
  "EC_PUBLIC_KEYS_TYPE_INVALID": "public keys should be an Array",
  "EC_PUBLIC_KEYS_LENGTH_INVALID": "public keys Array should have at least 1 element",
  "EC_PUBLIC_KEY_TYPE_INVALID": "public key should be a Buffer",
  "EC_PUBLIC_KEY_LENGTH_INVALID": "public key length is invalid",
  "EC_PUBLIC_KEY_PARSE_FAIL": "the public key could not be parsed or is invalid",
  "EC_PUBLIC_KEY_CREATE_FAIL": "private was invalid, try again",
  "EC_PUBLIC_KEY_TWEAK_ADD_FAIL": "tweak out of range or resulting public key is invalid",
  "EC_PUBLIC_KEY_TWEAK_MUL_FAIL": "tweak out of range",
  "EC_PUBLIC_KEY_COMBINE_FAIL": "the sum of the public keys is not valid",
  "ECDH_FAIL": "scalar was invalid (zero or overflow)",
  "ECDSA_SIGNATURE_TYPE_INVALID": "signature should be a Buffer",
  "ECDSA_SIGNATURE_LENGTH_INVALID": "signature length is invalid",
  "ECDSA_SIGNATURE_PARSE_FAIL": "couldn't parse signature",
  "ECDSA_SIGNATURE_PARSE_DER_FAIL": "couldn't parse DER signature",
  "ECDSA_SIGNATURE_SERIALIZE_DER_FAIL": "couldn't serialize signature to DER format",
  "ECDSA_SIGN_FAIL": "nonce generation function failed or private key is invalid",
  "ECDSA_RECOVER_FAIL": "couldn't recover public key from signature",
  "MSG32_TYPE_INVALID": "message should be a Buffer",
  "MSG32_LENGTH_INVALID": "message length is invalid",
  "OPTIONS_TYPE_INVALID": "options should be an Object",
  "OPTIONS_DATA_TYPE_INVALID": "options.data should be a Buffer",
  "OPTIONS_DATA_LENGTH_INVALID": "options.data length is invalid",
  "OPTIONS_NONCEFN_TYPE_INVALID": "options.noncefn should be a Function",
  "RECOVERY_ID_TYPE_INVALID": "recovery should be a Number",
  "RECOVERY_ID_VALUE_INVALID": "recovery should have value between -1 and 4",
  "TWEAK_TYPE_INVALID": "tweak should be a Buffer",
  "TWEAK_LENGTH_INVALID": "tweak length is invalid"
}

      };
    };
  }
}, {package:"@metamask/eth-ledger-bridge-keyring>hdkey>secp256k1",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js", {"./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\ComposedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class ComposedStore extends ObservableStore_1.ObservableStore {
    constructor(children) {
        super();
        // set default state
        const state = this.getState();
        if (!state) {
            this.putState({});
        }
        // subscribe to children
        this._children = children || {};
        Object.keys(this._children).forEach((childKey) => {
            const child = this._children[childKey];
            this._addChild(childKey, child);
        });
    }
    _addChild(childKey, child) {
        const updateFromChild = (childValue) => {
            const state = this.getState();
            state[childKey] = childValue;
            this.putState(state);
        };
        child.subscribe(updateFromChild);
        updateFromChild(child.getState());
    }
}
exports.ComposedStore = ComposedStore;
//# sourceMappingURL=ComposedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\LocalStorageStore.js", {"./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\LocalStorageStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalStorageStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class LocalStorageStore extends ObservableStore_1.ObservableStore {
    constructor(opts = {}) {
        if (!global.localStorage) {
            throw new Error('LocalStorageStore - can\'t find localStorage.');
        }
        super();
        if (!opts.storageKey) {
            throw new Error('LocalStorageStore - no storageKey specified.');
        }
        this._storageKey = opts.storageKey;
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        const serialized = global.localStorage.getItem(this._storageKey);
        return serialized ? JSON.parse(serialized) : undefined;
    }
    // write to persistence
    _putState(newState) {
        const serialized = JSON.stringify(newState);
        return global.localStorage.setItem(this._storageKey, serialized);
    }
}
exports.LocalStorageStore = LocalStorageStore;
//# sourceMappingURL=LocalStorageStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js", {"./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\MergedStore.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MergedStore = void 0;
const ObservableStore_1 = require("./ObservableStore");
class MergedStore extends ObservableStore_1.ObservableStore {
    constructor(children = []) {
        super();
        // set default state
        const state = this.getState();
        if (!state) {
            this.putState({});
        }
        this._children = children;
        // subscribe to children
        children.forEach((child) => this._addChild(child));
        this._updateWholeState();
    }
    _addChild(child) {
        child.subscribe(() => this._updateWholeState());
    }
    _updateWholeState() {
        const childStates = this._children.map((child) => child.getState());
        // apply shallow merge over states
        const state = Object.assign({}, ...childStates);
        this.putState(state);
    }
}
exports.MergedStore = MergedStore;
//# sourceMappingURL=MergedStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js", {"@metamask/safe-event-emitter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\ObservableStore.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservableStore = void 0;
const safe_event_emitter_1 = __importDefault(require("@metamask/safe-event-emitter"));
class ObservableStore extends safe_event_emitter_1.default {
    constructor(initState = {}) {
        super();
        // set init state
        this._state = initState;
    }
    // wrapper around internal getState
    getState() {
        return this._getState();
    }
    // wrapper around internal putState
    putState(newState) {
        this._putState(newState);
        this.emit('update', newState);
    }
    updateState(partialState) {
        // if non-null object, merge
        if (partialState && typeof partialState === 'object') {
            const state = this.getState();
            const newState = Object.assign({}, state, partialState);
            this.putState(newState);
            // if not object, use new value
        }
        else {
            this.putState(partialState);
        }
    }
    // subscribe to changes
    subscribe(handler) {
        this.on('update', handler);
    }
    // unsubscribe to changes
    unsubscribe(handler) {
        this.removeListener('update', handler);
    }
    //
    // private
    //
    // read from persistence
    _getState() {
        return this._state;
    }
    // write to persistence
    _putState(newState) {
        this._state = newState;
    }
}
exports.ObservableStore = ObservableStore;
//# sourceMappingURL=ObservableStore.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\asStream.js", {"stream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\asStream.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeAsStream = void 0;
const stream_1 = require("stream");
class ObservableStoreStream extends stream_1.Duplex {
    constructor(obsStore) {
        super({
            // pass values, not serializations
            objectMode: true,
        });
        // dont buffer outgoing updates
        this.resume();
        // save handler so we can unsubscribe later
        this.handler = (state) => this.push(state);
        // subscribe to obsStore changes
        this.obsStore = obsStore;
        this.obsStore.subscribe(this.handler);
    }
    // emit current state on new destination
    pipe(dest, options) {
        const result = super.pipe(dest, options);
        dest.write(this.obsStore.getState());
        return result;
    }
    // write from incoming stream to state
    _write(chunk, _encoding, callback) {
        this.obsStore.putState(chunk);
        callback();
    }
    // noop - outgoing stream is asking us if we have data we arent giving it
    _read(_size) {
        return undefined;
    }
    // unsubscribe from event emitter
    _destroy(err, callback) {
        this.obsStore.unsubscribe(this.handler);
        super._destroy(err, callback);
    }
}
function storeAsStream(obsStore) {
    return new ObservableStoreStream(obsStore);
}
exports.storeAsStream = storeAsStream;
//# sourceMappingURL=asStream.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\index.js", {"./ComposedStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ComposedStore.js","./LocalStorageStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\LocalStorageStore.js","./MergedStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\MergedStore.js","./ObservableStore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\ObservableStore.js","./asStream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\asStream.js","./transform":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\transform.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./asStream"), exports);
__exportStar(require("./ComposedStore"), exports);
__exportStar(require("./LocalStorageStore"), exports);
__exportStar(require("./MergedStore"), exports);
__exportStar(require("./ObservableStore"), exports);
__exportStar(require("./transform"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\dist\\transform.js", {"through2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\node_modules\\through2\\through2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\dist\transform.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.storeTransformStream = void 0;
const through2_1 = require("through2");
function storeTransformStream(syncTransformFn) {
    return through2_1.obj((state, _encoding, cb) => {
        try {
            const newState = syncTransformFn(state);
            cb(null, newState);
            return undefined;
        }
        catch (err) {
            cb(err);
            return undefined;
        }
    });
}
exports.storeTransformStream = storeTransformStream;
//# sourceMappingURL=transform.js.map
      };
    };
  }
}, {package:"@metamask/obs-store",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\obs-store\\node_modules\\through2\\through2.js", {"_process":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js","readable-stream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\readable-stream\\readable-browser.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\obs-store\node_modules\through2\through2.js
      return function (require, module, exports) {
(function (process){(function (){
var Transform = require('readable-stream').Transform
  , inherits  = require('util').inherits
  , xtend     = require('xtend')

function DestroyableTransform(opts) {
  Transform.call(this, opts)
  this._destroyed = false
}

inherits(DestroyableTransform, Transform)

DestroyableTransform.prototype.destroy = function(err) {
  if (this._destroyed) return
  this._destroyed = true
  
  var self = this
  process.nextTick(function() {
    if (err)
      self.emit('error', err)
    self.emit('close')
  })
}

// a noop _transform function
function noop (chunk, enc, callback) {
  callback(null, chunk)
}


// create a new export function, used by both the main export and
// the .ctor export, contains common logic for dealing with arguments
function through2 (construct) {
  return function (options, transform, flush) {
    if (typeof options == 'function') {
      flush     = transform
      transform = options
      options   = {}
    }

    if (typeof transform != 'function')
      transform = noop

    if (typeof flush != 'function')
      flush = null

    return construct(options, transform, flush)
  }
}


// main export, just make me a transform stream!
module.exports = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(options)

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})


// make me a reusable prototype that I can `new`, or implicitly `new`
// with a constructor call
module.exports.ctor = through2(function (options, transform, flush) {
  function Through2 (override) {
    if (!(this instanceof Through2))
      return new Through2(override)

    this.options = xtend(options, override)

    DestroyableTransform.call(this, this.options)
  }

  inherits(Through2, DestroyableTransform)

  Through2.prototype._transform = transform

  if (flush)
    Through2.prototype._flush = flush

  return Through2
})


module.exports.obj = through2(function (options, transform, flush) {
  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

  t2._transform = transform

  if (flush)
    t2._flush = flush

  return t2
})

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"@metamask/obs-store>through2",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\rpc-methods\\dist\\utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\rpc-methods\dist\utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isEqual = exports.selectHooks = void 0;
/**
 * Returns the subset of the specified `hooks` that are included in the
 * `hookNames` object. This is a Principle of Least Authority (POLA) measure
 * to ensure that each RPC method implementation only has access to the
 * API "hooks" it needs to do its job.
 *
 * @param hooks - The hooks to select from.
 * @param hookNames - The names of the hooks to select.
 * @returns The selected hooks.
 * @template Hooks - The hooks to select from.
 * @template HookName - The names of the hooks to select.
 */
function selectHooks(hooks, hookNames) {
    if (hookNames) {
        return Object.keys(hookNames).reduce((hookSubset, _hookName) => {
            const hookName = _hookName;
            hookSubset[hookName] = hooks[hookName];
            return hookSubset;
        }, {});
    }
    return undefined;
}
exports.selectHooks = selectHooks;
/**
 * Checks if array `a` is equal to array `b`. Note that this does not do a deep
 * equality check. It only checks if the arrays are the same length and if each
 * element in `a` is equal to (`===`) the corresponding element in `b`.
 *
 * @param a - The first array to compare.
 * @param b - The second array to compare.
 * @returns `true` if the arrays are equal, `false` otherwise.
 */
function isEqual(a, b) {
    return a.length === b.length && a.every((value, index) => value === b[index]);
}
exports.isEqual = isEqual;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/rpc-methods",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\SmartTransactionsController.js", {"./constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js","./types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js","./utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\utils.js","@ethersproject/bignumber":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethersproject\\bignumber\\lib\\index.js","@ethersproject/bytes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethersproject\\bytes\\lib\\index.js","@ethersproject/providers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethersproject\\providers\\lib\\index.js","@metamask/controllers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\index.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\bignumber.js\\bignumber.js","lodash/cloneDeep":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\cloneDeep.js","lodash/mapValues":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\mapValues.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\dist\SmartTransactionsController.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_INTERVAL = void 0;
const controllers_1 = require("@metamask/controllers");
const bignumber_js_1 = require("bignumber.js");
const bignumber_1 = require("@ethersproject/bignumber");
const providers_1 = require("@ethersproject/providers");
const bytes_1 = require("@ethersproject/bytes");
const mapValues_1 = __importDefault(require("lodash/mapValues"));
const cloneDeep_1 = __importDefault(require("lodash/cloneDeep"));
const types_1 = require("./types");
const utils_1 = require("./utils");
const constants_1 = require("./constants");
const { safelyExecute } = controllers_1.util;
const SECOND = 1000;
exports.DEFAULT_INTERVAL = SECOND * 5;
class SmartTransactionsController extends controllers_1.BaseController {
    constructor({ onNetworkStateChange, getNonceLock, getNetwork, provider, confirmExternalTransaction, trackMetaMetricsEvent, }, config, state) {
        super(config, state);
        this.defaultConfig = {
            interval: exports.DEFAULT_INTERVAL,
            chainId: constants_1.CHAIN_IDS.ETHEREUM,
            clientId: 'default',
            supportedChainIds: [constants_1.CHAIN_IDS.ETHEREUM, constants_1.CHAIN_IDS.RINKEBY],
        };
        this.defaultState = {
            smartTransactionsState: {
                smartTransactions: {},
                userOptIn: undefined,
                fees: {
                    approvalTxFees: undefined,
                    tradeTxFees: undefined,
                },
                liveness: true,
            },
        };
        this.getNonceLock = getNonceLock;
        this.getNetwork = getNetwork;
        this.ethersProvider = new providers_1.Web3Provider(provider);
        this.confirmExternalTransaction = confirmExternalTransaction;
        this.trackMetaMetricsEvent = trackMetaMetricsEvent;
        this.initialize();
        this.initializeSmartTransactionsForChainId();
        onNetworkStateChange(({ provider: newProvider }) => {
            const { chainId } = newProvider;
            this.configure({ chainId });
            this.initializeSmartTransactionsForChainId();
            this.checkPoll(this.state);
            this.ethersProvider = new providers_1.Web3Provider(provider);
        });
        this.subscribe((currentState) => this.checkPoll(currentState));
    }
    /* istanbul ignore next */
    async fetch(request, options) {
        const { clientId } = this.config;
        const fetchOptions = Object.assign(Object.assign({}, options), { headers: Object.assign({ 'Content-Type': 'application/json' }, (clientId && { 'X-Client-Id': clientId })) });
        return utils_1.handleFetch(request, fetchOptions);
    }
    checkPoll(state) {
        const { smartTransactions } = state.smartTransactionsState;
        const currentSmartTransactions = smartTransactions[this.config.chainId];
        const pendingTransactions = currentSmartTransactions === null || currentSmartTransactions === void 0 ? void 0 : currentSmartTransactions.filter(utils_1.isSmartTransactionPending);
        if (!this.timeoutHandle && (pendingTransactions === null || pendingTransactions === void 0 ? void 0 : pendingTransactions.length) > 0) {
            this.poll();
        }
        else if (this.timeoutHandle && (pendingTransactions === null || pendingTransactions === void 0 ? void 0 : pendingTransactions.length) === 0) {
            this.stop();
        }
    }
    initializeSmartTransactionsForChainId() {
        var _a;
        if (this.config.supportedChainIds.includes(this.config.chainId)) {
            const { smartTransactionsState } = this.state;
            this.update({
                smartTransactionsState: Object.assign(Object.assign({}, smartTransactionsState), { smartTransactions: Object.assign(Object.assign({}, smartTransactionsState.smartTransactions), { [this.config.chainId]: (_a = smartTransactionsState.smartTransactions[this.config.chainId]) !== null && _a !== void 0 ? _a : [] }) }),
            });
        }
    }
    async poll(interval) {
        const { chainId, supportedChainIds } = this.config;
        interval && this.configure({ interval }, false, false);
        this.timeoutHandle && clearInterval(this.timeoutHandle);
        if (!supportedChainIds.includes(chainId)) {
            return;
        }
        await safelyExecute(() => this.updateSmartTransactions());
        this.timeoutHandle = setInterval(() => {
            safelyExecute(() => this.updateSmartTransactions());
        }, this.config.interval);
    }
    async stop() {
        this.timeoutHandle && clearInterval(this.timeoutHandle);
        this.timeoutHandle = undefined;
    }
    setOptInState(state) {
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { userOptIn: state }),
        });
    }
    trackStxStatusChange(smartTransaction, prevSmartTransaction) {
        if (!prevSmartTransaction) {
            return; // Don't track the first STX, because it doesn't have all necessary params.
        }
        let updatedSmartTransaction = cloneDeep_1.default(smartTransaction);
        updatedSmartTransaction = Object.assign(Object.assign({}, cloneDeep_1.default(prevSmartTransaction)), updatedSmartTransaction);
        if (!updatedSmartTransaction.swapMetaData ||
            (updatedSmartTransaction.status === prevSmartTransaction.status &&
                prevSmartTransaction.swapMetaData)) {
            return; // If status hasn't changed, don't track it again.
        }
        const sensitiveProperties = {
            stx_status: updatedSmartTransaction.status,
            token_from_symbol: updatedSmartTransaction.sourceTokenSymbol,
            token_to_symbol: updatedSmartTransaction.destinationTokenSymbol,
            processing_time: utils_1.getStxProcessingTime(updatedSmartTransaction.time),
            stx_enabled: true,
            current_stx_enabled: true,
            stx_user_opt_in: true,
        };
        this.trackMetaMetricsEvent({
            event: 'STX Status Updated',
            category: 'swaps',
            sensitiveProperties,
        });
    }
    isNewSmartTransaction(smartTransactionUuid) {
        const { chainId } = this.config;
        const { smartTransactionsState } = this.state;
        const { smartTransactions } = smartTransactionsState;
        const currentSmartTransactions = smartTransactions[chainId];
        const currentIndex = currentSmartTransactions === null || currentSmartTransactions === void 0 ? void 0 : currentSmartTransactions.findIndex((stx) => stx.uuid === smartTransactionUuid);
        return currentIndex === -1 || currentIndex === undefined;
    }
    updateSmartTransaction(smartTransaction) {
        const { chainId } = this.config;
        const { smartTransactionsState } = this.state;
        const { smartTransactions } = smartTransactionsState;
        const currentSmartTransactions = smartTransactions[chainId];
        const currentIndex = currentSmartTransactions === null || currentSmartTransactions === void 0 ? void 0 : currentSmartTransactions.findIndex((stx) => stx.uuid === smartTransaction.uuid);
        const isNewSmartTransaction = this.isNewSmartTransaction(smartTransaction.uuid);
        this.trackStxStatusChange(smartTransaction, isNewSmartTransaction
            ? undefined
            : currentSmartTransactions[currentIndex]);
        if (isNewSmartTransaction) {
            // add smart transaction
            const cancelledNonceIndex = currentSmartTransactions.findIndex((stx) => {
                var _a, _b, _c;
                return ((_a = stx.txParams) === null || _a === void 0 ? void 0 : _a.nonce) === ((_b = smartTransaction.txParams) === null || _b === void 0 ? void 0 : _b.nonce) &&
                    ((_c = stx.status) === null || _c === void 0 ? void 0 : _c.startsWith('cancelled'));
            });
            const snapshot = cloneDeep_1.default(smartTransaction);
            const history = [snapshot];
            const historifiedSmartTransaction = Object.assign(Object.assign({}, smartTransaction), { history });
            const nextSmartTransactions = cancelledNonceIndex > -1
                ? currentSmartTransactions
                    .slice(0, cancelledNonceIndex)
                    .concat(currentSmartTransactions.slice(cancelledNonceIndex + 1))
                    .concat(historifiedSmartTransaction)
                : currentSmartTransactions.concat(historifiedSmartTransaction);
            this.update({
                smartTransactionsState: Object.assign(Object.assign({}, smartTransactionsState), { smartTransactions: Object.assign(Object.assign({}, smartTransactionsState.smartTransactions), { [chainId]: nextSmartTransactions }) }),
            });
            return;
        }
        if ((smartTransaction.status === types_1.SmartTransactionStatuses.SUCCESS ||
            smartTransaction.status === types_1.SmartTransactionStatuses.REVERTED) &&
            !smartTransaction.confirmed) {
            // confirm smart transaction
            const currentSmartTransaction = currentSmartTransactions[currentIndex];
            const nextSmartTransaction = Object.assign(Object.assign({}, currentSmartTransaction), smartTransaction);
            this.confirmSmartTransaction(nextSmartTransaction);
        }
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, smartTransactionsState), { smartTransactions: Object.assign(Object.assign({}, smartTransactionsState.smartTransactions), { [chainId]: smartTransactionsState.smartTransactions[chainId].map((item, index) => {
                        return index === currentIndex
                            ? Object.assign(Object.assign({}, item), smartTransaction) : item;
                    }) }) }),
        });
    }
    async updateSmartTransactions() {
        const { smartTransactions } = this.state.smartTransactionsState;
        const { chainId } = this.config;
        const currentSmartTransactions = smartTransactions === null || smartTransactions === void 0 ? void 0 : smartTransactions[chainId];
        const transactionsToUpdate = currentSmartTransactions
            .filter(utils_1.isSmartTransactionPending)
            .map((smartTransaction) => smartTransaction.uuid);
        if (transactionsToUpdate.length > 0) {
            this.fetchSmartTransactionsStatus(transactionsToUpdate);
        }
    }
    async confirmSmartTransaction(smartTransaction) {
        var _a, _b, _c;
        const txHash = (_a = smartTransaction.statusMetadata) === null || _a === void 0 ? void 0 : _a.minedHash;
        try {
            const transactionReceipt = await this.ethersProvider.getTransactionReceipt(txHash);
            const transaction = await this.ethersProvider.getTransaction(txHash);
            const maxFeePerGas = (_b = transaction.maxFeePerGas) === null || _b === void 0 ? void 0 : _b.toHexString();
            const maxPriorityFeePerGas = (_c = transaction.maxPriorityFeePerGas) === null || _c === void 0 ? void 0 : _c.toHexString();
            if (transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockNumber) {
                const blockData = await this.ethersProvider.getBlock(transactionReceipt === null || transactionReceipt === void 0 ? void 0 : transactionReceipt.blockNumber, false);
                const baseFeePerGas = blockData === null || blockData === void 0 ? void 0 : blockData.baseFeePerGas.toHexString();
                const txReceipt = mapValues_1.default(transactionReceipt, (value) => {
                    if (value instanceof bignumber_1.BigNumber) {
                        return value.toHexString();
                    }
                    return value;
                });
                const updatedTxParams = Object.assign(Object.assign({}, smartTransaction.txParams), { maxFeePerGas,
                    maxPriorityFeePerGas });
                // call confirmExternalTransaction
                const originalTxMeta = Object.assign(Object.assign({}, smartTransaction), { id: smartTransaction.uuid, status: 'confirmed', hash: txHash, txParams: updatedTxParams });
                // create txMeta snapshot for history
                const snapshot = utils_1.snapshotFromTxMeta(originalTxMeta);
                // recover previous tx state obj
                const previousState = utils_1.replayHistory(originalTxMeta.history);
                // generate history entry and add to history
                const entry = utils_1.generateHistoryEntry(previousState, snapshot, 'txStateManager: setting status to confirmed');
                const txMeta = entry.length > 0
                    ? Object.assign(Object.assign({}, originalTxMeta), { history: originalTxMeta.history.concat(entry) }) : originalTxMeta;
                this.confirmExternalTransaction(txMeta, txReceipt, baseFeePerGas);
                this.trackMetaMetricsEvent({
                    event: 'STX Confirmed',
                    category: 'swaps',
                });
                this.updateSmartTransaction(Object.assign(Object.assign({}, smartTransaction), { confirmed: true }));
            }
        }
        catch (e) {
            this.trackMetaMetricsEvent({
                event: 'STX Confirmation Failed',
                category: 'swaps',
            });
            console.error('confirm error', e);
        }
    }
    // ! Ask backend API to accept list of uuids as params
    async fetchSmartTransactionsStatus(uuids) {
        const { chainId } = this.config;
        const params = new URLSearchParams({
            uuids: uuids.join(','),
        });
        const url = `${utils_1.getAPIRequestURL(types_1.APIType.BATCH_STATUS, chainId)}?${params.toString()}`;
        const data = await this.fetch(url);
        Object.entries(data).forEach(([uuid, stxStatus]) => {
            this.updateSmartTransaction({
                statusMetadata: stxStatus,
                status: utils_1.calculateStatus(stxStatus),
                cancellable: utils_1.isSmartTransactionCancellable(stxStatus),
                uuid,
            });
        });
        return data;
    }
    async addNonceToTransaction(transaction) {
        const nonceLock = await this.getNonceLock(transaction.from);
        const nonce = nonceLock.nextNonce;
        nonceLock.releaseLock();
        return Object.assign(Object.assign({}, transaction), { nonce: `0x${nonce.toString(16)}` });
    }
    clearFees() {
        const fees = {
            approvalTxFees: undefined,
            tradeTxFees: undefined,
        };
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { fees }),
        });
        return fees;
    }
    async getFees(tradeTx, approvalTx) {
        const { chainId } = this.config;
        const transactions = [];
        let unsignedTradeTransactionWithNonce;
        if (approvalTx) {
            const unsignedApprovalTransactionWithNonce = await this.addNonceToTransaction(approvalTx);
            transactions.push(unsignedApprovalTransactionWithNonce);
            unsignedTradeTransactionWithNonce = Object.assign(Object.assign({}, tradeTx), { 
                // If there is an approval tx, the trade tx's nonce is increased by 1.
                nonce: utils_1.incrementNonceInHex(unsignedApprovalTransactionWithNonce.nonce) });
        }
        else {
            unsignedTradeTransactionWithNonce = await this.addNonceToTransaction(tradeTx);
        }
        transactions.push(unsignedTradeTransactionWithNonce);
        const data = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.GET_FEES, chainId), {
            method: 'POST',
            body: JSON.stringify({
                txs: transactions,
            }),
        });
        let approvalTxFees;
        let tradeTxFees;
        if (approvalTx) {
            approvalTxFees = data === null || data === void 0 ? void 0 : data.txs[0];
            tradeTxFees = data === null || data === void 0 ? void 0 : data.txs[1];
        }
        else {
            tradeTxFees = data === null || data === void 0 ? void 0 : data.txs[0];
        }
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { fees: {
                    approvalTxFees,
                    tradeTxFees,
                } }),
        });
        return {
            approvalTxFees,
            tradeTxFees,
        };
    }
    // * After this successful call client must add a nonce representative to
    // * transaction controller external transactions list
    async submitSignedTransactions({ txParams, signedTransactions, signedCanceledTransactions, }) {
        const { chainId } = this.config;
        const data = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.SUBMIT_TRANSACTIONS, chainId), {
            method: 'POST',
            body: JSON.stringify({
                rawTxs: signedTransactions,
                rawCancelTxs: signedCanceledTransactions,
            }),
        });
        const time = Date.now();
        const metamaskNetworkId = this.getNetwork();
        let preTxBalance;
        try {
            const preTxBalanceBN = await this.ethersProvider.getBalance(txParams === null || txParams === void 0 ? void 0 : txParams.from);
            preTxBalance = new bignumber_js_1.BigNumber(preTxBalanceBN.toHexString()).toString(16);
        }
        catch (e) {
            console.error('ethers error', e);
        }
        const nonceLock = await this.getNonceLock(txParams === null || txParams === void 0 ? void 0 : txParams.from);
        const nonce = bytes_1.hexlify(nonceLock.nextNonce);
        if (txParams && !(txParams === null || txParams === void 0 ? void 0 : txParams.nonce)) {
            txParams.nonce = nonce;
        }
        const { nonceDetails } = nonceLock;
        this.updateSmartTransaction({
            chainId,
            nonceDetails,
            metamaskNetworkId,
            preTxBalance,
            status: types_1.SmartTransactionStatuses.PENDING,
            time,
            txParams,
            uuid: data.uuid,
            cancellable: true,
        });
        nonceLock.releaseLock();
        return data;
    }
    // TODO: This should return if the cancellation was on chain or not (for nonce management)
    // After this successful call client must update nonce representative
    // in transaction controller external transactions list
    async cancelSmartTransaction(uuid) {
        const { chainId } = this.config;
        await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.CANCEL, chainId), {
            method: 'POST',
            body: JSON.stringify({ uuid }),
        });
    }
    async fetchLiveness() {
        const { chainId } = this.config;
        let liveness = false;
        try {
            const response = await this.fetch(utils_1.getAPIRequestURL(types_1.APIType.LIVENESS, chainId));
            liveness = Boolean(response.lastBlock);
        }
        catch (e) {
            console.log('"fetchLiveness" API call failed');
        }
        this.update({
            smartTransactionsState: Object.assign(Object.assign({}, this.state.smartTransactionsState), { liveness }),
        });
        return liveness;
    }
    async setStatusRefreshInterval(interval) {
        if (interval !== this.config.interval) {
            this.configure({ interval }, false, false);
        }
    }
    getTransactions({ addressFrom, status, }) {
        const { smartTransactions } = this.state.smartTransactionsState;
        const { chainId } = this.config;
        const currentSmartTransactions = smartTransactions === null || smartTransactions === void 0 ? void 0 : smartTransactions[chainId];
        if (!currentSmartTransactions || currentSmartTransactions.length === 0) {
            return [];
        }
        return currentSmartTransactions.filter((stx) => {
            var _a;
            return stx.status === status && ((_a = stx.txParams) === null || _a === void 0 ? void 0 : _a.from) === addressFrom;
        });
    }
}
exports.default = SmartTransactionsController;
//# sourceMappingURL=SmartTransactionsController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\dist\constants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CHAIN_IDS = exports.API_BASE_URL = void 0;
exports.API_BASE_URL = 'https://transaction.metaswap.codefi.network';
exports.CHAIN_IDS = {
    ETHEREUM: '0x1',
    RINKEBY: '0x4',
    BSC: '0x38',
};
//# sourceMappingURL=constants.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\index.js", {"./SmartTransactionsController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\SmartTransactionsController.js","isomorphic-fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\isomorphic-fetch\\fetch-npm-browserify.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\dist\index.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// eslint-disable-next-line import/no-unassigned-import
require("isomorphic-fetch");
const SmartTransactionsController_1 = __importDefault(require("./SmartTransactionsController"));
exports.default = SmartTransactionsController_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\dist\types.js
      return function (require, module, exports) {
"use strict";
/** API */
Object.defineProperty(exports, "__esModule", { value: true });
exports.cancellationReasonToStatusMap = exports.SmartTransactionStatuses = exports.SmartTransactionCancellationReason = exports.SmartTransactionMinedTx = exports.APIType = void 0;
var APIType;
(function (APIType) {
    APIType[APIType["GET_FEES"] = 0] = "GET_FEES";
    APIType[APIType["ESTIMATE_GAS"] = 1] = "ESTIMATE_GAS";
    APIType[APIType["SUBMIT_TRANSACTIONS"] = 2] = "SUBMIT_TRANSACTIONS";
    APIType[APIType["CANCEL"] = 3] = "CANCEL";
    APIType[APIType["BATCH_STATUS"] = 4] = "BATCH_STATUS";
    APIType[APIType["LIVENESS"] = 5] = "LIVENESS";
})(APIType = exports.APIType || (exports.APIType = {}));
/** SmartTransactions */
var SmartTransactionMinedTx;
(function (SmartTransactionMinedTx) {
    SmartTransactionMinedTx["NOT_MINED"] = "not_mined";
    SmartTransactionMinedTx["SUCCESS"] = "success";
    SmartTransactionMinedTx["CANCELLED"] = "cancelled";
    SmartTransactionMinedTx["REVERTED"] = "reverted";
    SmartTransactionMinedTx["UNKNOWN"] = "unknown";
})(SmartTransactionMinedTx = exports.SmartTransactionMinedTx || (exports.SmartTransactionMinedTx = {}));
var SmartTransactionCancellationReason;
(function (SmartTransactionCancellationReason) {
    SmartTransactionCancellationReason["WOULD_REVERT"] = "would_revert";
    SmartTransactionCancellationReason["TOO_CHEAP"] = "too_cheap";
    SmartTransactionCancellationReason["DEADLINE_MISSED"] = "deadline_missed";
    SmartTransactionCancellationReason["INVALID_NONCE"] = "invalid_nonce";
    SmartTransactionCancellationReason["USER_CANCELLED"] = "user_cancelled";
    SmartTransactionCancellationReason["NOT_CANCELLED"] = "not_cancelled";
    SmartTransactionCancellationReason["PREVIOUS_TX_CANCELLED"] = "previous_tx_cancelled";
})(SmartTransactionCancellationReason = exports.SmartTransactionCancellationReason || (exports.SmartTransactionCancellationReason = {}));
var SmartTransactionStatuses;
(function (SmartTransactionStatuses) {
    SmartTransactionStatuses["PENDING"] = "pending";
    SmartTransactionStatuses["SUCCESS"] = "success";
    SmartTransactionStatuses["REVERTED"] = "reverted";
    SmartTransactionStatuses["UNKNOWN"] = "unknown";
    SmartTransactionStatuses["CANCELLED"] = "cancelled";
    SmartTransactionStatuses["CANCELLED_WOULD_REVERT"] = "cancelled_would_revert";
    SmartTransactionStatuses["CANCELLED_TOO_CHEAP"] = "cancelled_too_cheap";
    SmartTransactionStatuses["CANCELLED_DEADLINE_MISSED"] = "cancelled_deadline_missed";
    SmartTransactionStatuses["CANCELLED_INVALID_NONCE"] = "cancelled_invalid_nonce";
    SmartTransactionStatuses["CANCELLED_USER_CANCELLED"] = "cancelled_user_cancelled";
    SmartTransactionStatuses["CANCELLED_PREVIOUS_TX_CANCELLED"] = "cancelled_previous_tx_cancelled";
    SmartTransactionStatuses["RESOLVED"] = "resolved";
})(SmartTransactionStatuses = exports.SmartTransactionStatuses || (exports.SmartTransactionStatuses = {}));
exports.cancellationReasonToStatusMap = {
    [SmartTransactionCancellationReason.WOULD_REVERT]: SmartTransactionStatuses.CANCELLED_WOULD_REVERT,
    [SmartTransactionCancellationReason.TOO_CHEAP]: SmartTransactionStatuses.CANCELLED_TOO_CHEAP,
    [SmartTransactionCancellationReason.DEADLINE_MISSED]: SmartTransactionStatuses.CANCELLED_DEADLINE_MISSED,
    [SmartTransactionCancellationReason.INVALID_NONCE]: SmartTransactionStatuses.CANCELLED_INVALID_NONCE,
    [SmartTransactionCancellationReason.USER_CANCELLED]: SmartTransactionStatuses.CANCELLED_USER_CANCELLED,
    [SmartTransactionCancellationReason.PREVIOUS_TX_CANCELLED]: SmartTransactionStatuses.CANCELLED_PREVIOUS_TX_CANCELLED,
};
//# sourceMappingURL=types.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\utils.js", {"./constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\constants.js","./types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\dist\\types.js","@ethersproject/bytes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethersproject\\bytes\\lib\\index.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\bignumber.js\\bignumber.js","fast-json-patch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\fast-json-patch\\index.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\dist\utils.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.incrementNonceInHex = exports.isSmartTransactionCancellable = exports.handleFetch = exports.mapKeysToCamel = exports.getStxProcessingTime = exports.snapshotFromTxMeta = exports.replayHistory = exports.generateHistoryEntry = exports.calculateStatus = exports.getAPIRequestURL = exports.isSmartTransactionStatusResolved = exports.isSmartTransactionPending = void 0;
const fast_json_patch_1 = __importDefault(require("fast-json-patch"));
const lodash_1 = __importDefault(require("lodash"));
const bignumber_js_1 = require("bignumber.js");
const bytes_1 = require("@ethersproject/bytes");
const types_1 = require("./types");
const constants_1 = require("./constants");
function isSmartTransactionPending(smartTransaction) {
    return smartTransaction.status === types_1.SmartTransactionStatuses.PENDING;
}
exports.isSmartTransactionPending = isSmartTransactionPending;
const isSmartTransactionStatusResolved = (stxStatus) => stxStatus === 'uuid_not_found';
exports.isSmartTransactionStatusResolved = isSmartTransactionStatusResolved;
// TODO use actual url once API is defined
function getAPIRequestURL(apiType, chainId) {
    const chainIdDec = parseInt(chainId, 16);
    switch (apiType) {
        case types_1.APIType.GET_FEES: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/getFees`;
        }
        case types_1.APIType.ESTIMATE_GAS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/estimateGas`;
        }
        case types_1.APIType.SUBMIT_TRANSACTIONS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/submitTransactions`;
        }
        case types_1.APIType.CANCEL: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/cancel`;
        }
        case types_1.APIType.BATCH_STATUS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/batchStatus`;
        }
        case types_1.APIType.LIVENESS: {
            return `${constants_1.API_BASE_URL}/networks/${chainIdDec}/health`;
        }
        default: {
            throw new Error(`Invalid APIType`); // It can never get here thanks to TypeScript.
        }
    }
}
exports.getAPIRequestURL = getAPIRequestURL;
const calculateStatus = (stxStatus) => {
    if (exports.isSmartTransactionStatusResolved(stxStatus)) {
        return types_1.SmartTransactionStatuses.RESOLVED;
    }
    const cancellations = [
        types_1.SmartTransactionCancellationReason.WOULD_REVERT,
        types_1.SmartTransactionCancellationReason.TOO_CHEAP,
        types_1.SmartTransactionCancellationReason.DEADLINE_MISSED,
        types_1.SmartTransactionCancellationReason.INVALID_NONCE,
        types_1.SmartTransactionCancellationReason.USER_CANCELLED,
        types_1.SmartTransactionCancellationReason.PREVIOUS_TX_CANCELLED,
    ];
    if ((stxStatus === null || stxStatus === void 0 ? void 0 : stxStatus.minedTx) === types_1.SmartTransactionMinedTx.NOT_MINED) {
        if (stxStatus.cancellationReason ===
            types_1.SmartTransactionCancellationReason.NOT_CANCELLED) {
            return types_1.SmartTransactionStatuses.PENDING;
        }
        const isCancellation = cancellations.findIndex((cancellation) => cancellation === stxStatus.cancellationReason) > -1;
        if (stxStatus.cancellationReason && isCancellation) {
            if (!stxStatus.isSettled) {
                return types_1.SmartTransactionStatuses.PENDING;
            }
            return types_1.cancellationReasonToStatusMap[stxStatus.cancellationReason];
        }
    }
    else if ((stxStatus === null || stxStatus === void 0 ? void 0 : stxStatus.minedTx) === types_1.SmartTransactionMinedTx.SUCCESS) {
        return types_1.SmartTransactionStatuses.SUCCESS;
    }
    else if ((stxStatus === null || stxStatus === void 0 ? void 0 : stxStatus.minedTx) === types_1.SmartTransactionMinedTx.CANCELLED) {
        return types_1.SmartTransactionStatuses.CANCELLED;
    }
    else if ((stxStatus === null || stxStatus === void 0 ? void 0 : stxStatus.minedTx) === types_1.SmartTransactionMinedTx.REVERTED) {
        return types_1.SmartTransactionStatuses.REVERTED;
    }
    else if ((stxStatus === null || stxStatus === void 0 ? void 0 : stxStatus.minedTx) === types_1.SmartTransactionMinedTx.UNKNOWN) {
        return types_1.SmartTransactionStatuses.UNKNOWN;
    }
    return types_1.SmartTransactionStatuses.UNKNOWN;
};
exports.calculateStatus = calculateStatus;
/**
  Generates an array of history objects sense the previous state.
  The object has the keys
    op (the operation performed),
    path (the key and if a nested object then each key will be separated with a `/`)
    value
  with the first entry having the note and a timestamp when the change took place
  @param {Object} previousState - the previous state of the object
  @param {Object} newState - the update object
  @param {string} [note] - a optional note for the state change
  @returns {Array}
*/
function generateHistoryEntry(previousState, newState, note) {
    const entry = fast_json_patch_1.default.compare(previousState, newState);
    // Add a note to the first op, since it breaks if we append it to the entry
    if (entry[0]) {
        if (note) {
            entry[0].note = note;
        }
        entry[0].timestamp = Date.now();
    }
    return entry;
}
exports.generateHistoryEntry = generateHistoryEntry;
/**
  Recovers previous txMeta state obj
  @returns {Object}
*/
function replayHistory(_shortHistory) {
    const shortHistory = lodash_1.default.cloneDeep(_shortHistory);
    return shortHistory.reduce((val, entry) => fast_json_patch_1.default.applyPatch(val, entry).newDocument);
}
exports.replayHistory = replayHistory;
/**
 * Snapshot {@code txMeta}
 * @param {Object} txMeta - the tx metadata object
 * @returns {Object} a deep clone without history
 */
function snapshotFromTxMeta(txMeta) {
    const shallow = Object.assign({}, txMeta);
    delete shallow.history;
    return lodash_1.default.cloneDeep(shallow);
}
exports.snapshotFromTxMeta = snapshotFromTxMeta;
/**
 * Returns processing time for an STX in seconds.
 * @param {number} smartTransactionSubmittedtime
 * @returns {number} Processing time in seconds.
 */
const getStxProcessingTime = (smartTransactionSubmittedtime) => {
    if (!smartTransactionSubmittedtime) {
        return undefined;
    }
    return Math.round((Date.now() - smartTransactionSubmittedtime) / 1000);
};
exports.getStxProcessingTime = getStxProcessingTime;
const mapKeysToCamel = (obj) => {
    if (!lodash_1.default.isObject(obj)) {
        return obj;
    }
    const mappedValues = lodash_1.default.mapValues(obj, (val) => {
        if (lodash_1.default.isArray(val)) {
            return val.map(exports.mapKeysToCamel);
        }
        else if (lodash_1.default.isObject(val)) {
            return exports.mapKeysToCamel(val);
        }
        return val;
    });
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    return lodash_1.default.mapKeys(mappedValues, (value, key) => lodash_1.default.camelCase(key));
};
exports.mapKeysToCamel = mapKeysToCamel;
async function handleFetch(request, options) {
    const response = await fetch(request, options);
    const json = await response.json();
    if (!response.ok) {
        console.log(`response`, response);
        throw new Error(`Fetch error:${JSON.stringify(Object.assign({ status: response.status }, exports.mapKeysToCamel(json)))}`);
    }
    return json;
}
exports.handleFetch = handleFetch;
const isSmartTransactionCancellable = (stxStatus) => {
    return (stxStatus.minedTx === types_1.SmartTransactionMinedTx.NOT_MINED &&
        (!stxStatus.cancellationReason ||
            stxStatus.cancellationReason ===
                types_1.SmartTransactionCancellationReason.NOT_CANCELLED));
};
exports.isSmartTransactionCancellable = isSmartTransactionCancellable;
const incrementNonceInHex = (nonceInHex) => {
    const nonceInDec = new bignumber_js_1.BigNumber(nonceInHex, 16).toString(10);
    return bytes_1.hexlify(Number(nonceInDec) + 1);
};
exports.incrementNonceInHex = incrementNonceInHex;
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\BaseController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseController = void 0;
/**
 * Controller class that provides configuration, state management, and subscriptions
 */
class BaseController {
    /**
     * Creates a BaseController instance. Both initial state and initial
     * configuration options are merged with defaults upon initialization.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config = {}, state = {}) {
        /**
         * Default options used to configure this controller
         */
        this.defaultConfig = {};
        /**
         * Default state set on this controller
         */
        this.defaultState = {};
        /**
         * Determines if listeners are notified of state changes
         */
        this.disabled = false;
        /**
         * Name of this controller used during composition
         */
        this.name = 'BaseController';
        this.internalConfig = this.defaultConfig;
        this.internalState = this.defaultState;
        this.internalListeners = [];
        // Use assign since generics can't be spread: https://git.io/vpRhY
        this.initialState = state;
        this.initialConfig = config;
    }
    /**
     * Enables the controller. This sets each config option as a member
     * variable on this instance and triggers any defined setters. This
     * also sets initial state and triggers any listeners.
     *
     * @returns This controller instance.
     */
    initialize() {
        this.internalState = this.defaultState;
        this.internalConfig = this.defaultConfig;
        this.configure(this.initialConfig);
        this.update(this.initialState);
        return this;
    }
    /**
     * Retrieves current controller configuration options.
     *
     * @returns The current configuration.
     */
    get config() {
        return this.internalConfig;
    }
    /**
     * Retrieves current controller state.
     *
     * @returns The current state.
     */
    get state() {
        return this.internalState;
    }
    /**
     * Updates controller configuration.
     *
     * @param config - New configuration options.
     * @param overwrite - Overwrite config instead of merging.
     * @param fullUpdate - Boolean that defines if the update is partial or not.
     */
    configure(config, overwrite = false, fullUpdate = true) {
        if (fullUpdate) {
            this.internalConfig = overwrite
                ? config
                : Object.assign(this.internalConfig, config);
            for (const key in this.internalConfig) {
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this[key] = this.internalConfig[key];
                }
            }
        }
        else {
            for (const key in config) {
                /* istanbul ignore else */
                if (typeof this.internalConfig[key] !== 'undefined') {
                    this.internalConfig[key] = config[key];
                    this[key] = config[key];
                }
            }
        }
    }
    /**
     * Notifies all subscribed listeners of current state.
     */
    notify() {
        if (this.disabled) {
            return;
        }
        this.internalListeners.forEach((listener) => {
            listener(this.internalState);
        });
    }
    /**
     * Adds new listener to be notified of state changes.
     *
     * @param listener - The callback triggered when state changes.
     */
    subscribe(listener) {
        this.internalListeners.push(listener);
    }
    /**
     * Removes existing listener from receiving state changes.
     *
     * @param listener - The callback to remove.
     * @returns `true` if a listener is found and unsubscribed.
     */
    unsubscribe(listener) {
        const index = this.internalListeners.findIndex((cb) => listener === cb);
        index > -1 && this.internalListeners.splice(index, 1);
        return index > -1;
    }
    /**
     * Updates controller state.
     *
     * @param state - The new state.
     * @param overwrite - Overwrite state instead of merging.
     */
    update(state, overwrite = false) {
        this.internalState = overwrite
            ? Object.assign({}, state)
            : Object.assign({}, this.internalState, state);
        this.notify();
    }
}
exports.BaseController = BaseController;
exports.default = BaseController;
//# sourceMappingURL=BaseController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js", {"immer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\immer\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\BaseControllerV2.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPersistentState = exports.getAnonymizedState = exports.BaseController = void 0;
const immer_1 = require("immer");
(0, immer_1.enablePatches)();
/**
 * Controller class that provides state management, subscriptions, and state metadata
 */
class BaseController {
    /**
     * Creates a BaseController instance.
     *
     * @param options - Controller options.
     * @param options.messenger - Controller messaging system.
     * @param options.metadata - State metadata, describing how to "anonymize" the state, and which
     * parts should be persisted.
     * @param options.name - The name of the controller, used as a namespace for events and actions.
     * @param options.state - Initial controller state.
     */
    constructor({ messenger, metadata, name, state, }) {
        this.messagingSystem = messenger;
        this.name = name;
        this.internalState = state;
        this.metadata = metadata;
        this.messagingSystem.registerActionHandler(`${name}:getState`, () => this.state);
    }
    /**
     * Retrieves current controller state.
     *
     * @returns The current state.
     */
    get state() {
        return this.internalState;
    }
    set state(_) {
        throw new Error(`Controller state cannot be directly mutated; use 'update' method instead.`);
    }
    /**
     * Updates controller state. Accepts a callback that is passed a draft copy
     * of the controller state. If a value is returned, it is set as the new
     * state. Otherwise, any changes made within that callback to the draft are
     * applied to the controller state.
     *
     * @param callback - Callback for updating state, passed a draft state
     * object. Return a new state object or mutate the draft to update state.
     */
    update(callback) {
        // We run into ts2589, "infinite type depth", if we don't cast
        // produceWithPatches here.
        // The final, omitted member of the returned tuple are the inverse patches.
        const [nextState, patches] = immer_1.produceWithPatches(this.internalState, callback);
        this.internalState = nextState;
        this.messagingSystem.publish(`${this.name}:stateChange`, nextState, patches);
    }
    /**
     * Prepares the controller for garbage collection. This should be extended
     * by any subclasses to clean up any additional connections or events.
     *
     * The only cleanup performed here is to remove listeners. While technically
     * this is not required to ensure this instance is garbage collected, it at
     * least ensures this instance won't be responsible for preventing the
     * listeners from being garbage collected.
     */
    destroy() {
        this.messagingSystem.clearEventSubscriptions(`${this.name}:stateChange`);
    }
}
exports.BaseController = BaseController;
/**
 * Returns an anonymized representation of the controller state.
 *
 * By "anonymized" we mean that it should not contain any information that could be personally
 * identifiable.
 *
 * @param state - The controller state.
 * @param metadata - The controller state metadata, which describes how to derive the
 * anonymized state.
 * @returns The anonymized controller state.
 */
function getAnonymizedState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'anonymous');
}
exports.getAnonymizedState = getAnonymizedState;
/**
 * Returns the subset of state that should be persisted.
 *
 * @param state - The controller state.
 * @param metadata - The controller state metadata, which describes which pieces of state should be persisted.
 * @returns The subset of controller state that should be persisted.
 */
function getPersistentState(state, metadata) {
    return deriveStateFromMetadata(state, metadata, 'persist');
}
exports.getPersistentState = getPersistentState;
/**
 * Use the metadata to derive state according to the given metadata property.
 *
 * @param state - The full controller state.
 * @param metadata - The controller metadata.
 * @param metadataProperty - The metadata property to use to derive state.
 * @returns The metadata-derived controller state.
 */
function deriveStateFromMetadata(state, metadata, metadataProperty) {
    return Object.keys(state).reduce((persistedState, key) => {
        const propertyMetadata = metadata[key][metadataProperty];
        const stateProperty = state[key];
        if (typeof propertyMetadata === 'function') {
            persistedState[key] = propertyMetadata(stateProperty);
        }
        else if (propertyMetadata) {
            persistedState[key] = stateProperty;
        }
        return persistedState;
    }, {});
}
//# sourceMappingURL=BaseControllerV2.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\ComposableController.js", {"./BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\ComposableController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComposableController = void 0;
const BaseController_1 = require("./BaseController");
/**
 * Controller that can be used to compose multiple controllers together
 */
class ComposableController extends BaseController_1.BaseController {
    /**
     * Creates a ComposableController instance.
     *
     * @param controllers - Map of names to controller instances.
     * @param messenger - The controller messaging system, used for communicating with BaseControllerV2 controllers.
     */
    constructor(controllers, messenger) {
        super(undefined, controllers.reduce((state, controller) => {
            state[controller.name] = controller.state;
            return state;
        }, {}));
        this.controllers = [];
        /**
         * Name of this controller used during composition
         */
        this.name = 'ComposableController';
        this.initialize();
        this.controllers = controllers;
        this.messagingSystem = messenger;
        this.controllers.forEach((controller) => {
            const { name } = controller;
            if (controller.subscribe !== undefined) {
                controller.subscribe((state) => {
                    this.update({ [name]: state });
                });
            }
            else if (this.messagingSystem) {
                this.messagingSystem.subscribe(`${name}:stateChange`, (state) => {
                    this.update({ [name]: state });
                });
            }
            else {
                throw new Error(`Messaging system required if any BaseControllerV2 controllers are used`);
            }
        });
    }
    /**
     * Flat state representation, one that isn't keyed
     * of controller name. Instead, all child controller state is merged
     * together into a single, flat object.
     *
     * @returns Merged state representation of all child controllers.
     */
    get flatState() {
        let flatState = {};
        for (const controller of this.controllers) {
            flatState = Object.assign(Object.assign({}, flatState), controller.state);
        }
        return flatState;
    }
}
exports.ComposableController = ComposableController;
exports.default = ComposableController;
//# sourceMappingURL=ComposableController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\ControllerMessenger.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\ControllerMessenger.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ControllerMessenger = exports.RestrictedControllerMessenger = void 0;
/**
 * A restricted controller messenger.
 *
 * This acts as a wrapper around the controller messenger instance that restricts access to actions
 * and events.
 *
 * @template N - The namespace for this messenger. Typically this is the name of the controller or
 * module that this messenger has been created for. The authority to publish events and register
 * actions under this namespace is granted to this restricted messenger instance.
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 * @template AllowedAction - A type union of the 'type' string for any allowed actions.
 * @template AllowedEvent - A type union of the 'type' string for any allowed events.
 */
class RestrictedControllerMessenger {
    /**
     * Constructs a restricted controller messenger
     *
     * The provided allowlists grant the ability to call the listed actions and subscribe to the
     * listed events. The "name" provided grants ownership of any actions and events under that
     * namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options - The controller options.
     * @param options.controllerMessenger - The controller messenger instance that is being wrapped.
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     * controller name). This grants "ownership" of actions and events under this namespace to the
     * restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     * should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     * should be allowed to subscribe to.
     */
    constructor({ controllerMessenger, name, allowedActions, allowedEvents, }) {
        this.controllerMessenger = controllerMessenger;
        this.controllerName = name;
        this.allowedActions = allowedActions || null;
        this.allowedEvents = allowedEvents || null;
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * The action type this handler is registered under *must* be in the current namespace.
     *
     * @param action - The action type. This is a unqiue identifier for this action.
     * @param handler - The action handler. This function gets called when the `call` method is
     * invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    registerActionHandler(action, handler) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed registering action handlers prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.registerActionHandler(action, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * The action type being unregistered *must* be in the current namespace.
     *
     * @param action - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings that are namespaced by N.
     */
    unregisterActionHandler(action) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!action.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed unregistering action handlers prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.unregisterActionHandler(action);
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * The action type being called must be on the action allowlist.
     *
     * @param action - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     * registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of allowed Action type strings.
     * @returns The action return value.
     */
    call(action, ...params) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedActions === null) {
            throw new Error('No actions allowed');
        }
        else if (!this.allowedActions.includes(action)) {
            throw new Error(`Action missing from allow list: ${action}`);
        }
        return this.controllerMessenger.call(action, ...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * The event type being published *must* be in the current namespace.
     *
     * @param event - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     * match the type of this payload.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    publish(event, ...payload) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed publishing events prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.publish(event, ...payload);
    }
    subscribe(event, handler, selector) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        if (selector) {
            return this.controllerMessenger.subscribe(event, handler, selector);
        }
        return this.controllerMessenger.subscribe(event, handler);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * The event type being unsubscribed to must be on the event allowlist.
     *
     * @param event - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template T - A type union of allowed Event type strings.
     */
    unsubscribe(event, handler) {
        /* istanbul ignore next */ // Branches unreachable with valid types
        if (this.allowedEvents === null) {
            throw new Error('No events allowed');
        }
        else if (!this.allowedEvents.includes(event)) {
            throw new Error(`Event missing from allow list: ${event}`);
        }
        this.controllerMessenger.unsubscribe(event, handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * The event type being cleared *must* be in the current namespace.
     *
     * @param event - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings that are namespaced by N.
     */
    clearEventSubscriptions(event) {
        /* istanbul ignore if */ // Branch unreachable with valid types
        if (!event.startsWith(`${this.controllerName}:`)) {
            throw new Error(`Only allowed clearing events prefixed by '${this.controllerName}:'`);
        }
        this.controllerMessenger.clearEventSubscriptions(event);
    }
}
exports.RestrictedControllerMessenger = RestrictedControllerMessenger;
/**
 * A messaging system for controllers.
 *
 * The controller messenger allows registering functions as 'actions' that can be called elsewhere,
 * and it allows publishing and subscribing to events. Both actions and events are identified by
 * unique strings.
 *
 * @template Action - A type union of all Action types.
 * @template Event - A type union of all Event types.
 */
class ControllerMessenger {
    constructor() {
        this.actions = new Map();
        this.events = new Map();
        /**
         * A cache of selector return values for their respective handlers.
         */
        this.eventPayloadCache = new Map();
    }
    /**
     * Register an action handler.
     *
     * This will make the registered function available to call via the `call` method.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param handler - The action handler. This function gets called when the `call` method is
     * invoked with the given action type.
     * @throws Will throw when a handler has been registered for this action type already.
     * @template T - A type union of Action type strings.
     */
    registerActionHandler(actionType, handler) {
        if (this.actions.has(actionType)) {
            throw new Error(`A handler for ${actionType} has already been registered`);
        }
        this.actions.set(actionType, handler);
    }
    /**
     * Unregister an action handler.
     *
     * This will prevent this action from being called.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @template T - A type union of Action type strings.
     */
    unregisterActionHandler(actionType) {
        this.actions.delete(actionType);
    }
    /**
     * Unregister all action handlers.
     *
     * This prevents all actions from being called.
     */
    clearActions() {
        this.actions.clear();
    }
    /**
     * Call an action.
     *
     * This function will call the action handler corresponding to the given action type, passing
     * along any parameters given.
     *
     * @param actionType - The action type. This is a unqiue identifier for this action.
     * @param params - The action parameters. These must match the type of the parameters of the
     * registered action handler.
     * @throws Will throw when no handler has been registered for the given type.
     * @template T - A type union of Action type strings.
     * @returns The action return value.
     */
    call(actionType, ...params) {
        const handler = this.actions.get(actionType);
        if (!handler) {
            throw new Error(`A handler for ${actionType} has not been registered`);
        }
        return handler(...params);
    }
    /**
     * Publish an event.
     *
     * Publishes the given payload to all subscribers of the given event type.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param payload - The event payload. The type of the parameters for each event handler must
     * match the type of this payload.
     * @template E - A type union of Event type strings.
     */
    publish(eventType, ...payload) {
        const subscribers = this.events.get(eventType);
        if (subscribers) {
            for (const [handler, selector] of subscribers.entries()) {
                if (selector) {
                    const previousValue = this.eventPayloadCache.get(handler);
                    const newValue = selector(...payload);
                    if (newValue !== previousValue) {
                        this.eventPayloadCache.set(handler, newValue);
                        handler(newValue, previousValue);
                    }
                }
                else {
                    handler(...payload);
                }
            }
        }
    }
    subscribe(eventType, handler, selector) {
        let subscribers = this.events.get(eventType);
        if (!subscribers) {
            subscribers = new Map();
            this.events.set(eventType, subscribers);
        }
        subscribers.set(handler, selector);
    }
    /**
     * Unsubscribe from an event.
     *
     * Unregisters the given function as an event handler for the given event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @param handler - The event handler to unregister.
     * @throws Will throw when the given event handler is not registered for this event.
     * @template E - A type union of Event type strings.
     */
    unsubscribe(eventType, handler) {
        const subscribers = this.events.get(eventType);
        if (!subscribers || !subscribers.has(handler)) {
            throw new Error(`Subscription not found for event: ${eventType}`);
        }
        const selector = subscribers.get(handler);
        if (selector) {
            this.eventPayloadCache.delete(handler);
        }
        subscribers.delete(handler);
    }
    /**
     * Clear subscriptions for a specific event.
     *
     * This will remove all subscribed handlers for this event.
     *
     * @param eventType - The event type. This is a unique identifier for this event.
     * @template E - A type union of Event type strings.
     */
    clearEventSubscriptions(eventType) {
        this.events.delete(eventType);
    }
    /**
     * Clear all subscriptions.
     *
     * This will remove all subscribed handlers for all events.
     */
    clearSubscriptions() {
        this.events.clear();
    }
    /**
     * Get a restricted controller messenger
     *
     * Returns a wrapper around the controller messenger instance that restricts access to actions
     * and events. The provided allowlists grant the ability to call the listed actions and subscribe
     * to the listed events. The "name" provided grants ownership of any actions and events under
     * that namespace. Ownership allows registering actions and publishing events, as well as
     * unregistering actions and clearing event subscriptions.
     *
     * @param options - Controller messenger options.
     * @param options.name - The name of the thing this messenger will be handed to (e.g. the
     * controller name). This grants "ownership" of actions and events under this namespace to the
     * restricted controller messenger returned.
     * @param options.allowedActions - The list of actions that this restricted controller messenger
     * should be alowed to call.
     * @param options.allowedEvents - The list of events that this restricted controller messenger
     * should be allowed to subscribe to.
     * @template N - The namespace for this messenger. Typically this is the name of the controller or
     * module that this messenger has been created for. The authority to publish events and register
     * actions under this namespace is granted to this restricted messenger instance.
     * @template AllowedAction - A type union of the 'type' string for any allowed actions.
     * @template AllowedEvent - A type union of the 'type' string for any allowed events.
     * @returns The restricted controller messenger.
     */
    getRestricted({ name, allowedActions, allowedEvents, }) {
        return new RestrictedControllerMessenger({
            controllerMessenger: this,
            name,
            allowedActions,
            allowedEvents,
        });
    }
}
exports.ControllerMessenger = ControllerMessenger;
//# sourceMappingURL=ControllerMessenger.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\announcement\\AnnouncementController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\announcement\AnnouncementController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnnouncementController = void 0;
const BaseController_1 = require("../BaseController");
const defaultState = {
    announcements: {},
};
/**
 * Controller for managing in-app announcements.
 */
class AnnouncementController extends BaseController_1.BaseController {
    /**
     * Creates a AnnouncementController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state || defaultState);
        this.initialize();
        this._addAnnouncements();
    }
    /**
     * Compares the announcements in state with the announcements from file
     * to check if there are any new announcements
     * if yes, the new announcement will be added to the state with a flag indicating
     * that the announcement is not seen by the user.
     */
    _addAnnouncements() {
        const newAnnouncements = {};
        const { allAnnouncements } = this.config;
        Object.values(allAnnouncements).forEach((announcement) => {
            newAnnouncements[announcement.id] = this.state.announcements[announcement.id]
                ? this.state.announcements[announcement.id]
                : Object.assign(Object.assign({}, announcement), { isShown: false });
        });
        this.update({ announcements: newAnnouncements });
    }
    /**
     * Updates the status of the status of the specified announcements
     * once it is read by the user.
     *
     * @param viewedIds - The announcement IDs to mark as viewed.
     */
    updateViewed(viewedIds) {
        const stateAnnouncements = this.state.announcements;
        for (const id of Object.keys(viewedIds).map(Number)) {
            stateAnnouncements[id].isShown = viewedIds[id];
        }
        this.update({ announcements: stateAnnouncements }, true);
    }
}
exports.AnnouncementController = AnnouncementController;
//# sourceMappingURL=AnnouncementController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\apis\\crypto-compare.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\apis\crypto-compare.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchExchangeRate = void 0;
const util_1 = require("../util");
/**
 * Get the CryptoCompare API URL for getting the conversion rate from the given native currency to
 * the given currency. Optionally, the conversion rate from the native currency to USD can also be
 * included in the response.
 *
 * @param currentCurrency - The currency to get a conversion rate for.
 * @param nativeCurrency - The native currency to convert from.
 * @param includeUSDRate - Whether or not the native currency to USD conversion rate should be
 * included in the response as well.
 * @returns The API URL for getting the conversion rate.
 */
function getPricingURL(currentCurrency, nativeCurrency, includeUSDRate) {
    return (`https://min-api.cryptocompare.com/data/price?fsym=` +
        `${nativeCurrency.toUpperCase()}&tsyms=${currentCurrency.toUpperCase()}` +
        `${includeUSDRate && currentCurrency.toUpperCase() !== 'USD' ? ',USD' : ''}`);
}
/**
 * Fetches the exchange rate for a given currency.
 *
 * @param currency - ISO 4217 currency code.
 * @param nativeCurrency - Symbol for base asset.
 * @param includeUSDRate - Whether to add the USD rate to the fetch.
 * @returns Promise resolving to exchange rate for given currency.
 */
function fetchExchangeRate(currency, nativeCurrency, includeUSDRate) {
    return __awaiter(this, void 0, void 0, function* () {
        const json = yield (0, util_1.handleFetch)(getPricingURL(currency, nativeCurrency, includeUSDRate));
        /*
        Example expected error response (if pair is not found)
        {
          Response: "Error",
          Message: "cccagg_or_exchange market does not exist for this coin pair (ETH-<NON_EXISTENT_TOKEN>)",
          HasWarning: false,
        }
        */
        if (json.Response === 'Error') {
            throw new Error(json.Message);
        }
        const conversionRate = Number(json[currency.toUpperCase()]);
        const usdConversionRate = Number(json.USD);
        if (!Number.isFinite(conversionRate)) {
            throw new Error(`Invalid response for ${currency.toUpperCase()}: ${json[currency.toUpperCase()]}`);
        }
        if (includeUSDRate && !Number.isFinite(usdConversionRate)) {
            throw new Error(`Invalid response for usdConversionRate: ${json.USD}`);
        }
        return {
            conversionRate,
            usdConversionRate,
        };
    });
}
exports.fetchExchangeRate = fetchExchangeRate;
//# sourceMappingURL=crypto-compare.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\apis\\token-service.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\apis\token-service.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchTokenMetadata = exports.fetchTokenList = exports.TOKEN_METADATA_NO_SUPPORT_ERROR = exports.TOKEN_END_POINT_API = void 0;
const util_1 = require("../util");
exports.TOKEN_END_POINT_API = 'https://token-api.metaswap.codefi.network';
exports.TOKEN_METADATA_NO_SUPPORT_ERROR = 'TokenService Error: Network does not support fetchTokenMetadata';
/**
 * Get the tokens URL for a specific network.
 *
 * @param chainId - The chain ID of the network the tokens requested are on.
 * @returns The tokens URL.
 */
function getTokensURL(chainId) {
    return `${exports.TOKEN_END_POINT_API}/tokens/${chainId}`;
}
/**
 * Get the token metadata URL for the given network and token.
 *
 * @param chainId - The chain ID of the network the token is on.
 * @param tokenAddress - The token address.
 * @returns The token metadata URL.
 */
function getTokenMetadataURL(chainId, tokenAddress) {
    return `${exports.TOKEN_END_POINT_API}/token/${chainId}?address=${tokenAddress}`;
}
const tenSecondsInMilliseconds = 10000;
// Token list averages 1.6 MB in size
// timeoutFetch by default has a 500ms timeout, which will almost always timeout given the response size.
const defaultTimeout = tenSecondsInMilliseconds;
/**
 * Fetch the list of token metadata for a given network. This request is cancellable using the
 * abort signal passed in.
 *
 * @param chainId - The chain ID of the network the requested tokens are on.
 * @param abortSignal - The abort signal used to cancel the request if necessary.
 * @param options - Additional fetch options.
 * @param options.timeout - The fetch timeout.
 * @returns The token list, or `undefined` if the request was cancelled.
 */
function fetchTokenList(chainId, abortSignal, { timeout = defaultTimeout } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const tokenURL = getTokensURL(chainId);
        const response = yield queryApi(tokenURL, abortSignal, timeout);
        if (response) {
            return parseJsonResponse(response);
        }
        return undefined;
    });
}
exports.fetchTokenList = fetchTokenList;
/**
 * Fetch metadata for the token address provided for a given network. This request is cancellable
 * using the abort signal passed in.
 *
 * @param chainId - The chain ID of the network the token is on.
 * @param tokenAddress - The address of the token to fetch metadata for.
 * @param abortSignal - The abort signal used to cancel the request if necessary.
 * @param options - Additional fetch options.
 * @param options.timeout - The fetch timeout.
 * @returns The token metadata, or `undefined` if the request was either aborted or failed.
 */
function fetchTokenMetadata(chainId, tokenAddress, abortSignal, { timeout = defaultTimeout } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!(0, util_1.isTokenListSupportedForNetwork)(chainId)) {
            throw new Error(exports.TOKEN_METADATA_NO_SUPPORT_ERROR);
        }
        const tokenMetadataURL = getTokenMetadataURL(chainId, tokenAddress);
        const response = yield queryApi(tokenMetadataURL, abortSignal, timeout);
        if (response) {
            return parseJsonResponse(response);
        }
        return undefined;
    });
}
exports.fetchTokenMetadata = fetchTokenMetadata;
/**
 * Perform fetch request against the api.
 *
 * @param apiURL - The URL of the API to fetch.
 * @param abortSignal - The abort signal used to cancel the request if necessary.
 * @param timeout - The fetch timeout.
 * @returns Promise resolving request response.
 */
function queryApi(apiURL, abortSignal, timeout) {
    return __awaiter(this, void 0, void 0, function* () {
        const fetchOptions = {
            referrer: apiURL,
            referrerPolicy: 'no-referrer-when-downgrade',
            method: 'GET',
            mode: 'cors',
            signal: abortSignal,
            cache: 'default',
        };
        fetchOptions.headers = new window.Headers();
        fetchOptions.headers.set('Content-Type', 'application/json');
        try {
            return yield (0, util_1.timeoutFetch)(apiURL, fetchOptions, timeout);
        }
        catch (error) {
            if (error instanceof Error && error.name === 'AbortError') {
                console.log('Request is aborted');
            }
        }
        return undefined;
    });
}
/**
 * Parse an API response and return the response JSON data.
 *
 * @param apiResponse - The API response to parse.
 * @returns The response JSON data.
 * @throws Will throw if the response includes an error.
 */
function parseJsonResponse(apiResponse) {
    return __awaiter(this, void 0, void 0, function* () {
        const responseObj = yield apiResponse.json();
        // api may return errors as json without setting an error http status code
        if (responseObj === null || responseObj === void 0 ? void 0 : responseObj.error) {
            throw new Error(`TokenService Error: ${responseObj.error}`);
        }
        return responseObj;
    });
}
//# sourceMappingURL=token-service.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\approval\\ApprovalController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","nanoid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\approval\ApprovalController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApprovalController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const nanoid_1 = require("nanoid");
const BaseControllerV2_1 = require("../BaseControllerV2");
const controllerName = 'ApprovalController';
const stateMetadata = {
    pendingApprovals: { persist: false, anonymous: true },
    pendingApprovalCount: { persist: false, anonymous: false },
};
const getAlreadyPendingMessage = (origin, type) => `Request of type '${type}' already pending for origin ${origin}. Please wait.`;
const getDefaultState = () => {
    return {
        pendingApprovals: {},
        pendingApprovalCount: 0,
    };
};
/**
 * Controller for managing requests that require user approval.
 *
 * Enables limiting the number of pending requests by origin and type, counting
 * pending requests, and more.
 *
 * Adding a request returns a promise that resolves or rejects when the request
 * is approved or denied, respectively.
 */
class ApprovalController extends BaseControllerV2_1.BaseController {
    /**
     * Construct an Approval controller.
     *
     * @param options - The controller options.
     * @param options.showApprovalRequest - Function for opening the UI such that
     * the request can be displayed to the user.
     * @param options.messenger - The restricted controller messenger for the Approval controller.
     * @param options.state - The initial controller state.
     */
    constructor({ messenger, showApprovalRequest, state = {}, }) {
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._approvals = new Map();
        this._origins = new Map();
        this._showApprovalRequest = showApprovalRequest;
        this.registerMessageHandlers();
    }
    /**
     * Constructor helper for registering this controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearRequests`, this.clear.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:addRequest`, (opts, shouldShowRequest) => {
            if (shouldShowRequest) {
                return this.addAndShowApprovalRequest(opts);
            }
            return this.add(opts);
        });
        this.messagingSystem.registerActionHandler(`${controllerName}:hasRequest`, this.has.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:acceptRequest`, this.accept.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:rejectRequest`, this.reject.bind(this));
    }
    /**
     * Adds an approval request per the given arguments, calls the show approval
     * request function, and returns the associated approval promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    addAndShowApprovalRequest(opts) {
        const promise = this._add(opts.origin, opts.type, opts.id, opts.requestData);
        this._showApprovalRequest();
        return promise;
    }
    /**
     * Adds an approval request per the given arguments and returns the approval
     * promise.
     *
     * There can only be one approval per origin and type. An error is thrown if
     * attempting to add an invalid or duplicate request.
     *
     * @param opts - Options bag.
     * @param opts.id - The id of the approval request. A random id will be
     * generated if none is provided.
     * @param opts.origin - The origin of the approval request.
     * @param opts.type - The type associated with the approval request.
     * @param opts.requestData - Additional data associated with the request,
     * if any.
     * @returns The approval promise.
     */
    add(opts) {
        return this._add(opts.origin, opts.type, opts.id, opts.requestData);
    }
    /**
     * Gets the info for the approval request with the given id.
     *
     * @param id - The id of the approval request.
     * @returns The approval request data associated with the id.
     */
    get(id) {
        return this.state.pendingApprovals[id];
    }
    /**
     * Gets the number of pending approvals, by origin and/or type.
     *
     * If only `origin` is specified, all approvals for that origin will be
     * counted, regardless of type.
     * If only `type` is specified, all approvals for that type will be counted,
     * regardless of origin.
     * If both `origin` and `type` are specified, 0 or 1 will be returned.
     *
     * @param opts - The approval count options.
     * @param opts.origin - An approval origin.
     * @param opts.type - The type of the approval request.
     * @returns The current approval request count for the given origin and/or
     * type.
     */
    getApprovalCount(opts = {}) {
        var _a, _b;
        if (!opts.origin && !opts.type) {
            throw new Error('Must specify origin, type, or both.');
        }
        const { origin, type: _type } = opts;
        if (origin && _type) {
            return Number(Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type)));
        }
        if (origin) {
            return ((_b = this._origins.get(origin)) === null || _b === void 0 ? void 0 : _b.size) || 0;
        }
        // Only "type" was specified
        let count = 0;
        for (const approval of Object.values(this.state.pendingApprovals)) {
            if (approval.type === _type) {
                count += 1;
            }
        }
        return count;
    }
    /**
     * Get the total count of all pending approval requests for all origins.
     *
     * @returns The total pending approval request count.
     */
    getTotalApprovalCount() {
        return this.state.pendingApprovalCount;
    }
    /**
     * Checks if there's a pending approval request per the given parameters.
     * At least one parameter must be specified. An error will be thrown if the
     * parameters are invalid.
     *
     * If `id` is specified, all other parameters will be ignored.
     * If `id` is not specified, the method will check for requests that match
     * all of the specified parameters.
     *
     * @param opts - Options bag.
     * @param opts.id - The ID to check for.
     * @param opts.origin - The origin to check for.
     * @param opts.type - The type to check for.
     * @returns `true` if a matching approval is found, and `false` otherwise.
     */
    has(opts = {}) {
        var _a;
        const { id, origin, type: _type } = opts;
        if (id) {
            if (typeof id !== 'string') {
                throw new Error('May not specify non-string id.');
            }
            return this._approvals.has(id);
        }
        if (_type && typeof _type !== 'string') {
            throw new Error('May not specify non-string type.');
        }
        if (origin) {
            if (typeof origin !== 'string') {
                throw new Error('May not specify non-string origin.');
            }
            // Check origin and type pair if type also specified
            if (_type) {
                return Boolean((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(_type));
            }
            return this._origins.has(origin);
        }
        if (_type) {
            for (const approval of Object.values(this.state.pendingApprovals)) {
                if (approval.type === _type) {
                    return true;
                }
            }
            return false;
        }
        throw new Error('Must specify a valid combination of id, origin, and type.');
    }
    /**
     * Resolves the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param value - The value to resolve the approval promise with.
     */
    accept(id, value) {
        this._deleteApprovalAndGetCallbacks(id).resolve(value);
    }
    /**
     * Rejects the promise of the approval with the given id, and deletes the
     * approval. Throws an error if no such approval exists.
     *
     * @param id - The id of the approval request.
     * @param error - The error to reject the approval promise with.
     */
    reject(id, error) {
        this._deleteApprovalAndGetCallbacks(id).reject(error);
    }
    /**
     * Rejects and deletes all approval requests.
     *
     * @param rejectionError - The EthereumRpcError to reject the approval
     * requests with.
     */
    clear(rejectionError) {
        for (const id of this._approvals.keys()) {
            this.reject(id, rejectionError);
        }
        this._origins.clear();
        this.update(() => getDefaultState());
    }
    /**
     * Implementation of add operation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param id - The id of the approval request.
     * @param requestData - The request data associated with the approval request.
     * @returns The approval promise.
     */
    _add(origin, type, id = (0, nanoid_1.nanoid)(), requestData) {
        var _a;
        this._validateAddParams(id, origin, type, requestData);
        if ((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.has(type)) {
            throw eth_rpc_errors_1.ethErrors.rpc.resourceUnavailable(getAlreadyPendingMessage(origin, type));
        }
        // add pending approval
        return new Promise((resolve, reject) => {
            this._approvals.set(id, { resolve, reject });
            this._addPendingApprovalOrigin(origin, type);
            this._addToStore(id, origin, type, requestData);
        });
    }
    /**
     * Validates parameters to the add method.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _validateAddParams(id, origin, type, requestData) {
        let errorMessage = null;
        if (!id || typeof id !== 'string') {
            errorMessage = 'Must specify non-empty string id.';
        }
        else if (this._approvals.has(id)) {
            errorMessage = `Approval request with id '${id}' already exists.`;
        }
        else if (!origin || typeof origin !== 'string') {
            errorMessage = 'Must specify non-empty string origin.';
        }
        else if (!type || typeof type !== 'string') {
            errorMessage = 'Must specify non-empty string type.';
        }
        else if (requestData &&
            (typeof requestData !== 'object' || Array.isArray(requestData))) {
            errorMessage = 'Request data must be a plain object if specified.';
        }
        if (errorMessage) {
            throw eth_rpc_errors_1.ethErrors.rpc.internal(errorMessage);
        }
    }
    /**
     * Adds an entry to _origins.
     * Performs no validation.
     *
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     */
    _addPendingApprovalOrigin(origin, type) {
        const originSet = this._origins.get(origin) || new Set();
        originSet.add(type);
        if (!this._origins.has(origin)) {
            this._origins.set(origin, originSet);
        }
    }
    /**
     * Adds an entry to the store.
     * Performs no validation.
     *
     * @param id - The id of the approval request.
     * @param origin - The origin of the approval request.
     * @param type - The type associated with the approval request.
     * @param requestData - The request data associated with the approval request.
     */
    _addToStore(id, origin, type, requestData) {
        const approval = {
            id,
            origin,
            type,
            time: Date.now(),
            requestData: requestData || null,
        };
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.pendingApprovals[id] = approval;
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Deletes the approval with the given id. The approval promise must be
     * resolved or reject before this method is called.
     * Deletion is an internal operation because approval state is solely
     * managed by this controller.
     *
     * @param id - The id of the approval request to be deleted.
     */
    _delete(id) {
        this._approvals.delete(id);
        // This method is only called after verifying that the approval with the
        // specified id exists.
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const { origin, type } = this.state.pendingApprovals[id];
        this._origins.get(origin).delete(type);
        if (this._isEmptyOrigin(origin)) {
            this._origins.delete(origin);
        }
        this.update((draftState) => {
            delete draftState.pendingApprovals[id];
            draftState.pendingApprovalCount = Object.keys(draftState.pendingApprovals).length;
        });
    }
    /**
     * Gets the approval callbacks for the given id, deletes the entry, and then
     * returns the callbacks for promise resolution.
     * Throws an error if no approval is found for the given id.
     *
     * @param id - The id of the approval request.
     * @returns The promise callbacks associated with the approval request.
     */
    _deleteApprovalAndGetCallbacks(id) {
        const callbacks = this._approvals.get(id);
        if (!callbacks) {
            throw new Error(`Approval request with id '${id}' not found.`);
        }
        this._delete(id);
        return callbacks;
    }
    /**
     * Checks whether there are any approvals associated with the given
     * origin.
     *
     * @param origin - The origin to check.
     * @returns True if the origin has no approvals, false otherwise.
     */
    _isEmptyOrigin(origin) {
        var _a;
        return !((_a = this._origins.get(origin)) === null || _a === void 0 ? void 0 : _a.size);
    }
}
exports.ApprovalController = ApprovalController;
exports.default = ApprovalController;
//# sourceMappingURL=ApprovalController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\AccountTrackerController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","eth-query":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\AccountTrackerController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountTrackerController = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that tracks information for all accounts in the current keychain
 */
class AccountTrackerController extends BaseController_1.BaseController {
    /**
     * Creates an AccountTracker instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.getIdentities - Gets the identities from the Preferences store.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, getIdentities, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AccountTrackerController';
        /**
         * Refreshes all accounts in the current keychain.
         */
        this.refresh = () => __awaiter(this, void 0, void 0, function* () {
            this.syncAccounts();
            const accounts = Object.assign({}, this.state.accounts);
            for (const address in accounts) {
                yield (0, util_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
                    const balance = yield (0, util_1.query)(this.ethQuery, 'getBalance', [address]);
                    accounts[address] = { balance: (0, util_1.BNToHex)(balance) };
                }));
            }
            this.update({ accounts });
        });
        this.defaultConfig = {
            interval: 10000,
        };
        this.defaultState = { accounts: {} };
        this.initialize();
        this.getIdentities = getIdentities;
        onPreferencesStateChange(() => {
            this.refresh();
        });
        this.poll();
    }
    syncAccounts() {
        const { accounts } = this.state;
        const addresses = Object.keys(this.getIdentities());
        const existing = Object.keys(accounts);
        const newAddresses = addresses.filter((address) => existing.indexOf(address) === -1);
        const oldAddresses = existing.filter((address) => addresses.indexOf(address) === -1);
        newAddresses.forEach((address) => {
            accounts[address] = { balance: '0x0' };
        });
        oldAddresses.forEach((address) => {
            delete accounts[address];
        });
        this.update({ accounts: Object.assign({}, accounts) });
    }
    /**
     * Sets a new provider.
     *
     * TODO: Replace this wth a method.
     *
     * @param provider - Provider used to create a new underlying EthQuery instance.
     */
    set provider(provider) {
        this.ethQuery = new eth_query_1.default(provider);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - Polling interval trigger a 'refresh'.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield this.refresh();
            this.handle = setTimeout(() => {
                releaseLock();
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Sync accounts balances with some additional addresses.
     *
     * @param addresses - the additional addresses, may be hardware wallet addresses.
     * @returns accounts - addresses with synced balance
     */
    syncBalanceWithAddresses(addresses) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield Promise.all(addresses.map((address) => {
                return (0, util_1.safelyExecuteWithTimeout)(() => __awaiter(this, void 0, void 0, function* () {
                    const balance = yield (0, util_1.query)(this.ethQuery, 'getBalance', [address]);
                    return [address, balance];
                }));
            })).then((value) => {
                return value.reduce((obj, item) => {
                    if (!item) {
                        return obj;
                    }
                    const [address, balance] = item;
                    return Object.assign(Object.assign({}, obj), { [address]: {
                            balance,
                        } });
                }, {});
            });
        });
    }
}
exports.AccountTrackerController = AccountTrackerController;
exports.default = AccountTrackerController;
//# sourceMappingURL=AccountTrackerController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\AssetsContractController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./Standards/CollectibleStandards/ERC1155/ERC1155Standard":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\CollectibleStandards\\ERC1155\\ERC1155Standard.js","./Standards/CollectibleStandards/ERC721/ERC721Standard":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\CollectibleStandards\\ERC721\\ERC721Standard.js","./Standards/ERC20Standard":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\ERC20Standard.js","single-call-balance-checker-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\single-call-balance-checker-abi\\index.js","web3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\AssetsContractController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AssetsContractController = exports.MISSING_PROVIDER_ERROR = exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = void 0;
const web3_1 = __importDefault(require("web3"));
const single_call_balance_checker_abi_1 = __importDefault(require("single-call-balance-checker-abi"));
const BaseController_1 = require("../BaseController");
const constants_1 = require("../constants");
const util_1 = require("../util");
const ERC721Standard_1 = require("./Standards/CollectibleStandards/ERC721/ERC721Standard");
const ERC1155Standard_1 = require("./Standards/CollectibleStandards/ERC1155/ERC1155Standard");
const ERC20Standard_1 = require("./Standards/ERC20Standard");
/**
 * Check if token detection is enabled for certain networks
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports token detection
 */
exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID = {
    [util_1.SupportedTokenDetectionNetworks.mainnet]: '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39',
    [util_1.SupportedTokenDetectionNetworks.bsc]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
    [util_1.SupportedTokenDetectionNetworks.polygon]: '0x2352c63A83f9Fd126af8676146721Fa00924d7e4',
    [util_1.SupportedTokenDetectionNetworks.avax]: '0xD023D153a0DFa485130ECFdE2FAA7e612EF94818',
};
exports.MISSING_PROVIDER_ERROR = 'AssetsContractController failed to set the provider correctly. A provider must be set for this method to be available';
/**
 * Controller that interacts with contracts on mainnet through web3
 */
class AssetsContractController extends BaseController_1.BaseController {
    /**
     * Creates a AssetsContractController instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AssetsContractController';
        this.defaultConfig = {
            provider: undefined,
            ipfsGateway: constants_1.IPFS_DEFAULT_GATEWAY_URL,
            chainId: util_1.SupportedTokenDetectionNetworks.mainnet,
        };
        this.initialize();
        onPreferencesStateChange(({ ipfsGateway }) => {
            this.configure({ ipfsGateway });
        });
        onNetworkStateChange((networkState) => {
            if (this.config.chainId !== networkState.provider.chainId) {
                this.configure({
                    chainId: networkState.provider.chainId,
                });
            }
        });
    }
    /**
     * Sets a new provider.
     *
     * TODO: Replace this wth a method.
     *
     * @property provider - Provider used to create a new underlying Web3 instance
     */
    set provider(provider) {
        this.web3 = new web3_1.default(provider);
        this.erc721Standard = new ERC721Standard_1.ERC721Standard(this.web3);
        this.erc1155Standard = new ERC1155Standard_1.ERC1155Standard(this.web3);
        this.erc20Standard = new ERC20Standard_1.ERC20Standard(this.web3);
    }
    get provider() {
        throw new Error('Property only used for setting');
    }
    /**
     * Get balance or count for current account on specific asset contract.
     *
     * @param address - Asset ERC20 contract address.
     * @param selectedAddress - Current account public address.
     * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
     */
    getERC20BalanceOf(address, selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.erc20Standard) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return this.erc20Standard.getBalanceOf(address, selectedAddress);
        });
    }
    /**
     * Query for the decimals for a given ERC20 asset.
     *
     * @param address - ERC20 asset contract address.
     * @returns Promise resolving to the 'decimals'.
     */
    getERC20TokenDecimals(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc20Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return yield this.erc20Standard.getTokenDecimals(address);
        });
    }
    /**
     * Enumerate assets assigned to an owner.
     *
     * @param address - ERC721 asset contract address.
     * @param selectedAddress - Current account public address.
     * @param index - A collectible counter less than `balanceOf(selectedAddress)`.
     * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
     */
    getERC721CollectibleTokenId(address, selectedAddress, index) {
        if (this.erc721Standard === undefined) {
            throw new Error(exports.MISSING_PROVIDER_ERROR);
        }
        return this.erc721Standard.getCollectibleTokenId(address, selectedAddress, index);
    }
    /**
     * Enumerate assets assigned to an owner.
     *
     * @param tokenAddress - ERC721 asset contract address.
     * @param userAddress - Current account public address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to an object containing the token standard and a set of details which depend on which standard the token supports.
     */
    getTokenStandardAndDetails(tokenAddress, userAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined ||
                this.erc1155Standard === undefined ||
                this.erc20Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            const { ipfsGateway } = this.config;
            // ERC721
            try {
                return Object.assign({}, (yield this.erc721Standard.getDetails(tokenAddress, ipfsGateway, tokenId)));
            }
            catch (_a) {
                // Ignore
            }
            // ERC1155
            try {
                return Object.assign({}, (yield this.erc1155Standard.getDetails(tokenAddress, ipfsGateway, tokenId)));
            }
            catch (_b) {
                // Ignore
            }
            // ERC20
            try {
                return Object.assign({}, (yield this.erc20Standard.getDetails(tokenAddress, userAddress)));
            }
            catch (_c) {
                // Ignore
            }
            throw new Error('Unable to determine contract standard');
        });
    }
    /**
     * Query for tokenURI for a given ERC721 asset.
     *
     * @param address - ERC721 asset contract address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to the 'tokenURI'.
     */
    getERC721TokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getTokenURI(address, tokenId);
        });
    }
    /**
     * Query for name for a given asset.
     *
     * @param address - ERC721 or ERC20 asset contract address.
     * @returns Promise resolving to the 'name'.
     */
    getERC721AssetName(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getAssetName(address);
        });
    }
    /**
     * Query for symbol for a given asset.
     *
     * @param address - ERC721 or ERC20 asset contract address.
     * @returns Promise resolving to the 'symbol'.
     */
    getERC721AssetSymbol(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getAssetSymbol(address);
        });
    }
    /**
     * Query for owner for a given ERC721 asset.
     *
     * @param address - ERC721 asset contract address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to the owner address.
     */
    getERC721OwnerOf(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc721Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return this.erc721Standard.getOwnerOf(address, tokenId);
        });
    }
    /**
     * Query for tokenURI for a given asset.
     *
     * @param address - ERC1155 asset contract address.
     * @param tokenId - ERC1155 asset identifier.
     * @returns Promise resolving to the 'tokenURI'.
     */
    getERC1155TokenURI(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc1155Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return this.erc1155Standard.getTokenURI(address, tokenId);
        });
    }
    /**
     * Query for balance of a given ERC 1155 token.
     *
     * @param userAddress - Wallet public address.
     * @param collectibleAddress - ERC1155 asset contract address.
     * @param collectibleId - ERC1155 asset identifier.
     * @returns Promise resolving to the 'balanceOf'.
     */
    getERC1155BalanceOf(userAddress, collectibleAddress, collectibleId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc1155Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return yield this.erc1155Standard.getBalanceOf(collectibleAddress, userAddress, collectibleId);
        });
    }
    /**
     * Transfer single ERC1155 token.
     *
     * @param collectibleAddress - ERC1155 token address.
     * @param senderAddress - ERC1155 token sender.
     * @param recipientAddress - ERC1155 token recipient.
     * @param collectibleId - ERC1155 token id.
     * @param qty - Quantity of tokens to be sent.
     * @returns Promise resolving to the 'transferSingle' ERC1155 token.
     */
    transferSingleERC1155(collectibleAddress, senderAddress, recipientAddress, collectibleId, qty) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.erc1155Standard === undefined) {
                throw new Error(exports.MISSING_PROVIDER_ERROR);
            }
            return yield this.erc1155Standard.transferSingle(collectibleAddress, senderAddress, recipientAddress, collectibleId, qty);
        });
    }
    /**
     * Get the token balance for a list of token addresses in a single call. Only non-zero balances
     * are returned.
     *
     * @param selectedAddress - The address to check token balances for.
     * @param tokensToDetect - The token addresses to detect balances for.
     * @returns The list of non-zero token balances.
     */
    getBalancesInSingleCall(selectedAddress, tokensToDetect) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(this.config.chainId in exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID)) {
                // Only fetch balance if contract address exists
                return {};
            }
            const contractAddress = exports.SINGLE_CALL_BALANCES_ADDRESS_BY_CHAINID[this.config.chainId];
            const contract = this.web3.eth
                .contract(single_call_balance_checker_abi_1.default)
                .at(contractAddress);
            return new Promise((resolve, reject) => {
                contract.balances([selectedAddress], tokensToDetect, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    const nonZeroBalances = {};
                    /* istanbul ignore else */
                    if (result.length > 0) {
                        tokensToDetect.forEach((tokenAddress, index) => {
                            const balance = result[index];
                            /* istanbul ignore else */
                            if (String(balance) !== '0') {
                                nonZeroBalances[tokenAddress] = balance;
                            }
                        });
                    }
                    resolve(nonZeroBalances);
                });
            });
        });
    }
}
exports.AssetsContractController = AssetsContractController;
exports.default = AssetsContractController;
//# sourceMappingURL=AssetsContractController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectibleDetectionController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\CollectibleDetectionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectibleDetectionController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const DEFAULT_INTERVAL = 180000;
/**
 * Controller that passively polls on a set interval for Collectibles auto detection
 */
class CollectibleDetectionController extends BaseController_1.BaseController {
    /**
     * Creates a CollectibleDetectionController instance.
     *
     * @param options - The controller options.
     * @param options.onCollectiblesStateChange - Allows subscribing to assets controller state changes.
     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getOpenSeaApiKey - Gets the OpenSea API key, if one is set.
     * @param options.addCollectible - Add a collectible.
     * @param options.getCollectiblesState - Gets the current state of the Assets controller.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, getOpenSeaApiKey, addCollectible, getCollectiblesState, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'CollectibleDetectionController';
        /**
         * Checks whether network is mainnet or not.
         *
         * @returns Whether current network is mainnet.
         */
        this.isMainnet = () => this.config.networkType === constants_1.MAINNET;
        this.defaultConfig = {
            interval: DEFAULT_INTERVAL,
            networkType: constants_1.MAINNET,
            chainId: '1',
            selectedAddress: '',
            disabled: true,
        };
        this.initialize();
        this.getCollectiblesState = getCollectiblesState;
        onPreferencesStateChange(({ selectedAddress, useCollectibleDetection }) => {
            const { selectedAddress: previouslySelectedAddress, disabled } = this.config;
            if (selectedAddress !== previouslySelectedAddress ||
                !useCollectibleDetection !== disabled) {
                this.configure({ selectedAddress, disabled: !useCollectibleDetection });
            }
            if (useCollectibleDetection !== undefined) {
                if (useCollectibleDetection) {
                    this.start();
                }
                else {
                    this.stop();
                }
            }
        });
        onNetworkStateChange(({ provider }) => {
            this.configure({
                networkType: provider.type,
                chainId: provider.chainId,
            });
        });
        this.getOpenSeaApiKey = getOpenSeaApiKey;
        this.addCollectible = addCollectible;
    }
    getOwnerCollectiblesApi({ address, offset, useProxy, }) {
        return useProxy
            ? `${constants_1.OPENSEA_PROXY_URL}/assets?owner=${address}&offset=${offset}&limit=50`
            : `${constants_1.OPENSEA_API_URL}/assets?owner=${address}&offset=${offset}&limit=50`;
    }
    getOwnerCollectibles(address) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            let collectiblesApiResponse;
            let collectibles = [];
            const openSeaApiKey = this.getOpenSeaApiKey();
            let offset = 0;
            let pagingFinish = false;
            /* istanbul ignore if */
            do {
                collectiblesApiResponse = yield (0, util_1.fetchWithErrorHandling)({
                    url: this.getOwnerCollectiblesApi({ address, offset, useProxy: true }),
                    timeout: 15000,
                });
                if (openSeaApiKey && !collectiblesApiResponse) {
                    collectiblesApiResponse = yield (0, util_1.fetchWithErrorHandling)({
                        url: this.getOwnerCollectiblesApi({
                            address,
                            offset,
                            useProxy: false,
                        }),
                        options: { headers: { 'X-API-KEY': openSeaApiKey } },
                        timeout: 15000,
                        // catch 403 errors (in case API key is down we don't want to blow up)
                        errorCodesToCatch: [403],
                    });
                }
                if (!collectiblesApiResponse) {
                    return collectibles;
                }
                ((_a = collectiblesApiResponse === null || collectiblesApiResponse === void 0 ? void 0 : collectiblesApiResponse.assets) === null || _a === void 0 ? void 0 : _a.length) !== 0
                    ? (collectibles = [...collectibles, ...collectiblesApiResponse.assets])
                    : (pagingFinish = true);
                offset += 50;
            } while (!pagingFinish);
            return collectibles;
        });
    }
    /**
     * Start polling for the currency rate.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isMainnet() || this.disabled) {
                return;
            }
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate.
     */
    stop() {
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - An interval on which to poll.
     */
    startPolling(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.stopPolling();
            yield this.detectCollectibles();
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield this.detectCollectibles();
            }), this.config.interval);
        });
    }
    /**
     * Triggers asset ERC721 token auto detection on mainnet. Any newly detected collectibles are
     * added.
     */
    detectCollectibles() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.isMainnet() || this.disabled) {
                return;
            }
            const { selectedAddress, chainId } = this.config;
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            const apiCollectibles = yield this.getOwnerCollectibles(selectedAddress);
            const addCollectiblesPromises = apiCollectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                const { token_id, num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, asset_contract: { address, schema_name }, last_sale, } = collectible;
                let ignored;
                /* istanbul ignore else */
                const { ignoredCollectibles } = this.getCollectiblesState();
                if (ignoredCollectibles.length) {
                    ignored = ignoredCollectibles.find((c) => {
                        /* istanbul ignore next */
                        return (c.address === (0, util_1.toChecksumHexAddress)(address) &&
                            c.tokenId === token_id);
                    });
                }
                /* istanbul ignore else */
                if (!ignored) {
                    /* istanbul ignore next */
                    const collectibleMetadata = Object.assign({}, { name }, creator && { creator }, description && { description }, image_url && { image: image_url }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                        animationOriginal: animation_original_url,
                    }, schema_name && { standard: schema_name }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale });
                    yield this.addCollectible(address, token_id, collectibleMetadata, {
                        userAddress: selectedAddress,
                        chainId: chainId,
                    });
                }
            }));
            yield Promise.all(addCollectiblesPromises);
        });
    }
}
exports.CollectibleDetectionController = CollectibleDetectionController;
exports.default = CollectibleDetectionController;
//# sourceMappingURL=CollectibleDetectionController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectiblesController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./assetsUtil":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\assetsUtil.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\CollectiblesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectiblesController = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const assetsUtil_1 = require("./assetsUtil");
const ALL_COLLECTIBLES_STATE_KEY = 'allCollectibles';
const ALL_COLLECTIBLES_CONTRACTS_STATE_KEY = 'allCollectibleContracts';
/**
 * Controller that stores assets and exposes convenience methods
 */
class CollectiblesController extends BaseController_1.BaseController {
    /**
     * Creates a CollectiblesController instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getERC721AssetName - Gets the name of the asset at the given address.
     * @param options.getERC721AssetSymbol - Gets the symbol of the asset at the given address.
     * @param options.getERC721TokenURI - Gets the URI of the ERC721 token at the given address, with the given ID.
     * @param options.getERC721OwnerOf - Get the owner of a ERC-721 collectible.
     * @param options.getERC1155BalanceOf - Gets balance of a ERC-1155 collectible.
     * @param options.getERC1155TokenURI - Gets the URI of the ERC1155 token at the given address, with the given ID.
     * @param options.onCollectibleAdded - Callback that is called when a collectible is added. Currently used pass data
     * for tracking the collectible added event.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, getERC721AssetName, getERC721AssetSymbol, getERC721TokenURI, getERC721OwnerOf, getERC1155BalanceOf, getERC1155TokenURI, onCollectibleAdded, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'CollectiblesController';
        this.defaultConfig = {
            networkType: constants_1.MAINNET,
            selectedAddress: '',
            chainId: '',
            ipfsGateway: constants_1.IPFS_DEFAULT_GATEWAY_URL,
            openSeaEnabled: false,
            useIPFSSubdomains: true,
        };
        this.defaultState = {
            allCollectibleContracts: {},
            allCollectibles: {},
            ignoredCollectibles: [],
        };
        this.initialize();
        this.getERC721AssetName = getERC721AssetName;
        this.getERC721AssetSymbol = getERC721AssetSymbol;
        this.getERC721TokenURI = getERC721TokenURI;
        this.getERC721OwnerOf = getERC721OwnerOf;
        this.getERC1155BalanceOf = getERC1155BalanceOf;
        this.getERC1155TokenURI = getERC1155TokenURI;
        this.onCollectibleAdded = onCollectibleAdded;
        onPreferencesStateChange(({ selectedAddress, ipfsGateway, openSeaEnabled }) => {
            this.configure({ selectedAddress, ipfsGateway, openSeaEnabled });
        });
        onNetworkStateChange(({ provider }) => {
            const { chainId } = provider;
            this.configure({ chainId });
        });
    }
    getCollectibleApi({ contractAddress, tokenId, useProxy, }) {
        const { chainId } = this.config;
        if (chainId === constants_1.RINKEBY_CHAIN_ID) {
            return `${constants_1.OPENSEA_TEST_API_URL}/asset/${contractAddress}/${tokenId}`;
        }
        return useProxy
            ? `${constants_1.OPENSEA_PROXY_URL}/asset/${contractAddress}/${tokenId}`
            : `${constants_1.OPENSEA_API_URL}/asset/${contractAddress}/${tokenId}`;
    }
    getCollectibleContractInformationApi({ contractAddress, useProxy, }) {
        const { chainId } = this.config;
        if (chainId === constants_1.RINKEBY_CHAIN_ID) {
            return `${constants_1.OPENSEA_TEST_API_URL}/asset_contract/${contractAddress}`;
        }
        return useProxy
            ? `${constants_1.OPENSEA_PROXY_URL}/asset_contract/${contractAddress}`
            : `${constants_1.OPENSEA_API_URL}/asset_contract/${contractAddress}`;
    }
    /**
     * Helper method to update nested state for allCollectibles and allCollectibleContracts.
     *
     * @param newCollection - the modified piece of state to update in the controller's store
     * @param baseStateKey - The root key in the store to update.
     * @param passedConfig - An object containing the selectedAddress and chainId that are passed through the auto-detection flow.
     * @param passedConfig.userAddress - the address passed through the collectible detection flow to ensure detected assets are stored to the correct account
     * @param passedConfig.chainId - the chainId passed through the collectible detection flow to ensure detected assets are stored to the correct account
     */
    updateNestedCollectibleState(newCollection, baseStateKey, { userAddress, chainId } = {
        userAddress: this.config.selectedAddress,
        chainId: this.config.chainId,
    }) {
        const { [baseStateKey]: oldState } = this.state;
        const addressState = oldState[userAddress];
        const newAddressState = Object.assign(Object.assign({}, addressState), { [chainId]: newCollection });
        const newState = Object.assign(Object.assign({}, oldState), { [userAddress]: newAddressState });
        this.update({
            [baseStateKey]: newState,
        });
    }
    /**
     * Request individual collectible information from OpenSea API.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleInformationFromApi(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Attempt to fetch the data with the proxy
            let collectibleInformation = yield (0, util_1.fetchWithErrorHandling)({
                url: this.getCollectibleApi({
                    contractAddress,
                    tokenId,
                    useProxy: true,
                }),
            });
            // if an openSeaApiKey is set we should attempt to refetch calling directly to OpenSea
            if (!collectibleInformation && this.openSeaApiKey) {
                collectibleInformation = yield (0, util_1.fetchWithErrorHandling)({
                    url: this.getCollectibleApi({
                        contractAddress,
                        tokenId,
                        useProxy: false,
                    }),
                    options: {
                        headers: { 'X-API-KEY': this.openSeaApiKey },
                    },
                    // catch 403 errors (in case API key is down we don't want to blow up)
                    errorCodesToCatch: [403],
                });
            }
            // if we were still unable to fetch the data we return out the default/null of `CollectibleMetadata`
            if (!collectibleInformation) {
                return {
                    name: null,
                    description: null,
                    image: null,
                    standard: null,
                };
            }
            // if we've reached this point, we have successfully fetched some data for collectibleInformation
            // now we reconfigure the data to conform to the `CollectibleMetadata` type for storage.
            const { num_sales, background_color, image_url, image_preview_url, image_thumbnail_url, image_original_url, animation_url, animation_original_url, name, description, external_link, creator, last_sale, asset_contract: { schema_name }, } = collectibleInformation;
            /* istanbul ignore next */
            const collectibleMetadata = Object.assign({}, { name: name || null }, { description: description || null }, { image: image_url || null }, creator && { creator }, num_sales && { numberOfSales: num_sales }, background_color && { backgroundColor: background_color }, image_preview_url && { imagePreview: image_preview_url }, image_thumbnail_url && { imageThumbnail: image_thumbnail_url }, image_original_url && { imageOriginal: image_original_url }, animation_url && { animation: animation_url }, animation_original_url && {
                animationOriginal: animation_original_url,
            }, external_link && { externalLink: external_link }, last_sale && { lastSale: last_sale }, schema_name && { standard: schema_name });
            return collectibleMetadata;
        });
    }
    /**
     * Request individual collectible information from contracts that follows Metadata Interface.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleInformationFromTokenURI(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { ipfsGateway, useIPFSSubdomains } = this.config;
            const result = yield this.getCollectibleURIAndStandard(contractAddress, tokenId);
            let tokenURI = result[0];
            const standard = result[1];
            if (tokenURI.startsWith('ipfs://')) {
                tokenURI = (0, util_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, useIPFSSubdomains);
            }
            try {
                const object = yield (0, util_1.handleFetch)(tokenURI);
                // TODO: Check image_url existence. This is not part of EIP721 nor EIP1155
                const image = Object.prototype.hasOwnProperty.call(object, 'image')
                    ? 'image'
                    : /* istanbul ignore next */ 'image_url';
                return {
                    image: object[image],
                    name: object.name,
                    description: object.description,
                    standard,
                    favorite: false,
                };
            }
            catch (_a) {
                return {
                    image: null,
                    name: null,
                    description: null,
                    standard: standard || null,
                    favorite: false,
                };
            }
        });
    }
    /**
     * Retrieve collectible uri with  metadata. TODO Update method to use IPFS.
     *
     * @param contractAddress - Collectible contract address.
     * @param tokenId - Collectible token id.
     * @returns Promise resolving collectible uri and token standard.
     */
    getCollectibleURIAndStandard(contractAddress, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            // try ERC721 uri
            try {
                const uri = yield this.getERC721TokenURI(contractAddress, tokenId);
                return [uri, constants_1.ERC721];
            }
            catch (_a) {
                // Ignore error
            }
            // try ERC1155 uri
            try {
                const tokenURI = yield this.getERC1155TokenURI(contractAddress, tokenId);
                /**
                 * According to EIP1155 the URI value allows for ID substitution
                 * in case the string `{id}` exists.
                 * https://eips.ethereum.org/EIPS/eip-1155#metadata
                 */
                if (!tokenURI.includes('{id}')) {
                    return [tokenURI, constants_1.ERC1155];
                }
                const hexTokenId = (0, ethereumjs_util_1.stripHexPrefix)((0, util_1.BNToHex)(new ethereumjs_util_1.BN(tokenId)))
                    .padStart(64, '0')
                    .toLowerCase();
                return [tokenURI.replace('{id}', hexTokenId), constants_1.ERC1155];
            }
            catch (_b) {
                // Ignore error
            }
            return ['', ''];
        });
    }
    /**
     * Request individual collectible information (name, image url and description).
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleInformation(contractAddress, tokenId) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainMetadata = yield (0, util_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);
            }));
            let openSeaMetadata;
            if (this.config.openSeaEnabled) {
                openSeaMetadata = yield (0, util_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this.getCollectibleInformationFromApi(contractAddress, tokenId);
                }));
            }
            return Object.assign(Object.assign({}, openSeaMetadata), { name: (_b = (_a = blockchainMetadata.name) !== null && _a !== void 0 ? _a : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.name) !== null && _b !== void 0 ? _b : null, description: (_d = (_c = blockchainMetadata.description) !== null && _c !== void 0 ? _c : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.description) !== null && _d !== void 0 ? _d : null, image: (_f = (_e = blockchainMetadata.image) !== null && _e !== void 0 ? _e : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.image) !== null && _f !== void 0 ? _f : null, standard: (_h = (_g = blockchainMetadata.standard) !== null && _g !== void 0 ? _g : openSeaMetadata === null || openSeaMetadata === void 0 ? void 0 : openSeaMetadata.standard) !== null && _h !== void 0 ? _h : null });
        });
    }
    /**
     * Request collectible contract information from OpenSea API.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleContractInformationFromApi(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            let apiCollectibleContractObject = yield (0, util_1.fetchWithErrorHandling)({
                url: this.getCollectibleContractInformationApi({
                    contractAddress,
                    useProxy: true,
                }),
            });
            // if we successfully fetched return the fetched data immediately
            if (apiCollectibleContractObject) {
                return apiCollectibleContractObject;
            }
            // if we were unsuccessful in fetching from the API and an OpenSea API key is present
            // attempt to refetch directly against the OpenSea API and if successful return the data immediately
            if (this.openSeaApiKey) {
                apiCollectibleContractObject = yield (0, util_1.fetchWithErrorHandling)({
                    url: this.getCollectibleContractInformationApi({
                        contractAddress,
                        useProxy: false,
                    }),
                    options: {
                        headers: { 'X-API-KEY': this.openSeaApiKey },
                    },
                    // catch 403 errors (in case API key is down we don't want to blow up)
                    errorCodesToCatch: [403],
                });
                if (apiCollectibleContractObject) {
                    return apiCollectibleContractObject;
                }
            }
            // If we've reached this point we were unable to fetch data from either the proxy or opensea so we return
            // the default/null of ApiCollectibleContract
            return {
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                schema_name: null,
                symbol: null,
                total_supply: null,
                description: null,
                external_link: null,
                collection: {
                    name: null,
                    image_url: null,
                },
            };
        });
    }
    /**
     * Request collectible contract information from the contract itself.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @returns Promise resolving to the current collectible name and image.
     */
    getCollectibleContractInformationFromContract(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const name = yield this.getERC721AssetName(contractAddress);
            const symbol = yield this.getERC721AssetSymbol(contractAddress);
            return {
                collection: { name },
                symbol,
                address: contractAddress,
            };
        });
    }
    /**
     * Request collectible contract information from OpenSea API.
     *
     * @param contractAddress - Hex address of the collectible contract.
     * @returns Promise resolving to the collectible contract name, image and description.
     */
    getCollectibleContractInformation(contractAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockchainContractData = yield (0, util_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                return yield this.getCollectibleContractInformationFromContract(contractAddress);
            }));
            let openSeaContractData;
            if (this.config.openSeaEnabled) {
                openSeaContractData = yield (0, util_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                    return yield this.getCollectibleContractInformationFromApi(contractAddress);
                }));
            }
            if (blockchainContractData || openSeaContractData) {
                return Object.assign(Object.assign(Object.assign({}, openSeaContractData), blockchainContractData), { collection: Object.assign(Object.assign({ image_url: null }, openSeaContractData === null || openSeaContractData === void 0 ? void 0 : openSeaContractData.collection), blockchainContractData === null || blockchainContractData === void 0 ? void 0 : blockchainContractData.collection) });
            }
            /* istanbul ignore next */
            return {
                address: contractAddress,
                asset_contract_type: null,
                created_date: null,
                schema_name: null,
                symbol: null,
                total_supply: null,
                description: null,
                external_link: null,
                collection: { name: null, image_url: null },
            };
        });
    }
    /**
     * Adds an individual collectible to the stored collectible list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @param collectibleMetadata - Collectible optional information (name, image and description).
     * @param collectibleContract - An object containing contract data of the collectible being added.
     * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.
     * @returns Promise resolving to the current collectible list.
     */
    addIndividualCollectible(address, tokenId, collectibleMetadata, collectibleContract, detection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Remove unused return
            const releaseLock = yield this.mutex.acquire();
            try {
                address = (0, util_1.toChecksumHexAddress)(address);
                const { allCollectibles } = this.state;
                let chainId, selectedAddress;
                if (detection) {
                    chainId = detection.chainId;
                    selectedAddress = detection.userAddress;
                }
                else {
                    chainId = this.config.chainId;
                    selectedAddress = this.config.selectedAddress;
                }
                const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
                const existingEntry = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                    collectible.tokenId === tokenId);
                if (existingEntry) {
                    const differentMetadata = (0, assetsUtil_1.compareCollectiblesMetadata)(collectibleMetadata, existingEntry);
                    if (differentMetadata) {
                        // TODO: Switch to indexToUpdate
                        const indexToRemove = collectibles.findIndex((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
                            collectible.tokenId === tokenId);
                        /* istanbul ignore next */
                        if (indexToRemove !== -1) {
                            collectibles.splice(indexToRemove, 1);
                        }
                    }
                    else {
                        return collectibles;
                    }
                }
                const newEntry = Object.assign({ address,
                    tokenId, favorite: (existingEntry === null || existingEntry === void 0 ? void 0 : existingEntry.favorite) || false, isCurrentlyOwned: true }, collectibleMetadata);
                const newCollectibles = [...collectibles, newEntry];
                this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY, { chainId, userAddress: selectedAddress });
                if (this.onCollectibleAdded) {
                    this.onCollectibleAdded({
                        address,
                        symbol: collectibleContract.symbol,
                        tokenId: tokenId.toString(),
                        standard: collectibleMetadata.standard,
                        source: detection ? 'detected' : 'custom',
                    });
                }
                return newCollectibles;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds a collectible contract to the stored collectible contracts list.
     *
     * @param address - Hex address of the collectible contract.
     * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.
     * @returns Promise resolving to the current collectible contracts list.
     */
    addCollectibleContract(address, detection) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                address = (0, util_1.toChecksumHexAddress)(address);
                const { allCollectibleContracts } = this.state;
                let chainId, selectedAddress;
                if (detection) {
                    chainId = detection.chainId;
                    selectedAddress = detection.userAddress;
                }
                else {
                    chainId = this.config.chainId;
                    selectedAddress = this.config.selectedAddress;
                }
                const collectibleContracts = ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
                const existingEntry = collectibleContracts.find((collectibleContract) => collectibleContract.address.toLowerCase() === address.toLowerCase());
                if (existingEntry) {
                    return collectibleContracts;
                }
                const contractInformation = yield this.getCollectibleContractInformation(address);
                const { asset_contract_type, created_date, schema_name, symbol, total_supply, description, external_link, collection: { name, image_url }, } = contractInformation;
                // If being auto-detected opensea information is expected
                // Otherwise at least name from the contract is needed
                if ((detection && !name) ||
                    Object.keys(contractInformation).length === 0) {
                    return collectibleContracts;
                }
                /* istanbul ignore next */
                const newEntry = Object.assign({}, { address }, description && { description }, name && { name }, image_url && { logo: image_url }, symbol && { symbol }, total_supply !== null &&
                    typeof total_supply !== 'undefined' && { totalSupply: total_supply }, asset_contract_type && { assetContractType: asset_contract_type }, created_date && { createdDate: created_date }, schema_name && { schemaName: schema_name }, external_link && { externalLink: external_link });
                const newCollectibleContracts = [...collectibleContracts, newEntry];
                this.updateNestedCollectibleState(newCollectibleContracts, ALL_COLLECTIBLES_CONTRACTS_STATE_KEY, { chainId, userAddress: selectedAddress });
                return newCollectibleContracts;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Removes an individual collectible from the stored token list and saves it in ignored collectibles list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeAndIgnoreIndividualCollectible(address, tokenId) {
        var _a;
        address = (0, util_1.toChecksumHexAddress)(address);
        const { allCollectibles, ignoredCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const newIgnoredCollectibles = [...ignoredCollectibles];
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const newCollectibles = collectibles.filter((collectible) => {
            if (collectible.address.toLowerCase() === address.toLowerCase() &&
                collectible.tokenId === tokenId) {
                const alreadyIgnored = newIgnoredCollectibles.find((c) => c.address === address && c.tokenId === tokenId);
                !alreadyIgnored && newIgnoredCollectibles.push(collectible);
                return false;
            }
            return true;
        });
        this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY);
        this.update({
            ignoredCollectibles: newIgnoredCollectibles,
        });
    }
    /**
     * Removes an individual collectible from the stored token list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeIndividualCollectible(address, tokenId) {
        var _a;
        address = (0, util_1.toChecksumHexAddress)(address);
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const newCollectibles = collectibles.filter((collectible) => !(collectible.address.toLowerCase() === address.toLowerCase() &&
            collectible.tokenId === tokenId));
        this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY);
    }
    /**
     * Removes a collectible contract to the stored collectible contracts list.
     *
     * @param address - Hex address of the collectible contract.
     * @returns Promise resolving to the current collectible contracts list.
     */
    removeCollectibleContract(address) {
        var _a;
        address = (0, util_1.toChecksumHexAddress)(address);
        const { allCollectibleContracts } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibleContracts = ((_a = allCollectibleContracts[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const newCollectibleContracts = collectibleContracts.filter((collectibleContract) => !(collectibleContract.address.toLowerCase() === address.toLowerCase()));
        this.updateNestedCollectibleState(newCollectibleContracts, ALL_COLLECTIBLES_CONTRACTS_STATE_KEY);
        return newCollectibleContracts;
    }
    /**
     * Sets an OpenSea API key to retrieve collectible information.
     *
     * @param openSeaApiKey - OpenSea API key.
     */
    setApiKey(openSeaApiKey) {
        this.openSeaApiKey = openSeaApiKey;
    }
    /**
     * Checks the ownership of a ERC-721 or ERC-1155 collectible for a given address.
     *
     * @param ownerAddress - User public address.
     * @param collectibleAddress - Collectible contract address.
     * @param collectibleId - Collectible token ID.
     * @returns Promise resolving the collectible ownership.
     */
    isCollectibleOwner(ownerAddress, collectibleAddress, collectibleId) {
        return __awaiter(this, void 0, void 0, function* () {
            // Checks the ownership for ERC-721.
            try {
                const owner = yield this.getERC721OwnerOf(collectibleAddress, collectibleId);
                return ownerAddress.toLowerCase() === owner.toLowerCase();
                // eslint-disable-next-line no-empty
            }
            catch (_a) {
                // Ignore ERC-721 contract error
            }
            // Checks the ownership for ERC-1155.
            try {
                const balance = yield this.getERC1155BalanceOf(ownerAddress, collectibleAddress, collectibleId);
                return balance > 0;
                // eslint-disable-next-line no-empty
            }
            catch (_b) {
                // Ignore ERC-1155 contract error
            }
            throw new Error('Unable to verify ownership. Probably because the standard is not supported or the chain is incorrect.');
        });
    }
    /**
     * Verifies currently selected address owns entered collectible address/tokenId combo and
     * adds the collectible and respective collectible contract to the stored collectible and collectible contracts lists.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     */
    addCollectibleVerifyOwnership(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const { selectedAddress } = this.config;
            if (!(yield this.isCollectibleOwner(selectedAddress, address, tokenId))) {
                throw new Error('This collectible is not owned by the user');
            }
            yield this.addCollectible(address, tokenId);
        });
    }
    /**
     * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - The collectible identifier.
     * @param collectibleMetadata - Collectible optional metadata.
     * @param detection - The chain ID and address of the currently selected network and account at the moment the collectible was detected.
     * @returns Promise resolving to the current collectible list.
     */
    addCollectible(address, tokenId, collectibleMetadata, detection) {
        return __awaiter(this, void 0, void 0, function* () {
            address = (0, util_1.toChecksumHexAddress)(address);
            const newCollectibleContracts = yield this.addCollectibleContract(address, detection);
            collectibleMetadata =
                collectibleMetadata ||
                    (yield this.getCollectibleInformation(address, tokenId));
            // If collectible contract was not added, do not add individual collectible
            const collectibleContract = newCollectibleContracts.find((contract) => contract.address.toLowerCase() === address.toLowerCase());
            // If collectible contract information, add individual collectible
            if (collectibleContract) {
                yield this.addIndividualCollectible(address, tokenId, collectibleMetadata, collectibleContract, detection);
            }
        });
    }
    /**
     * Removes a collectible from the stored token list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeCollectible(address, tokenId) {
        var _a;
        address = (0, util_1.toChecksumHexAddress)(address);
        this.removeIndividualCollectible(address, tokenId);
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes a collectible from the stored token list and saves it in ignored collectibles list.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Token identifier of the collectible.
     */
    removeAndIgnoreCollectible(address, tokenId) {
        var _a;
        address = (0, util_1.toChecksumHexAddress)(address);
        this.removeAndIgnoreIndividualCollectible(address, tokenId);
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const remainingCollectible = collectibles.find((collectible) => collectible.address.toLowerCase() === address.toLowerCase());
        if (!remainingCollectible) {
            this.removeCollectibleContract(address);
        }
    }
    /**
     * Removes all collectibles from the ignored list.
     */
    clearIgnoredCollectibles() {
        this.update({ ignoredCollectibles: [] });
    }
    /**
     * Checks whether input collectible is still owned by the user
     * And updates the isCurrentlyOwned value on the collectible object accordingly.
     *
     * @param collectible - The collectible object to check and update.
     * @param batch - A boolean indicating whether this method is being called as part of a batch or single update.
     * @param accountParams - The userAddress and chainId to check ownership against
     * @param accountParams.userAddress - the address passed through the confirmed transaction flow to ensure detected assets are stored to the correct account
     * @param accountParams.chainId - the chainId passed through the confirmed transaction flow to ensure detected assets are stored to the correct account
     * @returns the collectible with the updated isCurrentlyOwned value
     */
    checkAndUpdateSingleCollectibleOwnershipStatus(collectible, batch, { userAddress, chainId } = {
        userAddress: this.config.selectedAddress,
        chainId: this.config.chainId,
    }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { address, tokenId } = collectible;
            let isOwned = collectible.isCurrentlyOwned;
            try {
                isOwned = yield this.isCollectibleOwner(userAddress, address, tokenId);
            }
            catch (error) {
                if (!(error instanceof Error &&
                    error.message.includes('Unable to verify ownership'))) {
                    throw error;
                }
            }
            collectible.isCurrentlyOwned = isOwned;
            if (batch === true) {
                return collectible;
            }
            // if this is not part of a batched update we update this one collectible in state
            const { allCollectibles } = this.state;
            const collectibles = ((_a = allCollectibles[userAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
            const collectibleToUpdate = collectibles.find((item) => item.tokenId === tokenId &&
                item.address.toLowerCase() === address.toLowerCase());
            if (collectibleToUpdate) {
                collectibleToUpdate.isCurrentlyOwned = isOwned;
                this.updateNestedCollectibleState(collectibles, ALL_COLLECTIBLES_STATE_KEY, { userAddress, chainId });
            }
            return collectible;
        });
    }
    /**
     * Checks whether Collectibles associated with current selectedAddress/chainId combination are still owned by the user
     * And updates the isCurrentlyOwned value on each accordingly.
     */
    checkAndUpdateAllCollectiblesOwnershipStatus() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const { allCollectibles } = this.state;
            const { chainId, selectedAddress } = this.config;
            const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
            const updatedCollectibles = yield Promise.all(collectibles.map((collectible) => __awaiter(this, void 0, void 0, function* () {
                var _b;
                return ((_b = (yield this.checkAndUpdateSingleCollectibleOwnershipStatus(collectible, true))) !== null && _b !== void 0 ? _b : collectible);
            })));
            this.updateNestedCollectibleState(updatedCollectibles, ALL_COLLECTIBLES_STATE_KEY);
        });
    }
    /**
     * Update collectible favorite status.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Hex address of the collectible contract.
     * @param favorite - Collectible new favorite status.
     */
    updateCollectibleFavoriteStatus(address, tokenId, favorite) {
        var _a;
        const { allCollectibles } = this.state;
        const { chainId, selectedAddress } = this.config;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const index = collectibles.findIndex((collectible) => collectible.address === address && collectible.tokenId === tokenId);
        if (index === -1) {
            return;
        }
        const updatedCollectible = Object.assign(Object.assign({}, collectibles[index]), { favorite });
        // Update Collectibles array
        collectibles[index] = updatedCollectible;
        this.updateNestedCollectibleState(collectibles, ALL_COLLECTIBLES_STATE_KEY);
    }
    /**
     * Returns the collectible by the address and token id.
     *
     * @param address - Hex address of the collectible contract.
     * @param tokenId - Number that represents the id of the token.
     * @param selectedAddress - Hex address of the user account.
     * @param chainId - Id of the current network.
     * @returns Object containing the Collectible and their position in the array
     */
    findCollectibleByAddressAndTokenId(address, tokenId, selectedAddress, chainId) {
        var _a;
        const { allCollectibles } = this.state;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const index = collectibles.findIndex((collectible) => collectible.address.toLowerCase() === address.toLowerCase() &&
            collectible.tokenId === tokenId);
        if (index === -1) {
            return null;
        }
        return { collectible: collectibles[index], index };
    }
    /**
     * Update collectible data.
     *
     * @param collectible - Collectible object to find the right collectible to updates.
     * @param updates - Collectible partial object to update properties of the collectible.
     * @param selectedAddress - Hex address of the user account.
     * @param chainId - Id of the current network.
     */
    updateCollectible(collectible, updates, selectedAddress, chainId) {
        var _a;
        const { allCollectibles } = this.state;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const collectibleInfo = this.findCollectibleByAddressAndTokenId(collectible.address, collectible.tokenId, selectedAddress, chainId);
        if (!collectibleInfo) {
            return;
        }
        const updatedCollectible = Object.assign(Object.assign({}, collectible), updates);
        // Update Collectibles array
        const newCollectibles = [
            ...collectibles.slice(0, collectibleInfo.index),
            updatedCollectible,
            ...collectibles.slice(collectibleInfo.index + 1),
        ];
        this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY);
    }
    /**
     * Resets the transaction status of a collectible.
     *
     * @param transactionId - Collectible transaction id.
     * @param selectedAddress - Hex address of the user account.
     * @param chainId - Id of the current network.
     * @returns a boolean indicating if the reset was well succeded or not
     */
    resetCollectibleTransactionStatusByTransactionId(transactionId, selectedAddress, chainId) {
        var _a;
        const { allCollectibles } = this.state;
        const collectibles = ((_a = allCollectibles[selectedAddress]) === null || _a === void 0 ? void 0 : _a[chainId]) || [];
        const index = collectibles.findIndex((collectible) => collectible.transactionId === transactionId);
        if (index === -1) {
            return false;
        }
        const updatedCollectible = Object.assign(Object.assign({}, collectibles[index]), { transactionId: undefined });
        // Update Collectibles array
        const newCollectibles = [
            ...collectibles.slice(0, index),
            updatedCollectible,
            ...collectibles.slice(index + 1),
        ];
        this.updateNestedCollectibleState(newCollectibles, ALL_COLLECTIBLES_STATE_KEY);
        return true;
    }
}
exports.CollectiblesController = CollectiblesController;
exports.default = CollectiblesController;
//# sourceMappingURL=CollectiblesController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\CurrencyRateController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../apis/crypto-compare":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\apis\\crypto-compare.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\CurrencyRateController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CurrencyRateController = void 0;
const async_mutex_1 = require("async-mutex");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const crypto_compare_1 = require("../apis/crypto-compare");
const constants_1 = require("../constants");
const name = 'CurrencyRateController';
const metadata = {
    conversionDate: { persist: true, anonymous: true },
    conversionRate: { persist: true, anonymous: true },
    currentCurrency: { persist: true, anonymous: true },
    nativeCurrency: { persist: true, anonymous: true },
    pendingCurrentCurrency: { persist: false, anonymous: true },
    pendingNativeCurrency: { persist: false, anonymous: true },
    usdConversionRate: { persist: true, anonymous: true },
};
const defaultState = {
    conversionDate: 0,
    conversionRate: 0,
    currentCurrency: 'usd',
    nativeCurrency: 'ETH',
    pendingCurrentCurrency: null,
    pendingNativeCurrency: null,
    usdConversionRate: null,
};
/**
 * Controller that passively polls on a set interval for an exchange rate from the current base
 * asset to the current currency
 */
class CurrencyRateController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a CurrencyRateController instance.
     *
     * @param options - Constructor options.
     * @param options.includeUsdRate - Keep track of the USD rate in addition to the current currency rate.
     * @param options.interval - The polling interval, in milliseconds.
     * @param options.messenger - A reference to the messaging system.
     * @param options.state - Initial state to set on this controller.
     * @param options.fetchExchangeRate - Fetches the exchange rate from an external API. This option is primarily meant for use in unit tests.
     */
    constructor({ includeUsdRate = false, interval = 180000, messenger, state, fetchExchangeRate = crypto_compare_1.fetchExchangeRate, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.includeUsdRate = includeUsdRate;
        this.intervalDelay = interval;
        this.fetchExchangeRate = fetchExchangeRate;
    }
    /**
     * Start polling for the currency rate.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the currency rate.
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    /**
     * Sets a currency to track.
     *
     * @param currentCurrency - ISO 4217 currency code.
     */
    setCurrentCurrency(currentCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingCurrentCurrency = currentCurrency;
            });
            yield this.updateExchangeRate();
        });
    }
    /**
     * Sets a new native currency.
     *
     * @param symbol - Symbol for the base asset.
     */
    setNativeCurrency(symbol) {
        return __awaiter(this, void 0, void 0, function* () {
            this.update((state) => {
                state.pendingNativeCurrency = symbol;
            });
            yield this.updateExchangeRate();
        });
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            // TODO: Expose polling currency rate update errors
            yield (0, util_1.safelyExecute)(() => this.updateExchangeRate());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield (0, util_1.safelyExecute)(() => this.updateExchangeRate());
            }), this.intervalDelay);
        });
    }
    /**
     * Updates exchange rate for the current currency.
     *
     * @returns The controller state.
     */
    updateExchangeRate() {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { currentCurrency: stateCurrentCurrency, nativeCurrency: stateNativeCurrency, pendingCurrentCurrency, pendingNativeCurrency, } = this.state;
            let conversionDate = null;
            let conversionRate = null;
            let usdConversionRate = null;
            const currentCurrency = pendingCurrentCurrency !== null && pendingCurrentCurrency !== void 0 ? pendingCurrentCurrency : stateCurrentCurrency;
            const nativeCurrency = pendingNativeCurrency !== null && pendingNativeCurrency !== void 0 ? pendingNativeCurrency : stateNativeCurrency;
            // For preloaded testnets (Rinkeby, Ropsten, Goerli, Kovan) we want to fetch exchange rate for real ETH.
            const nativeCurrencyForExchangeRate = Object.values(constants_1.TESTNET_TICKER_SYMBOLS).includes(nativeCurrency)
                ? constants_1.FALL_BACK_VS_CURRENCY // ETH
                : nativeCurrency;
            try {
                if (currentCurrency &&
                    nativeCurrency &&
                    // if either currency is an empty string we can skip the comparison
                    // because it will result in an error from the api and ultimately
                    // a null conversionRate either way.
                    currentCurrency !== '' &&
                    nativeCurrency !== '') {
                    ({ conversionRate, usdConversionRate } = yield this.fetchExchangeRate(currentCurrency, nativeCurrencyForExchangeRate, this.includeUsdRate));
                    conversionDate = Date.now() / 1000;
                }
            }
            catch (error) {
                if (!(error instanceof Error &&
                    error.message.includes('market does not exist for this coin pair'))) {
                    throw error;
                }
            }
            finally {
                try {
                    this.update(() => {
                        return {
                            conversionDate,
                            conversionRate,
                            // we currently allow and handle an empty string as a valid nativeCurrency
                            // in cases where a user has not entered a native ticker symbol for a custom network
                            // currentCurrency is not from user input but this protects us from unexpected changes.
                            nativeCurrency,
                            currentCurrency,
                            pendingCurrentCurrency: null,
                            pendingNativeCurrency: null,
                            usdConversionRate,
                        };
                    });
                }
                finally {
                    releaseLock();
                }
            }
            return this.state;
        });
    }
}
exports.CurrencyRateController = CurrencyRateController;
exports.default = CurrencyRateController;
//# sourceMappingURL=CurrencyRateController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\CollectibleStandards\\ERC1155\\ERC1155Standard.js", {"../../../../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../../../../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","@metamask/metamask-eth-abis":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\Standards\CollectibleStandards\ERC1155\ERC1155Standard.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC1155Standard = void 0;
const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
const constants_1 = require("../../../../constants");
const util_1 = require("../../../../util");
class ERC1155Standard {
    constructor(web3) {
        /**
         * Query if contract implements ERC1155 URI Metadata interface.
         *
         * @param address - ERC1155 asset contract address.
         * @returns Promise resolving to whether the contract implements ERC1155 URI Metadata interface.
         */
        this.contractSupportsURIMetadataInterface = (address) => __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, constants_1.ERC1155_METADATA_URI_INTERFACE_ID);
        });
        /**
         * Query if contract implements ERC1155 Token Receiver interface.
         *
         * @param address - ERC1155 asset contract address.
         * @returns Promise resolving to whether the contract implements ERC1155 Token Receiver interface.
         */
        this.contractSupportsTokenReceiverInterface = (address) => __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, constants_1.ERC1155_TOKEN_RECEIVER_INTERFACE_ID);
        });
        /**
         * Query if contract implements ERC1155 interface.
         *
         * @param address - ERC1155 asset contract address.
         * @returns Promise resolving to whether the contract implements the base ERC1155 interface.
         */
        this.contractSupportsBase1155Interface = (address) => __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, constants_1.ERC1155_INTERFACE_ID);
        });
        /**
         * Query for tokenURI for a given asset.
         *
         * @param address - ERC1155 asset contract address.
         * @param tokenId - ERC1155 asset identifier.
         * @returns Promise resolving to the 'tokenURI'.
         */
        this.getTokenURI = (address, tokenId) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC1155).at(address);
            return new Promise((resolve, reject) => {
                contract.uri(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query for balance of a given ERC1155 token.
         *
         * @param contractAddress - ERC1155 asset contract address.
         * @param address - Wallet public address.
         * @param tokenId - ERC1155 asset identifier.
         * @returns Promise resolving to the 'balanceOf'.
         */
        this.getBalanceOf = (contractAddress, address, tokenId) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC1155).at(contractAddress);
            return new Promise((resolve, reject) => {
                contract.balanceOf(address, tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Transfer single ERC1155 token.
         * When minting/creating tokens, the from arg MUST be set to 0x0 (i.e. zero address).
         * When burning/destroying tokens, the to arg MUST be set to 0x0 (i.e. zero address).
         *
         * @param operator - ERC1155 token address.
         * @param from - ERC1155 token holder.
         * @param to - ERC1155 token recipient.
         * @param id - ERC1155 token id.
         * @param value - Number of tokens to be sent.
         * @returns Promise resolving to the 'transferSingle'.
         */
        this.transferSingle = (operator, from, to, id, value) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC1155).at(operator);
            return new Promise((resolve, reject) => {
                contract.transferSingle(operator, from, to, id, value, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query if a contract implements an interface.
         *
         * @param address - ERC1155 asset contract address.
         * @param interfaceId - Interface identifier.
         * @returns Promise resolving to whether the contract implements `interfaceID`.
         */
        this.contractSupportsInterface = (address, interfaceId) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC1155).at(address);
            return new Promise((resolve, reject) => {
                contract.supportsInterface(interfaceId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query if a contract implements an interface.
         *
         * @param address - Asset contract address.
         * @param ipfsGateway - The user's preferred IPFS gateway.
         * @param tokenId - tokenId of a given token in the contract.
         * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
         */
        this.getDetails = (address, ipfsGateway, tokenId) => __awaiter(this, void 0, void 0, function* () {
            const isERC1155 = yield this.contractSupportsBase1155Interface(address);
            if (!isERC1155) {
                throw new Error("This isn't a valid ERC1155 contract");
            }
            let tokenURI, image;
            if (tokenId) {
                tokenURI = yield this.getTokenURI(address, tokenId);
                if (tokenURI.startsWith('ipfs://')) {
                    tokenURI = (0, util_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, true);
                }
                try {
                    const response = yield (0, util_1.timeoutFetch)(tokenURI);
                    const object = yield response.json();
                    image = object === null || object === void 0 ? void 0 : object.image;
                    if (image === null || image === void 0 ? void 0 : image.startsWith('ipfs://')) {
                        image = (0, util_1.getFormattedIpfsUrl)(ipfsGateway, image, true);
                    }
                }
                catch (_a) {
                    // ignore
                }
            }
            // TODO consider querying to the metadata to get name.
            return {
                standard: constants_1.ERC1155,
                tokenURI,
                image,
            };
        });
        this.web3 = web3;
    }
}
exports.ERC1155Standard = ERC1155Standard;
//# sourceMappingURL=ERC1155Standard.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\CollectibleStandards\\ERC721\\ERC721Standard.js", {"../../../../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../../../../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","@metamask/metamask-eth-abis":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\Standards\CollectibleStandards\ERC721\ERC721Standard.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC721Standard = void 0;
const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
const util_1 = require("../../../../util");
const constants_1 = require("../../../../constants");
class ERC721Standard {
    constructor(web3) {
        /**
         * Query if contract implements ERC721Metadata interface.
         *
         * @param address - ERC721 asset contract address.
         * @returns Promise resolving to whether the contract implements ERC721Metadata interface.
         */
        this.contractSupportsMetadataInterface = (address) => __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, constants_1.ERC721_METADATA_INTERFACE_ID);
        });
        /**
         * Query if contract implements ERC721Enumerable interface.
         *
         * @param address - ERC721 asset contract address.
         * @returns Promise resolving to whether the contract implements ERC721Enumerable interface.
         */
        this.contractSupportsEnumerableInterface = (address) => __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, constants_1.ERC721_ENUMERABLE_INTERFACE_ID);
        });
        /**
         * Query if contract implements ERC721 interface.
         *
         * @param address - ERC721 asset contract address.
         * @returns Promise resolving to whether the contract implements ERC721 interface.
         */
        this.contractSupportsBase721Interface = (address) => __awaiter(this, void 0, void 0, function* () {
            return this.contractSupportsInterface(address, constants_1.ERC721_INTERFACE_ID);
        });
        /**
         * Enumerate assets assigned to an owner.
         *
         * @param address - ERC721 asset contract address.
         * @param selectedAddress - Current account public address.
         * @param index - A collectible counter less than `balanceOf(selectedAddress)`.
         * @returns Promise resolving to token identifier for the 'index'th asset assigned to 'selectedAddress'.
         */
        this.getCollectibleTokenId = (address, selectedAddress, index) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.tokenOfOwnerByIndex(selectedAddress, index, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query for tokenURI for a given asset.
         *
         * @param address - ERC721 asset contract address.
         * @param tokenId - ERC721 asset identifier.
         * @returns Promise resolving to the 'tokenURI'.
         */
        this.getTokenURI = (address, tokenId) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC721).at(address);
            const supportsMetadata = yield this.contractSupportsMetadataInterface(address);
            if (!supportsMetadata) {
                throw new Error('Contract does not support ERC721 metadata interface.');
            }
            return new Promise((resolve, reject) => {
                contract.tokenURI(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query for name for a given asset.
         *
         * @param address - ERC721 asset contract address.
         * @returns Promise resolving to the 'name'.
         */
        this.getAssetName = (address) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.name((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query for symbol for a given asset.
         *
         * @param address - ERC721 asset contract address.
         * @returns Promise resolving to the 'symbol'.
         */
        this.getAssetSymbol = (address) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.symbol((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query if a contract implements an interface.
         *
         * @param address - Asset contract address.
         * @param interfaceId - Interface identifier.
         * @returns Promise resolving to whether the contract implements `interfaceID`.
         */
        this.contractSupportsInterface = (address, interfaceId) => __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.supportsInterface(interfaceId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
        /**
         * Query if a contract implements an interface.
         *
         * @param address - Asset contract address.
         * @param ipfsGateway - The user's preferred IPFS gateway.
         * @param tokenId - tokenId of a given token in the contract.
         * @returns Promise resolving an object containing the standard, tokenURI, symbol and name of the given contract/tokenId pair.
         */
        this.getDetails = (address, ipfsGateway, tokenId) => __awaiter(this, void 0, void 0, function* () {
            const isERC721 = yield this.contractSupportsBase721Interface(address);
            if (!isERC721) {
                throw new Error("This isn't a valid ERC721 contract");
            }
            let tokenURI, image, symbol, name;
            // TODO upgrade to use Promise.allSettled for name/symbol when we can refactor to use es2020 in tsconfig
            try {
                symbol = yield this.getAssetSymbol(address);
            }
            catch (_a) {
                // ignore
            }
            try {
                name = yield this.getAssetName(address);
            }
            catch (_b) {
                // ignore
            }
            if (tokenId) {
                try {
                    tokenURI = yield this.getTokenURI(address, tokenId);
                    if (tokenURI.startsWith('ipfs://')) {
                        tokenURI = (0, util_1.getFormattedIpfsUrl)(ipfsGateway, tokenURI, true);
                    }
                    const response = yield (0, util_1.timeoutFetch)(tokenURI);
                    const object = yield response.json();
                    image = object === null || object === void 0 ? void 0 : object.image;
                    if (image === null || image === void 0 ? void 0 : image.startsWith('ipfs://')) {
                        image = (0, util_1.getFormattedIpfsUrl)(ipfsGateway, image, true);
                    }
                }
                catch (_c) {
                    // ignore
                }
            }
            return {
                standard: constants_1.ERC721,
                tokenURI,
                symbol,
                name,
                image,
            };
        });
        this.web3 = web3;
    }
    /**
     * Query for owner for a given ERC721 asset.
     *
     * @param address - ERC721 asset contract address.
     * @param tokenId - ERC721 asset identifier.
     * @returns Promise resolving to the owner address.
     */
    getOwnerOf(address, tokenId) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC721).at(address);
            return new Promise((resolve, reject) => {
                contract.ownerOf(tokenId, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
}
exports.ERC721Standard = ERC721Standard;
//# sourceMappingURL=ERC721Standard.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\Standards\\ERC20Standard.js", {"../../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","@metamask/metamask-eth-abis":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethers/lib/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\Standards\ERC20Standard.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ERC20Standard = void 0;
const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
const ethereumjs_util_1 = require("ethereumjs-util");
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("../../constants");
class ERC20Standard {
    constructor(web3) {
        this.web3 = web3;
    }
    /**
     * Get balance or count for current account on specific asset contract.
     *
     * @param address - Asset ERC20 contract address.
     * @param selectedAddress - Current account public address.
     * @returns Promise resolving to BN object containing balance for current account on specific asset contract.
     */
    getBalanceOf(address, selectedAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC20).at(address);
            return new Promise((resolve, reject) => {
                contract.balanceOf(selectedAddress, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result);
                });
            });
        });
    }
    /**
     * Query for the decimals for a given ERC20 asset.
     *
     * @param address - ERC20 asset contract string.
     * @returns Promise resolving to the 'decimals'.
     */
    getTokenDecimals(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contract = this.web3.eth.contract(metamask_eth_abis_1.abiERC20).at(address);
            return new Promise((resolve, reject) => {
                contract.decimals((error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    resolve(result.toString());
                });
            });
        });
    }
    /**
     * Query for symbol for a given ERC20 asset.
     *
     * @param address - ERC20 asset contract address.
     * @returns Promise resolving to the 'symbol'.
     */
    getTokenSymbol(address) {
        return __awaiter(this, void 0, void 0, function* () {
            // Signature for calling `symbol()`
            const payload = { to: address, data: '0x95d89b41' };
            return new Promise((resolve, reject) => {
                this.web3.eth.call(payload, undefined, (error, result) => {
                    /* istanbul ignore if */
                    if (error) {
                        reject(error);
                        return;
                    }
                    const abiCoder = new utils_1.AbiCoder();
                    // Parse as string
                    try {
                        const decoded = abiCoder.decode(['string'], result)[0];
                        if (decoded) {
                            resolve(decoded);
                            return;
                        }
                    }
                    catch (_a) {
                        // Ignore error
                    }
                    // Parse as bytes
                    try {
                        const utf8 = (0, ethereumjs_util_1.toUtf8)(result);
                        resolve(utf8);
                        return;
                    }
                    catch (_b) {
                        // Ignore error
                    }
                    reject(new Error('Failed to parse token symbol'));
                });
            });
        });
    }
    /**
     * Query if a contract implements an interface.
     *
     * @param address - Asset contract address.
     * @param userAddress - The public address for the currently active user's account.
     * @returns Promise resolving an object containing the standard, decimals, symbol and balance of the given contract/userAddress pair.
     */
    getDetails(address, userAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const [decimals, symbol] = yield Promise.all([
                this.getTokenDecimals(address),
                this.getTokenSymbol(address),
            ]);
            let balance;
            if (userAddress) {
                balance = yield this.getBalanceOf(address, userAddress);
            }
            return {
                decimals,
                symbol,
                balance,
                standard: constants_1.ERC20,
            };
        });
    }
}
exports.ERC20Standard = ERC20Standard;
//# sourceMappingURL=ERC20Standard.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenBalancesController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\TokenBalancesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenBalancesController = exports.BN = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
Object.defineProperty(exports, "BN", { enumerable: true, get: function () { return ethereumjs_util_1.BN; } });
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval token balances
 * for tokens stored in the TokensController
 */
class TokenBalancesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenBalancesController instance.
     *
     * @param options - The controller options.
     * @param options.onTokensStateChange - Allows subscribing to assets controller state changes.
     * @param options.getSelectedAddress - Gets the current selected address.
     * @param options.getERC20BalanceOf - Gets the balance of the given account at the given contract address.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onTokensStateChange, getSelectedAddress, getERC20BalanceOf, }, config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenBalancesController';
        this.defaultConfig = {
            interval: 180000,
            tokens: [],
        };
        this.defaultState = { contractBalances: {} };
        this.initialize();
        onTokensStateChange(({ tokens, detectedTokens }) => {
            this.configure({ tokens: [...tokens, ...detectedTokens] });
            this.updateBalances();
        });
        this.getSelectedAddress = getSelectedAddress;
        this.getERC20BalanceOf = getERC20BalanceOf;
        this.poll();
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - Polling interval used to fetch new token balances.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield (0, util_1.safelyExecute)(() => this.updateBalances());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Updates balances for all tokens.
     */
    updateBalances() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const { tokens } = this.config;
            const newContractBalances = {};
            for (const i in tokens) {
                const { address } = tokens[i];
                try {
                    newContractBalances[address] = yield this.getERC20BalanceOf(address, this.getSelectedAddress());
                    tokens[i].balanceError = null;
                }
                catch (error) {
                    newContractBalances[address] = new ethereumjs_util_1.BN(0);
                    tokens[i].balanceError = error;
                }
            }
            this.update({ contractBalances: newContractBalances });
        });
    }
}
exports.TokenBalancesController = TokenBalancesController;
exports.default = TokenBalancesController;
//# sourceMappingURL=TokenBalancesController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenDetectionController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\TokenDetectionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenDetectionController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const DEFAULT_INTERVAL = 180000;
/**
 * Controller that passively polls on a set interval for Tokens auto detection
 */
class TokenDetectionController extends BaseController_1.BaseController {
    /**
     * Creates a TokenDetectionController instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preferences controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.onTokenListStateChange - Allows subscribing to token list controller state changes.
     * @param options.getBalancesInSingleCall - Gets the balances of a list of tokens for the given address.
     * @param options.addDetectedTokens - Add a list of detected tokens.
     * @param options.getTokenListState - Gets the current state of the TokenList controller.
     * @param options.getTokensState - Gets the current state of the Tokens controller.
     * @param options.getNetworkState - Gets the state of the network controller.
     * @param options.getPreferencesState - Gets the state of the preferences controller.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, onTokenListStateChange, getBalancesInSingleCall, addDetectedTokens, getTokenListState, getTokensState, getNetworkState, getPreferencesState, }, config, state) {
        const { provider: { chainId: defaultChainId }, } = getNetworkState();
        const { useTokenDetection: defaultUseTokenDetection } = getPreferencesState();
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenDetectionController';
        this.defaultConfig = Object.assign({ interval: DEFAULT_INTERVAL, selectedAddress: '', disabled: true, chainId: defaultChainId, isDetectionEnabledFromPreferences: defaultUseTokenDetection, isDetectionEnabledForNetwork: (0, util_1.isTokenDetectionSupportedForNetwork)(defaultChainId) }, config);
        this.initialize();
        this.getTokensState = getTokensState;
        this.getTokenListState = getTokenListState;
        this.addDetectedTokens = addDetectedTokens;
        this.getBalancesInSingleCall = getBalancesInSingleCall;
        onTokenListStateChange(({ tokenList }) => {
            const hasTokens = Object.keys(tokenList).length;
            if (hasTokens) {
                this.detectTokens();
            }
        });
        onPreferencesStateChange(({ selectedAddress, useTokenDetection }) => {
            const { selectedAddress: currentSelectedAddress, isDetectionEnabledFromPreferences, } = this.config;
            const isSelectedAddressChanged = selectedAddress !== currentSelectedAddress;
            const isDetectionChangedFromPreferences = isDetectionEnabledFromPreferences !== useTokenDetection;
            this.configure({
                isDetectionEnabledFromPreferences: useTokenDetection,
                selectedAddress,
            });
            if (useTokenDetection &&
                (isSelectedAddressChanged || isDetectionChangedFromPreferences)) {
                this.detectTokens();
            }
        });
        onNetworkStateChange(({ provider: { chainId } }) => {
            const { chainId: currentChainId } = this.config;
            const isDetectionEnabledForNetwork = (0, util_1.isTokenDetectionSupportedForNetwork)(chainId);
            const isChainIdChanged = currentChainId !== chainId;
            this.configure({
                chainId,
                isDetectionEnabledForNetwork,
            });
            if (isDetectionEnabledForNetwork && isChainIdChanged) {
                this.detectTokens();
            }
        });
    }
    /**
     * Start polling for detected tokens.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.configure({ disabled: false });
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for detected tokens.
     */
    stop() {
        this.configure({ disabled: true });
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - An interval on which to poll.
     */
    startPolling(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.stopPolling();
            yield this.detectTokens();
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield this.detectTokens();
            }), this.config.interval);
        });
    }
    /**
     * Triggers asset ERC20 token auto detection for each contract address in contract metadata on mainnet.
     */
    detectTokens() {
        return __awaiter(this, void 0, void 0, function* () {
            const { disabled, isDetectionEnabledForNetwork, isDetectionEnabledFromPreferences, } = this.config;
            if (disabled ||
                !isDetectionEnabledForNetwork ||
                !isDetectionEnabledFromPreferences) {
                return;
            }
            const { tokens } = this.getTokensState();
            const { selectedAddress } = this.config;
            const tokensAddresses = tokens.map(
            /* istanbul ignore next*/ (token) => token.address.toLowerCase());
            const { tokenList } = this.getTokenListState();
            const tokensToDetect = [];
            for (const address in tokenList) {
                if (!tokensAddresses.includes(address)) {
                    tokensToDetect.push(address);
                }
            }
            const sliceOfTokensToDetect = [];
            sliceOfTokensToDetect[0] = tokensToDetect.slice(0, 1000);
            sliceOfTokensToDetect[1] = tokensToDetect.slice(1000, tokensToDetect.length - 1);
            /* istanbul ignore else */
            if (!selectedAddress) {
                return;
            }
            for (const tokensSlice of sliceOfTokensToDetect) {
                if (tokensSlice.length === 0) {
                    break;
                }
                yield (0, util_1.safelyExecute)(() => __awaiter(this, void 0, void 0, function* () {
                    const balances = yield this.getBalancesInSingleCall(selectedAddress, tokensSlice);
                    const tokensToAdd = [];
                    for (const tokenAddress in balances) {
                        let ignored;
                        /* istanbul ignore else */
                        const { ignoredTokens } = this.getTokensState();
                        if (ignoredTokens.length) {
                            ignored = ignoredTokens.find((ignoredTokenAddress) => ignoredTokenAddress === (0, util_1.toChecksumHexAddress)(tokenAddress));
                        }
                        const caseInsensitiveTokenKey = Object.keys(tokenList).find((i) => i.toLowerCase() === tokenAddress.toLowerCase()) || '';
                        if (ignored === undefined) {
                            const { decimals, symbol, aggregators, iconUrl } = tokenList[caseInsensitiveTokenKey];
                            tokensToAdd.push({
                                address: tokenAddress,
                                decimals,
                                symbol,
                                aggregators,
                                image: iconUrl,
                                isERC721: false,
                            });
                        }
                    }
                    if (tokensToAdd.length) {
                        yield this.addDetectedTokens(tokensToAdd);
                    }
                }));
            }
        });
    }
}
exports.TokenDetectionController = TokenDetectionController;
exports.default = TokenDetectionController;
//# sourceMappingURL=TokenDetectionController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenListController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../apis/token-service":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\apis\\token-service.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./assetsUtil":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\assetsUtil.js","abort-controller":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\abort-controller\\browser.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\TokenListController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenListController = void 0;
const async_mutex_1 = require("async-mutex");
const abort_controller_1 = require("abort-controller");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const token_service_1 = require("../apis/token-service");
const assetsUtil_1 = require("./assetsUtil");
const DEFAULT_INTERVAL = 24 * 60 * 60 * 1000;
const DEFAULT_THRESHOLD = 24 * 60 * 60 * 1000;
const name = 'TokenListController';
const metadata = {
    tokenList: { persist: true, anonymous: true },
    tokensChainsCache: { persist: true, anonymous: true },
    preventPollingOnNetworkRestart: { persist: true, anonymous: true },
};
const defaultState = {
    tokenList: {},
    tokensChainsCache: {},
    preventPollingOnNetworkRestart: false,
};
/**
 * Controller that passively polls on a set interval for the list of tokens from metaswaps api
 */
class TokenListController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a TokenListController instance.
     *
     * @param options - The controller options.
     * @param options.chainId - The chain ID of the current network.
     * @param options.onNetworkStateChange - A function for registering an event handler for network state changes.
     * @param options.interval - The polling interval, in milliseconds.
     * @param options.cacheRefreshThreshold - The token cache expiry time, in milliseconds.
     * @param options.messenger - A restricted controller messenger.
     * @param options.state - Initial state to set on this controller.
     * @param options.preventPollingOnNetworkRestart - Determines whether to prevent poilling on network restart in extension.
     */
    constructor({ chainId, preventPollingOnNetworkRestart = false, onNetworkStateChange, interval = DEFAULT_INTERVAL, cacheRefreshThreshold = DEFAULT_THRESHOLD, messenger, state, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.mutex = new async_mutex_1.Mutex();
        this.intervalDelay = interval;
        this.cacheRefreshThreshold = cacheRefreshThreshold;
        this.chainId = chainId;
        this.updatePreventPollingOnNetworkRestart(preventPollingOnNetworkRestart);
        this.abortController = new abort_controller_1.AbortController();
        onNetworkStateChange((networkState) => __awaiter(this, void 0, void 0, function* () {
            if (this.chainId !== networkState.provider.chainId) {
                this.abortController.abort();
                this.abortController = new abort_controller_1.AbortController();
                this.chainId = networkState.provider.chainId;
                if (this.state.preventPollingOnNetworkRestart) {
                    this.clearingTokenListData();
                }
                else {
                    // Ensure tokenList is referencing data from correct network
                    this.update(() => {
                        var _a;
                        return Object.assign(Object.assign({}, this.state), { tokenList: ((_a = this.state.tokensChainsCache[this.chainId]) === null || _a === void 0 ? void 0 : _a.data) || {} });
                    });
                    yield this.restart();
                }
            }
        }));
    }
    /**
     * Start polling for the token list.
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, util_1.isTokenListSupportedForNetwork)(this.chainId)) {
                return;
            }
            yield this.startPolling();
        });
    }
    /**
     * Restart polling for the token list.
     */
    restart() {
        return __awaiter(this, void 0, void 0, function* () {
            this.stopPolling();
            yield this.startPolling();
        });
    }
    /**
     * Stop polling for the token list.
     */
    stop() {
        this.stopPolling();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
    }
    /**
     * Starts a new polling interval.
     */
    startPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, util_1.safelyExecute)(() => this.fetchTokenList());
            this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
                yield (0, util_1.safelyExecute)(() => this.fetchTokenList());
            }), this.intervalDelay);
        });
    }
    /**
     * Fetching token list from the Token Service API.
     */
    fetchTokenList() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const { tokensChainsCache } = this.state;
                let tokenList = {};
                const cachedTokens = yield (0, util_1.safelyExecute)(() => this.fetchFromCache());
                if (cachedTokens) {
                    // Use non-expired cached tokens
                    tokenList = Object.assign({}, cachedTokens);
                }
                else {
                    // Fetch fresh token list
                    const tokensFromAPI = yield (0, util_1.safelyExecute)(() => (0, token_service_1.fetchTokenList)(this.chainId, this.abortController.signal));
                    if (!tokensFromAPI) {
                        // Fallback to expired cached tokens
                        tokenList = Object.assign({}, (((_a = tokensChainsCache[this.chainId]) === null || _a === void 0 ? void 0 : _a.data) || {}));
                        this.update(() => {
                            return Object.assign(Object.assign({}, this.state), { tokenList,
                                tokensChainsCache });
                        });
                        return;
                    }
                    // Filtering out tokens with less than 3 occurrences and native tokens
                    const filteredTokenList = tokensFromAPI.filter((token) => token.occurrences &&
                        token.occurrences >= 3 &&
                        token.address !== '0x0000000000000000000000000000000000000000');
                    // Removing the tokens with symbol conflicts
                    const symbolsList = filteredTokenList.map((token) => token.symbol);
                    const duplicateSymbols = [
                        ...new Set(symbolsList.filter((symbol, index) => symbolsList.indexOf(symbol) !== index)),
                    ];
                    const uniqueTokenList = filteredTokenList.filter((token) => !duplicateSymbols.includes(token.symbol));
                    for (const token of uniqueTokenList) {
                        const formattedToken = Object.assign(Object.assign({}, token), { aggregators: (0, assetsUtil_1.formatAggregatorNames)(token.aggregators), iconUrl: (0, assetsUtil_1.formatIconUrlWithProxy)({
                                chainId: this.chainId,
                                tokenAddress: token.address,
                            }) });
                        tokenList[token.address] = formattedToken;
                    }
                }
                const updatedTokensChainsCache = Object.assign(Object.assign({}, tokensChainsCache), { [this.chainId]: {
                        timestamp: Date.now(),
                        data: tokenList,
                    } });
                this.update(() => {
                    return Object.assign(Object.assign({}, this.state), { tokenList, tokensChainsCache: updatedTokensChainsCache });
                });
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Checks if the Cache timestamp is valid,
     * if yes data in cache will be returned
     * otherwise null will be returned.
     *
     * @returns The cached data, or `null` if the cache was expired.
     */
    fetchFromCache() {
        return __awaiter(this, void 0, void 0, function* () {
            const { tokensChainsCache } = this.state;
            const dataCache = tokensChainsCache[this.chainId];
            const now = Date.now();
            if ((dataCache === null || dataCache === void 0 ? void 0 : dataCache.data) &&
                now - (dataCache === null || dataCache === void 0 ? void 0 : dataCache.timestamp) < this.cacheRefreshThreshold) {
                return dataCache.data;
            }
            return null;
        });
    }
    /**
     * Clearing tokenList and tokensChainsCache explicitly.
     */
    clearingTokenListData() {
        this.update(() => {
            return Object.assign(Object.assign({}, this.state), { tokenList: {}, tokensChainsCache: {} });
        });
    }
    /**
     * Updates preventPollingOnNetworkRestart from extension.
     *
     * @param shouldPreventPolling - Determine whether to prevent polling on network change
     */
    updatePreventPollingOnNetworkRestart(shouldPreventPolling) {
        this.update(() => {
            return Object.assign(Object.assign({}, this.state), { preventPollingOnNetworkRestart: shouldPreventPolling });
        });
    }
}
exports.TokenListController = TokenListController;
exports.default = TokenListController;
//# sourceMappingURL=TokenListController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenRatesController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../apis/crypto-compare":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\apis\\crypto-compare.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\TokenRatesController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenRatesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const crypto_compare_1 = require("../apis/crypto-compare");
const CoinGeckoApi = {
    BASE_URL: 'https://api.coingecko.com/api/v3',
    getTokenPriceURL(chainSlug, query) {
        return `${this.BASE_URL}/simple/token_price/${chainSlug}?${query}`;
    },
    getPlatformsURL() {
        return `${this.BASE_URL}/asset_platforms`;
    },
    getSupportedVsCurrencies() {
        return `${this.BASE_URL}/simple/supported_vs_currencies`;
    },
};
/**
 * Finds the chain slug in the data array given a chainId.
 *
 * @param chainId - The current chain ID.
 * @param data - A list platforms supported by the CoinGecko API.
 * @returns The CoinGecko slug for the given chain ID, or `null` if the slug was not found.
 */
function findChainSlug(chainId, data) {
    var _a;
    if (!data) {
        return null;
    }
    const chain = (_a = data.find(({ chain_identifier }) => chain_identifier !== null && String(chain_identifier) === chainId)) !== null && _a !== void 0 ? _a : null;
    return (chain === null || chain === void 0 ? void 0 : chain.id) || null;
}
/**
 * Controller that passively polls on a set interval for token-to-fiat exchange rates
 * for tokens stored in the TokensController
 */
class TokenRatesController extends BaseController_1.BaseController {
    /**
     * Creates a TokenRatesController instance.
     *
     * @param options - The controller options.
     * @param options.onTokensStateChange - Allows subscribing to token controller state changes.
     * @param options.onCurrencyRateStateChange - Allows subscribing to currency rate controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network state changes.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ onTokensStateChange, onCurrencyRateStateChange, onNetworkStateChange, }, config, state) {
        super(config, state);
        this.tokenList = [];
        this.supportedChains = {
            timestamp: 0,
            data: null,
        };
        this.supportedVsCurrencies = {
            timestamp: 0,
            data: [],
        };
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokenRatesController';
        this.defaultConfig = {
            disabled: true,
            interval: 3 * 60 * 1000,
            nativeCurrency: 'eth',
            chainId: '',
            tokens: [],
            threshold: 6 * 60 * 60 * 1000,
        };
        this.defaultState = {
            contractExchangeRates: {},
        };
        this.initialize();
        this.configure({ disabled: false }, false, false);
        onTokensStateChange(({ tokens, detectedTokens }) => {
            this.configure({ tokens: [...tokens, ...detectedTokens] });
        });
        onCurrencyRateStateChange((currencyRateState) => {
            this.configure({ nativeCurrency: currencyRateState.nativeCurrency });
        });
        onNetworkStateChange(({ provider }) => {
            const { chainId } = provider;
            this.update({ contractExchangeRates: {} });
            this.configure({ chainId });
        });
        this.poll();
    }
    /**
     * Sets a new polling interval.
     *
     * @param interval - Polling interval used to fetch new token rates.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield (0, util_1.safelyExecute)(() => this.updateExchangeRates());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Sets a new chainId.
     *
     * TODO: Replace this with a method.
     *
     * @param _chainId - The current chain ID.
     */
    set chainId(_chainId) {
        !this.disabled && (0, util_1.safelyExecute)(() => this.updateExchangeRates());
    }
    get chainId() {
        throw new Error('Property only used for setting');
    }
    /**
     * Sets a new token list to track prices.
     *
     * TODO: Replace this with a method.
     *
     * @param tokens - List of tokens to track exchange rates for.
     */
    set tokens(tokens) {
        this.tokenList = tokens;
        !this.disabled && (0, util_1.safelyExecute)(() => this.updateExchangeRates());
    }
    get tokens() {
        throw new Error('Property only used for setting');
    }
    /**
     * Fetches a pairs of token address and native currency.
     *
     * @param chainSlug - Chain string identifier.
     * @param vsCurrency - Query according to tokens in tokenList and native currency.
     * @returns The exchange rates for the given pairs.
     */
    fetchExchangeRate(chainSlug, vsCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenPairs = this.tokenList.map((token) => token.address).join(',');
            const query = `contract_addresses=${tokenPairs}&vs_currencies=${vsCurrency.toLowerCase()}`;
            return (0, util_1.handleFetch)(CoinGeckoApi.getTokenPriceURL(chainSlug, query));
        });
    }
    /**
     * Checks if the current native currency is a supported vs currency to use
     * to query for token exchange rates.
     *
     * @param nativeCurrency - The native currency of the currently active network.
     * @returns A boolean indicating whether it's a supported vsCurrency.
     */
    checkIsSupportedVsCurrency(nativeCurrency) {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold } = this.config;
            const { timestamp, data } = this.supportedVsCurrencies;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const currencies = yield (0, util_1.handleFetch)(CoinGeckoApi.getSupportedVsCurrencies());
                this.supportedVsCurrencies = {
                    data: currencies,
                    timestamp: Date.now(),
                };
                return currencies.includes(nativeCurrency.toLowerCase());
            }
            return data.includes(nativeCurrency.toLowerCase());
        });
    }
    /**
     * Gets current chain ID slug from cached supported platforms CoinGecko API response.
     * If cached supported platforms response is stale, fetches and updates it.
     *
     * @returns The CoinGecko slug for the current chain ID.
     */
    getChainSlug() {
        return __awaiter(this, void 0, void 0, function* () {
            const { threshold, chainId } = this.config;
            const { data, timestamp } = this.supportedChains;
            const now = Date.now();
            if (now - timestamp > threshold) {
                const platforms = yield (0, util_1.handleFetch)(CoinGeckoApi.getPlatformsURL());
                this.supportedChains = {
                    data: platforms,
                    timestamp: Date.now(),
                };
                return findChainSlug(chainId, platforms);
            }
            return findChainSlug(chainId, data);
        });
    }
    /**
     * Updates exchange rates for all tokens.
     */
    updateExchangeRates() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokenList.length === 0 || this.disabled) {
                return;
            }
            const slug = yield this.getChainSlug();
            let newContractExchangeRates = {};
            if (!slug) {
                this.tokenList.forEach((token) => {
                    const address = (0, util_1.toChecksumHexAddress)(token.address);
                    newContractExchangeRates[address] = undefined;
                });
            }
            else {
                const { nativeCurrency } = this.config;
                newContractExchangeRates = yield this.fetchAndMapExchangeRates(nativeCurrency, slug);
            }
            this.update({ contractExchangeRates: newContractExchangeRates });
        });
    }
    /**
     * Checks if the active network's native currency is supported by the coingecko API.
     * If supported, it fetches and maps contractExchange rates to a format to be consumed by the UI.
     * If not supported, it fetches contractExchange rates and maps them from token/fallback-currency
     * to token/nativeCurrency.
     *
     * @param nativeCurrency - The native currency of the currently active network.
     * @param slug - The unique slug used to id the chain by the coingecko api
     * should be used to query token exchange rates.
     * @returns An object with conversion rates for each token
     * related to the network's native currency.
     */
    fetchAndMapExchangeRates(nativeCurrency, slug) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractExchangeRates = {};
            // check if native currency is supported as a vs_currency by the API
            const nativeCurrencySupported = yield this.checkIsSupportedVsCurrency(nativeCurrency);
            if (nativeCurrencySupported) {
                // If it is we can do a simple fetch against the CoinGecko API
                const prices = yield this.fetchExchangeRate(slug, nativeCurrency);
                this.tokenList.forEach((token) => {
                    const price = prices[token.address.toLowerCase()];
                    contractExchangeRates[(0, util_1.toChecksumHexAddress)(token.address)] = price
                        ? price[nativeCurrency.toLowerCase()]
                        : 0;
                });
            }
            else {
                // if native currency is not supported we need to use a fallback vsCurrency, get the exchange rates
                // in token/fallback-currency format and convert them to expected token/nativeCurrency format.
                let tokenExchangeRates;
                let vsCurrencyToNativeCurrencyConversionRate = 0;
                try {
                    [
                        tokenExchangeRates,
                        { conversionRate: vsCurrencyToNativeCurrencyConversionRate },
                    ] = yield Promise.all([
                        this.fetchExchangeRate(slug, constants_1.FALL_BACK_VS_CURRENCY),
                        (0, crypto_compare_1.fetchExchangeRate)(nativeCurrency, constants_1.FALL_BACK_VS_CURRENCY, false),
                    ]);
                }
                catch (error) {
                    if (error instanceof Error &&
                        error.message.includes('market does not exist for this coin pair')) {
                        return {};
                    }
                    throw error;
                }
                for (const [tokenAddress, conversion] of Object.entries(tokenExchangeRates)) {
                    const tokenToVsCurrencyConversionRate = conversion[constants_1.FALL_BACK_VS_CURRENCY.toLowerCase()];
                    contractExchangeRates[(0, util_1.toChecksumHexAddress)(tokenAddress)] =
                        tokenToVsCurrencyConversionRate *
                            vsCurrencyToNativeCurrencyConversionRate;
                }
            }
            return contractExchangeRates;
        });
    }
}
exports.TokenRatesController = TokenRatesController;
exports.default = TokenRatesController;
//# sourceMappingURL=TokenRatesController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokensController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../apis/token-service":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\apis\\token-service.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./assetsUtil":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\assetsUtil.js","@metamask/contract-metadata":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\contract-metadata\\index.js","@metamask/metamask-eth-abis":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","abort-controller":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\abort-controller\\browser.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","ethers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\TokensController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokensController = void 0;
const events_1 = require("events");
const contract_metadata_1 = __importDefault(require("@metamask/contract-metadata"));
const metamask_eth_abis_1 = require("@metamask/metamask-eth-abis");
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const ethers_1 = require("ethers");
const abort_controller_1 = require("abort-controller");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const token_service_1 = require("../apis/token-service");
const assetsUtil_1 = require("./assetsUtil");
var SuggestedAssetStatus;
(function (SuggestedAssetStatus) {
    SuggestedAssetStatus["accepted"] = "accepted";
    SuggestedAssetStatus["failed"] = "failed";
    SuggestedAssetStatus["pending"] = "pending";
    SuggestedAssetStatus["rejected"] = "rejected";
})(SuggestedAssetStatus || (SuggestedAssetStatus = {}));
/**
 * Controller that stores assets and exposes convenience methods
 */
class TokensController extends BaseController_1.BaseController {
    /**
     * Creates a TokensController instance.
     *
     * @param options - The controller options.
     * @param options.onPreferencesStateChange - Allows subscribing to preference controller state changes.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.config - Initial options used to configure this controller.
     * @param options.state - Initial state to set on this controller.
     */
    constructor({ onPreferencesStateChange, onNetworkStateChange, config, state, }) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * EventEmitter instance used to listen to specific EIP747 events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TokensController';
        this.defaultConfig = Object.assign({ networkType: constants_1.MAINNET, selectedAddress: '', chainId: '', provider: undefined }, config);
        this.defaultState = Object.assign({ tokens: [], ignoredTokens: [], detectedTokens: [], allTokens: {}, allIgnoredTokens: {}, allDetectedTokens: {}, suggestedAssets: [] }, state);
        this.initialize();
        this.abortController = new abort_controller_1.AbortController();
        onPreferencesStateChange(({ selectedAddress }) => {
            var _a, _b, _c;
            const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
            const { chainId } = this.config;
            this.configure({ selectedAddress });
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
                detectedTokens: ((_c = allDetectedTokens[chainId]) === null || _c === void 0 ? void 0 : _c[selectedAddress]) || [],
            });
        });
        onNetworkStateChange(({ provider }) => {
            var _a, _b, _c;
            const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
            const { selectedAddress } = this.config;
            const { chainId } = provider;
            this.abortController.abort();
            this.abortController = new abort_controller_1.AbortController();
            this.configure({ chainId });
            this.ethersProvider = this._instantiateNewEthersProvider();
            this.update({
                tokens: ((_a = allTokens[chainId]) === null || _a === void 0 ? void 0 : _a[selectedAddress]) || [],
                ignoredTokens: ((_b = allIgnoredTokens[chainId]) === null || _b === void 0 ? void 0 : _b[selectedAddress]) || [],
                detectedTokens: ((_c = allDetectedTokens[chainId]) === null || _c === void 0 ? void 0 : _c[selectedAddress]) || [],
            });
        });
    }
    failSuggestedAsset(suggestedAssetMeta, error) {
        const failedSuggestedAssetMeta = Object.assign(Object.assign({}, suggestedAssetMeta), { status: SuggestedAssetStatus.failed, error });
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, failedSuggestedAssetMeta);
    }
    /**
     * Fetch metadata for a token.
     *
     * @param tokenAddress - The address of the token.
     * @returns The token metadata.
     */
    fetchTokenMetadata(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const token = yield (0, token_service_1.fetchTokenMetadata)(this.config.chainId, tokenAddress, this.abortController.signal);
                return token;
            }
            catch (error) {
                if (error instanceof Error &&
                    error.message.includes(token_service_1.TOKEN_METADATA_NO_SUPPORT_ERROR)) {
                    return undefined;
                }
                throw error;
            }
        });
    }
    _instantiateNewEthersProvider() {
        var _a;
        return new ethers_1.ethers.providers.Web3Provider((_a = this.config) === null || _a === void 0 ? void 0 : _a.provider);
    }
    /**
     * Adds a token to the stored token list.
     *
     * @param address - Hex address of the token contract.
     * @param symbol - Symbol of the token.
     * @param decimals - Number of decimals the token uses.
     * @param image - Image of the token.
     * @returns Current token list.
     */
    addToken(address, symbol, decimals, image) {
        return __awaiter(this, void 0, void 0, function* () {
            const currentChainId = this.config.chainId;
            const releaseLock = yield this.mutex.acquire();
            try {
                address = (0, util_1.toChecksumHexAddress)(address);
                const { tokens, ignoredTokens, detectedTokens } = this.state;
                const newTokens = [...tokens];
                const [isERC721, tokenMetadata] = yield Promise.all([
                    this._detectIsERC721(address),
                    this.fetchTokenMetadata(address),
                ]);
                if (currentChainId !== this.config.chainId) {
                    throw new Error('TokensController Error: Switched networks while adding token');
                }
                const newEntry = {
                    address,
                    symbol,
                    decimals,
                    image: image ||
                        (0, assetsUtil_1.formatIconUrlWithProxy)({
                            chainId: this.config.chainId,
                            tokenAddress: address,
                        }),
                    isERC721,
                    aggregators: (0, assetsUtil_1.formatAggregatorNames)((tokenMetadata === null || tokenMetadata === void 0 ? void 0 : tokenMetadata.aggregators) || []),
                };
                const previousEntry = newTokens.find((token) => token.address.toLowerCase() === address.toLowerCase());
                if (previousEntry) {
                    const previousIndex = newTokens.indexOf(previousEntry);
                    newTokens[previousIndex] = newEntry;
                }
                else {
                    newTokens.push(newEntry);
                }
                const newIgnoredTokens = ignoredTokens.filter((tokenAddress) => tokenAddress.toLowerCase() !== address.toLowerCase());
                const newDetectedTokens = detectedTokens.filter((token) => token.address.toLowerCase() !== address.toLowerCase());
                const { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens } = this._getNewAllTokensState({
                    newTokens,
                    newIgnoredTokens,
                    newDetectedTokens,
                });
                this.update({
                    tokens: newTokens,
                    ignoredTokens: newIgnoredTokens,
                    detectedTokens: newDetectedTokens,
                    allTokens: newAllTokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                    allDetectedTokens: newAllDetectedTokens,
                });
                return newTokens;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Add a batch of tokens.
     *
     * @param tokensToImport - Array of tokens to import.
     */
    addTokens(tokensToImport) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { tokens, detectedTokens, ignoredTokens } = this.state;
            const importedTokensMap = {};
            // Used later to dedupe imported tokens
            const newTokensMap = tokens.reduce((output, current) => {
                output[current.address] = current;
                return output;
            }, {});
            try {
                tokensToImport.forEach((tokenToAdd) => {
                    const { address, symbol, decimals, image, aggregators } = tokenToAdd;
                    const checksumAddress = (0, util_1.toChecksumHexAddress)(address);
                    const formattedToken = {
                        address: checksumAddress,
                        symbol,
                        decimals,
                        image,
                        aggregators,
                    };
                    newTokensMap[address] = formattedToken;
                    importedTokensMap[address.toLowerCase()] = true;
                    return formattedToken;
                });
                const newTokens = Object.values(newTokensMap);
                const newDetectedTokens = detectedTokens.filter((token) => !importedTokensMap[token.address.toLowerCase()]);
                const newIgnoredTokens = ignoredTokens.filter((tokenAddress) => !newTokensMap[tokenAddress.toLowerCase()]);
                const { newAllTokens, newAllDetectedTokens, newAllIgnoredTokens } = this._getNewAllTokensState({
                    newTokens,
                    newDetectedTokens,
                    newIgnoredTokens,
                });
                this.update({
                    tokens: newTokens,
                    allTokens: newAllTokens,
                    detectedTokens: newDetectedTokens,
                    allDetectedTokens: newAllDetectedTokens,
                    ignoredTokens: newIgnoredTokens,
                    allIgnoredTokens: newAllIgnoredTokens,
                });
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Ignore a batch of tokens.
     *
     * @param tokenAddressesToIgnore - Array of token addresses to ignore.
     */
    ignoreTokens(tokenAddressesToIgnore) {
        const { ignoredTokens, detectedTokens, tokens } = this.state;
        const ignoredTokensMap = {};
        let newIgnoredTokens = [...ignoredTokens];
        const checksummedTokenAddresses = tokenAddressesToIgnore.map((address) => {
            const checksumAddress = (0, util_1.toChecksumHexAddress)(address);
            ignoredTokensMap[address.toLowerCase()] = true;
            return checksumAddress;
        });
        newIgnoredTokens = [...ignoredTokens, ...checksummedTokenAddresses];
        const newDetectedTokens = detectedTokens.filter((token) => !ignoredTokensMap[token.address.toLowerCase()]);
        const newTokens = tokens.filter((token) => !ignoredTokensMap[token.address.toLowerCase()]);
        const { newAllIgnoredTokens, newAllDetectedTokens, newAllTokens } = this._getNewAllTokensState({
            newIgnoredTokens,
            newDetectedTokens,
            newTokens,
        });
        this.update({
            ignoredTokens: newIgnoredTokens,
            tokens: newTokens,
            detectedTokens: newDetectedTokens,
            allIgnoredTokens: newAllIgnoredTokens,
            allDetectedTokens: newAllDetectedTokens,
            allTokens: newAllTokens,
        });
    }
    /**
     * Adds a batch of detected tokens to the stored token list.
     *
     * @param incomingDetectedTokens - Array of detected tokens to be added or updated.
     */
    addDetectedTokens(incomingDetectedTokens) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            const { tokens, detectedTokens, ignoredTokens } = this.state;
            const newTokens = [...tokens];
            const newDetectedTokens = [...detectedTokens];
            try {
                incomingDetectedTokens.forEach((tokenToAdd) => {
                    const { address, symbol, decimals, image, aggregators, isERC721 } = tokenToAdd;
                    const checksumAddress = (0, util_1.toChecksumHexAddress)(address);
                    const newEntry = {
                        address: checksumAddress,
                        symbol,
                        decimals,
                        image,
                        isERC721,
                        aggregators,
                    };
                    const previousImportedEntry = newTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                    if (previousImportedEntry) {
                        // Update existing data of imported token
                        const previousImportedIndex = newTokens.indexOf(previousImportedEntry);
                        newTokens[previousImportedIndex] = newEntry;
                    }
                    else {
                        const ignoredTokenIndex = ignoredTokens.indexOf(address);
                        if (ignoredTokenIndex === -1) {
                            // Add detected token
                            const previousDetectedEntry = newDetectedTokens.find((token) => token.address.toLowerCase() === checksumAddress.toLowerCase());
                            if (previousDetectedEntry) {
                                const previousDetectedIndex = newDetectedTokens.indexOf(previousDetectedEntry);
                                newDetectedTokens[previousDetectedIndex] = newEntry;
                            }
                            else {
                                newDetectedTokens.push(newEntry);
                            }
                        }
                    }
                });
                const { newAllTokens, newAllDetectedTokens } = this._getNewAllTokensState({
                    newTokens,
                    newDetectedTokens,
                });
                this.update({
                    tokens: newTokens,
                    allTokens: newAllTokens,
                    detectedTokens: newDetectedTokens,
                    allDetectedTokens: newAllDetectedTokens,
                });
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Adds isERC721 field to token object. This is called when a user attempts to add tokens that
     * were previously added which do not yet had isERC721 field.
     *
     * @param tokenAddress - The contract address of the token requiring the isERC721 field added.
     * @returns The new token object with the added isERC721 field.
     */
    updateTokenType(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const isERC721 = yield this._detectIsERC721(tokenAddress);
            const { tokens } = this.state;
            const tokenIndex = tokens.findIndex((token) => {
                return token.address.toLowerCase() === tokenAddress.toLowerCase();
            });
            tokens[tokenIndex].isERC721 = isERC721;
            this.update({ tokens });
            return tokens[tokenIndex];
        });
    }
    /**
     * Detects whether or not a token is ERC-721 compatible.
     *
     * @param tokenAddress - The token contract address.
     * @returns A boolean indicating whether the token address passed in supports the EIP-721
     * interface.
     */
    _detectIsERC721(tokenAddress) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const checksumAddress = (0, util_1.toChecksumHexAddress)(tokenAddress);
            // if this token is already in our contract metadata map we don't need
            // to check against the contract
            if (((_a = contract_metadata_1.default[checksumAddress]) === null || _a === void 0 ? void 0 : _a.erc721) === true) {
                return Promise.resolve(true);
            }
            else if (((_b = contract_metadata_1.default[checksumAddress]) === null || _b === void 0 ? void 0 : _b.erc20) === true) {
                return Promise.resolve(false);
            }
            const tokenContract = yield this._createEthersContract(tokenAddress, metamask_eth_abis_1.abiERC721, this.ethersProvider);
            try {
                return yield tokenContract.supportsInterface(constants_1.ERC721_INTERFACE_ID);
            }
            catch (error) {
                // currently we see a variety of errors across different networks when
                // token contracts are not ERC721 compatible. We need to figure out a better
                // way of differentiating token interface types but for now if we get an error
                // we have to assume the token is not ERC721 compatible.
                return false;
            }
        });
    }
    _createEthersContract(tokenAddress, abi, ethersProvider) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenContract = yield new ethers_1.ethers.Contract(tokenAddress, abi, ethersProvider);
            return tokenContract;
        });
    }
    _generateRandomId() {
        return (0, uuid_1.v1)();
    }
    /**
     * Adds a new suggestedAsset to state. Parameters will be validated according to
     * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.
     *
     * @param asset - The asset to be watched. For now only ERC20 tokens are accepted.
     * @param type - The asset type.
     * @returns Object containing a Promise resolving to the suggestedAsset address if accepted.
     */
    watchAsset(asset, type) {
        return __awaiter(this, void 0, void 0, function* () {
            const suggestedAssetMeta = {
                asset,
                id: this._generateRandomId(),
                status: SuggestedAssetStatus.pending,
                time: Date.now(),
                type,
            };
            try {
                switch (type) {
                    case 'ERC20':
                        (0, util_1.validateTokenToWatch)(asset);
                        break;
                    default:
                        throw new Error(`Asset of type ${type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${suggestedAssetMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case SuggestedAssetStatus.accepted:
                            return resolve(meta.asset.address);
                        case SuggestedAssetStatus.rejected:
                            return reject(new Error('User rejected to watch the asset.'));
                        case SuggestedAssetStatus.failed:
                            return reject(new Error(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(new Error(`Unknown status: ${meta.status}`));
                    }
                });
            });
            const { suggestedAssets } = this.state;
            suggestedAssets.push(suggestedAssetMeta);
            this.update({ suggestedAssets: [...suggestedAssets] });
            this.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);
            return { result, suggestedAssetMeta };
        });
    }
    /**
     * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,
     * adding the asset to corresponding asset state. In this case ERC20 tokens.
     * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.
     *
     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
     */
    acceptWatchAsset(suggestedAssetID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { suggestedAssets } = this.state;
            const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
            const suggestedAssetMeta = suggestedAssets[index];
            try {
                switch (suggestedAssetMeta.type) {
                    case 'ERC20':
                        const { address, symbol, decimals, image } = suggestedAssetMeta.asset;
                        yield this.addToken(address, symbol, decimals, image);
                        suggestedAssetMeta.status = SuggestedAssetStatus.accepted;
                        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
                        break;
                    default:
                        throw new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);
                }
            }
            catch (error) {
                this.failSuggestedAsset(suggestedAssetMeta, error);
            }
            const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
            this.update({ suggestedAssets: [...newSuggestedAssets] });
        });
    }
    /**
     * Rejects a watchAsset request based on its ID by setting its status to "rejected"
     * and emitting a `<suggestedAssetMeta.id>:finished` hub event.
     *
     * @param suggestedAssetID - The ID of the suggestedAsset to accept.
     */
    rejectWatchAsset(suggestedAssetID) {
        const { suggestedAssets } = this.state;
        const index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);
        const suggestedAssetMeta = suggestedAssets[index];
        if (!suggestedAssetMeta) {
            return;
        }
        suggestedAssetMeta.status = SuggestedAssetStatus.rejected;
        this.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);
        const newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);
        this.update({ suggestedAssets: [...newSuggestedAssets] });
    }
    /**
     * Takes a new tokens and ignoredTokens array for the current network/account combination
     * and returns new allTokens and allIgnoredTokens state to update to.
     *
     * @param params - Object that holds token params.
     * @param params.newTokens - The new tokens to set for the current network and selected account.
     * @param params.newIgnoredTokens - The new ignored tokens to set for the current network and selected account.
     * @param params.newDetectedTokens - The new detected tokens to set for the current network and selected account.
     * @returns The updated `allTokens` and `allIgnoredTokens` state.
     */
    _getNewAllTokensState(params) {
        const { newTokens, newIgnoredTokens, newDetectedTokens } = params;
        const { allTokens, allIgnoredTokens, allDetectedTokens } = this.state;
        const { chainId, selectedAddress } = this.config;
        let newAllTokens = allTokens;
        if (newTokens) {
            const networkTokens = allTokens[chainId];
            const newNetworkTokens = Object.assign(Object.assign({}, networkTokens), { [selectedAddress]: newTokens });
            newAllTokens = Object.assign(Object.assign({}, allTokens), { [chainId]: newNetworkTokens });
        }
        let newAllIgnoredTokens = allIgnoredTokens;
        if (newIgnoredTokens) {
            const networkIgnoredTokens = allIgnoredTokens[chainId];
            const newIgnoredNetworkTokens = Object.assign(Object.assign({}, networkIgnoredTokens), { [selectedAddress]: newIgnoredTokens });
            newAllIgnoredTokens = Object.assign(Object.assign({}, allIgnoredTokens), { [chainId]: newIgnoredNetworkTokens });
        }
        let newAllDetectedTokens = allDetectedTokens;
        if (newDetectedTokens) {
            const networkDetectedTokens = allDetectedTokens[chainId];
            const newDetectedNetworkTokens = Object.assign(Object.assign({}, networkDetectedTokens), { [selectedAddress]: newDetectedTokens });
            newAllDetectedTokens = Object.assign(Object.assign({}, allDetectedTokens), { [chainId]: newDetectedNetworkTokens });
        }
        return { newAllTokens, newAllIgnoredTokens, newAllDetectedTokens };
    }
    /**
     * Removes all tokens from the ignored list.
     */
    clearIgnoredTokens() {
        this.update({ ignoredTokens: [], allIgnoredTokens: {} });
    }
}
exports.TokensController = TokensController;
exports.default = TokensController;
//# sourceMappingURL=TokensController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\assetsUtil.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\assets\assetsUtil.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatIconUrlWithProxy = exports.formatAggregatorNames = exports.compareCollectiblesMetadata = void 0;
const util_1 = require("../util");
/**
 * Compares collectible metadata entries to any collectible entry.
 * We need this method when comparing a new fetched collectible metadata, in case a entry changed to a defined value,
 * there's a need to update the collectible in state.
 *
 * @param newCollectibleMetadata - Collectible metadata object.
 * @param collectible - Collectible object to compare with.
 * @returns Whether there are differences.
 */
function compareCollectiblesMetadata(newCollectibleMetadata, collectible) {
    const keys = [
        'image',
        'backgroundColor',
        'imagePreview',
        'imageThumbnail',
        'imageOriginal',
        'animation',
        'animationOriginal',
        'externalLink',
    ];
    const differentValues = keys.reduce((value, key) => {
        if (newCollectibleMetadata[key] &&
            newCollectibleMetadata[key] !== collectible[key]) {
            return value + 1;
        }
        return value;
    }, 0);
    return differentValues > 0;
}
exports.compareCollectiblesMetadata = compareCollectiblesMetadata;
const aggregatorNameByKey = {
    aave: 'Aave',
    bancor: 'Bancor',
    cmc: 'CMC',
    cryptocom: 'Crypto.com',
    coinGecko: 'CoinGecko',
    oneInch: '1inch',
    paraswap: 'Paraswap',
    pmm: 'PMM',
    zapper: 'Zapper',
    zerion: 'Zerion',
    zeroEx: '0x',
    synthetix: 'Synthetix',
    yearn: 'Yearn',
    apeswap: 'ApeSwap',
    binanceDex: 'BinanceDex',
    pancakeTop100: 'PancakeTop100',
    pancakeExtended: 'PancakeExtended',
    balancer: 'Balancer',
    quickswap: 'QuickSwap',
    matcha: 'Matcha',
    pangolinDex: 'PangolinDex',
    pangolinDexStableCoin: 'PangolinDexStableCoin',
    pangolinDexAvaxBridge: 'PangolinDexAvaxBridge',
    traderJoe: 'TraderJoe',
    airswapLight: 'AirswapLight',
    kleros: 'Kleros',
};
/**
 * Formats aggregator names to presentable format.
 *
 * @param aggregators - List of token list names in camelcase.
 * @returns Formatted aggregator names.
 */
const formatAggregatorNames = (aggregators) => {
    return aggregators.map((key) => aggregatorNameByKey[key] ||
        `${key[0].toUpperCase()}${key.substring(1, key.length)}`);
};
exports.formatAggregatorNames = formatAggregatorNames;
/**
 * Format token list assets to use image proxy from Codefi.
 *
 * @param params - Object that contains chainID and tokenAddress.
 * @param params.chainId - ChainID of network in decimal or hexadecimal format.
 * @param params.tokenAddress - Address of token in mixed or lowercase.
 * @returns Formatted image url
 */
const formatIconUrlWithProxy = ({ chainId, tokenAddress, }) => {
    const chainIdDecimal = (0, util_1.convertHexToDecimal)(chainId).toString();
    return `https://static.metaswap.codefi.network/api/v1/tokenIcons/${chainIdDecimal}/${tokenAddress.toLowerCase()}.png`;
};
exports.formatIconUrlWithProxy = formatIconUrlWithProxy;
//# sourceMappingURL=assetsUtil.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\constants.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OPENSEA_TEST_API_URL = exports.OPENSEA_API_URL = exports.OPENSEA_PROXY_URL = exports.TESTNET_NETWORK_TYPE_TO_TICKER_SYMBOL = exports.TESTNET_TICKER_SYMBOLS = exports.ASSET_TYPES = exports.GWEI = exports.ERC1155_TOKEN_RECEIVER_INTERFACE_ID = exports.ERC1155_METADATA_URI_INTERFACE_ID = exports.ERC1155_INTERFACE_ID = exports.ERC721_ENUMERABLE_INTERFACE_ID = exports.ERC721_METADATA_INTERFACE_ID = exports.ERC721_INTERFACE_ID = exports.ERC20 = exports.ERC1155 = exports.ERC721 = exports.GANACHE_CHAIN_ID = exports.RINKEBY_CHAIN_ID = exports.IPFS_DEFAULT_GATEWAY_URL = exports.FALL_BACK_VS_CURRENCY = exports.RPC = exports.MAINNET = void 0;
exports.MAINNET = 'mainnet';
exports.RPC = 'rpc';
exports.FALL_BACK_VS_CURRENCY = 'ETH';
exports.IPFS_DEFAULT_GATEWAY_URL = 'https://cloudflare-ipfs.com/ipfs/';
// NETWORKS ID
exports.RINKEBY_CHAIN_ID = '4';
exports.GANACHE_CHAIN_ID = '1337';
// TOKEN STANDARDS
exports.ERC721 = 'ERC721';
exports.ERC1155 = 'ERC1155';
exports.ERC20 = 'ERC20';
// TOKEN INTERFACE IDS
exports.ERC721_INTERFACE_ID = '0x80ac58cd';
exports.ERC721_METADATA_INTERFACE_ID = '0x5b5e139f';
exports.ERC721_ENUMERABLE_INTERFACE_ID = '0x780e9d63';
exports.ERC1155_INTERFACE_ID = '0xd9b67a26';
exports.ERC1155_METADATA_URI_INTERFACE_ID = '0x0e89341c';
exports.ERC1155_TOKEN_RECEIVER_INTERFACE_ID = '0x4e2312e0';
// UNITS
exports.GWEI = 'gwei';
// ASSET TYPES
exports.ASSET_TYPES = {
    NATIVE: 'NATIVE',
    TOKEN: 'TOKEN',
    COLLECTIBLE: 'COLLECTIBLE',
    UNKNOWN: 'UNKNOWN',
};
// TICKER SYMBOLS
exports.TESTNET_TICKER_SYMBOLS = {
    RINKEBY: 'RinkebyETH',
    GOERLI: 'GoerliETH',
    ROPSTEN: 'RopstenETH',
    KOVAN: 'KovanETH',
};
// TYPED NetworkType TICKER SYMBOLS
exports.TESTNET_NETWORK_TYPE_TO_TICKER_SYMBOL = {
    rinkeby: 'RinkebyETH',
    goerli: 'GoerliETH',
    ropsten: 'RopstenETH',
    kovan: 'KovanETH',
    mainnet: '',
    rpc: '',
    localhost: '',
    optimism: '',
    optimismTest: '',
};
// APIs
exports.OPENSEA_PROXY_URL = 'https://proxy.metaswap.codefi.network/opensea/v1/api/v1';
exports.OPENSEA_API_URL = 'https://api.opensea.io/api/v1';
exports.OPENSEA_TEST_API_URL = 'https://testnets-api.opensea.io/api/v1';
//# sourceMappingURL=constants.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\GasFeeController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./determineGasFeeCalculations":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\determineGasFeeCalculations.js","./fetchGasEstimatesViaEthFeeHistory":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory.js","./gas-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\gas-util.js","eth-query":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\GasFeeController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GasFeeController = exports.GAS_ESTIMATE_TYPES = exports.LEGACY_GAS_PRICES_API_URL = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const uuid_1 = require("uuid");
const ethereumjs_util_1 = require("ethereumjs-util");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const gas_util_1 = require("./gas-util");
const determineGasFeeCalculations_1 = __importDefault(require("./determineGasFeeCalculations"));
const fetchGasEstimatesViaEthFeeHistory_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory"));
const GAS_FEE_API = 'https://mock-gas-server.herokuapp.com/';
exports.LEGACY_GAS_PRICES_API_URL = `https://api.metaswap.codefi.network/gasPrices`;
/**
 * Indicates which type of gasEstimate the controller is currently returning.
 * This is useful as a way of asserting that the shape of gasEstimates matches
 * expectations. NONE is a special case indicating that no previous gasEstimate
 * has been fetched.
 */
exports.GAS_ESTIMATE_TYPES = {
    FEE_MARKET: 'fee-market',
    LEGACY: 'legacy',
    ETH_GASPRICE: 'eth_gasPrice',
    NONE: 'none',
};
const metadata = {
    gasFeeEstimates: { persist: true, anonymous: false },
    estimatedGasFeeTimeBounds: { persist: true, anonymous: false },
    gasEstimateType: { persist: true, anonymous: false },
};
const name = 'GasFeeController';
const defaultState = {
    gasFeeEstimates: {},
    estimatedGasFeeTimeBounds: {},
    gasEstimateType: exports.GAS_ESTIMATE_TYPES.NONE,
};
/**
 * Controller that retrieves gas fee estimate data and polls for updated data on a set interval
 */
class GasFeeController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a GasFeeController instance.
     *
     * @param options - The controller options.
     * @param options.interval - The time in milliseconds to wait between polls.
     * @param options.messenger - The controller messenger.
     * @param options.state - The initial state.
     * @param options.getCurrentNetworkEIP1559Compatibility - Determines whether or not the current
     * network is EIP-1559 compatible.
     * @param options.getCurrentNetworkLegacyGasAPICompatibility - Determines whether or not the
     * current network is compatible with the legacy gas price API.
     * @param options.getCurrentAccountEIP1559Compatibility - Determines whether or not the current
     * account is EIP-1559 compatible.
     * @param options.getChainId - Returns the current chain ID.
     * @param options.getProvider - Returns a network provider for the current network.
     * @param options.onNetworkStateChange - A function for registering an event handler for the
     * network state change event.
     * @param options.legacyAPIEndpoint - The legacy gas price API URL. This option is primarily for
     * testing purposes.
     * @param options.EIP1559APIEndpoint - The EIP-1559 gas price API URL. This option is primarily
     * for testing purposes.
     * @param options.clientId - The client ID used to identify to the gas estimation API who is
     * asking for estimates.
     */
    constructor({ interval = 15000, messenger, state, getCurrentNetworkEIP1559Compatibility, getCurrentAccountEIP1559Compatibility, getChainId, getCurrentNetworkLegacyGasAPICompatibility, getProvider, onNetworkStateChange, legacyAPIEndpoint = exports.LEGACY_GAS_PRICES_API_URL, EIP1559APIEndpoint = GAS_FEE_API, clientId, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.intervalDelay = interval;
        this.pollTokens = new Set();
        this.getCurrentNetworkEIP1559Compatibility =
            getCurrentNetworkEIP1559Compatibility;
        this.getCurrentNetworkLegacyGasAPICompatibility =
            getCurrentNetworkLegacyGasAPICompatibility;
        this.getCurrentAccountEIP1559Compatibility =
            getCurrentAccountEIP1559Compatibility;
        this.EIP1559APIEndpoint = EIP1559APIEndpoint;
        this.legacyAPIEndpoint = legacyAPIEndpoint;
        this.getChainId = getChainId;
        this.currentChainId = this.getChainId();
        const provider = getProvider();
        this.ethQuery = new eth_query_1.default(provider);
        this.clientId = clientId;
        onNetworkStateChange(() => __awaiter(this, void 0, void 0, function* () {
            const newProvider = getProvider();
            const newChainId = this.getChainId();
            this.ethQuery = new eth_query_1.default(newProvider);
            if (this.currentChainId !== newChainId) {
                this.currentChainId = newChainId;
                yield this.resetPolling();
            }
        }));
    }
    resetPolling() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pollTokens.size !== 0) {
                const tokens = Array.from(this.pollTokens);
                this.stopPolling();
                yield this.getGasFeeEstimatesAndStartPolling(tokens[0]);
                tokens.slice(1).forEach((token) => {
                    this.pollTokens.add(token);
                });
            }
        });
    }
    fetchGasFeeEstimates(options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this._fetchGasFeeEstimateData(options);
        });
    }
    getGasFeeEstimatesAndStartPolling(pollToken) {
        return __awaiter(this, void 0, void 0, function* () {
            const _pollToken = pollToken || (0, uuid_1.v1)();
            this.pollTokens.add(_pollToken);
            if (this.pollTokens.size === 1) {
                yield this._fetchGasFeeEstimateData();
                this._poll();
            }
            return _pollToken;
        });
    }
    /**
     * Gets and sets gasFeeEstimates in state.
     *
     * @param options - The gas fee estimate options.
     * @param options.shouldUpdateState - Determines whether the state should be updated with the
     * updated gas estimates.
     * @returns The gas fee estimates.
     */
    _fetchGasFeeEstimateData(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { shouldUpdateState = true } = options;
            let isEIP1559Compatible;
            const isLegacyGasAPICompatible = this.getCurrentNetworkLegacyGasAPICompatibility();
            let chainId = this.getChainId();
            if (typeof chainId === 'string' && (0, ethereumjs_util_1.isHexString)(chainId)) {
                chainId = parseInt(chainId, 16);
            }
            try {
                isEIP1559Compatible = yield this.getEIP1559Compatibility();
            }
            catch (e) {
                console.error(e);
                isEIP1559Compatible = false;
            }
            const gasFeeCalculations = yield (0, determineGasFeeCalculations_1.default)({
                isEIP1559Compatible,
                isLegacyGasAPICompatible,
                fetchGasEstimates: gas_util_1.fetchGasEstimates,
                fetchGasEstimatesUrl: this.EIP1559APIEndpoint.replace('<chain_id>', `${chainId}`),
                fetchGasEstimatesViaEthFeeHistory: fetchGasEstimatesViaEthFeeHistory_1.default,
                fetchLegacyGasPriceEstimates: gas_util_1.fetchLegacyGasPriceEstimates,
                fetchLegacyGasPriceEstimatesUrl: this.legacyAPIEndpoint.replace('<chain_id>', `${chainId}`),
                fetchEthGasPriceEstimate: gas_util_1.fetchEthGasPriceEstimate,
                calculateTimeEstimate: gas_util_1.calculateTimeEstimate,
                clientId: this.clientId,
                ethQuery: this.ethQuery,
            });
            if (shouldUpdateState) {
                this.update((state) => {
                    state.gasFeeEstimates = gasFeeCalculations.gasFeeEstimates;
                    state.estimatedGasFeeTimeBounds =
                        gasFeeCalculations.estimatedGasFeeTimeBounds;
                    state.gasEstimateType = gasFeeCalculations.gasEstimateType;
                });
            }
            return gasFeeCalculations;
        });
    }
    /**
     * Remove the poll token, and stop polling if the set of poll tokens is empty.
     *
     * @param pollToken - The poll token to disconnect.
     */
    disconnectPoller(pollToken) {
        this.pollTokens.delete(pollToken);
        if (this.pollTokens.size === 0) {
            this.stopPolling();
        }
    }
    stopPolling() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.pollTokens.clear();
        this.resetState();
    }
    /**
     * Prepare to discard this controller.
     *
     * This stops any active polling.
     */
    destroy() {
        super.destroy();
        this.stopPolling();
    }
    _poll() {
        if (this.intervalId) {
            clearInterval(this.intervalId);
        }
        this.intervalId = setInterval(() => __awaiter(this, void 0, void 0, function* () {
            yield (0, util_1.safelyExecute)(() => this._fetchGasFeeEstimateData());
        }), this.intervalDelay);
    }
    resetState() {
        this.update(() => {
            return defaultState;
        });
    }
    getEIP1559Compatibility() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const currentNetworkIsEIP1559Compatible = yield this.getCurrentNetworkEIP1559Compatibility();
            const currentAccountIsEIP1559Compatible = (_b = (_a = this.getCurrentAccountEIP1559Compatibility) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : true;
            return (currentNetworkIsEIP1559Compatible && currentAccountIsEIP1559Compatible);
        });
    }
    getTimeEstimate(maxPriorityFeePerGas, maxFeePerGas) {
        if (!this.state.gasFeeEstimates ||
            this.state.gasEstimateType !== exports.GAS_ESTIMATE_TYPES.FEE_MARKET) {
            return {};
        }
        return (0, gas_util_1.calculateTimeEstimate)(maxPriorityFeePerGas, maxFeePerGas, this.state.gasFeeEstimates);
    }
}
exports.GasFeeController = GasFeeController;
exports.default = GasFeeController;
//# sourceMappingURL=GasFeeController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\determineGasFeeCalculations.js", {"./GasFeeController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\GasFeeController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\determineGasFeeCalculations.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const GasFeeController_1 = require("./GasFeeController");
/**
 * Obtains a set of max base and priority fee estimates along with time estimates so that we
 * can present them to users when they are sending transactions or making swaps.
 *
 * @param args - The arguments.
 * @param args.isEIP1559Compatible - Governs whether or not we can use an EIP-1559-only method to
 * produce estimates.
 * @param args.isLegacyGasAPICompatible - Governs whether or not we can use a non-EIP-1559 method to
 * produce estimates (for instance, testnets do not support estimates altogether).
 * @param args.fetchGasEstimates - A function that fetches gas estimates using an EIP-1559-specific
 * API.
 * @param args.fetchGasEstimatesUrl - The URL for the API we can use to obtain EIP-1559-specific
 * estimates.
 * @param args.fetchGasEstimatesViaEthFeeHistory - A function that fetches gas estimates using
 * `eth_feeHistory` (an EIP-1559 feature).
 * @param args.fetchLegacyGasPriceEstimates - A function that fetches gas estimates using an
 * non-EIP-1559-specific API.
 * @param args.fetchLegacyGasPriceEstimatesUrl - The URL for the API we can use to obtain
 * non-EIP-1559-specific estimates.
 * @param args.fetchEthGasPriceEstimate - A function that fetches gas estimates using
 * `eth_gasPrice`.
 * @param args.calculateTimeEstimate - A function that determine time estimate bounds.
 * @param args.clientId - An identifier that an API can use to know who is asking for estimates.
 * @param args.ethQuery - An EthQuery instance we can use to talk to Ethereum directly.
 * @returns The gas fee calculations.
 */
function determineGasFeeCalculations({ isEIP1559Compatible, isLegacyGasAPICompatible, fetchGasEstimates, fetchGasEstimatesUrl, fetchGasEstimatesViaEthFeeHistory, fetchLegacyGasPriceEstimates, fetchLegacyGasPriceEstimatesUrl, fetchEthGasPriceEstimate, calculateTimeEstimate, clientId, ethQuery, }) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            if (isEIP1559Compatible) {
                let estimates;
                try {
                    estimates = yield fetchGasEstimates(fetchGasEstimatesUrl, clientId);
                }
                catch (_a) {
                    estimates = yield fetchGasEstimatesViaEthFeeHistory(ethQuery);
                }
                const { suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas } = estimates.medium;
                const estimatedGasFeeTimeBounds = calculateTimeEstimate(suggestedMaxPriorityFeePerGas, suggestedMaxFeePerGas, estimates);
                return {
                    gasFeeEstimates: estimates,
                    estimatedGasFeeTimeBounds,
                    gasEstimateType: GasFeeController_1.GAS_ESTIMATE_TYPES.FEE_MARKET,
                };
            }
            else if (isLegacyGasAPICompatible) {
                const estimates = yield fetchLegacyGasPriceEstimates(fetchLegacyGasPriceEstimatesUrl, clientId);
                return {
                    gasFeeEstimates: estimates,
                    estimatedGasFeeTimeBounds: {},
                    gasEstimateType: GasFeeController_1.GAS_ESTIMATE_TYPES.LEGACY,
                };
            }
            throw new Error('Main gas fee/price estimation failed. Use fallback');
        }
        catch (_b) {
            try {
                const estimates = yield fetchEthGasPriceEstimate(ethQuery);
                return {
                    gasFeeEstimates: estimates,
                    estimatedGasFeeTimeBounds: {},
                    gasEstimateType: GasFeeController_1.GAS_ESTIMATE_TYPES.ETH_GASPRICE,
                };
            }
            catch (error) {
                if (error instanceof Error) {
                    throw new Error(`Gas fee/price estimation failed. Message: ${error.message}`);
                }
                throw error;
            }
        }
    });
}
exports.default = determineGasFeeCalculations;
//# sourceMappingURL=determineGasFeeCalculations.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchBlockFeeHistory.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\fetchBlockFeeHistory.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("ethereumjs-util");
const util_1 = require("../util");
const MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL = 1024;
/**
 * Uses `eth_feeHistory` (an EIP-1559 feature) to obtain information about gas fees from a range of
 * blocks that have occurred recently on a network.
 *
 * To learn more, see these resources:
 *
 * - <https://infura.io/docs/ethereum#operation/eth_feeHistory>
 * - <https://github.com/zsfelfoldi/feehistory/blob/main/docs/feeHistory.md>
 * - <https://github.com/ethereum/go-ethereum/blob/57a3fab8a75eeb9c2f4fab770b73b51b9fe672c5/eth/gasprice/feehistory.go#L180>
 * - <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md>
 * - <https://gas-api.metaswap.codefi.network/testFeeHistory>
 *
 * @param args - The arguments to this function.
 * @param args.ethQuery - An EthQuery instance that wraps a provider for the network in question.
 * @param args.endBlock - The desired end of the requested block range. Can be "latest" if you want
 * to start from the latest successful block or the number of a known past block.
 * @param args.numberOfBlocks - How many total blocks to fetch. Note that if this is more than 1024,
 * multiple calls to `eth_feeHistory` will be made.
 * @param args.percentiles - A set of numbers between 1 and 100 which will dictate how
 * `priorityFeesByPercentile` in each returned block will be formed. When Ethereum runs the
 * `eth_feeHistory` method, for each block it is considering, it will first sort all transactions by
 * the priority fee. It will then go through each transaction and add the total amount of gas paid
 * for that transaction to a bucket which maxes out at the total gas used for the whole block. As
 * the bucket fills, it will cross percentages which correspond to the percentiles specified here,
 * and the priority fees of the first transactions which cause it to reach those percentages will be
 * recorded. Hence, `priorityFeesByPercentile` represents the priority fees of transactions at key
 * gas used contribution levels, where earlier levels have smaller contributions and later levels
 * have higher contributions.
 * @param args.includeNextBlock - Whether to include an extra block that represents the next
 * block after the latest one. Only the `baseFeePerGas` will be filled in for this block (which is
 * estimated).
 * @returns The list of blocks and their fee data, sorted from oldest to newest.
 */
function fetchBlockFeeHistory({ ethQuery, numberOfBlocks: totalNumberOfBlocks, endBlock: givenEndBlock = 'latest', percentiles: givenPercentiles = [], includeNextBlock = false, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const percentiles = givenPercentiles.length > 0
            ? Array.from(new Set(givenPercentiles)).sort((a, b) => a - b)
            : [];
        const finalEndBlockNumber = givenEndBlock === 'latest'
            ? (0, util_1.fromHex)(yield (0, util_1.query)(ethQuery, 'blockNumber'))
            : givenEndBlock;
        const requestChunkSpecifiers = determineRequestChunkSpecifiers(finalEndBlockNumber, totalNumberOfBlocks);
        const blockChunks = yield Promise.all(requestChunkSpecifiers.map(({ numberOfBlocks, endBlockNumber }, i) => {
            return i === requestChunkSpecifiers.length - 1
                ? makeRequestForChunk({
                    ethQuery,
                    numberOfBlocks,
                    endBlockNumber,
                    percentiles,
                    includeNextBlock,
                })
                : makeRequestForChunk({
                    ethQuery,
                    numberOfBlocks,
                    endBlockNumber,
                    percentiles,
                    includeNextBlock: false,
                });
        }));
        return blockChunks.reduce((array, blocks) => [...array, ...blocks], []);
    });
}
exports.default = fetchBlockFeeHistory;
/**
 * Builds an ExistingFeeHistoryBlock.
 *
 * @param args - The args to this function.
 * @param args.number - The number of the block.
 * @param args.baseFeePerGas - The base fee per gas of the block.
 * @param args.blockIndex - The index of the block in the source chunk.
 * @param args.gasUsedRatios - The gas used ratios for the block.
 * @param args.priorityFeePercentileGroups - The priority fee percentile groups for the block.
 * @param args.percentiles - The percentiles used to fetch the source chunk.
 * @returns The ExistingFeeHistoryBlock.
 */
function buildExistingFeeHistoryBlock({ baseFeePerGas, number, blockIndex, gasUsedRatios, priorityFeePercentileGroups, percentiles, }) {
    const gasUsedRatio = gasUsedRatios[blockIndex];
    const priorityFeesForEachPercentile = priorityFeePercentileGroups[blockIndex];
    const priorityFeesByPercentile = percentiles.reduce((obj, percentile, percentileIndex) => {
        const priorityFee = priorityFeesForEachPercentile[percentileIndex];
        return Object.assign(Object.assign({}, obj), { [percentile]: (0, util_1.fromHex)(priorityFee) });
    }, {});
    return {
        number,
        baseFeePerGas,
        gasUsedRatio,
        priorityFeesByPercentile,
    };
}
/**
 * Builds a NextFeeHistoryBlock.
 *
 * @param args - The args to this function.
 * @param args.baseFeePerGas - The base fee per gas of the block.
 * @param args.number - The number of the block.
 * @returns The NextFeeHistoryBlock.
 */
function buildNextFeeHistoryBlock({ baseFeePerGas, number, }) {
    return {
        number,
        baseFeePerGas,
        gasUsedRatio: null,
        priorityFeesByPercentile: null,
    };
}
/**
 * Uses eth_feeHistory to request historical data about a group of blocks (max size 1024).
 *
 * @param args - The arguments
 * @param args.ethQuery - An EthQuery instance.
 * @param args.numberOfBlocks - The number of blocks in the chunk. Must be at most 1024, as this is
 * the maximum that `eth_feeHistory` can return in one call.
 * @param args.endBlockNumber - The end of the requested block range.
 * @param args.percentiles - A set of numbers between 1 and 100 that will be used to pull priority
 * fees for each block.
 * @param args.includeNextBlock - Whether to include an extra block that represents the next
 * block after the latest one. Only the `baseFeePerGas` will be filled in for this block (which is
 * estimated).
 * @returns A list of block data.
 */
function makeRequestForChunk({ ethQuery, numberOfBlocks, endBlockNumber, percentiles, includeNextBlock, }) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield (0, util_1.query)(ethQuery, 'eth_feeHistory', [(0, util_1.toHex)(numberOfBlocks), (0, util_1.toHex)(endBlockNumber), percentiles]);
        const startBlockNumber = (0, util_1.fromHex)(response.oldestBlock);
        if (response.baseFeePerGas !== undefined &&
            response.baseFeePerGas.length > 0 &&
            response.gasUsedRatio.length > 0 &&
            (response.reward === undefined || response.reward.length > 0)) {
            // Per
            // <https://github.com/ethereum/go-ethereum/blob/57a3fab8a75eeb9c2f4fab770b73b51b9fe672c5/eth/gasprice/feehistory.go#L191-L192>,
            // baseFeePerGas will always include an extra item which is the calculated base fee for the
            // next (future) block. We may or may not care about this; if we don't, chop it off.
            const baseFeesPerGasAsHex = includeNextBlock
                ? response.baseFeePerGas
                : response.baseFeePerGas.slice(0, numberOfBlocks);
            const gasUsedRatios = response.gasUsedRatio;
            const priorityFeePercentileGroups = (_a = response.reward) !== null && _a !== void 0 ? _a : [];
            // Chain is allowed to return fewer number of block results
            const numberOfExistingResults = gasUsedRatios.length;
            return baseFeesPerGasAsHex.map((baseFeePerGasAsHex, blockIndex) => {
                const baseFeePerGas = (0, util_1.fromHex)(baseFeePerGasAsHex);
                const number = startBlockNumber.addn(blockIndex);
                return blockIndex >= numberOfExistingResults
                    ? buildNextFeeHistoryBlock({ baseFeePerGas, number })
                    : buildExistingFeeHistoryBlock({
                        baseFeePerGas,
                        number,
                        blockIndex,
                        gasUsedRatios,
                        priorityFeePercentileGroups,
                        percentiles,
                    });
            });
        }
        return [];
    });
}
/**
 * Divides a block range (specified by a range size and the end of the range) into chunks based on
 * the maximum number of blocks that `eth_feeHistory` can return in a single call.
 *
 * If the requested totalNumberOfBlocks exceed endBlockNumber, totalNumberOfBlocks is
 * truncated to avoid requesting chunks with negative endBlockNumber.
 *
 * @param endBlockNumber - The final block in the complete desired block range after all
 * `eth_feeHistory` requests have been made.
 * @param totalNumberOfBlocks - The total number of desired blocks after all `eth_feeHistory`
 * requests have been made.
 * @returns A set of arguments that can be used to make requests to `eth_feeHistory` in order to
 * retrieve all of the requested blocks, sorted from oldest block to newest block.
 */
function determineRequestChunkSpecifiers(endBlockNumber, totalNumberOfBlocks) {
    if (endBlockNumber.lt(new ethereumjs_util_1.BN(totalNumberOfBlocks))) {
        totalNumberOfBlocks = endBlockNumber.toNumber();
    }
    const specifiers = [];
    for (let chunkStartBlockNumber = endBlockNumber.subn(totalNumberOfBlocks); chunkStartBlockNumber.lt(endBlockNumber); chunkStartBlockNumber = chunkStartBlockNumber.addn(MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL)) {
        const distanceToEnd = endBlockNumber.sub(chunkStartBlockNumber).toNumber();
        const numberOfBlocks = distanceToEnd < MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL
            ? distanceToEnd
            : MAX_NUMBER_OF_BLOCKS_PER_ETH_FEE_HISTORY_CALL;
        const chunkEndBlockNumber = chunkStartBlockNumber.addn(numberOfBlocks);
        specifiers.push({ numberOfBlocks, endBlockNumber: chunkEndBlockNumber });
    }
    return specifiers;
}
//# sourceMappingURL=fetchBlockFeeHistory.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory.js", {"../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","./fetchBlockFeeHistory":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchBlockFeeHistory.js","./fetchGasEstimatesViaEthFeeHistory/calculateGasFeeEstimatesForPriorityLevels":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory\\calculateGasFeeEstimatesForPriorityLevels.js","./fetchGasEstimatesViaEthFeeHistory/fetchLatestBlock":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory\\fetchLatestBlock.js","ethjs-unit":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethjs-unit\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\fetchGasEstimatesViaEthFeeHistory.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethjs_unit_1 = require("ethjs-unit");
const constants_1 = require("../constants");
const fetchBlockFeeHistory_1 = __importDefault(require("./fetchBlockFeeHistory"));
const fetchLatestBlock_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory/fetchLatestBlock"));
const calculateGasFeeEstimatesForPriorityLevels_1 = __importDefault(require("./fetchGasEstimatesViaEthFeeHistory/calculateGasFeeEstimatesForPriorityLevels"));
/**
 * Generates gas fee estimates based on gas fees that have been used in the recent past so that
 * those estimates can be displayed to users.
 *
 * To produce the estimates, the last 5 blocks are read from the network, and for each block, the
 * priority fees for transactions at the 10th, 20th, and 30th percentiles are also read (here
 * "percentile" signifies the level at which those transactions contribute to the overall gas used
 * for the block, where higher percentiles correspond to higher fees). This information is used to
 * calculate reasonable max priority and max fees for three different priority levels (higher
 * priority = higher fee).
 *
 * Note that properties are returned for other data that are normally obtained via the API; however,
 * to prevent extra requests to Infura, these properties are empty.
 *
 * @param ethQuery - An EthQuery instance.
 * @returns Base and priority fee estimates, categorized by priority level, as well as an estimate
 * for the next block's base fee.
 */
function fetchGasEstimatesViaEthFeeHistory(ethQuery) {
    return __awaiter(this, void 0, void 0, function* () {
        const latestBlock = yield (0, fetchLatestBlock_1.default)(ethQuery);
        const blocks = yield (0, fetchBlockFeeHistory_1.default)({
            ethQuery,
            endBlock: latestBlock.number,
            numberOfBlocks: 5,
            percentiles: [10, 20, 30],
        });
        const estimatedBaseFee = (0, ethjs_unit_1.fromWei)(latestBlock.baseFeePerGas, constants_1.GWEI);
        const levelSpecificEstimates = (0, calculateGasFeeEstimatesForPriorityLevels_1.default)(blocks);
        return Object.assign(Object.assign({}, levelSpecificEstimates), { estimatedBaseFee, historicalBaseFeeRange: null, baseFeeTrend: null, latestPriorityFeeRange: null, historicalPriorityFeeRange: null, priorityFeeTrend: null, networkCongestion: null });
    });
}
exports.default = fetchGasEstimatesViaEthFeeHistory;
//# sourceMappingURL=fetchGasEstimatesViaEthFeeHistory.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory\\calculateGasFeeEstimatesForPriorityLevels.js", {"../../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","./medianOf":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory\\medianOf.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethjs-unit":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethjs-unit\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\fetchGasEstimatesViaEthFeeHistory\calculateGasFeeEstimatesForPriorityLevels.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_unit_1 = require("ethjs-unit");
const constants_1 = require("../../constants");
const medianOf_1 = __importDefault(require("./medianOf"));
const PRIORITY_LEVELS = ['low', 'medium', 'high'];
const PRIORITY_LEVEL_PERCENTILES = [10, 20, 30];
const SETTINGS_BY_PRIORITY_LEVEL = {
    low: {
        percentile: 10,
        baseFeePercentageMultiplier: new ethereumjs_util_1.BN(110),
        priorityFeePercentageMultiplier: new ethereumjs_util_1.BN(94),
        minSuggestedMaxPriorityFeePerGas: new ethereumjs_util_1.BN(1000000000),
        estimatedWaitTimes: {
            minWaitTimeEstimate: 15000,
            maxWaitTimeEstimate: 30000,
        },
    },
    medium: {
        percentile: 20,
        baseFeePercentageMultiplier: new ethereumjs_util_1.BN(120),
        priorityFeePercentageMultiplier: new ethereumjs_util_1.BN(97),
        minSuggestedMaxPriorityFeePerGas: new ethereumjs_util_1.BN(1500000000),
        estimatedWaitTimes: {
            minWaitTimeEstimate: 15000,
            maxWaitTimeEstimate: 45000,
        },
    },
    high: {
        percentile: 30,
        baseFeePercentageMultiplier: new ethereumjs_util_1.BN(125),
        priorityFeePercentageMultiplier: new ethereumjs_util_1.BN(98),
        minSuggestedMaxPriorityFeePerGas: new ethereumjs_util_1.BN(2000000000),
        estimatedWaitTimes: {
            minWaitTimeEstimate: 15000,
            maxWaitTimeEstimate: 60000,
        },
    },
};
/**
 * Calculates a set of estimates assigned to a particular priority level based on the data returned
 * by `eth_feeHistory`.
 *
 * @param priorityLevel - The level of fees that dictates how soon a transaction may go through
 * ("low", "medium", or "high").
 * @param blocks - A set of blocks as obtained from {@link fetchBlockFeeHistory}.
 * @returns The estimates.
 */
function calculateEstimatesForPriorityLevel(priorityLevel, blocks) {
    const settings = SETTINGS_BY_PRIORITY_LEVEL[priorityLevel];
    const latestBaseFeePerGas = blocks[blocks.length - 1].baseFeePerGas;
    const adjustedBaseFee = latestBaseFeePerGas
        .mul(settings.baseFeePercentageMultiplier)
        .divn(100);
    const priorityFees = blocks
        .map((block) => {
        return 'priorityFeesByPercentile' in block
            ? block.priorityFeesByPercentile[settings.percentile]
            : null;
    })
        .filter(ethereumjs_util_1.BN.isBN);
    const medianPriorityFee = (0, medianOf_1.default)(priorityFees);
    const adjustedPriorityFee = medianPriorityFee
        .mul(settings.priorityFeePercentageMultiplier)
        .divn(100);
    const suggestedMaxPriorityFeePerGas = ethereumjs_util_1.BN.max(adjustedPriorityFee, settings.minSuggestedMaxPriorityFeePerGas);
    const suggestedMaxFeePerGas = adjustedBaseFee.add(suggestedMaxPriorityFeePerGas);
    return Object.assign(Object.assign({}, settings.estimatedWaitTimes), { suggestedMaxPriorityFeePerGas: (0, ethjs_unit_1.fromWei)(suggestedMaxPriorityFeePerGas, constants_1.GWEI), suggestedMaxFeePerGas: (0, ethjs_unit_1.fromWei)(suggestedMaxFeePerGas, constants_1.GWEI) });
}
/**
 * Calculates a set of estimates suitable for different priority levels based on the data returned
 * by `eth_feeHistory`.
 *
 * @param blocks - A set of blocks populated with data for priority fee percentiles 10, 20, and 30,
 * obtained via {@link BlockFeeHistoryDatasetFetcher}.
 * @returns The estimates.
 */
function calculateGasFeeEstimatesForPriorityLevels(blocks) {
    return PRIORITY_LEVELS.reduce((obj, priorityLevel) => {
        const gasEstimatesForPriorityLevel = calculateEstimatesForPriorityLevel(priorityLevel, blocks);
        return Object.assign(Object.assign({}, obj), { [priorityLevel]: gasEstimatesForPriorityLevel });
    }, {});
}
exports.default = calculateGasFeeEstimatesForPriorityLevels;
//# sourceMappingURL=calculateGasFeeEstimatesForPriorityLevels.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory\\fetchLatestBlock.js", {"../../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\fetchGasEstimatesViaEthFeeHistory\fetchLatestBlock.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../../util");
/**
 * Returns information about the latest completed block.
 *
 * @param ethQuery - An EthQuery instance
 * @param includeFullTransactionData - Whether or not to include all data for transactions as
 * opposed to merely hashes. False by default.
 * @returns The block.
 */
function fetchLatestBlock(ethQuery, includeFullTransactionData = false) {
    return __awaiter(this, void 0, void 0, function* () {
        const blockNumber = yield (0, util_1.query)(ethQuery, 'blockNumber');
        const block = yield (0, util_1.query)(ethQuery, 'getBlockByNumber', [
            blockNumber,
            includeFullTransactionData,
        ]);
        return Object.assign(Object.assign({}, block), { number: (0, util_1.fromHex)(block.number), baseFeePerGas: (0, util_1.fromHex)(block.baseFeePerGas) });
    });
}
exports.default = fetchLatestBlock;
//# sourceMappingURL=fetchLatestBlock.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\fetchGasEstimatesViaEthFeeHistory\\medianOf.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\fetchGasEstimatesViaEthFeeHistory\medianOf.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Finds the median among a list of numbers. Note that this is different from the implementation
 * in the MetaSwap API, as we want to hold to using BN as much as possible.
 *
 * @param numbers - A list of numbers, as BNs. Will be sorted automatically if unsorted.
 * @returns The median number.
 */
function medianOf(numbers) {
    const sortedNumbers = numbers.slice().sort((a, b) => a.cmp(b));
    const len = sortedNumbers.length;
    const index = Math.floor((len - 1) / 2);
    return sortedNumbers[index];
}
exports.default = medianOf;
//# sourceMappingURL=medianOf.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\gas-util.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\gas\gas-util.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTimeEstimate = exports.fetchEthGasPriceEstimate = exports.fetchLegacyGasPriceEstimates = exports.fetchGasEstimates = exports.normalizeGWEIDecimalNumbers = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const util_1 = require("../util");
const makeClientIdHeader = (clientId) => ({ 'X-Client-Id': clientId });
/**
 * Convert a decimal GWEI value to a decimal string rounded to the nearest WEI.
 *
 * @param n - The input GWEI amount, as a decimal string or a number.
 * @returns The decimal string GWEI amount.
 */
function normalizeGWEIDecimalNumbers(n) {
    const numberAsWEIHex = (0, util_1.gweiDecToWEIBN)(n).toString(16);
    const numberAsGWEI = (0, util_1.weiHexToGweiDec)(numberAsWEIHex).toString(10);
    return numberAsGWEI;
}
exports.normalizeGWEIDecimalNumbers = normalizeGWEIDecimalNumbers;
/**
 * Fetch gas estimates from the given URL.
 *
 * @param url - The gas estimate URL.
 * @param clientId - The client ID used to identify to the API who is asking for estimates.
 * @returns The gas estimates.
 */
function fetchGasEstimates(url, clientId) {
    return __awaiter(this, void 0, void 0, function* () {
        const estimates = yield (0, util_1.handleFetch)(url, clientId ? { headers: makeClientIdHeader(clientId) } : undefined);
        return {
            low: Object.assign(Object.assign({}, estimates.low), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.low.suggestedMaxFeePerGas) }),
            medium: Object.assign(Object.assign({}, estimates.medium), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.medium.suggestedMaxFeePerGas) }),
            high: Object.assign(Object.assign({}, estimates.high), { suggestedMaxPriorityFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxPriorityFeePerGas), suggestedMaxFeePerGas: normalizeGWEIDecimalNumbers(estimates.high.suggestedMaxFeePerGas) }),
            estimatedBaseFee: normalizeGWEIDecimalNumbers(estimates.estimatedBaseFee),
            historicalBaseFeeRange: estimates.historicalBaseFeeRange,
            baseFeeTrend: estimates.baseFeeTrend,
            latestPriorityFeeRange: estimates.latestPriorityFeeRange,
            historicalPriorityFeeRange: estimates.historicalPriorityFeeRange,
            priorityFeeTrend: estimates.priorityFeeTrend,
            networkCongestion: estimates.networkCongestion,
        };
    });
}
exports.fetchGasEstimates = fetchGasEstimates;
/**
 * Hit the legacy MetaSwaps gasPrices estimate api and return the low, medium
 * high values from that API.
 *
 * @param url - The URL to fetch gas price estimates from.
 * @param clientId - The client ID used to identify to the API who is asking for estimates.
 * @returns The gas price estimates.
 */
function fetchLegacyGasPriceEstimates(url, clientId) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield (0, util_1.handleFetch)(url, {
            referrer: url,
            referrerPolicy: 'no-referrer-when-downgrade',
            method: 'GET',
            mode: 'cors',
            headers: Object.assign({ 'Content-Type': 'application/json' }, (clientId && makeClientIdHeader(clientId))),
        });
        return {
            low: result.SafeGasPrice,
            medium: result.ProposeGasPrice,
            high: result.FastGasPrice,
        };
    });
}
exports.fetchLegacyGasPriceEstimates = fetchLegacyGasPriceEstimates;
/**
 * Get a gas price estimate from the network using the `eth_gasPrice` method.
 *
 * @param ethQuery - The EthQuery instance to call the network with.
 * @returns A gas price estimate.
 */
function fetchEthGasPriceEstimate(ethQuery) {
    return __awaiter(this, void 0, void 0, function* () {
        const gasPrice = yield (0, util_1.query)(ethQuery, 'gasPrice');
        return {
            gasPrice: (0, util_1.weiHexToGweiDec)(gasPrice).toString(),
        };
    });
}
exports.fetchEthGasPriceEstimate = fetchEthGasPriceEstimate;
/**
 * Estimate the time it will take for a transaction to be confirmed.
 *
 * @param maxPriorityFeePerGas - The max priority fee per gas.
 * @param maxFeePerGas - The max fee per gas.
 * @param gasFeeEstimates - The gas fee estimates.
 * @returns The estimated lower and upper bounds for when this transaction will be confirmed.
 */
function calculateTimeEstimate(maxPriorityFeePerGas, maxFeePerGas, gasFeeEstimates) {
    const { low, medium, high, estimatedBaseFee } = gasFeeEstimates;
    const maxPriorityFeePerGasInWEI = (0, util_1.gweiDecToWEIBN)(maxPriorityFeePerGas);
    const maxFeePerGasInWEI = (0, util_1.gweiDecToWEIBN)(maxFeePerGas);
    const estimatedBaseFeeInWEI = (0, util_1.gweiDecToWEIBN)(estimatedBaseFee);
    const effectiveMaxPriorityFee = ethereumjs_util_1.BN.min(maxPriorityFeePerGasInWEI, maxFeePerGasInWEI.sub(estimatedBaseFeeInWEI));
    const lowMaxPriorityFeeInWEI = (0, util_1.gweiDecToWEIBN)(low.suggestedMaxPriorityFeePerGas);
    const mediumMaxPriorityFeeInWEI = (0, util_1.gweiDecToWEIBN)(medium.suggestedMaxPriorityFeePerGas);
    const highMaxPriorityFeeInWEI = (0, util_1.gweiDecToWEIBN)(high.suggestedMaxPriorityFeePerGas);
    let lowerTimeBound;
    let upperTimeBound;
    if (effectiveMaxPriorityFee.lt(lowMaxPriorityFeeInWEI)) {
        lowerTimeBound = null;
        upperTimeBound = 'unknown';
    }
    else if (effectiveMaxPriorityFee.gte(lowMaxPriorityFeeInWEI) &&
        effectiveMaxPriorityFee.lt(mediumMaxPriorityFeeInWEI)) {
        lowerTimeBound = low.minWaitTimeEstimate;
        upperTimeBound = low.maxWaitTimeEstimate;
    }
    else if (effectiveMaxPriorityFee.gte(mediumMaxPriorityFeeInWEI) &&
        effectiveMaxPriorityFee.lt(highMaxPriorityFeeInWEI)) {
        lowerTimeBound = medium.minWaitTimeEstimate;
        upperTimeBound = medium.maxWaitTimeEstimate;
    }
    else if (effectiveMaxPriorityFee.eq(highMaxPriorityFeeInWEI)) {
        lowerTimeBound = high.minWaitTimeEstimate;
        upperTimeBound = high.maxWaitTimeEstimate;
    }
    else {
        lowerTimeBound = 0;
        upperTimeBound = high.maxWaitTimeEstimate;
    }
    return {
        lowerTimeBound,
        upperTimeBound,
    };
}
exports.calculateTimeEstimate = calculateTimeEstimate;
//# sourceMappingURL=gas-util.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\index.js", {"./BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","./BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","./ComposableController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\ComposableController.js","./ControllerMessenger":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\ControllerMessenger.js","./announcement/AnnouncementController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\announcement\\AnnouncementController.js","./approval/ApprovalController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\approval\\ApprovalController.js","./assets/AccountTrackerController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\AccountTrackerController.js","./assets/AssetsContractController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\AssetsContractController.js","./assets/CollectibleDetectionController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectibleDetectionController.js","./assets/CollectiblesController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\CollectiblesController.js","./assets/CurrencyRateController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\CurrencyRateController.js","./assets/TokenBalancesController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenBalancesController.js","./assets/TokenDetectionController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenDetectionController.js","./assets/TokenListController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenListController.js","./assets/TokenRatesController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokenRatesController.js","./assets/TokensController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\TokensController.js","./assets/assetsUtil":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\assets\\assetsUtil.js","./gas/GasFeeController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\gas\\GasFeeController.js","./keyring/KeyringController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\keyring\\KeyringController.js","./message-manager/MessageManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\MessageManager.js","./message-manager/PersonalMessageManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\PersonalMessageManager.js","./message-manager/TypedMessageManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\TypedMessageManager.js","./network/NetworkController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\network\\NetworkController.js","./notification/NotificationController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\notification\\NotificationController.js","./permissions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\index.js","./ratelimit/RateLimitController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\ratelimit\\RateLimitController.js","./subject-metadata":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\subject-metadata\\index.js","./third-party/PhishingController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\third-party\\PhishingController.js","./transaction/TransactionController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\transaction\\TransactionController.js","./user/AddressBookController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\user\\AddressBookController.js","./user/PreferencesController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\user\\PreferencesController.js","./util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","isomorphic-fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\isomorphic-fetch\\fetch-npm-browserify.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatIconUrlWithProxy = exports.util = exports.getAnonymizedState = exports.getPersistentState = exports.BaseControllerV2 = void 0;
require("isomorphic-fetch");
const util = __importStar(require("./util"));
exports.util = util;
const assetsUtil_1 = require("./assets/assetsUtil");
Object.defineProperty(exports, "formatIconUrlWithProxy", { enumerable: true, get: function () { return assetsUtil_1.formatIconUrlWithProxy; } });
__exportStar(require("./assets/AccountTrackerController"), exports);
__exportStar(require("./user/AddressBookController"), exports);
__exportStar(require("./approval/ApprovalController"), exports);
__exportStar(require("./assets/AssetsContractController"), exports);
__exportStar(require("./BaseController"), exports);
var BaseControllerV2_1 = require("./BaseControllerV2");
Object.defineProperty(exports, "BaseControllerV2", { enumerable: true, get: function () { return BaseControllerV2_1.BaseController; } });
Object.defineProperty(exports, "getPersistentState", { enumerable: true, get: function () { return BaseControllerV2_1.getPersistentState; } });
Object.defineProperty(exports, "getAnonymizedState", { enumerable: true, get: function () { return BaseControllerV2_1.getAnonymizedState; } });
__exportStar(require("./ComposableController"), exports);
__exportStar(require("./ControllerMessenger"), exports);
__exportStar(require("./assets/CurrencyRateController"), exports);
__exportStar(require("./keyring/KeyringController"), exports);
__exportStar(require("./message-manager/MessageManager"), exports);
__exportStar(require("./network/NetworkController"), exports);
__exportStar(require("./third-party/PhishingController"), exports);
__exportStar(require("./user/PreferencesController"), exports);
__exportStar(require("./assets/TokenBalancesController"), exports);
__exportStar(require("./assets/TokenRatesController"), exports);
__exportStar(require("./transaction/TransactionController"), exports);
__exportStar(require("./message-manager/PersonalMessageManager"), exports);
__exportStar(require("./message-manager/TypedMessageManager"), exports);
__exportStar(require("./announcement/AnnouncementController"), exports);
__exportStar(require("./assets/TokenListController"), exports);
__exportStar(require("./gas/GasFeeController"), exports);
__exportStar(require("./assets/TokensController"), exports);
__exportStar(require("./assets/CollectiblesController"), exports);
__exportStar(require("./assets/TokenDetectionController"), exports);
__exportStar(require("./assets/CollectibleDetectionController"), exports);
__exportStar(require("./permissions"), exports);
__exportStar(require("./subject-metadata"), exports);
__exportStar(require("./ratelimit/RateLimitController"), exports);
__exportStar(require("./notification/NotificationController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\keyring\\KeyringController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","eth-keyring-controller":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-keyring-controller\\index.js","eth-sig-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-sig-util\\dist\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethereumjs-wallet":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\ethereumjs-wallet\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\keyring\KeyringController.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _KeyringController_keyring;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyringController = exports.SignTypedDataVersion = exports.AccountImportStrategy = exports.KeyringTypes = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_sig_util_1 = require("eth-sig-util");
const ethereumjs_wallet_1 = __importStar(require("ethereumjs-wallet"));
const eth_keyring_controller_1 = __importDefault(require("eth-keyring-controller"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Available keyring types
 */
var KeyringTypes;
(function (KeyringTypes) {
    KeyringTypes["simple"] = "Simple Key Pair";
    KeyringTypes["hd"] = "HD Key Tree";
    KeyringTypes["qr"] = "QR Hardware Wallet Device";
})(KeyringTypes = exports.KeyringTypes || (exports.KeyringTypes = {}));
/**
 * A strategy for importing an account
 */
var AccountImportStrategy;
(function (AccountImportStrategy) {
    AccountImportStrategy["privateKey"] = "privateKey";
    AccountImportStrategy["json"] = "json";
})(AccountImportStrategy = exports.AccountImportStrategy || (exports.AccountImportStrategy = {}));
/**
 * The `signTypedMessage` version
 *
 * @see https://docs.metamask.io/guide/signing-data.html
 */
var SignTypedDataVersion;
(function (SignTypedDataVersion) {
    SignTypedDataVersion["V1"] = "V1";
    SignTypedDataVersion["V3"] = "V3";
    SignTypedDataVersion["V4"] = "V4";
})(SignTypedDataVersion = exports.SignTypedDataVersion || (exports.SignTypedDataVersion = {}));
/**
 * Controller responsible for establishing and managing user identity
 */
class KeyringController extends BaseController_1.BaseController {
    /**
     * Creates a KeyringController instance.
     *
     * @param options - The controller options.
     * @param options.removeIdentity - Remove the identity with the given address.
     * @param options.syncIdentities - Sync identities with the given list of addresses.
     * @param options.updateIdentities - Generate an identity for each address given that doesn't already have an identity.
     * @param options.setSelectedAddress - Set the selected address.
     * @param options.setAccountLabel - Set a new name for account.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ removeIdentity, syncIdentities, updateIdentities, setSelectedAddress, setAccountLabel, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'KeyringController';
        _KeyringController_keyring.set(this, void 0);
        __classPrivateFieldSet(this, _KeyringController_keyring, new eth_keyring_controller_1.default(Object.assign({ initState: state }, config)), "f");
        this.defaultState = Object.assign(Object.assign({}, __classPrivateFieldGet(this, _KeyringController_keyring, "f").store.getState()), { keyrings: [] });
        this.removeIdentity = removeIdentity;
        this.syncIdentities = syncIdentities;
        this.updateIdentities = updateIdentities;
        this.setSelectedAddress = setSelectedAddress;
        this.setAccountLabel = setAccountLabel;
        this.initialize();
        this.fullUpdate();
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring.
     *
     * @returns Promise resolving to current state when the account is added.
     */
    addNewAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            const oldAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").addNewAccount(primaryKeyring);
            const newAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
            yield this.verifySeedPhrase();
            this.updateIdentities(newAccounts);
            newAccounts.forEach((selectedAddress) => {
                if (!oldAccounts.includes(selectedAddress)) {
                    this.setSelectedAddress(selectedAddress);
                }
            });
            return this.fullUpdate();
        });
    }
    /**
     * Adds a new account to the default (first) HD seed phrase keyring without updating identities in preferences.
     *
     * @returns Promise resolving to current state when the account is added.
     */
    addNewAccountWithoutUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringsByType('HD Key Tree')[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found');
            }
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").addNewAccount(primaryKeyring);
            yield this.verifySeedPhrase();
            return this.fullUpdate();
        });
    }
    /**
     * Effectively the same as creating a new keychain then populating it
     * using the given seed phrase.
     *
     * @param password - Password to unlock keychain.
     * @param seed - A BIP39-compliant seed phrase,
     * either as a string or an array of UTF-8 bytes that represent the string.
     * @returns Promise resolving to the restored keychain object.
     */
    createNewVaultAndRestore(password, seed) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            if (!password || !password.length) {
                throw new Error('Invalid password');
            }
            try {
                this.updateIdentities([]);
                const vault = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").createNewVaultAndRestore(password, seed);
                this.updateIdentities(yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Create a new primary keychain and wipe any previous keychains.
     *
     * @param password - Password to unlock the new vault.
     * @returns Newly-created keychain object.
     */
    createNewVaultAndKeychain(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const vault = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").createNewVaultAndKeychain(password);
                this.updateIdentities(yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
                this.fullUpdate();
                return vault;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Method to validate a password against the password from the keyring.
     *
     * @param password - Password of the keyring.
     * @returns Boolean indicating if input password is valid
     */
    validatePassword(password) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").password === password;
    }
    /**
     * Returns the status of the vault.
     *
     * @returns Boolean returning true if the vault is unlocked.
     */
    isUnlocked() {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").memStore.getState().isUnlocked;
    }
    /**
     * Gets the seed phrase of the HD keyring.
     *
     * @param password - Password of the keyring.
     * @returns Promise resolving to the seed phrase.
     */
    exportSeedPhrase(password) {
        if (this.validatePassword(password)) {
            return __classPrivateFieldGet(this, _KeyringController_keyring, "f").keyrings[0].mnemonic;
        }
        throw new Error('Invalid password');
    }
    /**
     * Gets the private key from the keyring controlling an address.
     *
     * @param password - Password of the keyring.
     * @param address - Address to export.
     * @returns Promise resolving to the private key for an address.
     */
    exportAccount(password, address) {
        if (this.validatePassword(password)) {
            return __classPrivateFieldGet(this, _KeyringController_keyring, "f").exportAccount(address);
        }
        throw new Error('Invalid password');
    }
    /**
     * Returns the public addresses of all accounts for the current keyring.
     *
     * @returns A promise resolving to an array of addresses.
     */
    getAccounts() {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
    }
    /**
     * Imports an account with the specified import strategy.
     *
     * @param strategy - Import strategy name.
     * @param args - Array of arguments to pass to the underlying stategy.
     * @throws Will throw when passed an unrecognized strategy.
     * @returns Promise resolving to current state when the import is complete.
     */
    importAccountWithStrategy(strategy, args) {
        return __awaiter(this, void 0, void 0, function* () {
            let privateKey;
            switch (strategy) {
                case 'privateKey':
                    const [importedKey] = args;
                    if (!importedKey) {
                        throw new Error('Cannot import an empty key.');
                    }
                    const prefixed = (0, ethereumjs_util_1.addHexPrefix)(importedKey);
                    let bufferedPrivateKey;
                    try {
                        bufferedPrivateKey = (0, ethereumjs_util_1.toBuffer)(prefixed);
                    }
                    catch (_a) {
                        throw new Error('Cannot import invalid private key.');
                    }
                    /* istanbul ignore if */
                    if (!(0, ethereumjs_util_1.isValidPrivate)(bufferedPrivateKey)) {
                        throw new Error('Cannot import invalid private key.');
                    }
                    privateKey = (0, ethereumjs_util_1.stripHexPrefix)(prefixed);
                    break;
                case 'json':
                    let wallet;
                    const [input, password] = args;
                    try {
                        wallet = ethereumjs_wallet_1.thirdparty.fromEtherWallet(input, password);
                    }
                    catch (e) {
                        wallet = wallet || (yield ethereumjs_wallet_1.default.fromV3(input, password, true));
                    }
                    privateKey = (0, ethereumjs_util_1.bufferToHex)(wallet.getPrivateKey());
                    break;
                default:
                    throw new Error(`Unexpected import strategy: '${strategy}'`);
            }
            const newKeyring = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").addNewKeyring(KeyringTypes.simple, [
                privateKey,
            ]);
            const accounts = yield newKeyring.getAccounts();
            const allAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
            this.updateIdentities(allAccounts);
            this.setSelectedAddress(accounts[0]);
            return this.fullUpdate();
        });
    }
    /**
     * Removes an account from keyring state.
     *
     * @param address - Address of the account to remove.
     * @returns Promise resolving current state when this account removal completes.
     */
    removeAccount(address) {
        return __awaiter(this, void 0, void 0, function* () {
            this.removeIdentity(address);
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").removeAccount(address);
            return this.fullUpdate();
        });
    }
    /**
     * Deallocates all secrets and locks the wallet.
     *
     * @returns Promise resolving to current state.
     */
    setLocked() {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").setLocked();
    }
    /**
     * Signs message by calling down into a specific keyring.
     *
     * @param messageParams - PersonalMessageParams object to sign.
     * @returns Promise resolving to a signed message string.
     */
    signMessage(messageParams) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").signMessage(messageParams);
    }
    /**
     * Signs personal message by calling down into a specific keyring.
     *
     * @param messageParams - PersonalMessageParams object to sign.
     * @returns Promise resolving to a signed message string.
     */
    signPersonalMessage(messageParams) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").signPersonalMessage(messageParams);
    }
    /**
     * Signs typed message by calling down into a specific keyring.
     *
     * @param messageParams - TypedMessageParams object to sign.
     * @param version - Compatibility version EIP712.
     * @throws Will throw when passed an unrecognized version.
     * @returns Promise resolving to a signed message string or an error if any.
     */
    signTypedMessage(messageParams, version) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const address = (0, eth_sig_util_1.normalize)(messageParams.from);
                const qrKeyring = yield this.getOrAddQRKeyring();
                const qrAccounts = yield qrKeyring.getAccounts();
                if (qrAccounts.findIndex((qrAddress) => qrAddress.toLowerCase() === address.toLowerCase()) !== -1) {
                    const messageParamsClone = Object.assign({}, messageParams);
                    if (version !== SignTypedDataVersion.V1 &&
                        typeof messageParamsClone.data === 'string') {
                        messageParamsClone.data = JSON.parse(messageParamsClone.data);
                    }
                    return __classPrivateFieldGet(this, _KeyringController_keyring, "f").signTypedMessage(messageParamsClone, { version });
                }
                const { password } = __classPrivateFieldGet(this, _KeyringController_keyring, "f");
                const privateKey = yield this.exportAccount(password, address);
                const privateKeyBuffer = (0, ethereumjs_util_1.toBuffer)((0, ethereumjs_util_1.addHexPrefix)(privateKey));
                switch (version) {
                    case SignTypedDataVersion.V1:
                        // signTypedDataLegacy will throw if the data is invalid.
                        return (0, eth_sig_util_1.signTypedDataLegacy)(privateKeyBuffer, {
                            data: messageParams.data,
                        });
                    case SignTypedDataVersion.V3:
                        return (0, eth_sig_util_1.signTypedData)(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    case SignTypedDataVersion.V4:
                        return (0, eth_sig_util_1.signTypedData_v4)(privateKeyBuffer, {
                            data: JSON.parse(messageParams.data),
                        });
                    default:
                        throw new Error(`Unexpected signTypedMessage version: '${version}'`);
                }
            }
            catch (error) {
                throw new Error(`Keyring Controller signTypedMessage: ${error}`);
            }
        });
    }
    /**
     * Signs a transaction by calling down into a specific keyring.
     *
     * @param transaction - Transaction object to sign. Must be a `ethereumjs-tx` transaction instance.
     * @param from - Address to sign from, should be in keychain.
     * @returns Promise resolving to a signed transaction string.
     */
    signTransaction(transaction, from) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").signTransaction(transaction, from);
    }
    /**
     * Attempts to decrypt the current vault and load its keyrings.
     *
     * @param password - Password to unlock the keychain.
     * @returns Promise resolving to the current state.
     */
    submitPassword(password) {
        return __awaiter(this, void 0, void 0, function* () {
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").submitPassword(password);
            const accounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
            yield this.syncIdentities(accounts);
            return this.fullUpdate();
        });
    }
    /**
     * Adds new listener to be notified of state changes.
     *
     * @param listener - Callback triggered when state changes.
     */
    subscribe(listener) {
        __classPrivateFieldGet(this, _KeyringController_keyring, "f").store.subscribe(listener);
    }
    /**
     * Removes existing listener from receiving state changes.
     *
     * @param listener - Callback to remove.
     * @returns True if a listener is found and unsubscribed.
     */
    unsubscribe(listener) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").store.unsubscribe(listener);
    }
    /**
     * Adds new listener to be notified when the wallet is locked.
     *
     * @param listener - Callback triggered when wallet is locked.
     * @returns EventEmitter if listener added.
     */
    onLock(listener) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").on('lock', listener);
    }
    /**
     * Adds new listener to be notified when the wallet is unlocked.
     *
     * @param listener - Callback triggered when wallet is unlocked.
     * @returns EventEmitter if listener added.
     */
    onUnlock(listener) {
        return __classPrivateFieldGet(this, _KeyringController_keyring, "f").on('unlock', listener);
    }
    /**
     * Verifies the that the seed phrase restores the current keychain's accounts.
     *
     * @returns Whether the verification succeeds.
     */
    verifySeedPhrase() {
        return __awaiter(this, void 0, void 0, function* () {
            const primaryKeyring = __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringsByType(KeyringTypes.hd)[0];
            /* istanbul ignore if */
            if (!primaryKeyring) {
                throw new Error('No HD keyring found.');
            }
            const seedWords = (yield primaryKeyring.serialize()).mnemonic;
            const accounts = yield primaryKeyring.getAccounts();
            /* istanbul ignore if */
            if (accounts.length === 0) {
                throw new Error('Cannot verify an empty keyring.');
            }
            const TestKeyringClass = __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringClassForType(KeyringTypes.hd);
            const testKeyring = new TestKeyringClass({
                mnemonic: seedWords,
                numberOfAccounts: accounts.length,
            });
            const testAccounts = yield testKeyring.getAccounts();
            /* istanbul ignore if */
            if (testAccounts.length !== accounts.length) {
                throw new Error('Seed phrase imported incorrect number of accounts.');
            }
            testAccounts.forEach((account, i) => {
                /* istanbul ignore if */
                if (account.toLowerCase() !== accounts[i].toLowerCase()) {
                    throw new Error('Seed phrase imported different accounts.');
                }
            });
            return seedWords;
        });
    }
    /**
     * Update keyrings in state and calls KeyringController fullUpdate method returning current state.
     *
     * @returns The current state.
     */
    fullUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyrings = yield Promise.all(__classPrivateFieldGet(this, _KeyringController_keyring, "f").keyrings.map((keyring, index) => __awaiter(this, void 0, void 0, function* () {
                const keyringAccounts = yield keyring.getAccounts();
                const accounts = Array.isArray(keyringAccounts)
                    ? keyringAccounts.map((address) => (0, util_1.toChecksumHexAddress)(address))
                    : /* istanbul ignore next */ [];
                return {
                    accounts,
                    index,
                    type: keyring.type,
                };
            })));
            this.update({ keyrings: [...keyrings] });
            return __classPrivateFieldGet(this, _KeyringController_keyring, "f").fullUpdate();
        });
    }
    // QR Hardware related methods
    /**
     * Add qr hardware keyring.
     *
     * @returns The added keyring
     */
    addQRKeyring() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").addNewKeyring(KeyringTypes.qr);
            yield this.fullUpdate();
            return keyring;
        });
    }
    /**
     * Get qr hardware keyring.
     *
     * @returns The added keyring
     */
    getOrAddQRKeyring() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringsByType(KeyringTypes.qr)[0];
            return keyring || (yield this.addQRKeyring());
        });
    }
    restoreQRKeyring(serialized) {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.getOrAddQRKeyring()).deserialize(serialized);
            this.updateIdentities(yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
            yield this.fullUpdate();
        });
    }
    resetQRKeyringState() {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.getOrAddQRKeyring()).resetStore();
        });
    }
    getQRKeyringState() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getOrAddQRKeyring()).getMemStore();
        });
    }
    submitQRCryptoHDKey(cryptoHDKey) {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.getOrAddQRKeyring()).submitCryptoHDKey(cryptoHDKey);
        });
    }
    submitQRCryptoAccount(cryptoAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.getOrAddQRKeyring()).submitCryptoAccount(cryptoAccount);
        });
    }
    submitQRSignature(requestId, ethSignature) {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.getOrAddQRKeyring()).submitSignature(requestId, ethSignature);
        });
    }
    cancelQRSignRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            (yield this.getOrAddQRKeyring()).cancelSignRequest();
        });
    }
    connectQRHardware(page) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const keyring = yield this.getOrAddQRKeyring();
                let accounts;
                switch (page) {
                    case -1:
                        accounts = yield keyring.getPreviousPage();
                        break;
                    case 1:
                        accounts = yield keyring.getNextPage();
                        break;
                    default:
                        accounts = yield keyring.getFirstPage();
                }
                return accounts.map((account) => {
                    return Object.assign(Object.assign({}, account), { balance: '0x0' });
                });
            }
            catch (e) {
                throw new Error(`Unspecified error when connect QR Hardware, ${e}`);
            }
        });
    }
    unlockQRHardwareWalletAccount(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = yield this.getOrAddQRKeyring();
            keyring.setAccountToUnlock(index);
            const oldAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").addNewAccount(keyring);
            const newAccounts = yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts();
            this.updateIdentities(newAccounts);
            newAccounts.forEach((address) => {
                if (!oldAccounts.includes(address)) {
                    if (this.setAccountLabel) {
                        this.setAccountLabel(address, `${keyring.getName()} ${index}`);
                    }
                    this.setSelectedAddress(address);
                }
            });
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").persistAllKeyrings();
            yield this.fullUpdate();
        });
    }
    getAccountKeyringType(account) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getKeyringForAccount(account)).type;
        });
    }
    forgetQRDevice() {
        return __awaiter(this, void 0, void 0, function* () {
            const keyring = yield this.getOrAddQRKeyring();
            keyring.forgetDevice();
            const accounts = (yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").getAccounts());
            accounts.forEach((account) => {
                this.setSelectedAddress(account);
            });
            yield __classPrivateFieldGet(this, _KeyringController_keyring, "f").persistAllKeyrings();
            yield this.fullUpdate();
        });
    }
}
exports.KeyringController = KeyringController;
_KeyringController_keyring = new WeakMap();
exports.default = KeyringController;
//# sourceMappingURL=KeyringController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\message-manager\AbstractMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractMessageManager = void 0;
const events_1 = require("events");
const BaseController_1 = require("../BaseController");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class AbstractMessageManager extends BaseController_1.BaseController {
    /**
     * Creates an AbstractMessageManager instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * EventEmitter instance used to listen to specific message events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'AbstractMessageManager';
        this.defaultState = {
            unapprovedMessages: {},
            unapprovedMessagesCount: 0,
        };
        this.messages = [];
        this.initialize();
    }
    /**
     * Saves the unapproved messages, and their count to state.
     *
     */
    saveMessageList() {
        const unapprovedMessages = this.getUnapprovedMessages();
        const unapprovedMessagesCount = this.getUnapprovedMessagesCount();
        this.update({ unapprovedMessages, unapprovedMessagesCount });
        this.hub.emit('updateBadge');
    }
    /**
     * Updates the status of a Message in this.messages.
     *
     * @param messageId - The id of the Message to update.
     * @param status - The new status of the Message.
     */
    setMessageStatus(messageId, status) {
        const message = this.getMessage(messageId);
        if (!message) {
            throw new Error(`${this.name}: Message not found for id: ${messageId}.`);
        }
        message.status = status;
        this.updateMessage(message);
        this.hub.emit(`${messageId}:${status}`, message);
        if (status === 'rejected' || status === 'signed' || status === 'errored') {
            this.hub.emit(`${messageId}:finished`, message);
        }
    }
    /**
     * Sets a Message in this.messages to the passed Message if the ids are equal.
     * Then saves the unapprovedMessage list to storage.
     *
     * @param message - A Message that will replace an existing Message (with the id) in this.messages.
     */
    updateMessage(message) {
        const index = this.messages.findIndex((msg) => message.id === msg.id);
        /* istanbul ignore next */
        if (index !== -1) {
            this.messages[index] = message;
        }
        this.saveMessageList();
    }
    /**
     * A getter for the number of 'unapproved' Messages in this.messages.
     *
     * @returns The number of 'unapproved' Messages in this.messages.
     */
    getUnapprovedMessagesCount() {
        return Object.keys(this.getUnapprovedMessages()).length;
    }
    /**
     * A getter for the 'unapproved' Messages in state messages.
     *
     * @returns An index of Message ids to Messages, for all 'unapproved' Messages in this.messages.
     */
    getUnapprovedMessages() {
        return this.messages
            .filter((message) => message.status === 'unapproved')
            .reduce((result, message) => {
            result[message.id] = message;
            return result;
        }, {});
    }
    /**
     * Adds a passed Message to this.messages, and calls this.saveMessageList() to save
     * the unapproved Messages from that list to this.messages.
     *
     * @param message - The Message to add to this.messages.
     */
    addMessage(message) {
        this.messages.push(message);
        this.saveMessageList();
    }
    /**
     * Returns a specified Message.
     *
     * @param messageId - The id of the Message to get.
     * @returns The Message with the id that matches the passed messageId, or undefined
     * if no Message has that id.
     */
    getMessage(messageId) {
        return this.messages.find((message) => message.id === messageId);
    }
    /**
     * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,
     * and returns a promise with any the message params modified for proper signing.
     *
     * @param messageParams - The messageParams to be used when signing method is called,
     * plus data added by MetaMask.
     * @returns Promise resolving to the messageParams with the metamaskId property removed.
     */
    approveMessage(messageParams) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.setMessageStatusApproved(messageParams.metamaskId);
        return this.prepMessageForSigning(messageParams);
    }
    /**
     * Sets a Message status to 'approved' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the Message to approve.
     */
    setMessageStatusApproved(messageId) {
        this.setMessageStatus(messageId, 'approved');
    }
    /**
     * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates
     * that Message in this.messages by adding the raw signature data of the signature
     * request to the Message.
     *
     * @param messageId - The id of the Message to sign.
     * @param rawSig - The raw data of the signature request.
     */
    setMessageStatusSigned(messageId, rawSig) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.rawSig = rawSig;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'signed');
    }
    /**
     * Sets a Message status to 'rejected' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the Message to reject.
     */
    rejectMessage(messageId) {
        this.setMessageStatus(messageId, 'rejected');
    }
}
exports.AbstractMessageManager = AbstractMessageManager;
exports.default = AbstractMessageManager;
//# sourceMappingURL=AbstractMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\MessageManager.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./AbstractMessageManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\message-manager\MessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class MessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'MessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns Promise resolving to the raw data of the signature request.
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            (0, util_1.validateSignMessageData)(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the eth_sign call to be made after the message
     * is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns The id of the newly created message.
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = (0, util_1.normalizeMessageData)(messageParams.data);
        const messageId = (0, uuid_1.v1)();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams.
     *
     * @param messageParams - The messageParams to modify.
     * @returns Promise resolving to the messageParams with the metamaskId property removed.
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.MessageManager = MessageManager;
exports.default = MessageManager;
//# sourceMappingURL=MessageManager.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\PersonalMessageManager.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./AbstractMessageManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\message-manager\PersonalMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PersonalMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - Messages.
 */
class PersonalMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PersonalMessageManager';
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns Promise resolving to the raw data of the signature request.
     */
    addUnapprovedMessageAsync(messageParams, req) {
        return new Promise((resolve, reject) => {
            (0, util_1.validateSignMessageData)(messageParams);
            const messageId = this.addUnapprovedMessage(messageParams, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Personal Message Signature: User denied message signature.'));
                    default:
                        return reject(new Error(`MetaMask Personal Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new Message with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new Message to this.messages, and to save the
     * unapproved Messages.
     *
     * @param messageParams - The params for the personal_sign call to be made after the message
     * is approved.
     * @param req - The original request object possibly containing the origin.
     * @returns The id of the newly created message.
     */
    addUnapprovedMessage(messageParams, req) {
        if (req) {
            messageParams.origin = req.origin;
        }
        messageParams.data = (0, util_1.normalizeMessageData)(messageParams.data);
        const messageId = (0, uuid_1.v1)();
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'personal_sign',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, Object.assign(Object.assign({}, messageParams), { metamaskId: messageId }));
        return messageId;
    }
    /**
     * Removes the metamaskId property from passed messageParams and returns a promise which
     * resolves the updated messageParams.
     *
     * @param messageParams - The messageParams to modify.
     * @returns Promise resolving to the messageParams with the metamaskId property removed.
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        return Promise.resolve(messageParams);
    }
}
exports.PersonalMessageManager = PersonalMessageManager;
exports.default = PersonalMessageManager;
//# sourceMappingURL=PersonalMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\TypedMessageManager.js", {"../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./AbstractMessageManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\message-manager\\AbstractMessageManager.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\message-manager\TypedMessageManager.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypedMessageManager = void 0;
const uuid_1 = require("uuid");
const util_1 = require("../util");
const AbstractMessageManager_1 = require("./AbstractMessageManager");
/**
 * Controller in charge of managing - storing, adding, removing, updating - TypedMessages.
 */
class TypedMessageManager extends AbstractMessageManager_1.AbstractMessageManager {
    constructor() {
        super(...arguments);
        /**
         * Name of this controller used during composition
         */
        this.name = 'TypedMessageManager';
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the unapproved TypedMessages.
     *
     * @param messageParams - The params for the eth_signTypedData call to be made after the message is approved.
     * @param version - Compatibility version EIP712.
     * @param req - The original request object possibly containing the origin.
     * @returns Promise resolving to the raw data of the signature request.
     */
    addUnapprovedMessageAsync(messageParams, version, req) {
        return new Promise((resolve, reject) => {
            if (version === 'V1') {
                (0, util_1.validateTypedSignMessageDataV1)(messageParams);
            }
            if (version === 'V3') {
                (0, util_1.validateTypedSignMessageDataV3)(messageParams);
            }
            const messageId = this.addUnapprovedMessage(messageParams, version, req);
            this.hub.once(`${messageId}:finished`, (data) => {
                switch (data.status) {
                    case 'signed':
                        return resolve(data.rawSig);
                    case 'rejected':
                        return reject(new Error('MetaMask Typed Message Signature: User denied message signature.'));
                    case 'errored':
                        return reject(new Error(`MetaMask Typed Message Signature: ${data.error}`));
                    default:
                        return reject(new Error(`MetaMask Typed Message Signature: Unknown problem: ${JSON.stringify(messageParams)}`));
                }
            });
        });
    }
    /**
     * Creates a new TypedMessage with an 'unapproved' status using the passed messageParams.
     * this.addMessage is called to add the new TypedMessage to this.messages, and to save the
     * unapproved TypedMessages.
     *
     * @param messageParams - The params for the 'eth_signTypedData' call to be made after the message
     * is approved.
     * @param version - Compatibility version EIP712.
     * @param req - The original request object possibly containing the origin.
     * @returns The id of the newly created TypedMessage.
     */
    addUnapprovedMessage(messageParams, version, req) {
        const messageId = (0, uuid_1.v1)();
        const messageParamsMetamask = Object.assign(Object.assign({}, messageParams), { metamaskId: messageId, version });
        if (req) {
            messageParams.origin = req.origin;
        }
        const messageData = {
            id: messageId,
            messageParams,
            status: 'unapproved',
            time: Date.now(),
            type: 'eth_signTypedData',
        };
        this.addMessage(messageData);
        this.hub.emit(`unapprovedMessage`, messageParamsMetamask);
        return messageId;
    }
    /**
     * Sets a TypedMessage status to 'errored' via a call to this.setMessageStatus.
     *
     * @param messageId - The id of the TypedMessage to error.
     * @param error - The error to be included in TypedMessage.
     */
    setMessageStatusErrored(messageId, error) {
        const message = this.getMessage(messageId);
        /* istanbul ignore if */
        if (!message) {
            return;
        }
        message.error = error;
        this.updateMessage(message);
        this.setMessageStatus(messageId, 'errored');
    }
    /**
     * Removes the metamaskId and version properties from passed messageParams and returns a promise which
     * resolves the updated messageParams.
     *
     * @param messageParams - The messageParams to modify.
     * @returns Promise resolving to the messageParams with the metamaskId and version properties removed.
     */
    prepMessageForSigning(messageParams) {
        delete messageParams.metamaskId;
        delete messageParams.version;
        return Promise.resolve(messageParams);
    }
}
exports.TypedMessageManager = TypedMessageManager;
exports.default = TypedMessageManager;
//# sourceMappingURL=TypedMessageManager.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\network\\NetworkController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","eth-json-rpc-infura/src/createProvider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-infura\\src\\createProvider.js","eth-query":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js","web3-provider-engine/subproviders/provider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\provider.js","web3-provider-engine/zero":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\zero.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\network\NetworkController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NetworkController = exports.NetworksChainId = void 0;
const eth_query_1 = __importDefault(require("eth-query"));
const provider_1 = __importDefault(require("web3-provider-engine/subproviders/provider"));
const createProvider_1 = __importDefault(require("eth-json-rpc-infura/src/createProvider"));
const zero_1 = __importDefault(require("web3-provider-engine/zero"));
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const constants_1 = require("../constants");
var NetworksChainId;
(function (NetworksChainId) {
    NetworksChainId["mainnet"] = "1";
    NetworksChainId["kovan"] = "42";
    NetworksChainId["rinkeby"] = "4";
    NetworksChainId["goerli"] = "5";
    NetworksChainId["ropsten"] = "3";
    NetworksChainId["localhost"] = "";
    NetworksChainId["rpc"] = "";
    NetworksChainId["optimism"] = "10";
    NetworksChainId["optimismTest"] = "69";
})(NetworksChainId = exports.NetworksChainId || (exports.NetworksChainId = {}));
const LOCALHOST_RPC_URL = 'http://localhost:8545';
/**
 * Controller that creates and manages an Ethereum network provider
 */
class NetworkController extends BaseController_1.BaseController {
    /**
     * Creates a NetworkController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        this.internalProviderConfig = {};
        this.mutex = new async_mutex_1.Mutex();
        /**
         * Name of this controller used during composition
         */
        this.name = 'NetworkController';
        this.defaultState = {
            network: 'loading',
            isCustomNetwork: false,
            provider: { type: constants_1.MAINNET, chainId: NetworksChainId.mainnet },
            properties: { isEIP1559Compatible: false },
        };
        this.initialize();
        this.getEIP1559Compatibility();
    }
    initializeProvider(type, rpcTarget, chainId, ticker, nickname) {
        this.update({ isCustomNetwork: this.getIsCustomNetwork(chainId) });
        switch (type) {
            case 'kovan':
            case constants_1.MAINNET:
            case 'rinkeby':
            case 'goerli':
            case 'optimism':
            case 'optimismTest':
            case 'ropsten':
                this.setupInfuraProvider(type);
                break;
            case 'localhost':
                this.setupStandardProvider(LOCALHOST_RPC_URL);
                break;
            case constants_1.RPC:
                rpcTarget &&
                    this.setupStandardProvider(rpcTarget, chainId, ticker, nickname);
                break;
            default:
                throw new Error(`Unrecognized network type: '${type}'`);
        }
    }
    refreshNetwork() {
        this.update({ network: 'loading', properties: {} });
        const { rpcTarget, type, chainId, ticker } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker);
        this.lookupNetwork();
    }
    registerProvider() {
        this.provider.on('error', this.verifyNetwork.bind(this));
        this.ethQuery = new eth_query_1.default(this.provider);
    }
    setupInfuraProvider(type) {
        const infuraProvider = (0, createProvider_1.default)({
            network: type,
            projectId: this.config.infuraProjectId,
        });
        const infuraSubprovider = new provider_1.default(infuraProvider);
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            dataSubprovider: infuraSubprovider,
            engineParams: {
                blockTrackerProvider: infuraProvider,
                pollingInterval: 12000,
            },
        });
        this.updateProvider((0, zero_1.default)(config));
    }
    getIsCustomNetwork(chainId) {
        return (chainId !== NetworksChainId.mainnet &&
            chainId !== NetworksChainId.kovan &&
            chainId !== NetworksChainId.rinkeby &&
            chainId !== NetworksChainId.goerli &&
            chainId !== NetworksChainId.ropsten &&
            chainId !== NetworksChainId.localhost);
    }
    setupStandardProvider(rpcTarget, chainId, ticker, nickname) {
        const config = Object.assign(Object.assign({}, this.internalProviderConfig), {
            chainId,
            engineParams: { pollingInterval: 12000 },
            nickname,
            rpcUrl: rpcTarget,
            ticker,
        });
        this.updateProvider((0, zero_1.default)(config));
    }
    updateProvider(provider) {
        this.safelyStopProvider(this.provider);
        this.provider = provider;
        this.registerProvider();
    }
    safelyStopProvider(provider) {
        setTimeout(() => {
            provider === null || provider === void 0 ? void 0 : provider.stop();
        }, 500);
    }
    verifyNetwork() {
        this.state.network === 'loading' && this.lookupNetwork();
    }
    /**
     * Sets a new configuration for web3-provider-engine.
     *
     * TODO: Replace this wth a method.
     *
     * @param providerConfig - The web3-provider-engine configuration.
     */
    set providerConfig(providerConfig) {
        this.internalProviderConfig = providerConfig;
        const { type, rpcTarget, chainId, ticker, nickname } = this.state.provider;
        this.initializeProvider(type, rpcTarget, chainId, ticker, nickname);
        this.registerProvider();
        this.lookupNetwork();
    }
    get providerConfig() {
        throw new Error('Property only used for setting');
    }
    /**
     * Refreshes the current network code.
     */
    lookupNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            /* istanbul ignore if */
            if (!this.ethQuery || !this.ethQuery.sendAsync) {
                return;
            }
            const releaseLock = yield this.mutex.acquire();
            this.ethQuery.sendAsync({ method: 'net_version' }, (error, network) => {
                this.update({
                    network: error ? /* istanbul ignore next*/ 'loading' : network,
                });
                releaseLock();
            });
        });
    }
    /**
     * Convenience method to update provider network type settings.
     *
     * @param type - Human readable network name.
     */
    setProviderType(type) {
        const _a = this.state.provider, { rpcTarget, chainId, nickname } = _a, providerState = __rest(_a, ["rpcTarget", "chainId", "nickname"]);
        // If testnet the ticker symbol should use a testnet prefix
        const ticker = type in constants_1.TESTNET_NETWORK_TYPE_TO_TICKER_SYMBOL &&
            constants_1.TESTNET_NETWORK_TYPE_TO_TICKER_SYMBOL[type].length > 0
            ? constants_1.TESTNET_NETWORK_TYPE_TO_TICKER_SYMBOL[type]
            : 'ETH';
        this.update({
            provider: Object.assign(Object.assign({}, providerState), {
                type,
                ticker,
                chainId: NetworksChainId[type],
            }),
        });
        this.refreshNetwork();
    }
    /**
     * Convenience method to update provider RPC settings.
     *
     * @param rpcTarget - The RPC endpoint URL.
     * @param chainId - The chain ID as per EIP-155.
     * @param ticker - The currency ticker.
     * @param nickname - Personalized network name.
     */
    setRpcTarget(rpcTarget, chainId, ticker, nickname) {
        this.update({
            provider: Object.assign(Object.assign({}, this.state.provider), { type: constants_1.RPC, ticker, rpcTarget, chainId, nickname }),
        });
        this.refreshNetwork();
    }
    getEIP1559Compatibility() {
        var _a;
        const { properties = {} } = this.state;
        if (!properties.isEIP1559Compatible) {
            if (typeof ((_a = this.ethQuery) === null || _a === void 0 ? void 0 : _a.sendAsync) !== 'function') {
                return Promise.resolve(true);
            }
            return new Promise((resolve, reject) => {
                this.ethQuery.sendAsync({ method: 'eth_getBlockByNumber', params: ['latest', false] }, (error, block) => {
                    if (error) {
                        reject(error);
                    }
                    else {
                        const isEIP1559Compatible = typeof block.baseFeePerGas !== 'undefined';
                        if (properties.isEIP1559Compatible !== isEIP1559Compatible) {
                            this.update({
                                properties: {
                                    isEIP1559Compatible,
                                },
                            });
                        }
                        resolve(isEIP1559Compatible);
                    }
                });
            });
        }
        return Promise.resolve(true);
    }
}
exports.NetworkController = NetworkController;
exports.default = NetworkController;
//# sourceMappingURL=NetworkController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\notification\\NotificationController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","nanoid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\notification\NotificationController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationController = void 0;
const nanoid_1 = require("nanoid");
const util_1 = require("../util");
const BaseControllerV2_1 = require("../BaseControllerV2");
const name = 'NotificationController';
const metadata = {
    notifications: { persist: true, anonymous: false },
};
const defaultState = {
    notifications: {},
};
/**
 * Controller that handles storing notifications and showing them to the user
 */
class NotificationController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a NotificationController instance.
     *
     * @param options - Constructor options.
     * @param options.messenger - A reference to the messaging system.
     * @param options.state - Initial state to set on this controller.
     */
    constructor({ messenger, state, }) {
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.messagingSystem.registerActionHandler(`${name}:show`, (origin, message) => this.show(origin, message));
        this.messagingSystem.registerActionHandler(`${name}:dismiss`, (ids) => this.dismiss(ids));
        this.messagingSystem.registerActionHandler(`${name}:markRead`, (ids) => this.markRead(ids));
    }
    /**
     * Shows a notification.
     *
     * @param origin - The origin trying to send a notification
     * @param message - A message to show on the notification
     */
    show(origin, message) {
        const id = (0, nanoid_1.nanoid)();
        const notification = {
            id,
            origin,
            createdDate: Date.now(),
            readDate: null,
            message,
        };
        this.update((state) => {
            state.notifications[id] = notification;
        });
    }
    /**
     * Dimisses a list of notifications.
     *
     * @param ids - A list of notification IDs
     */
    dismiss(ids) {
        this.update((state) => {
            for (const id of ids) {
                if ((0, util_1.hasProperty)(state.notifications, id)) {
                    delete state.notifications[id];
                }
            }
        });
    }
    /**
     * Marks a list of notifications as read.
     *
     * @param ids - A list of notification IDs
     */
    markRead(ids) {
        this.update((state) => {
            for (const id of ids) {
                if ((0, util_1.hasProperty)(state.notifications, id)) {
                    state.notifications[id].readDate = Date.now();
                }
            }
        });
    }
}
exports.NotificationController = NotificationController;
//# sourceMappingURL=NotificationController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\Caveat.js", {"./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\Caveat.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decorateWithCaveats = void 0;
const errors_1 = require("./errors");
/**
 * Decorate a restricted method implementation with its caveats.
 *
 * Note that all caveat functions (i.e. the argument and return value of the
 * decorator) must be awaited.
 *
 * @param methodImplementation - The restricted method implementation
 * @param permission - The origin's potential permission
 * @param caveatSpecifications - All caveat implementations
 * @returns The decorated method implementation
 */
function decorateWithCaveats(methodImplementation, permission, // bound to the requesting origin
caveatSpecifications) {
    const { caveats } = permission;
    if (!caveats) {
        return methodImplementation;
    }
    let decorated = (args) => __awaiter(this, void 0, void 0, function* () { return methodImplementation(args); });
    for (const caveat of caveats) {
        const specification = caveatSpecifications[caveat.type];
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type);
        }
        decorated = specification.decorator(decorated, caveat);
    }
    return decorated;
}
exports.decorateWithCaveats = decorateWithCaveats;
//# sourceMappingURL=Caveat.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\Permission.js", {"nanoid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\Permission.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasSpecificationType = exports.PermissionType = exports.findCaveat = exports.constructPermission = void 0;
const nanoid_1 = require("nanoid");
/**
 * The default permission factory function. Naively constructs a permission from
 * the inputs. Sets a default, random `id` if none is provided.
 *
 * @see {@link Permission} For more details.
 * @template TargetPermission- - The {@link Permission} that will be constructed.
 * @param options - The options for the permission.
 * @returns The new permission object.
 */
function constructPermission(options) {
    const { caveats = null, invoker, target } = options;
    return {
        id: (0, nanoid_1.nanoid)(),
        parentCapability: target,
        invoker,
        caveats,
        date: new Date().getTime(),
    };
}
exports.constructPermission = constructPermission;
/**
 * Gets the caveat of the specified type belonging to the specified permission.
 *
 * @param permission - The permission whose caveat to retrieve.
 * @param caveatType - The type of the caveat to retrieve.
 * @returns The caveat, or undefined if no such caveat exists.
 */
function findCaveat(permission, caveatType) {
    var _a;
    return (_a = permission.caveats) === null || _a === void 0 ? void 0 : _a.find((caveat) => caveat.type === caveatType);
}
exports.findCaveat = findCaveat;
/**
 * The different possible types of permissions.
 */
var PermissionType;
(function (PermissionType) {
    /**
     * A restricted JSON-RPC method. A subject must have the requisite permission
     * to call a restricted JSON-RPC method.
     */
    PermissionType["RestrictedMethod"] = "RestrictedMethod";
    /**
     * An "endowment" granted to subjects that possess the requisite permission,
     * such as a global environment variable exposing a restricted API, etc.
     */
    PermissionType["Endowment"] = "Endowment";
})(PermissionType = exports.PermissionType || (exports.PermissionType = {}));
/**
 * Checks that the specification has the expected permission type.
 *
 * @param specification - The specification to check.
 * @param expectedType - The expected permission type.
 * @template Specification - The specification to check.
 * @template Type - The expected permission type.
 * @returns Whether or not the specification is of the expected type.
 */
function hasSpecificationType(specification, expectedType) {
    return specification.permissionType === expectedType;
}
exports.hasSpecificationType = hasSpecificationType;
//# sourceMappingURL=Permission.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\PermissionController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","./Caveat":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\Caveat.js","./Permission":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\Permission.js","./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\errors.js","./permission-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\permission-middleware.js","./utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\utils.js","deep-freeze-strict":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\deep-freeze-strict\\index.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","immer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\immer\\dist\\index.js","nanoid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\nanoid\\index.browser.cjs"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\PermissionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionController = exports.CaveatMutatorOperation = void 0;
const deep_freeze_strict_1 = __importDefault(require("deep-freeze-strict"));
const immer_1 = require("immer");
const nanoid_1 = require("nanoid");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const BaseControllerV2_1 = require("../BaseControllerV2");
const util_1 = require("../util");
const Caveat_1 = require("./Caveat");
const errors_1 = require("./errors");
const Permission_1 = require("./Permission");
const permission_middleware_1 = require("./permission-middleware");
const utils_1 = require("./utils");
/**
 * The name of the {@link PermissionController}.
 */
const controllerName = 'PermissionController';
/**
 * Get the state metadata of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 * @returns The state metadata
 */
function getStateMetadata() {
    return { subjects: { anonymous: true, persist: true } };
}
/**
 * Get the default state of the {@link PermissionController}.
 *
 * @template Permission - The controller's permission type union.
 * @returns The default state of the controller
 */
function getDefaultState() {
    return { subjects: {} };
}
/**
 * Describes the possible results of a {@link CaveatMutator} function.
 */
var CaveatMutatorOperation;
(function (CaveatMutatorOperation) {
    CaveatMutatorOperation[CaveatMutatorOperation["noop"] = 0] = "noop";
    CaveatMutatorOperation[CaveatMutatorOperation["updateValue"] = 1] = "updateValue";
    CaveatMutatorOperation[CaveatMutatorOperation["deleteCaveat"] = 2] = "deleteCaveat";
    CaveatMutatorOperation[CaveatMutatorOperation["revokePermission"] = 3] = "revokePermission";
})(CaveatMutatorOperation = exports.CaveatMutatorOperation || (exports.CaveatMutatorOperation = {}));
/**
 * The permission controller. See the README for details.
 *
 * Assumes the existence of an {@link ApprovalController} reachable via the
 * {@link ControllerMessenger}.
 *
 * @template ControllerPermissionSpecification - A union of the types of all
 * permission specifications available to the controller. Any referenced caveats
 * must be included in the controller's caveat specifications.
 * @template ControllerCaveatSpecification - A union of the types of all
 * caveat specifications available to the controller.
 */
class PermissionController extends BaseControllerV2_1.BaseController {
    /**
     * Constructs the PermissionController.
     *
     * @param options - Permission controller options.
     * @param options.caveatSpecifications - The specifications of all caveats
     * available to the controller. See {@link CaveatSpecificationMap} and the
     * documentation for more details.
     * @param options.permissionSpecifications - The specifications of all
     * permissions available to the controller. See
     * {@link PermissionSpecificationMap} and the README for more details.
     * @param options.unrestrictedMethods - The callable names of all JSON-RPC
     * methods ignored by the new controller.
     * @param options.messenger - The controller messenger. See
     * {@link BaseController} for more information.
     * @param options.state - Existing state to hydrate the controller with at
     * initialization.
     */
    constructor(options) {
        const { caveatSpecifications, permissionSpecifications, unrestrictedMethods, messenger, state = {}, } = options;
        super({
            name: controllerName,
            metadata: getStateMetadata(),
            messenger,
            state: Object.assign(Object.assign({}, getDefaultState()), state),
        });
        this._unrestrictedMethods = new Set(unrestrictedMethods);
        this._caveatSpecifications = (0, deep_freeze_strict_1.default)(Object.assign({}, caveatSpecifications));
        this.validatePermissionSpecifications(permissionSpecifications, this._caveatSpecifications);
        this._permissionSpecifications = (0, deep_freeze_strict_1.default)(Object.assign({}, permissionSpecifications));
        this.registerMessageHandlers();
        this.createPermissionMiddleware = (0, permission_middleware_1.getPermissionMiddlewareFactory)({
            executeRestrictedMethod: this._executeRestrictedMethod.bind(this),
            getRestrictedMethod: this.getRestrictedMethod.bind(this),
            isUnrestrictedMethod: this.unrestrictedMethods.has.bind(this.unrestrictedMethods),
        });
    }
    /**
     * The names of all JSON-RPC methods that will be ignored by the controller.
     *
     * @returns The names of all unrestricted JSON-RPC methods
     */
    get unrestrictedMethods() {
        return this._unrestrictedMethods;
    }
    /**
     * Gets a permission specification.
     *
     * @param targetKey - The target key of the permission specification to get.
     * @returns The permission specification with the specified target key.
     */
    getPermissionSpecification(targetKey) {
        return this._permissionSpecifications[targetKey];
    }
    /**
     * Gets a caveat specification.
     *
     * @param caveatType - The type of the caveat specification to get.
     * @returns The caveat specification with the specified type.
     */
    getCaveatSpecification(caveatType) {
        return this._caveatSpecifications[caveatType];
    }
    /**
     * Constructor helper for validating permission specifications. This is
     * intended to prevent the use of invalid target keys which, while impossible
     * to add in TypeScript, could rather easily occur in plain JavaScript.
     *
     * Throws an error if validation fails.
     *
     * @param permissionSpecifications - The permission specifications passed to
     * this controller's constructor.
     * @param caveatSpecifications - The caveat specifications passed to this
     * controller.
     */
    validatePermissionSpecifications(permissionSpecifications, caveatSpecifications) {
        Object.entries(permissionSpecifications).forEach(([targetKey, { permissionType, targetKey: innerTargetKey, allowedCaveats },]) => {
            if (!permissionType || !(0, util_1.hasProperty)(Permission_1.PermissionType, permissionType)) {
                throw new Error(`Invalid permission type: "${permissionType}"`);
            }
            // Check if the target key is the empty string, ends with "_", or ends
            // with "*" but not "_*"
            if (!targetKey || /_$/u.test(targetKey) || /[^_]\*$/u.test(targetKey)) {
                throw new Error(`Invalid permission target key: "${targetKey}"`);
            }
            if (targetKey !== innerTargetKey) {
                throw new Error(`Invalid permission specification: key "${targetKey}" must match specification.target value "${innerTargetKey}".`);
            }
            if (allowedCaveats) {
                allowedCaveats.forEach((caveatType) => {
                    if (!(0, util_1.hasProperty)(caveatSpecifications, caveatType)) {
                        throw new errors_1.UnrecognizedCaveatTypeError(caveatType);
                    }
                });
            }
        });
    }
    /**
     * Constructor helper for registering the controller's messaging system
     * actions.
     */
    registerMessageHandlers() {
        this.messagingSystem.registerActionHandler(`${controllerName}:clearPermissions`, () => this.clearState());
        this.messagingSystem.registerActionHandler(`${controllerName}:getEndowments`, (origin, targetName, requestData) => this.getEndowments(origin, targetName, requestData));
        this.messagingSystem.registerActionHandler(`${controllerName}:getSubjectNames`, () => this.getSubjectNames());
        this.messagingSystem.registerActionHandler(`${controllerName}:getPermissions`, (origin) => this.getPermissions(origin));
        this.messagingSystem.registerActionHandler(`${controllerName}:hasPermission`, (origin, targetName) => this.hasPermission(origin, targetName));
        this.messagingSystem.registerActionHandler(`${controllerName}:hasPermissions`, (origin) => this.hasPermissions(origin));
        this.messagingSystem.registerActionHandler(`${controllerName}:grantPermissions`, this.grantPermissions.bind(this));
        this.messagingSystem.registerActionHandler(`${controllerName}:requestPermissions`, (subject, permissions) => this.requestPermissions(subject, permissions));
        this.messagingSystem.registerActionHandler(`${controllerName}:revokeAllPermissions`, (origin) => this.revokeAllPermissions(origin));
        this.messagingSystem.registerActionHandler(`${controllerName}:revokePermissionForAllSubjects`, (target) => this.revokePermissionForAllSubjects(target));
        this.messagingSystem.registerActionHandler(`${controllerName}:revokePermissions`, this.revokePermissions.bind(this));
    }
    /**
     * Clears the state of the controller.
     */
    clearState() {
        this.update((_draftState) => {
            return Object.assign({}, getDefaultState());
        });
    }
    /**
     * Gets the permission specification corresponding to the given permission
     * type and target name. Throws an error if the target name does not
     * correspond to a permission, or if the specification is not of the
     * given permission type.
     *
     * @template Type - The type of the permission specification to get.
     * @param permissionType - The type of the permission specification to get.
     * @param targetName - The name of the permission whose specification to get.
     * @param requestingOrigin - The origin of the requesting subject, if any.
     * Will be added to any thrown errors.
     * @returns The specification object corresponding to the given type and
     * target name.
     */
    getTypedPermissionSpecification(permissionType, targetName, requestingOrigin) {
        const failureError = permissionType === Permission_1.PermissionType.RestrictedMethod
            ? (0, errors_1.methodNotFound)(targetName, requestingOrigin ? { origin: requestingOrigin } : undefined)
            : new errors_1.EndowmentPermissionDoesNotExistError(targetName, requestingOrigin);
        const targetKey = this.getTargetKey(targetName);
        if (!targetKey) {
            throw failureError;
        }
        const specification = this.getPermissionSpecification(targetKey);
        if (!(0, Permission_1.hasSpecificationType)(specification, permissionType)) {
            throw failureError;
        }
        return specification;
    }
    /**
     * Gets the implementation of the specified restricted method.
     *
     * A JSON-RPC error is thrown if the method does not exist.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for internal usage.
     * @param method - The name of the restricted method.
     * @param origin - The origin associated with the request for the restricted
     * method, if any.
     * @returns The restricted method implementation.
     */
    getRestrictedMethod(method, origin) {
        return this.getTypedPermissionSpecification(Permission_1.PermissionType.RestrictedMethod, method, origin).methodImplementation;
    }
    /**
     * Gets a list of all origins of subjects.
     *
     * @returns The origins (i.e. IDs) of all subjects.
     */
    getSubjectNames() {
        return Object.keys(this.state.subjects);
    }
    /**
     * Gets the permission for the specified target of the subject corresponding
     * to the specified origin.
     *
     * @param origin - The origin of the subject.
     * @param targetName - The method name as invoked by a third party (i.e., not
     * a method key).
     * @returns The permission if it exists, or undefined otherwise.
     */
    getPermission(origin, targetName) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[targetName];
    }
    /**
     * Gets all permissions for the specified subject, if any.
     *
     * @param origin - The origin of the subject.
     * @returns The permissions of the subject, if any.
     */
    getPermissions(origin) {
        var _a;
        return (_a = this.state.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions;
    }
    /**
     * Checks whether the subject with the specified origin has the specified
     * permission.
     *
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @returns Whether the subject has the permission.
     */
    hasPermission(origin, target) {
        return Boolean(this.getPermission(origin, target));
    }
    /**
     * Checks whether the subject with the specified origin has any permissions.
     * Use this if you want to know if a subject "exists".
     *
     * @param origin - The origin of the subject to check.
     * @returns Whether the subject has any permissions.
     */
    hasPermissions(origin) {
        return Boolean(this.state.subjects[origin]);
    }
    /**
     * Revokes all permissions from the specified origin.
     *
     * Throws an error of the origin has no permissions.
     *
     * @param origin - The origin whose permissions to revoke.
     */
    revokeAllPermissions(origin) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            delete draftState.subjects[origin];
        });
    }
    /**
     * Revokes the specified permission from the subject with the specified
     * origin.
     *
     * Throws an error if the subject or the permission does not exist.
     *
     * @param origin - The origin of the subject whose permission to revoke.
     * @param target - The target name of the permission to revoke.
     */
    revokePermission(origin, target) {
        this.revokePermissions({ [origin]: [target] });
    }
    /**
     * Revokes the specified permissions from the specified subjects.
     *
     * Throws an error if any of the subjects or permissions do not exist.
     *
     * @param subjectsAndPermissions - An object mapping subject origins
     * to arrays of permission target names to revoke.
     */
    revokePermissions(subjectsAndPermissions) {
        this.update((draftState) => {
            Object.keys(subjectsAndPermissions).forEach((origin) => {
                if (!(0, util_1.hasProperty)(draftState.subjects, origin)) {
                    throw new errors_1.UnrecognizedSubjectError(origin);
                }
                subjectsAndPermissions[origin].forEach((target) => {
                    const { permissions } = draftState.subjects[origin];
                    if (!(0, util_1.hasProperty)(permissions, target)) {
                        throw new errors_1.PermissionDoesNotExistError(origin, target);
                    }
                    this.deletePermission(draftState.subjects, origin, target);
                });
            });
        });
    }
    /**
     * Revokes all permissions corresponding to the specified target for all subjects.
     * Does nothing if no subjects or no such permission exists.
     *
     * @param target - The name of the target to revoke all permissions for.
     */
    revokePermissionForAllSubjects(target) {
        if (this.getSubjectNames().length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.entries(draftState.subjects).forEach(([origin, subject]) => {
                const { permissions } = subject;
                if ((0, util_1.hasProperty)(permissions, target)) {
                    this.deletePermission(draftState.subjects, origin, target);
                }
            });
        });
    }
    /**
     * Deletes the permission identified by the given origin and target. If the
     * permission is the single remaining permission of its subject, the subject
     * is also deleted.
     *
     * @param subjects - The draft permission controller subjects.
     * @param origin - The origin of the subject associated with the permission
     * to delete.
     * @param target - The target name of the permission to delete.
     */
    deletePermission(subjects, origin, target) {
        const { permissions } = subjects[origin];
        if (Object.keys(permissions).length > 1) {
            delete permissions[target];
        }
        else {
            delete subjects[origin];
        }
    }
    /**
     * Checks whether the permission of the subject corresponding to the given
     * origin has a caveat of the specified type.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to check for.
     * @returns Whether the permission has the specified caveat.
     */
    hasCaveat(origin, target, caveatType) {
        return Boolean(this.getCaveat(origin, target, caveatType));
    }
    /**
     * Gets the caveat of the specified type, if any, for the permission of
     * the subject corresponding to the given origin.
     *
     * Throws an error if the subject does not have a permission with the
     * specified target name.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to get.
     * @returns The caveat, or `undefined` if no such caveat exists.
     */
    getCaveat(origin, target, caveatType) {
        const permission = this.getPermission(origin, target);
        if (!permission) {
            throw new errors_1.PermissionDoesNotExistError(origin, target);
        }
        return (0, Permission_1.findCaveat)(permission, caveatType);
    }
    /**
     * Adds a caveat of the specified type, with the specified caveat value, to
     * the permission corresponding to the given subject origin and permission
     * target.
     *
     * For modifying existing caveats, use
     * {@link PermissionController.updateCaveat}.
     *
     * Throws an error if no such permission exists, or if the caveat already
     * exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to add.
     * @param caveatValue - The value of the caveat to add.
     */
    addCaveat(origin, target, caveatType, caveatValue) {
        if (this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatAlreadyExistsError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Updates the value of the caveat of the specified type belonging to the
     * permission corresponding to the given subject origin and permission
     * target.
     *
     * For adding new caveats, use
     * {@link PermissionController.addCaveat}.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to update.
     * @param caveatValue - The new value of the caveat.
     */
    updateCaveat(origin, target, caveatType, caveatValue) {
        if (!this.hasCaveat(origin, target, caveatType)) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        this.setCaveat(origin, target, caveatType, caveatValue);
    }
    /**
     * Sets the specified caveat on the specified permission. Overwrites existing
     * caveats of the same type in-place (preserving array order), and adds the
     * caveat to the end of the array otherwise.
     *
     * Throws an error if the permission does not exist or fails to validate after
     * its caveats have been modified.
     *
     * @see {@link PermissionController.addCaveat}
     * @see {@link PermissionController.updateCaveat}
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to set.
     * @param caveatValue - The value of the caveat to set.
     */
    setCaveat(origin, target, caveatType, caveatValue) {
        this.update((draftState) => {
            const subject = draftState.subjects[origin];
            // Unreachable because `hasCaveat` is always called before this, and it
            // throws if permissions are missing. TypeScript needs this, however.
            /* istanbul ignore if */
            if (!subject) {
                throw new errors_1.UnrecognizedSubjectError(origin);
            }
            const permission = subject.permissions[target];
            /* istanbul ignore if: practically impossible, but TypeScript wants it */
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            const caveat = {
                type: caveatType,
                value: caveatValue,
            };
            this.validateCaveat(caveat, origin, target);
            if (permission.caveats) {
                const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveat.type);
                if (caveatIndex === -1) {
                    permission.caveats.push(caveat);
                }
                else {
                    permission.caveats.splice(caveatIndex, 1, caveat);
                }
            }
            else {
                // Typecast: At this point, we don't know if the specific permission
                // is allowed to have caveats, but it should be impossible to call
                // this method for a permission that may not have any caveats.
                // If all else fails, the permission validator is also called.
                permission.caveats = [caveat];
            }
            this.validateModifiedPermission(permission, origin, target);
        });
    }
    /**
     * Updates all caveats with the specified type for all subjects and
     * permissions by applying the specified mutator function to them.
     *
     * ATTN: Permissions can be revoked entirely by the action of this method,
     * read on for details.
     *
     * Caveat mutators are functions that receive a caveat value and return a
     * tuple consisting of a {@link CaveatMutatorOperation} and, optionally, a new
     * value to update the existing caveat with.
     *
     * For each caveat, depending on the mutator result, this method will:
     * - Do nothing ({@link CaveatMutatorOperation.noop})
     * - Update the value of the caveat ({@link CaveatMutatorOperation.updateValue}). The caveat specification validator, if any, will be called after updating the value.
     * - Delete the caveat ({@link CaveatMutatorOperation.deleteCaveat}). The permission specification validator, if any, will be called after deleting the caveat.
     * - Revoke the parent permission ({@link CaveatMutatorOperation.revokePermission})
     *
     * This method throws if the validation of any caveat or permission fails.
     *
     * @param targetCaveatType - The type of the caveats to update.
     * @param mutator - The mutator function which will be applied to all caveat
     * values.
     */
    updatePermissionsByCaveat(targetCaveatType, mutator) {
        if (Object.keys(this.state.subjects).length === 0) {
            return;
        }
        this.update((draftState) => {
            Object.values(draftState.subjects).forEach((subject) => {
                Object.values(subject.permissions).forEach((permission) => {
                    const { caveats } = permission;
                    const targetCaveat = caveats === null || caveats === void 0 ? void 0 : caveats.find(({ type }) => type === targetCaveatType);
                    if (!targetCaveat) {
                        return;
                    }
                    // The mutator may modify the caveat value in place, and must always
                    // return a valid mutation result.
                    const mutatorResult = mutator(targetCaveat.value);
                    switch (mutatorResult.operation) {
                        case CaveatMutatorOperation.noop:
                            break;
                        case CaveatMutatorOperation.updateValue:
                            // Typecast: `Mutable` is used here to assign to a readonly
                            // property. `targetConstraint` should already be mutable because
                            // it's part of a draft, but for some reason it's not. We can't
                            // use the more-correct `Draft` type here either because it
                            // results in an error.
                            targetCaveat.value =
                                mutatorResult.value;
                            this.validateCaveat(targetCaveat, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.deleteCaveat:
                            this.deleteCaveat(permission, targetCaveatType, subject.origin, permission.parentCapability);
                            break;
                        case CaveatMutatorOperation.revokePermission:
                            this.deletePermission(draftState.subjects, subject.origin, permission.parentCapability);
                            break;
                        default: {
                            // This type check ensures that the switch statement is
                            // exhaustive.
                            const _exhaustiveCheck = mutatorResult;
                            throw new Error(`Unrecognized mutation result: "${_exhaustiveCheck.operation}"`);
                        }
                    }
                });
            });
        });
    }
    /**
     * Removes the caveat of the specified type from the permission corresponding
     * to the given subject origin and target name.
     *
     * Throws an error if no such permission or caveat exists.
     *
     * @template TargetName - The permission target name. Should be inferred.
     * @template CaveatType - The valid caveat types for the permission. Should
     * be inferred.
     * @param origin - The origin of the subject.
     * @param target - The target name of the permission.
     * @param caveatType - The type of the caveat to remove.
     */
    removeCaveat(origin, target, caveatType) {
        this.update((draftState) => {
            var _a;
            const permission = (_a = draftState.subjects[origin]) === null || _a === void 0 ? void 0 : _a.permissions[target];
            if (!permission) {
                throw new errors_1.PermissionDoesNotExistError(origin, target);
            }
            if (!permission.caveats) {
                throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
            }
            this.deleteCaveat(permission, caveatType, origin, target);
        });
    }
    /**
     * Deletes the specified caveat from the specified permission. If no caveats
     * remain after deletion, the permission's caveat property is set to `null`.
     * The permission is validated after being modified.
     *
     * Throws an error if the permission does not have a caveat with the specified
     * type.
     *
     * @param permission - The permission whose caveat to delete.
     * @param caveatType - The type of the caveat to delete.
     * @param origin - The origin the permission subject.
     * @param target - The name of the permission target.
     */
    deleteCaveat(permission, caveatType, origin, target) {
        /* istanbul ignore if: not possible in our usage */
        if (!permission.caveats) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        const caveatIndex = permission.caveats.findIndex((existingCaveat) => existingCaveat.type === caveatType);
        if (caveatIndex === -1) {
            throw new errors_1.CaveatDoesNotExistError(origin, target, caveatType);
        }
        if (permission.caveats.length === 1) {
            permission.caveats = null;
        }
        else {
            permission.caveats.splice(caveatIndex, 1);
        }
        this.validateModifiedPermission(permission, origin, target);
    }
    /**
     * Validates the specified modified permission. Should **always** be invoked
     * on a permission after its caveats have been modified.
     *
     * Just like {@link PermissionController.validatePermission}, except that the
     * corresponding target key and specification are retrieved first, and an
     * error is thrown if the target key does not exist.
     *
     * @param permission - The modified permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name name of the permission.
     */
    validateModifiedPermission(permission, origin, targetName) {
        const targetKey = this.getTargetKey(permission.parentCapability);
        /* istanbul ignore if: this should be impossible */
        if (!targetKey) {
            throw new Error(`Fatal: Existing permission target key "${targetKey}" has no specification.`);
        }
        this.validatePermission(this.getPermissionSpecification(targetKey), permission, origin, targetName);
    }
    /**
     * Gets the key for the specified permission target.
     *
     * Used to support our namespaced permission target feature, which is used
     * to implement namespaced restricted JSON-RPC methods.
     *
     * @param target - The requested permission target.
     * @returns The internal key of the permission target.
     */
    getTargetKey(target) {
        if ((0, util_1.hasProperty)(this._permissionSpecifications, target)) {
            return target;
        }
        const namespacedTargetsWithoutWildcard = {};
        for (const targetKey of Object.keys(this._permissionSpecifications)) {
            const wildCardMatch = targetKey.match(/(.+)\*$/u);
            if (wildCardMatch) {
                namespacedTargetsWithoutWildcard[wildCardMatch[1]] = true;
            }
        }
        // Check for potentially nested namespaces:
        // Ex: wildzone_
        // Ex: eth_plugin_
        const segments = target.split('_');
        let targetKey = '';
        while (segments.length > 0 &&
            !(0, util_1.hasProperty)(this._permissionSpecifications, targetKey) &&
            !namespacedTargetsWithoutWildcard[targetKey]) {
            targetKey += `${segments.shift()}_`;
        }
        if (namespacedTargetsWithoutWildcard[targetKey]) {
            return `${targetKey}*`;
        }
        return undefined;
    }
    /**
     * Grants _approved_ permissions to the specified subject. Every permission and
     * caveat is stringently validated – including by calling every specification
     * validator – and an error is thrown if any validation fails.
     *
     * ATTN: This method does **not** prompt the user for approval.
     *
     * @see {@link PermissionController.requestPermissions} For initiating a
     * permissions request requiring user approval.
     * @param options - Options bag.
     * @param options.approvedPermissions - The requested permissions approved by
     * the user.
     * @param options.requestData - Permission request data. Passed to permission
     * factory functions.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions.
     * @param options.subject - The subject to grant permissions to.
     * @returns The granted permissions.
     */
    grantPermissions({ approvedPermissions, requestData, preserveExistingPermissions = true, subject, }) {
        const { origin } = subject;
        if (!origin || typeof origin !== 'string') {
            throw new errors_1.InvalidSubjectIdentifierError(origin);
        }
        const permissions = (preserveExistingPermissions
            ? Object.assign({}, this.getPermissions(origin)) : {});
        for (const [requestedTarget, approvedPermission] of Object.entries(approvedPermissions)) {
            const targetKey = this.getTargetKey(requestedTarget);
            if (!targetKey) {
                throw (0, errors_1.methodNotFound)(requestedTarget);
            }
            if (approvedPermission.parentCapability !== undefined &&
                requestedTarget !== approvedPermission.parentCapability) {
                throw new errors_1.InvalidApprovedPermissionError(origin, requestedTarget, approvedPermission);
            }
            // The requested target must be a valid target name if we found its key.
            // We reassign it to change its type.
            const targetName = requestedTarget;
            const specification = this.getPermissionSpecification(targetKey);
            // The requested caveats are validated here.
            const caveats = this.constructCaveats(origin, targetName, approvedPermission.caveats);
            const permissionOptions = {
                caveats,
                invoker: origin,
                target: targetName,
            };
            let permission;
            if (specification.factory) {
                permission = specification.factory(permissionOptions, requestData);
                // Full caveat and permission validation is performed here since the
                // factory function can arbitrarily modify the entire permission object,
                // including its caveats.
                this.validatePermission(specification, permission, origin, targetName);
            }
            else {
                permission = (0, Permission_1.constructPermission)(permissionOptions);
                // We do not need to validate caveats in this case, because the plain
                // permission constructor function does not modify the caveats, which
                // were already validated by `constructCaveats` above.
                this.validatePermission(specification, permission, origin, targetName, {
                    invokePermissionValidator: true,
                    performCaveatValidation: false,
                });
            }
            permissions[targetName] = permission;
        }
        this.setValidatedPermissions(origin, permissions);
        return permissions;
    }
    /**
     * Validates the specified permission by:
     * - Ensuring that its `caveats` property is either `null` or a non-empty array.
     * - Ensuring that it only includes caveats allowed by its specification.
     * - Ensuring that it includes no duplicate caveats (by caveat type).
     * - Validating each caveat object, if `performCaveatValidation` is `true`.
     * - Calling the validator of its specification, if one exists and `invokePermissionValidator` is `true`.
     *
     * An error is thrown if validation fails.
     *
     * @param specification - The specification of the permission.
     * @param permission - The permission to validate.
     * @param origin - The origin associated with the permission.
     * @param targetName - The target name of the permission.
     * @param validationOptions - Validation options.
     * @param validationOptions.invokePermissionValidator - Whether to invoke the
     * permission's consumer-specified validator function, if any.
     * @param validationOptions.performCaveatValidation - Whether to invoke
     * {@link PermissionController.validateCaveat} on each of the permission's
     * caveats.
     */
    validatePermission(specification, permission, origin, targetName, { invokePermissionValidator, performCaveatValidation } = {
        invokePermissionValidator: true,
        performCaveatValidation: true,
    }) {
        const { allowedCaveats, validator } = specification;
        if ((0, util_1.hasProperty)(permission, 'caveats')) {
            const { caveats } = permission;
            if (caveats !== null && !(Array.isArray(caveats) && caveats.length > 0)) {
                throw new errors_1.InvalidCaveatsPropertyError(origin, targetName, caveats);
            }
            const seenCaveatTypes = new Set();
            caveats === null || caveats === void 0 ? void 0 : caveats.forEach((caveat) => {
                if (performCaveatValidation) {
                    this.validateCaveat(caveat, origin, targetName);
                }
                if (!(allowedCaveats === null || allowedCaveats === void 0 ? void 0 : allowedCaveats.includes(caveat.type))) {
                    throw new errors_1.ForbiddenCaveatError(caveat.type, origin, targetName);
                }
                if (seenCaveatTypes.has(caveat.type)) {
                    throw new errors_1.DuplicateCaveatError(caveat.type, origin, targetName);
                }
                seenCaveatTypes.add(caveat.type);
            });
        }
        if (invokePermissionValidator && validator) {
            validator(permission, origin, targetName);
        }
    }
    /**
     * Assigns the specified permissions to the subject with the given origin.
     * Overwrites all existing permissions, and creates a subject entry if it
     * doesn't already exist.
     *
     * ATTN: Assumes that the new permissions have been validated.
     *
     * @param origin - The origin of the grantee subject.
     * @param permissions - The new permissions for the grantee subject.
     */
    setValidatedPermissions(origin, permissions) {
        this.update((draftState) => {
            if (!draftState.subjects[origin]) {
                draftState.subjects[origin] = { origin, permissions: {} };
            }
            draftState.subjects[origin].permissions = (0, immer_1.castDraft)(permissions);
        });
    }
    /**
     * Validates the requested caveats for the permission of the specified
     * subject origin and target name and returns the validated caveat array.
     *
     * Throws an error if validation fails.
     *
     * @param origin - The origin of the permission subject.
     * @param target - The permission target name.
     * @param requestedCaveats - The requested caveats to construct.
     * @returns The constructed caveats.
     */
    constructCaveats(origin, target, requestedCaveats) {
        const caveatArray = requestedCaveats === null || requestedCaveats === void 0 ? void 0 : requestedCaveats.map((requestedCaveat) => {
            this.validateCaveat(requestedCaveat, origin, target);
            // Reassign so that we have a fresh object.
            const { type, value } = requestedCaveat;
            return { type, value };
        });
        return caveatArray && (0, util_1.isNonEmptyArray)(caveatArray)
            ? caveatArray
            : undefined;
    }
    /**
     * This methods validates that the specified caveat is an object with the
     * expected properties and types. It also ensures that a caveat specification
     * exists for the requested caveat type, and calls the specification
     * validator, if it exists, on the caveat object.
     *
     * Throws an error if validation fails.
     *
     * @param caveat - The caveat object to validate.
     * @param origin - The origin associated with the subject of the parent
     * permission.
     * @param target - The target name associated with the parent permission.
     */
    validateCaveat(caveat, origin, target) {
        var _a;
        if (!(0, util_1.isPlainObject)(caveat)) {
            throw new errors_1.InvalidCaveatError(caveat, origin, target);
        }
        if (Object.keys(caveat).length !== 2) {
            throw new errors_1.InvalidCaveatFieldsError(caveat, origin, target);
        }
        if (typeof caveat.type !== 'string') {
            throw new errors_1.InvalidCaveatTypeError(caveat, origin, target);
        }
        const specification = this.getCaveatSpecification(caveat.type);
        if (!specification) {
            throw new errors_1.UnrecognizedCaveatTypeError(caveat.type, origin, target);
        }
        if (!(0, util_1.hasProperty)(caveat, 'value') || caveat.value === undefined) {
            throw new errors_1.CaveatMissingValueError(caveat, origin, target);
        }
        if (!(0, util_1.isValidJson)(caveat.value)) {
            throw new errors_1.CaveatInvalidJsonError(caveat, origin, target);
        }
        // Typecast: TypeScript still believes that the caveat is a PlainObject.
        (_a = specification.validator) === null || _a === void 0 ? void 0 : _a.call(specification, caveat, origin, target);
    }
    /**
     * Initiates a permission request that requires user approval. This should
     * always be used to grant additional permissions to a subject, unless user
     * approval has been obtained through some other means.
     *
     * Permissions are validated at every step of the approval process, and this
     * method will reject if validation fails.
     *
     * @see {@link ApprovalController} For the user approval logic.
     * @see {@link PermissionController.acceptPermissionsRequest} For the method
     * that _accepts_ the request and resolves the user approval promise.
     * @see {@link PermissionController.rejectPermissionsRequest} For the method
     * that _rejects_ the request and the user approval promise.
     * @param subject - The grantee subject.
     * @param requestedPermissions - The requested permissions.
     * @param options - Additional options.
     * @param options.id - The id of the permissions request. Defaults to a unique
     * id.
     * @param options.preserveExistingPermissions - Whether to preserve the
     * subject's existing permissions. Defaults to `true`.
     * @returns The granted permissions and request metadata.
     */
    requestPermissions(subject, requestedPermissions, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { origin } = subject;
            const { id = (0, nanoid_1.nanoid)(), preserveExistingPermissions = true } = options;
            this.validateRequestedPermissions(origin, requestedPermissions);
            const metadata = {
                id,
                origin,
            };
            const permissionsRequest = {
                metadata,
                permissions: requestedPermissions,
            };
            const _a = yield this.requestUserApproval(permissionsRequest), { permissions: approvedPermissions } = _a, requestData = __rest(_a, ["permissions"]);
            return [
                this.grantPermissions({
                    subject,
                    approvedPermissions,
                    preserveExistingPermissions,
                    requestData,
                }),
                metadata,
            ];
        });
    }
    /**
     * Validates requested permissions. Throws if validation fails.
     *
     * This method ensures that the requested permissions are a properly
     * formatted {@link RequestedPermissions} object, and performs the same
     * validation as {@link PermissionController.grantPermissions}, except that
     * consumer-specified permission validator functions are not called, since
     * they are only called on fully constructed, approved permissions that are
     * otherwise completely valid.
     *
     * Unrecognzied properties on requested permissions are ignored.
     *
     * @param origin - The origin of the grantee subject.
     * @param requestedPermissions - The requested permissions.
     */
    validateRequestedPermissions(origin, requestedPermissions) {
        if (!(0, util_1.isPlainObject)(requestedPermissions)) {
            throw (0, errors_1.invalidParams)({
                message: `Requested permissions for origin "${origin}" is not a plain object.`,
                data: { origin, requestedPermissions },
            });
        }
        if (Object.keys(requestedPermissions).length === 0) {
            throw (0, errors_1.invalidParams)({
                message: `Permissions request for origin "${origin}" contains no permissions.`,
                data: { requestedPermissions },
            });
        }
        for (const targetName of Object.keys(requestedPermissions)) {
            const permission = requestedPermissions[targetName];
            const targetKey = this.getTargetKey(targetName);
            if (!targetKey) {
                throw (0, errors_1.methodNotFound)(targetName, { origin, requestedPermissions });
            }
            if (!(0, util_1.isPlainObject)(permission) ||
                (permission.parentCapability !== undefined &&
                    targetName !== permission.parentCapability)) {
                throw (0, errors_1.invalidParams)({
                    message: `Permissions request for origin "${origin}" contains invalid requested permission(s).`,
                    data: { origin, requestedPermissions },
                });
            }
            // Here we validate the permission without invoking its validator, if any.
            // The validator will be invoked after the permission has been approved.
            this.validatePermission(this.getPermissionSpecification(targetKey), 
            // Typecast: The permission is still a "PlainObject" here.
            permission, origin, targetName, { invokePermissionValidator: false, performCaveatValidation: true });
        }
    }
    /**
     * Adds a request to the {@link ApprovalController} using the
     * {@link AddApprovalRequest} action. Also validates the resulting approved
     * permissions request, and throws an error if validation fails.
     *
     * @param permissionsRequest - The permissions request object.
     * @returns The approved permissions request object.
     */
    requestUserApproval(permissionsRequest) {
        return __awaiter(this, void 0, void 0, function* () {
            const { origin, id } = permissionsRequest.metadata;
            const approvedRequest = yield this.messagingSystem.call('ApprovalController:addRequest', {
                id,
                origin,
                requestData: permissionsRequest,
                type: utils_1.MethodNames.requestPermissions,
            }, true);
            this.validateApprovedPermissions(approvedRequest, { id, origin });
            return approvedRequest;
        });
    }
    /**
     * Validates an approved {@link PermissionsRequest} object. The approved
     * request must have the required `metadata` and `permissions` properties,
     * the `id` and `origin` of the `metadata` must match the original request
     * metadata, and the requested permissions must be valid per
     * {@link PermissionController.validateRequestedPermissions}. Any extra
     * metadata properties are ignored.
     *
     * An error is thrown if validation fails.
     *
     * @param approvedRequest - The approved permissions request object.
     * @param originalMetadata - The original request metadata.
     */
    validateApprovedPermissions(approvedRequest, originalMetadata) {
        const { id, origin } = originalMetadata;
        if (!(0, util_1.isPlainObject)(approvedRequest) ||
            !(0, util_1.isPlainObject)(approvedRequest.metadata)) {
            throw (0, errors_1.internalError)(`Approved permissions request for subject "${origin}" is invalid.`, { data: { approvedRequest } });
        }
        const { metadata: { id: newId, origin: newOrigin }, permissions, } = approvedRequest;
        if (newId !== id) {
            throw (0, errors_1.internalError)(`Approved permissions request for subject "${origin}" mutated its id.`, { originalId: id, mutatedId: newId });
        }
        if (newOrigin !== origin) {
            throw (0, errors_1.internalError)(`Approved permissions request for subject "${origin}" mutated its origin.`, { originalOrigin: origin, mutatedOrigin: newOrigin });
        }
        try {
            this.validateRequestedPermissions(origin, permissions);
        }
        catch (error) {
            if (error instanceof eth_rpc_errors_1.EthereumRpcError) {
                // Re-throw as an internal error; we should never receive invalid approved
                // permissions.
                throw (0, errors_1.internalError)(`Invalid approved permissions request: ${error.message}`, error.data);
            }
            throw (0, errors_1.internalError)('Unrecognized error type', { error });
        }
    }
    /**
     * Accepts a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param request - The permissions request.
     */
    acceptPermissionsRequest(request) {
        return __awaiter(this, void 0, void 0, function* () {
            const { id } = request.metadata;
            if (!this.hasApprovalRequest({ id })) {
                throw new errors_1.PermissionsRequestNotFoundError(id);
            }
            if (Object.keys(request.permissions).length === 0) {
                this._rejectPermissionsRequest(id, (0, errors_1.invalidParams)({
                    message: 'Must request at least one permission.',
                }));
                return;
            }
            try {
                this.messagingSystem.call('ApprovalController:acceptRequest', id, request);
            }
            catch (error) {
                // If accepting unexpectedly fails, reject the request and re-throw the
                // error
                this._rejectPermissionsRequest(id, error);
                throw error;
            }
        });
    }
    /**
     * Rejects a permissions request created by
     * {@link PermissionController.requestPermissions}.
     *
     * @param id - The id of the request to be rejected.
     */
    rejectPermissionsRequest(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasApprovalRequest({ id })) {
                throw new errors_1.PermissionsRequestNotFoundError(id);
            }
            this._rejectPermissionsRequest(id, (0, errors_1.userRejectedRequest)());
        });
    }
    /**
     * Checks whether the {@link ApprovalController} has a particular permissions
     * request.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param options - The {@link HasApprovalRequest} options.
     * @param options.id - The id of the approval request to check for.
     * @returns Whether the specified request exists.
     */
    hasApprovalRequest(options) {
        return this.messagingSystem.call('ApprovalController:hasRequest', 
        // Typecast: For some reason, the type here expects all of the possible
        // HasApprovalRequest options to be specified, when they're actually all
        // optional. Passing just the id is definitely valid, so we just cast it.
        options);
    }
    /**
     * Rejects the permissions request with the specified id, with the specified
     * error as the reason. This method is effectively a wrapper around a
     * messenger call for the `ApprovalController:rejectRequest` action.
     *
     * @see {@link PermissionController.acceptPermissionsRequest} and
     * {@link PermissionController.rejectPermissionsRequest} for usage.
     * @param id - The id of the request to reject.
     * @param error - The error associated with the rejection.
     * @returns Nothing
     */
    _rejectPermissionsRequest(id, error) {
        return this.messagingSystem.call('ApprovalController:rejectRequest', id, error);
    }
    /**
     * Gets the subject's endowments per the specified endowment permission.
     * Throws if the subject does not have the required permission or if the
     * permission is not an endowment permission.
     *
     * @param origin - The origin of the subject whose endowments to retrieve.
     * @param targetName - The name of the endowment permission. This must be a
     * valid permission target name.
     * @param requestData - Additional data associated with the request, if any.
     * Forwarded to the endowment getter function for the permission.
     * @returns The endowments, if any.
     */
    getEndowments(origin, targetName, requestData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasPermission(origin, targetName)) {
                throw (0, errors_1.unauthorized)({ data: { origin, targetName } });
            }
            return this.getTypedPermissionSpecification(Permission_1.PermissionType.Endowment, targetName, origin).endowmentGetter({ origin, requestData });
        });
    }
    /**
     * Executes a restricted method as the subject with the given origin.
     * The specified params, if any, will be passed to the method implementation.
     *
     * ATTN: Great caution should be exercised in the use of this method.
     * Methods that cause side effects or affect application state should
     * be avoided.
     *
     * This method will first attempt to retrieve the requested restricted method
     * implementation, throwing if it does not exist. The method will then be
     * invoked as though the subject with the specified origin had invoked it with
     * the specified parameters. This means that any existing caveats will be
     * applied to the restricted method, and this method will throw if the
     * restricted method or its caveat decorators throw.
     *
     * In addition, this method will throw if the subject does not have a
     * permission for the specified restricted method.
     *
     * @param origin - The origin of the subject to execute the method on behalf
     * of.
     * @param targetName - The name of the method to execute. This must be a valid
     * permission target name.
     * @param params - The parameters to pass to the method implementation.
     * @returns The result of the executed method.
     */
    executeRestrictedMethod(origin, targetName, params) {
        return __awaiter(this, void 0, void 0, function* () {
            // Throws if the method does not exist
            const methodImplementation = this.getRestrictedMethod(targetName, origin);
            const result = yield this._executeRestrictedMethod(methodImplementation, { origin }, targetName, params);
            if (result === undefined) {
                throw new Error(`Internal request for method "${targetName}" as origin "${origin}" returned no result.`);
            }
            return result;
        });
    }
    /**
     * An internal method used in the controller's `json-rpc-engine` middleware
     * and {@link PermissionController.executeRestrictedMethod}. Calls the
     * specified restricted method implementation after decorating it with the
     * caveats of its permission. Throws if the subject does not have the
     * requisite permission.
     *
     * ATTN: Parameter validation is the responsibility of the caller, or
     * the restricted method implementation in the case of `params`.
     *
     * @see {@link PermissionController.executeRestrictedMethod} and
     * {@link PermissionController.createPermissionMiddleware} for usage.
     * @param methodImplementation - The implementation of the method to call.
     * @param subject - Metadata about the subject that made the request.
     * @param method - The method name
     * @param params - Params needed for executing the restricted method
     * @returns The result of the restricted method implementation
     */
    _executeRestrictedMethod(methodImplementation, subject, method, params = []) {
        const { origin } = subject;
        const permission = this.getPermission(origin, method);
        if (!permission) {
            throw (0, errors_1.unauthorized)({ data: { origin, method } });
        }
        return (0, Caveat_1.decorateWithCaveats)(methodImplementation, permission, this._caveatSpecifications)({ method, params, context: { origin } });
    }
}
exports.PermissionController = PermissionController;
//# sourceMappingURL=PermissionController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\errors.js", {"eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\errors.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PermissionsRequestNotFoundError = exports.DuplicateCaveatError = exports.ForbiddenCaveatError = exports.InvalidCaveatFieldsError = exports.CaveatInvalidJsonError = exports.CaveatMissingValueError = exports.InvalidCaveatTypeError = exports.InvalidCaveatError = exports.CaveatAlreadyExistsError = exports.CaveatDoesNotExistError = exports.InvalidCaveatsPropertyError = exports.UnrecognizedCaveatTypeError = exports.EndowmentPermissionDoesNotExistError = exports.PermissionDoesNotExistError = exports.InvalidApprovedPermissionError = exports.UnrecognizedSubjectError = exports.InvalidSubjectIdentifierError = exports.internalError = exports.userRejectedRequest = exports.invalidParams = exports.methodNotFound = exports.unauthorized = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
/**
 * Utility function for building an "unauthorized" error.
 *
 * @param opts - Optional arguments that add extra context
 * @returns The built error
 */
function unauthorized(opts) {
    return eth_rpc_errors_1.ethErrors.provider.unauthorized({
        message: 'Unauthorized to perform action. Try requesting the required permission(s) first. For more information, see: https://docs.metamask.io/guide/rpc-api.html#permissions',
        data: opts.data,
    });
}
exports.unauthorized = unauthorized;
/**
 * Utility function for building a "method not found" error.
 *
 * @param method - The method in question.
 * @param data - Optional data for context.
 * @returns The built error
 */
function methodNotFound(method, data) {
    const message = `The method "${method}" does not exist / is not available.`;
    const opts = { message };
    if (data !== undefined) {
        opts.data = data;
    }
    return eth_rpc_errors_1.ethErrors.rpc.methodNotFound(opts);
}
exports.methodNotFound = methodNotFound;
/**
 * Utility function for building an "invalid params" error.
 *
 * @param opts - Optional arguments that add extra context
 * @returns The built error
 */
function invalidParams(opts) {
    return eth_rpc_errors_1.ethErrors.rpc.invalidParams({
        data: opts.data,
        message: opts.message,
    });
}
exports.invalidParams = invalidParams;
/**
 * Utility function for building an "user rejected request" error.
 *
 * @param data - Optional data to add extra context
 * @returns The built error
 */
function userRejectedRequest(data) {
    return eth_rpc_errors_1.ethErrors.provider.userRejectedRequest({ data });
}
exports.userRejectedRequest = userRejectedRequest;
/**
 * Utility function for building an internal error.
 *
 * @param message - The error message
 * @param data - Optional data to add extra context
 * @returns The built error
 */
function internalError(message, data) {
    return eth_rpc_errors_1.ethErrors.rpc.internal({ message, data });
}
exports.internalError = internalError;
class InvalidSubjectIdentifierError extends Error {
    constructor(origin) {
        super(`Invalid subject identifier: "${typeof origin === 'string' ? origin : typeof origin}"`);
    }
}
exports.InvalidSubjectIdentifierError = InvalidSubjectIdentifierError;
class UnrecognizedSubjectError extends Error {
    constructor(origin) {
        super(`Unrecognized subject: "${origin}" has no permissions.`);
    }
}
exports.UnrecognizedSubjectError = UnrecognizedSubjectError;
class InvalidApprovedPermissionError extends Error {
    constructor(origin, target, approvedPermission) {
        super(`Invalid approved permission for origin "${origin}" and target "${target}".`);
        this.data = { origin, target, approvedPermission };
    }
}
exports.InvalidApprovedPermissionError = InvalidApprovedPermissionError;
class PermissionDoesNotExistError extends Error {
    constructor(origin, target) {
        super(`Subject "${origin}" has no permission for "${target}".`);
    }
}
exports.PermissionDoesNotExistError = PermissionDoesNotExistError;
class EndowmentPermissionDoesNotExistError extends Error {
    constructor(target, origin) {
        super(`Subject "${origin}" has no permission for "${target}".`);
        if (origin) {
            this.data = { origin };
        }
    }
}
exports.EndowmentPermissionDoesNotExistError = EndowmentPermissionDoesNotExistError;
class UnrecognizedCaveatTypeError extends Error {
    constructor(caveatType, origin, target) {
        super(`Unrecognized caveat type: "${caveatType}"`);
        this.data = { caveatType };
        if (origin !== undefined) {
            this.data.origin = origin;
        }
        if (target !== undefined) {
            this.data.target = target;
        }
    }
}
exports.UnrecognizedCaveatTypeError = UnrecognizedCaveatTypeError;
class InvalidCaveatsPropertyError extends Error {
    constructor(origin, target, caveatsProperty) {
        super(`The "caveats" property of permission for "${target}" of subject "${origin}" is invalid. It must be a non-empty array if specified.`);
        this.data = { origin, target, caveatsProperty };
    }
}
exports.InvalidCaveatsPropertyError = InvalidCaveatsPropertyError;
class CaveatDoesNotExistError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" has no caveat of type "${caveatType}".`);
    }
}
exports.CaveatDoesNotExistError = CaveatDoesNotExistError;
class CaveatAlreadyExistsError extends Error {
    constructor(origin, target, caveatType) {
        super(`Permission for "${target}" of subject "${origin}" already has a caveat of type "${caveatType}".`);
    }
}
exports.CaveatAlreadyExistsError = CaveatAlreadyExistsError;
class InvalidCaveatError extends eth_rpc_errors_1.EthereumRpcError {
    constructor(receivedCaveat, origin, target) {
        super(eth_rpc_errors_1.errorCodes.rpc.invalidParams, `Invalid caveat. Caveats must be plain objects.`, { receivedCaveat });
        this.data = { origin, target };
    }
}
exports.InvalidCaveatError = InvalidCaveatError;
class InvalidCaveatTypeError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat types must be strings. Received: "${typeof caveat.type}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatTypeError = InvalidCaveatTypeError;
class CaveatMissingValueError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat is missing "value" field.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatMissingValueError = CaveatMissingValueError;
class CaveatInvalidJsonError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat "value" is invalid JSON.`);
        this.data = { caveat, origin, target };
    }
}
exports.CaveatInvalidJsonError = CaveatInvalidJsonError;
class InvalidCaveatFieldsError extends Error {
    constructor(caveat, origin, target) {
        super(`Caveat has unexpected number of fields: "${Object.keys(caveat).length}"`);
        this.data = { caveat, origin, target };
    }
}
exports.InvalidCaveatFieldsError = InvalidCaveatFieldsError;
class ForbiddenCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" may not have caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.ForbiddenCaveatError = ForbiddenCaveatError;
class DuplicateCaveatError extends Error {
    constructor(caveatType, origin, targetName) {
        super(`Permissions for target "${targetName}" contains multiple caveats of type "${caveatType}".`);
        this.data = { caveatType, origin, target: targetName };
    }
}
exports.DuplicateCaveatError = DuplicateCaveatError;
class PermissionsRequestNotFoundError extends Error {
    constructor(id) {
        super(`Permissions request with id "${id}" not found.`);
    }
}
exports.PermissionsRequestNotFoundError = PermissionsRequestNotFoundError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\index.js", {"./Caveat":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\Caveat.js","./Permission":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\Permission.js","./PermissionController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\PermissionController.js","./rpc-methods":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\rpc-methods\\index.js","./utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.permissionRpcMethods = void 0;
__exportStar(require("./Caveat"), exports);
__exportStar(require("./Permission"), exports);
__exportStar(require("./PermissionController"), exports);
__exportStar(require("./utils"), exports);
exports.permissionRpcMethods = __importStar(require("./rpc-methods"));
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\permission-middleware.js", {"./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\errors.js","json-rpc-engine":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-rpc-engine\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\permission-middleware.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionMiddlewareFactory = void 0;
const json_rpc_engine_1 = require("json-rpc-engine");
const errors_1 = require("./errors");
/**
 * Creates a permission middleware function factory. Intended for internal use
 * in the {@link PermissionController}. Like any {@link JsonRpcEngine}
 * middleware, each middleware will only receive requests from a particular
 * subject / origin. However, each middleware also requires access to some
 * `PermissionController` internals, which is why this "factory factory" exists.
 *
 * The middlewares returned by the factory will pass through requests for
 * unrestricted methods, and attempt to execute restricted methods. If a method
 * is neither restricted nor unrestricted, a "method not found" error will be
 * returned.
 * If a method is restricted, the middleware will first attempt to retrieve the
 * subject's permission for that method. If the permission is found, the method
 * will be executed. Otherwise, an "unauthorized" error will be returned.
 *
 * @param options - Options bag.
 * @param options.executeRestrictedMethod - {@link PermissionController._executeRestrictedMethod}.
 * @param options.getRestrictedMethod - {@link PermissionController.getRestrictedMethod}.
 * @param options.isUnrestrictedMethod - A function that checks whether a
 * particular method is unrestricted.
 * @returns A permission middleware factory function.
 */
function getPermissionMiddlewareFactory({ executeRestrictedMethod, getRestrictedMethod, isUnrestrictedMethod, }) {
    return function createPermissionMiddleware(subject) {
        const { origin } = subject;
        if (typeof origin !== 'string' || !origin) {
            throw new Error('The subject "origin" must be a non-empty string.');
        }
        const permissionsMiddleware = (req, res, next) => __awaiter(this, void 0, void 0, function* () {
            const { method, params } = req;
            // Skip registered unrestricted methods.
            if (isUnrestrictedMethod(method)) {
                return next();
            }
            // This will throw if no restricted method implementation is found.
            const methodImplementation = getRestrictedMethod(method, origin);
            // This will throw if the permission does not exist.
            const result = yield executeRestrictedMethod(methodImplementation, subject, method, params);
            if (result === undefined) {
                res.error = (0, errors_1.internalError)(`Request for method "${req.method}" returned undefined result.`, { request: req });
                return undefined;
            }
            res.result = result;
            return undefined;
        });
        return (0, json_rpc_engine_1.createAsyncMiddleware)(permissionsMiddleware);
    };
}
exports.getPermissionMiddlewareFactory = getPermissionMiddlewareFactory;
//# sourceMappingURL=permission-middleware.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\rpc-methods\\getPermissions.js", {"../utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\rpc-methods\getPermissions.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPermissionsHandler = void 0;
const utils_1 = require("../utils");
exports.getPermissionsHandler = {
    methodNames: [utils_1.MethodNames.getPermissions],
    implementation: getPermissionsImplementation,
    hookNames: {
        getPermissionsForOrigin: true,
    },
};
/**
 * Get Permissions implementation to be used in JsonRpcEngine middleware.
 *
 * @param _req - The JsonRpcEngine request - unused
 * @param res - The JsonRpcEngine result object
 * @param _next - JsonRpcEngine next() callback - unused
 * @param end - JsonRpcEngine end() callback
 * @param options - Method hooks passed to the method implementation
 * @param options.getPermissionsForOrigin - The specific method hook needed for this method implementation
 * @returns A promise that resolves to nothing
 */
function getPermissionsImplementation(_req, res, _next, end, { getPermissionsForOrigin }) {
    return __awaiter(this, void 0, void 0, function* () {
        res.result = Object.values(getPermissionsForOrigin() || {});
        return end();
    });
}
//# sourceMappingURL=getPermissions.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\rpc-methods\\index.js", {"./getPermissions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\rpc-methods\\getPermissions.js","./requestPermissions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\rpc-methods\\requestPermissions.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\rpc-methods\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlers = void 0;
const requestPermissions_1 = require("./requestPermissions");
const getPermissions_1 = require("./getPermissions");
exports.handlers = [requestPermissions_1.requestPermissionsHandler, getPermissions_1.getPermissionsHandler];
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\rpc-methods\\requestPermissions.js", {"../../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","../errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\errors.js","../utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\utils.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\rpc-methods\requestPermissions.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestPermissionsHandler = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const utils_1 = require("../utils");
const errors_1 = require("../errors");
const util_1 = require("../../util");
exports.requestPermissionsHandler = {
    methodNames: [utils_1.MethodNames.requestPermissions],
    implementation: requestPermissionsImplementation,
    hookNames: {
        requestPermissionsForOrigin: true,
    },
};
/**
 * Request Permissions implementation to be used in JsonRpcEngine middleware.
 *
 * @param req - The JsonRpcEngine request
 * @param res - The JsonRpcEngine result object
 * @param _next - JsonRpcEngine next() callback - unused
 * @param end - JsonRpcEngine end() callback
 * @param options - Method hooks passed to the method implementation
 * @param options.requestPermissionsForOrigin - The specific method hook needed for this method implementation
 * @returns A promise that resolves to nothing
 */
function requestPermissionsImplementation(req, res, _next, end, { requestPermissionsForOrigin }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { id, params } = req;
        if ((typeof id !== 'number' && typeof id !== 'string') ||
            (typeof id === 'string' && !id)) {
            return end(eth_rpc_errors_1.ethErrors.rpc.invalidRequest({
                message: 'Invalid request: Must specify a valid id.',
                data: { request: req },
            }));
        }
        if (!Array.isArray(params) || !(0, util_1.isPlainObject)(params[0])) {
            return end((0, errors_1.invalidParams)({ data: { request: req } }));
        }
        const [requestedPermissions] = params;
        const [grantedPermissions] = yield requestPermissionsForOrigin(requestedPermissions, String(id));
        // `wallet_requestPermission` is specified to return an array.
        res.result = Object.values(grantedPermissions);
        return end();
    });
}
//# sourceMappingURL=requestPermissions.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\permissions\\utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\permissions\utils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MethodNames = void 0;
var MethodNames;
(function (MethodNames) {
    MethodNames["requestPermissions"] = "wallet_requestPermissions";
    MethodNames["getPermissions"] = "wallet_getPermissions";
})(MethodNames = exports.MethodNames || (exports.MethodNames = {}));
//# sourceMappingURL=utils.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\ratelimit\\RateLimitController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\ratelimit\RateLimitController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimitController = void 0;
const eth_rpc_errors_1 = require("eth-rpc-errors");
const BaseControllerV2_1 = require("../BaseControllerV2");
const name = 'RateLimitController';
const metadata = {
    requests: { persist: false, anonymous: false },
};
/**
 * Controller with logic for rate-limiting API endpoints per requesting origin.
 */
class RateLimitController extends BaseControllerV2_1.BaseController {
    /**
     * Creates a RateLimitController instance.
     *
     * @param options - Constructor options.
     * @param options.messenger - A reference to the messaging system.
     * @param options.state - Initial state to set on this controller.
     * @param options.implementations - Mapping from API type to API implementation.
     * @param options.rateLimitTimeout - The time window in which the rate limit is applied (in ms).
     * @param options.rateLimitCount - The amount of calls an origin can make in the rate limit time window.
     */
    constructor({ rateLimitTimeout = 5000, rateLimitCount = 1, messenger, state, implementations, }) {
        const defaultState = {
            requests: Object.keys(implementations).reduce((acc, key) => (Object.assign(Object.assign({}, acc), { [key]: {} })), {}),
        };
        super({
            name,
            metadata,
            messenger,
            state: Object.assign(Object.assign({}, defaultState), state),
        });
        this.implementations = implementations;
        this.rateLimitTimeout = rateLimitTimeout;
        this.rateLimitCount = rateLimitCount;
        this.messagingSystem.registerActionHandler(`${name}:call`, ((origin, type, ...args) => this.call(origin, type, ...args)));
    }
    /**
     * Calls an API if the requesting origin is not rate-limited.
     *
     * @param origin - The requesting origin.
     * @param type - The type of API call to make.
     * @param args - Arguments for the API call.
     * @returns `false` if rate-limited, and `true` otherwise.
     */
    call(origin, type, ...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isRateLimited(type, origin)) {
                throw eth_rpc_errors_1.ethErrors.rpc.limitExceeded({
                    message: `"${type}" is currently rate-limited. Please try again later.`,
                });
            }
            this.recordRequest(type, origin);
            const implementation = this.implementations[type];
            if (!implementation) {
                throw new Error('Invalid api type');
            }
            return implementation(...args);
        });
    }
    /**
     * Checks whether an origin is rate limited for the a specific API.
     *
     * @param api - The API the origin is trying to access.
     * @param origin - The origin trying to access the API.
     * @returns `true` if rate-limited, and `false` otherwise.
     */
    isRateLimited(api, origin) {
        return this.state.requests[api][origin] >= this.rateLimitCount;
    }
    /**
     * Records that an origin has made a request to call an API, for rate-limiting purposes.
     *
     * @param api - The API the origin is trying to access.
     * @param origin - The origin trying to access the API.
     */
    recordRequest(api, origin) {
        this.update((state) => {
            var _a;
            const previous = (_a = state.requests[api][origin]) !== null && _a !== void 0 ? _a : 0;
            state.requests[api][origin] = previous + 1;
            if (previous === 0) {
                setTimeout(() => this.resetRequestCount(api, origin), this.rateLimitTimeout);
            }
        });
    }
    /**
     * Resets the request count for a given origin and API combination, for rate-limiting purposes.
     *
     * @param api - The API in question.
     * @param origin - The origin in question.
     */
    resetRequestCount(api, origin) {
        this.update((state) => {
            state.requests[api][origin] = 0;
        });
    }
}
exports.RateLimitController = RateLimitController;
//# sourceMappingURL=RateLimitController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\subject-metadata\\SubjectMetadataController.js", {"../BaseControllerV2":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseControllerV2.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\subject-metadata\SubjectMetadataController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubjectMetadataController = void 0;
const BaseControllerV2_1 = require("../BaseControllerV2");
const controllerName = 'SubjectMetadataController';
const stateMetadata = {
    subjectMetadata: { persist: true, anonymous: false },
};
const defaultState = {
    subjectMetadata: {},
};
/**
 * A controller for storing metadata associated with permission subjects. More
 * or less, a cache.
 */
class SubjectMetadataController extends BaseControllerV2_1.BaseController {
    constructor({ messenger, subjectCacheLimit, state = {}, }) {
        if (!Number.isInteger(subjectCacheLimit) || subjectCacheLimit < 1) {
            throw new Error(`subjectCacheLimit must be a positive integer. Received: "${subjectCacheLimit}"`);
        }
        const hasPermissions = (origin) => {
            return messenger.call('PermissionController:hasPermissions', origin);
        };
        super({
            name: controllerName,
            metadata: stateMetadata,
            messenger,
            state: Object.assign({}, SubjectMetadataController.getTrimmedState(state, hasPermissions)),
        });
        this.subjectHasPermissions = hasPermissions;
        this.subjectCacheLimit = subjectCacheLimit;
        this.subjectsWithoutPermissionsEcounteredSinceStartup = new Set();
    }
    /**
     * Clears the state of this controller. Also resets the cache of subjects
     * encountered since startup, so as to not prematurely reach the cache limit.
     */
    clearState() {
        this.subjectsWithoutPermissionsEcounteredSinceStartup.clear();
        this.update((_draftState) => {
            return Object.assign({}, defaultState);
        });
    }
    /**
     * Stores domain metadata for the given origin (subject). Deletes metadata for
     * subjects without permissions in a FIFO manner once more than
     * {@link SubjectMetadataController.subjectCacheLimit} distinct origins have
     * been added since boot.
     *
     * In order to prevent a degraded user experience,
     * metadata is never deleted for subjects with permissions, since metadata
     * cannot yet be requested on demand.
     *
     * @param metadata - The subject metadata to store.
     */
    addSubjectMetadata(metadata) {
        const { origin } = metadata;
        const newMetadata = Object.assign(Object.assign({}, metadata), { extensionId: metadata.extensionId || null, iconUrl: metadata.iconUrl || null, name: metadata.name || null });
        let originToForget = null;
        // We only delete the oldest encountered subject from the cache, again to
        // ensure that the user's experience isn't degraded by missing icons etc.
        if (this.subjectsWithoutPermissionsEcounteredSinceStartup.size >=
            this.subjectCacheLimit) {
            const cachedOrigin = this.subjectsWithoutPermissionsEcounteredSinceStartup
                .values()
                .next().value;
            this.subjectsWithoutPermissionsEcounteredSinceStartup.delete(cachedOrigin);
            if (!this.subjectHasPermissions(cachedOrigin)) {
                originToForget = cachedOrigin;
            }
        }
        this.subjectsWithoutPermissionsEcounteredSinceStartup.add(origin);
        this.update((draftState) => {
            // Typecast: ts(2589)
            draftState.subjectMetadata[origin] = newMetadata;
            if (typeof originToForget === 'string') {
                delete draftState.subjectMetadata[originToForget];
            }
        });
    }
    /**
     * Deletes all subjects without permissions from the controller's state.
     */
    trimMetadataState() {
        this.update((draftState) => {
            return SubjectMetadataController.getTrimmedState(
            // Typecast: ts(2589)
            draftState, this.subjectHasPermissions);
        });
    }
    /**
     * Returns a new state object that only includes subjects with permissions.
     * This method is static because we want to call it in the constructor, before
     * the controller's state is initialized.
     *
     * @param state - The state object to trim.
     * @param hasPermissions - A function that returns a boolean indicating
     * whether a particular subject (identified by its origin) has any
     * permissions.
     * @returns The new state object. If the specified `state` object has no
     * subject metadata, the returned object will be equivalent to the default
     * state of this controller.
     */
    static getTrimmedState(state, hasPermissions) {
        const { subjectMetadata = {} } = state;
        return {
            subjectMetadata: Object.keys(subjectMetadata).reduce((newSubjectMetadata, origin) => {
                if (hasPermissions(origin)) {
                    newSubjectMetadata[origin] = subjectMetadata[origin];
                }
                return newSubjectMetadata;
            }, {}),
        };
    }
}
exports.SubjectMetadataController = SubjectMetadataController;
//# sourceMappingURL=SubjectMetadataController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\subject-metadata\\index.js", {"./SubjectMetadataController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\subject-metadata\\SubjectMetadataController.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\subject-metadata\index.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./SubjectMetadataController"), exports);
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\third-party\\PhishingController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","eth-phishing-detect/src/config.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-phishing-detect\\src\\config.json","eth-phishing-detect/src/detector":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-phishing-detect\\src\\detector.js","punycode/":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\punycode\\punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\third-party\PhishingController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PhishingController = void 0;
const punycode_1 = require("punycode/");
const config_json_1 = __importDefault(require("eth-phishing-detect/src/config.json"));
const detector_1 = __importDefault(require("eth-phishing-detect/src/detector"));
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that passively polls on a set interval for approved and unapproved website origins
 */
class PhishingController extends BaseController_1.BaseController {
    /**
     * Creates a PhishingController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        this.configUrlMetaMask = 'https://cdn.jsdelivr.net/gh/MetaMask/eth-phishing-detect@master/src/config.json';
        this.configUrlPhishFortHotlist = `https://cdn.jsdelivr.net/gh/phishfort/phishfort-lists@master/blacklists/hotlist.json`;
        /**
         * Name of this controller used during composition
         */
        this.name = 'PhishingController';
        this.defaultConfig = { interval: 60 * 60 * 1000 };
        this.defaultState = {
            phishing: [
                {
                    allowlist: config_json_1.default
                        .whitelist,
                    blocklist: config_json_1.default
                        .blacklist,
                    fuzzylist: config_json_1.default
                        .fuzzylist,
                    tolerance: config_json_1.default
                        .tolerance,
                    name: `MetaMask`,
                    version: config_json_1.default.version,
                },
            ],
            whitelist: [],
        };
        this.detector = new detector_1.default(this.defaultState.phishing);
        this.initialize();
        this.poll();
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - Polling interval used to fetch new approval lists.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield (0, util_1.safelyExecute)(() => this.updatePhishingLists());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Determines if a given origin is unapproved.
     *
     * @param origin - Domain origin of a website.
     * @returns Whether the origin is an unapproved origin.
     */
    test(origin) {
        const punycodeOrigin = (0, punycode_1.toASCII)(origin);
        if (this.state.whitelist.indexOf(punycodeOrigin) !== -1) {
            return { result: false, type: 'all' }; // Same as whitelisted match returned by detector.check(...).
        }
        return this.detector.check(punycodeOrigin);
    }
    /**
     * Temporarily marks a given origin as approved.
     *
     * @param origin - The origin to mark as approved.
     */
    bypass(origin) {
        const punycodeOrigin = (0, punycode_1.toASCII)(origin);
        const { whitelist } = this.state;
        if (whitelist.indexOf(punycodeOrigin) !== -1) {
            return;
        }
        this.update({ whitelist: [...whitelist, punycodeOrigin] });
    }
    /**
     * Updates lists of approved and unapproved website origins.
     */
    updatePhishingLists() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.disabled) {
                return;
            }
            const configs = [];
            const [metamaskConfigLegacy, phishfortHotlist] = yield Promise.all([
                yield this.queryConfig(this.configUrlMetaMask),
                yield this.queryConfig(this.configUrlPhishFortHotlist),
            ]);
            // Correctly shaping MetaMask config.
            const metamaskConfig = {
                allowlist: metamaskConfigLegacy ? metamaskConfigLegacy.whitelist : [],
                blocklist: metamaskConfigLegacy ? metamaskConfigLegacy.blacklist : [],
                fuzzylist: metamaskConfigLegacy ? metamaskConfigLegacy.fuzzylist : [],
                tolerance: metamaskConfigLegacy ? metamaskConfigLegacy.tolerance : 0,
                name: `MetaMask`,
                version: metamaskConfigLegacy ? metamaskConfigLegacy.version : 0,
            };
            if (metamaskConfigLegacy) {
                configs.push(metamaskConfig);
            }
            // Correctly shaping PhishFort config.
            const phishfortConfig = {
                allowlist: [],
                blocklist: (phishfortHotlist || []).filter((i) => !metamaskConfig.blocklist.includes(i)),
                fuzzylist: [],
                tolerance: 0,
                name: `PhishFort`,
                version: 1,
            };
            if (phishfortHotlist) {
                configs.push(phishfortConfig);
            }
            // Do not update if all configs are unavailable.
            if (!configs.length) {
                return;
            }
            this.detector = new detector_1.default(configs);
            this.update({
                phishing: configs,
            });
        });
    }
    queryConfig(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield fetch(input, { cache: 'no-cache' });
            switch (response.status) {
                case 200: {
                    return yield response.json();
                }
                default: {
                    return null;
                }
            }
        });
    }
}
exports.PhishingController = PhishingController;
exports.default = PhishingController;
//# sourceMappingURL=PhishingController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\transaction\\TransactionController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js","@ethereumjs/common":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js","@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","async-mutex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async-mutex\\lib\\index.js","eth-method-registry":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\eth-method-registry\\index.js","eth-query":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\transaction\TransactionController.js
      return function (require, module, exports) {
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionController = exports.SPEED_UP_RATE = exports.CANCEL_RATE = exports.WalletDevice = exports.TransactionStatus = void 0;
const events_1 = require("events");
const ethereumjs_util_1 = require("ethereumjs-util");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_method_registry_1 = __importDefault(require("eth-method-registry"));
const eth_query_1 = __importDefault(require("eth-query"));
const common_1 = __importDefault(require("@ethereumjs/common"));
const tx_1 = require("@ethereumjs/tx");
const uuid_1 = require("uuid");
const async_mutex_1 = require("async-mutex");
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
const constants_1 = require("../constants");
const HARDFORK = 'london';
/**
 * The status of the transaction. Each status represents the state of the transaction internally
 * in the wallet. Some of these correspond with the state of the transaction on the network, but
 * some are wallet-specific.
 */
var TransactionStatus;
(function (TransactionStatus) {
    TransactionStatus["approved"] = "approved";
    TransactionStatus["cancelled"] = "cancelled";
    TransactionStatus["confirmed"] = "confirmed";
    TransactionStatus["failed"] = "failed";
    TransactionStatus["rejected"] = "rejected";
    TransactionStatus["signed"] = "signed";
    TransactionStatus["submitted"] = "submitted";
    TransactionStatus["unapproved"] = "unapproved";
})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));
/**
 * Options for wallet device.
 */
var WalletDevice;
(function (WalletDevice) {
    WalletDevice["MM_MOBILE"] = "metamask_mobile";
    WalletDevice["MM_EXTENSION"] = "metamask_extension";
    WalletDevice["OTHER"] = "other_device";
})(WalletDevice = exports.WalletDevice || (exports.WalletDevice = {}));
/**
 * Multiplier used to determine a transaction's increased gas fee during cancellation
 */
exports.CANCEL_RATE = 1.5;
/**
 * Multiplier used to determine a transaction's increased gas fee during speed up
 */
exports.SPEED_UP_RATE = 1.1;
/**
 * Controller responsible for submitting and managing transactions
 */
class TransactionController extends BaseController_1.BaseController {
    /**
     * Creates a TransactionController instance.
     *
     * @param options - The controller options.
     * @param options.getNetworkState - Gets the state of the network controller.
     * @param options.onNetworkStateChange - Allows subscribing to network controller state changes.
     * @param options.getProvider - Returns a provider for the current network.
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor({ getNetworkState, onNetworkStateChange, getProvider, }, config, state) {
        super(config, state);
        this.mutex = new async_mutex_1.Mutex();
        this.normalizeTokenTx = (txMeta, currentNetworkID, currentChainId) => {
            const time = parseInt(txMeta.timeStamp, 10) * 1000;
            const { to, from, gas, gasPrice, gasUsed, hash, contractAddress, tokenDecimal, tokenSymbol, value, } = txMeta;
            return {
                id: (0, uuid_1.v1)({ msecs: time }),
                isTransfer: true,
                networkID: currentNetworkID,
                chainId: currentChainId,
                status: TransactionStatus.confirmed,
                time,
                transaction: {
                    chainId: 1,
                    from,
                    gas,
                    gasPrice,
                    gasUsed,
                    to,
                    value,
                },
                transactionHash: hash,
                transferInformation: {
                    contractAddress,
                    decimals: Number(tokenDecimal),
                    symbol: tokenSymbol,
                },
                verifiedOnBlockchain: false,
            };
        };
        /**
         * EventEmitter instance used to listen to specific transactional events
         */
        this.hub = new events_1.EventEmitter();
        /**
         * Name of this controller used during composition
         */
        this.name = 'TransactionController';
        this.defaultConfig = {
            interval: 15000,
            txHistoryLimit: 40,
        };
        this.defaultState = {
            methodData: {},
            transactions: [],
        };
        this.initialize();
        const provider = getProvider();
        this.getNetworkState = getNetworkState;
        this.ethQuery = new eth_query_1.default(provider);
        this.registry = new eth_method_registry_1.default({ provider });
        onNetworkStateChange(() => {
            const newProvider = getProvider();
            this.ethQuery = new eth_query_1.default(newProvider);
            this.registry = new eth_method_registry_1.default({ provider: newProvider });
        });
        this.poll();
    }
    failTransaction(transactionMeta, error) {
        const newTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { error, status: TransactionStatus.failed });
        this.updateTransaction(newTransactionMeta);
        this.hub.emit(`${transactionMeta.id}:finished`, newTransactionMeta);
    }
    registryLookup(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const registryMethod = yield this.registry.lookup(fourBytePrefix);
            const parsedRegistryMethod = this.registry.parse(registryMethod);
            return { registryMethod, parsedRegistryMethod };
        });
    }
    /**
     * Normalizes the transaction information from etherscan
     * to be compatible with the TransactionMeta interface.
     *
     * @param txMeta - The transaction.
     * @param currentNetworkID - The current network ID.
     * @param currentChainId - The current chain ID.
     * @returns The normalized transaction.
     */
    normalizeTx(txMeta, currentNetworkID, currentChainId) {
        const time = parseInt(txMeta.timeStamp, 10) * 1000;
        const normalizedTransactionBase = {
            blockNumber: txMeta.blockNumber,
            id: (0, uuid_1.v1)({ msecs: time }),
            networkID: currentNetworkID,
            chainId: currentChainId,
            time,
            transaction: {
                data: txMeta.input,
                from: txMeta.from,
                gas: (0, util_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gas)),
                gasPrice: (0, util_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasPrice)),
                gasUsed: (0, util_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.gasUsed)),
                nonce: (0, util_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.nonce)),
                to: txMeta.to,
                value: (0, util_1.BNToHex)(new ethereumjs_util_1.BN(txMeta.value)),
            },
            transactionHash: txMeta.hash,
            verifiedOnBlockchain: false,
        };
        /* istanbul ignore else */
        if (txMeta.isError === '0') {
            return Object.assign(Object.assign({}, normalizedTransactionBase), { status: TransactionStatus.confirmed });
        }
        /* istanbul ignore next */
        return Object.assign(Object.assign({}, normalizedTransactionBase), { error: new Error('Transaction failed'), status: TransactionStatus.failed });
    }
    /**
     * Starts a new polling interval.
     *
     * @param interval - The polling interval used to fetch new transaction statuses.
     */
    poll(interval) {
        return __awaiter(this, void 0, void 0, function* () {
            interval && this.configure({ interval }, false, false);
            this.handle && clearTimeout(this.handle);
            yield (0, util_1.safelyExecute)(() => this.queryTransactionStatuses());
            this.handle = setTimeout(() => {
                this.poll(this.config.interval);
            }, this.config.interval);
        });
    }
    /**
     * Handle new method data request.
     *
     * @param fourBytePrefix - The method prefix.
     * @returns The method data object corresponding to the given signature prefix.
     */
    handleMethodData(fourBytePrefix) {
        return __awaiter(this, void 0, void 0, function* () {
            const releaseLock = yield this.mutex.acquire();
            try {
                const { methodData } = this.state;
                const knownMethod = Object.keys(methodData).find((knownFourBytePrefix) => fourBytePrefix === knownFourBytePrefix);
                if (knownMethod) {
                    return methodData[fourBytePrefix];
                }
                const registry = yield this.registryLookup(fourBytePrefix);
                this.update({
                    methodData: Object.assign(Object.assign({}, methodData), { [fourBytePrefix]: registry }),
                });
                return registry;
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Add a new unapproved transaction to state. Parameters will be validated, a
     * unique transaction id will be generated, and gas and gasPrice will be calculated
     * if not provided. If A `<tx.id>:unapproved` hub event will be emitted once added.
     *
     * @param transaction - The transaction object to add.
     * @param origin - The domain origin to append to the generated TransactionMeta.
     * @param deviceConfirmedOn - An enum to indicate what device the transaction was confirmed to append to the generated TransactionMeta.
     * @returns Object containing a promise resolving to the transaction hash if approved.
     */
    addTransaction(transaction, origin, deviceConfirmedOn) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network } = this.getNetworkState();
            const { transactions } = this.state;
            transaction = (0, util_1.normalizeTransaction)(transaction);
            (0, util_1.validateTransaction)(transaction);
            const transactionMeta = {
                id: (0, uuid_1.v1)(),
                networkID: network,
                chainId: provider.chainId,
                origin,
                status: TransactionStatus.unapproved,
                time: Date.now(),
                transaction,
                deviceConfirmedOn,
                verifiedOnBlockchain: false,
            };
            try {
                const { gas } = yield this.estimateGas(transaction);
                transaction.gas = gas;
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
                return Promise.reject(error);
            }
            const result = new Promise((resolve, reject) => {
                this.hub.once(`${transactionMeta.id}:finished`, (meta) => {
                    switch (meta.status) {
                        case TransactionStatus.submitted:
                            return resolve(meta.transactionHash);
                        case TransactionStatus.rejected:
                            return reject(eth_rpc_errors_1.ethErrors.provider.userRejectedRequest('User rejected the transaction'));
                        case TransactionStatus.cancelled:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal('User cancelled the transaction'));
                        case TransactionStatus.failed:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(meta.error.message));
                        /* istanbul ignore next */
                        default:
                            return reject(eth_rpc_errors_1.ethErrors.rpc.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(meta)}`));
                    }
                });
            });
            transactions.push(transactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`unapprovedTransaction`, transactionMeta);
            return { result, transactionMeta };
        });
    }
    prepareUnsignedEthTx(txParams) {
        return tx_1.TransactionFactory.fromTxData(txParams, {
            common: this.getCommonConfiguration(),
            freeze: false,
        });
    }
    /**
     * `@ethereumjs/tx` uses `@ethereumjs/common` as a configuration tool for
     * specifying which chain, network, hardfork and EIPs to support for
     * a transaction. By referencing this configuration, and analyzing the fields
     * specified in txParams, @ethereumjs/tx is able to determine which EIP-2718
     * transaction type to use.
     *
     * @returns {Common} common configuration object
     */
    getCommonConfiguration() {
        const { network: networkId, provider: { type: chain, chainId, nickname: name }, } = this.getNetworkState();
        if (chain !== constants_1.RPC) {
            return new common_1.default({ chain, hardfork: HARDFORK });
        }
        const customChainParams = {
            name,
            chainId: parseInt(chainId, undefined),
            networkId: parseInt(networkId, undefined),
        };
        return common_1.default.forCustomChain(constants_1.MAINNET, customChainParams, HARDFORK);
    }
    /**
     * Approves a transaction and updates it's status in state. If this is not a
     * retry transaction, a nonce will be generated. The transaction is signed
     * using the sign configuration property, then published to the blockchain.
     * A `<tx.id>:finished` hub event is fired after success or failure.
     *
     * @param transactionID - The ID of the transaction to approve.
     */
    approveTransaction(transactionID) {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const releaseLock = yield this.mutex.acquire();
            const { provider } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            const index = transactions.findIndex(({ id }) => transactionID === id);
            const transactionMeta = transactions[index];
            const { nonce } = transactionMeta.transaction;
            try {
                const { from } = transactionMeta.transaction;
                if (!this.sign) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No sign method defined.'));
                    return;
                }
                else if (!currentChainId) {
                    releaseLock();
                    this.failTransaction(transactionMeta, new Error('No chainId defined.'));
                    return;
                }
                const chainId = parseInt(currentChainId, undefined);
                const { approved: status } = TransactionStatus;
                const txNonce = nonce ||
                    (yield (0, util_1.query)(this.ethQuery, 'getTransactionCount', [from, 'pending']));
                transactionMeta.status = status;
                transactionMeta.transaction.nonce = txNonce;
                transactionMeta.transaction.chainId = chainId;
                const baseTxParams = Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, chainId, nonce: txNonce, status });
                const isEIP1559 = (0, util_1.isEIP1559Transaction)(transactionMeta.transaction);
                const txParams = isEIP1559
                    ? Object.assign(Object.assign({}, baseTxParams), { maxFeePerGas: transactionMeta.transaction.maxFeePerGas, maxPriorityFeePerGas: transactionMeta.transaction.maxPriorityFeePerGas, estimatedBaseFee: transactionMeta.transaction.estimatedBaseFee, 
                        // specify type 2 if maxFeePerGas and maxPriorityFeePerGas are set
                        type: 2 }) : baseTxParams;
                // delete gasPrice if maxFeePerGas and maxPriorityFeePerGas are set
                if (isEIP1559) {
                    delete txParams.gasPrice;
                }
                const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
                const signedTx = yield this.sign(unsignedEthTx, from);
                transactionMeta.status = TransactionStatus.signed;
                this.updateTransaction(transactionMeta);
                const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
                transactionMeta.rawTransaction = rawTransaction;
                this.updateTransaction(transactionMeta);
                const transactionHash = yield (0, util_1.query)(this.ethQuery, 'sendRawTransaction', [
                    rawTransaction,
                ]);
                transactionMeta.transactionHash = transactionHash;
                transactionMeta.status = TransactionStatus.submitted;
                this.updateTransaction(transactionMeta);
                this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
            }
            catch (error) {
                this.failTransaction(transactionMeta, error);
            }
            finally {
                releaseLock();
            }
        });
    }
    /**
     * Cancels a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - The ID of the transaction to cancel.
     */
    cancelTransaction(transactionID) {
        const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
        if (!transactionMeta) {
            return;
        }
        transactionMeta.status = TransactionStatus.rejected;
        this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        const transactions = this.state.transactions.filter(({ id }) => id !== transactionID);
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Attempts to cancel a transaction based on its ID by setting its status to "rejected"
     * and emitting a `<tx.id>:finished` hub event.
     *
     * @param transactionID - The ID of the transaction to cancel.
     * @param gasValues - The gas values to use for the cancellation transation.
     */
    stopTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                (0, util_1.validateGasValues)(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            if (!transactionMeta) {
                return;
            }
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            // gasPrice (legacy non EIP1559)
            const minGasPrice = (0, util_1.getIncreasedPriceFromExisting)(transactionMeta.transaction.gasPrice, exports.CANCEL_RATE);
            const gasPriceFromValues = (0, util_1.isGasPriceValue)(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                (0, util_1.validateMinimumIncrease)(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = (0, util_1.getIncreasedPriceFromExisting)(existingMaxFeePerGas, exports.CANCEL_RATE);
            const maxFeePerGasValues = (0, util_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                (0, util_1.validateMinimumIncrease)(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = (0, util_1.getIncreasedPriceFromExisting)(existingMaxPriorityFeePerGas, exports.CANCEL_RATE);
            const maxPriorityFeePerGasValues = (0, util_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                (0, util_1.validateMinimumIncrease)(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    maxFeePerGas: newMaxFeePerGas,
                    maxPriorityFeePerGas: newMaxPriorityFeePerGas,
                    type: 2,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                }
                : {
                    from: transactionMeta.transaction.from,
                    gasLimit: transactionMeta.transaction.gas,
                    gasPrice: newGasPrice,
                    nonce: transactionMeta.transaction.nonce,
                    to: transactionMeta.transaction.from,
                    value: '0x0',
                };
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
            yield (0, util_1.query)(this.ethQuery, 'sendRawTransaction', [rawTransaction]);
            transactionMeta.status = TransactionStatus.cancelled;
            this.hub.emit(`${transactionMeta.id}:finished`, transactionMeta);
        });
    }
    /**
     * Attempts to speed up a transaction increasing transaction gasPrice by ten percent.
     *
     * @param transactionID - The ID of the transaction to speed up.
     * @param gasValues - The gas values to use for the speed up transation.
     */
    speedUpTransaction(transactionID, gasValues) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (gasValues) {
                (0, util_1.validateGasValues)(gasValues);
            }
            const transactionMeta = this.state.transactions.find(({ id }) => id === transactionID);
            /* istanbul ignore next */
            if (!transactionMeta) {
                return;
            }
            /* istanbul ignore next */
            if (!this.sign) {
                throw new Error('No sign method defined.');
            }
            const { transactions } = this.state;
            // gasPrice (legacy non EIP1559)
            const minGasPrice = (0, util_1.getIncreasedPriceFromExisting)(transactionMeta.transaction.gasPrice, exports.SPEED_UP_RATE);
            const gasPriceFromValues = (0, util_1.isGasPriceValue)(gasValues) && gasValues.gasPrice;
            const newGasPrice = (gasPriceFromValues &&
                (0, util_1.validateMinimumIncrease)(gasPriceFromValues, minGasPrice)) ||
                minGasPrice;
            // maxFeePerGas (EIP1559)
            const existingMaxFeePerGas = (_a = transactionMeta.transaction) === null || _a === void 0 ? void 0 : _a.maxFeePerGas;
            const minMaxFeePerGas = (0, util_1.getIncreasedPriceFromExisting)(existingMaxFeePerGas, exports.SPEED_UP_RATE);
            const maxFeePerGasValues = (0, util_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxFeePerGas;
            const newMaxFeePerGas = (maxFeePerGasValues &&
                (0, util_1.validateMinimumIncrease)(maxFeePerGasValues, minMaxFeePerGas)) ||
                (existingMaxFeePerGas && minMaxFeePerGas);
            // maxPriorityFeePerGas (EIP1559)
            const existingMaxPriorityFeePerGas = (_b = transactionMeta.transaction) === null || _b === void 0 ? void 0 : _b.maxPriorityFeePerGas;
            const minMaxPriorityFeePerGas = (0, util_1.getIncreasedPriceFromExisting)(existingMaxPriorityFeePerGas, exports.SPEED_UP_RATE);
            const maxPriorityFeePerGasValues = (0, util_1.isFeeMarketEIP1559Values)(gasValues) && gasValues.maxPriorityFeePerGas;
            const newMaxPriorityFeePerGas = (maxPriorityFeePerGasValues &&
                (0, util_1.validateMinimumIncrease)(maxPriorityFeePerGasValues, minMaxPriorityFeePerGas)) ||
                (existingMaxPriorityFeePerGas && minMaxPriorityFeePerGas);
            const txParams = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas, type: 2 }) : Object.assign(Object.assign({}, transactionMeta.transaction), { gasLimit: transactionMeta.transaction.gas, gasPrice: newGasPrice });
            const unsignedEthTx = this.prepareUnsignedEthTx(txParams);
            const signedTx = yield this.sign(unsignedEthTx, transactionMeta.transaction.from);
            const rawTransaction = (0, ethereumjs_util_1.bufferToHex)(signedTx.serialize());
            const transactionHash = yield (0, util_1.query)(this.ethQuery, 'sendRawTransaction', [
                rawTransaction,
            ]);
            const baseTransactionMeta = Object.assign(Object.assign({}, transactionMeta), { id: (0, uuid_1.v1)(), time: Date.now(), transactionHash });
            const newTransactionMeta = newMaxFeePerGas && newMaxPriorityFeePerGas
                ? Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { maxFeePerGas: newMaxFeePerGas, maxPriorityFeePerGas: newMaxPriorityFeePerGas }) }) : Object.assign(Object.assign({}, baseTransactionMeta), { transaction: Object.assign(Object.assign({}, transactionMeta.transaction), { gasPrice: newGasPrice }) });
            transactions.push(newTransactionMeta);
            this.update({ transactions: this.trimTransactionsForState(transactions) });
            this.hub.emit(`${transactionMeta.id}:speedup`, newTransactionMeta);
        });
    }
    /**
     * Estimates required gas for a given transaction.
     *
     * @param transaction - The transaction to estimate gas for.
     * @returns The gas and gas price.
     */
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const estimatedTransaction = Object.assign({}, transaction);
            const { gas, gasPrice: providedGasPrice, to, value, data, } = estimatedTransaction;
            const gasPrice = typeof providedGasPrice === 'undefined'
                ? yield (0, util_1.query)(this.ethQuery, 'gasPrice')
                : providedGasPrice;
            const { isCustomNetwork } = this.getNetworkState();
            // 1. If gas is already defined on the transaction, use it
            if (typeof gas !== 'undefined') {
                return { gas, gasPrice };
            }
            const { gasLimit } = yield (0, util_1.query)(this.ethQuery, 'getBlockByNumber', [
                'latest',
                false,
            ]);
            // 2. If to is not defined or this is not a contract address, and there is no data use 0x5208 / 21000.
            // If the newtwork is a custom network then bypass this check and fetch 'estimateGas'.
            /* istanbul ignore next */
            const code = to ? yield (0, util_1.query)(this.ethQuery, 'getCode', [to]) : undefined;
            /* istanbul ignore next */
            if (!isCustomNetwork &&
                (!to || (to && !data && (!code || code === '0x')))) {
                return { gas: '0x5208', gasPrice };
            }
            // if data, should be hex string format
            estimatedTransaction.data = !data
                ? data
                : /* istanbul ignore next */ (0, ethereumjs_util_1.addHexPrefix)(data);
            // 3. If this is a contract address, safely estimate gas using RPC
            estimatedTransaction.value =
                typeof value === 'undefined' ? '0x0' : /* istanbul ignore next */ value;
            const gasLimitBN = (0, util_1.hexToBN)(gasLimit);
            estimatedTransaction.gas = (0, util_1.BNToHex)((0, util_1.fractionBN)(gasLimitBN, 19, 20));
            const gasHex = yield (0, util_1.query)(this.ethQuery, 'estimateGas', [
                estimatedTransaction,
            ]);
            // 4. Pad estimated gas without exceeding the most recent block gasLimit. If the network is a
            // a custom network then return the eth_estimateGas value.
            const gasBN = (0, util_1.hexToBN)(gasHex);
            const maxGasBN = gasLimitBN.muln(0.9);
            const paddedGasBN = gasBN.muln(1.5);
            /* istanbul ignore next */
            if (gasBN.gt(maxGasBN) || isCustomNetwork) {
                return { gas: (0, ethereumjs_util_1.addHexPrefix)(gasHex), gasPrice };
            }
            /* istanbul ignore next */
            if (paddedGasBN.lt(maxGasBN)) {
                return { gas: (0, ethereumjs_util_1.addHexPrefix)((0, util_1.BNToHex)(paddedGasBN)), gasPrice };
            }
            return { gas: (0, ethereumjs_util_1.addHexPrefix)((0, util_1.BNToHex)(maxGasBN)), gasPrice };
        });
    }
    /**
     * Check the status of submitted transactions on the network to determine whether they have
     * been included in a block. Any that have been included in a block are marked as confirmed.
     */
    queryTransactionStatuses() {
        return __awaiter(this, void 0, void 0, function* () {
            const { transactions } = this.state;
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId } = provider;
            let gotUpdates = false;
            yield (0, util_1.safelyExecute)(() => Promise.all(transactions.map((meta, index) => __awaiter(this, void 0, void 0, function* () {
                // Using fallback to networkID only when there is no chainId present.
                // Should be removed when networkID is completely removed.
                const txBelongsToCurrentChain = meta.chainId === currentChainId ||
                    (!meta.chainId && meta.networkID === currentNetworkID);
                if (!meta.verifiedOnBlockchain && txBelongsToCurrentChain) {
                    const [reconciledTx, updateRequired] = yield this.blockchainTransactionStateReconciler(meta);
                    if (updateRequired) {
                        transactions[index] = reconciledTx;
                        gotUpdates = updateRequired;
                    }
                }
            }))));
            /* istanbul ignore else */
            if (gotUpdates) {
                this.update({
                    transactions: this.trimTransactionsForState(transactions),
                });
            }
        });
    }
    /**
     * Updates an existing transaction in state.
     *
     * @param transactionMeta - The new transaction to store in state.
     */
    updateTransaction(transactionMeta) {
        const { transactions } = this.state;
        transactionMeta.transaction = (0, util_1.normalizeTransaction)(transactionMeta.transaction);
        (0, util_1.validateTransaction)(transactionMeta.transaction);
        const index = transactions.findIndex(({ id }) => transactionMeta.id === id);
        transactions[index] = transactionMeta;
        this.update({ transactions: this.trimTransactionsForState(transactions) });
    }
    /**
     * Removes all transactions from state, optionally based on the current network.
     *
     * @param ignoreNetwork - Determines whether to wipe all transactions, or just those on the
     * current network. If `true`, all transactions are wiped.
     */
    wipeTransactions(ignoreNetwork) {
        /* istanbul ignore next */
        if (ignoreNetwork) {
            this.update({ transactions: [] });
            return;
        }
        const { provider, network: currentNetworkID } = this.getNetworkState();
        const { chainId: currentChainId } = provider;
        const newTransactions = this.state.transactions.filter(({ networkID, chainId }) => {
            // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
            const isCurrentNetwork = chainId === currentChainId ||
                (!chainId && networkID === currentNetworkID);
            return !isCurrentNetwork;
        });
        this.update({
            transactions: this.trimTransactionsForState(newTransactions),
        });
    }
    /**
     * Get transactions from Etherscan for the given address. By default all transactions are
     * returned, but the `fromBlock` option can be given to filter just for transactions from a
     * specific block onward.
     *
     * @param address - The address to fetch the transactions for.
     * @param opt - Object containing optional data, fromBlock and Etherscan API key.
     * @returns The block number of the latest incoming transaction.
     */
    fetchAll(address, opt) {
        return __awaiter(this, void 0, void 0, function* () {
            const { provider, network: currentNetworkID } = this.getNetworkState();
            const { chainId: currentChainId, type: networkType } = provider;
            const { transactions } = this.state;
            const supportedNetworkIds = ['1', '3', '4', '42'];
            /* istanbul ignore next */
            if (supportedNetworkIds.indexOf(currentNetworkID) === -1) {
                return undefined;
            }
            const [etherscanTxResponse, etherscanTokenResponse] = yield (0, util_1.handleTransactionFetch)(networkType, address, this.config.txHistoryLimit, opt);
            const normalizedTxs = etherscanTxResponse.result.map((tx) => this.normalizeTx(tx, currentNetworkID, currentChainId));
            const normalizedTokenTxs = etherscanTokenResponse.result.map((tx) => this.normalizeTokenTx(tx, currentNetworkID, currentChainId));
            const [updateRequired, allTxs] = this.etherscanTransactionStateReconciler([...normalizedTxs, ...normalizedTokenTxs], transactions);
            allTxs.sort((a, b) => (a.time < b.time ? -1 : 1));
            let latestIncomingTxBlockNumber;
            allTxs.forEach((tx) => __awaiter(this, void 0, void 0, function* () {
                /* istanbul ignore next */
                if (
                // Using fallback to networkID only when there is no chainId present. Should be removed when networkID is completely removed.
                (tx.chainId === currentChainId ||
                    (!tx.chainId && tx.networkID === currentNetworkID)) &&
                    tx.transaction.to &&
                    tx.transaction.to.toLowerCase() === address.toLowerCase()) {
                    if (tx.blockNumber &&
                        (!latestIncomingTxBlockNumber ||
                            parseInt(latestIncomingTxBlockNumber, 10) <
                                parseInt(tx.blockNumber, 10))) {
                        latestIncomingTxBlockNumber = tx.blockNumber;
                    }
                }
                /* istanbul ignore else */
                if (tx.toSmartContract === undefined) {
                    // If not `to` is a contract deploy, if not `data` is send eth
                    if (tx.transaction.to &&
                        (!tx.transaction.data || tx.transaction.data !== '0x')) {
                        const code = yield (0, util_1.query)(this.ethQuery, 'getCode', [
                            tx.transaction.to,
                        ]);
                        tx.toSmartContract = (0, util_1.isSmartContractCode)(code);
                    }
                    else {
                        tx.toSmartContract = false;
                    }
                }
            }));
            // Update state only if new transactions were fetched or
            // the status or gas data of a transaction has changed
            if (updateRequired) {
                this.update({ transactions: this.trimTransactionsForState(allTxs) });
            }
            return latestIncomingTxBlockNumber;
        });
    }
    /**
     * Trim the amount of transactions that are set on the state. Checks
     * if the length of the tx history is longer then desired persistence
     * limit and then if it is removes the oldest confirmed or rejected tx.
     * Pending or unapproved transactions will not be removed by this
     * operation. For safety of presenting a fully functional transaction UI
     * representation, this function will not break apart transactions with the
     * same nonce, created on the same day, per network. Not accounting for transactions of the same
     * nonce, same day and network combo can result in confusing or broken experiences
     * in the UI. The transactions are then updated using the BaseController update.
     *
     * @param transactions - The transactions to be applied to the state.
     * @returns The trimmed list of transactions.
     */
    trimTransactionsForState(transactions) {
        const nonceNetworkSet = new Set();
        const txsToKeep = transactions.reverse().filter((tx) => {
            const { chainId, networkID, status, transaction, time } = tx;
            if (transaction) {
                const key = `${transaction.nonce}-${chainId !== null && chainId !== void 0 ? chainId : networkID}-${new Date(time).toDateString()}`;
                if (nonceNetworkSet.has(key)) {
                    return true;
                }
                else if (nonceNetworkSet.size < this.config.txHistoryLimit ||
                    !this.isFinalState(status)) {
                    nonceNetworkSet.add(key);
                    return true;
                }
            }
            return false;
        });
        txsToKeep.reverse();
        return txsToKeep;
    }
    /**
     * Determines if the transaction is in a final state.
     *
     * @param status - The transaction status.
     * @returns Whether the transaction is in a final state.
     */
    isFinalState(status) {
        return (status === TransactionStatus.rejected ||
            status === TransactionStatus.confirmed ||
            status === TransactionStatus.failed ||
            status === TransactionStatus.cancelled);
    }
    /**
     * Method to verify the state of a transaction using the Blockchain as a source of truth.
     *
     * @param meta - The local transaction to verify on the blockchain.
     * @returns A tuple containing the updated transaction, and whether or not an update was required.
     */
    blockchainTransactionStateReconciler(meta) {
        return __awaiter(this, void 0, void 0, function* () {
            const { status, transactionHash } = meta;
            switch (status) {
                case TransactionStatus.confirmed:
                    const txReceipt = yield (0, util_1.query)(this.ethQuery, 'getTransactionReceipt', [
                        transactionHash,
                    ]);
                    if (!txReceipt) {
                        return [meta, false];
                    }
                    meta.verifiedOnBlockchain = true;
                    meta.transaction.gasUsed = txReceipt.gasUsed;
                    // According to the Web3 docs:
                    // TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
                    if (Number(txReceipt.status) === 0) {
                        const error = new Error('Transaction failed. The transaction was reversed');
                        this.failTransaction(meta, error);
                        return [meta, false];
                    }
                    return [meta, true];
                case TransactionStatus.submitted:
                    const txObj = yield (0, util_1.query)(this.ethQuery, 'getTransactionByHash', [
                        transactionHash,
                    ]);
                    if (!txObj) {
                        const receiptShowsFailedStatus = yield this.checkTxReceiptStatusIsFailed(transactionHash);
                        // Case the txObj is evaluated as false, a second check will
                        // determine if the tx failed or it is pending or confirmed
                        if (receiptShowsFailedStatus) {
                            const error = new Error('Transaction failed. The transaction was dropped or replaced by a new one');
                            this.failTransaction(meta, error);
                        }
                    }
                    /* istanbul ignore next */
                    if (txObj === null || txObj === void 0 ? void 0 : txObj.blockNumber) {
                        meta.status = TransactionStatus.confirmed;
                        this.hub.emit(`${meta.id}:confirmed`, meta);
                        return [meta, true];
                    }
                    return [meta, false];
                default:
                    return [meta, false];
            }
        });
    }
    /**
     * Method to check if a tx has failed according to their receipt
     * According to the Web3 docs:
     * TRUE if the transaction was successful, FALSE if the EVM reverted the transaction.
     * The receipt is not available for pending transactions and returns null.
     *
     * @param txHash - The transaction hash.
     * @returns Whether the transaction has failed.
     */
    checkTxReceiptStatusIsFailed(txHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const txReceipt = yield (0, util_1.query)(this.ethQuery, 'getTransactionReceipt', [
                txHash,
            ]);
            if (!txReceipt) {
                // Transaction is pending
                return false;
            }
            return Number(txReceipt.status) === 0;
        });
    }
    /**
     * Method to verify the state of transactions using Etherscan as a source of truth.
     *
     * @param remoteTxs - Transactions to reconcile that are from a remote source.
     * @param localTxs - Transactions to reconcile that are local.
     * @returns A tuple containing a boolean indicating whether or not an update was required, and the updated transaction.
     */
    etherscanTransactionStateReconciler(remoteTxs, localTxs) {
        const updatedTxs = this.getUpdatedTransactions(remoteTxs, localTxs);
        const newTxs = this.getNewTransactions(remoteTxs, localTxs);
        const updatedLocalTxs = localTxs.map((tx) => {
            const txIdx = updatedTxs.findIndex(({ transactionHash }) => transactionHash === tx.transactionHash);
            return txIdx === -1 ? tx : updatedTxs[txIdx];
        });
        const updateRequired = newTxs.length > 0 || updatedLocalTxs.length > 0;
        return [updateRequired, [...newTxs, ...updatedLocalTxs]];
    }
    /**
     * Get all transactions that are in the remote transactions array
     * but not in the local transactions array.
     *
     * @param remoteTxs - Array of transactions from remote source.
     * @param localTxs - Array of transactions stored locally.
     * @returns The new transactions.
     */
    getNewTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((tx) => {
            const alreadyInTransactions = localTxs.find(({ transactionHash }) => transactionHash === tx.transactionHash);
            return !alreadyInTransactions;
        });
    }
    /**
     * Get all the transactions that are locally outdated with respect
     * to a remote source (etherscan or blockchain). The returned array
     * contains the transactions with the updated data.
     *
     * @param remoteTxs - Array of transactions from remote source.
     * @param localTxs - Array of transactions stored locally.
     * @returns The updated transactions.
     */
    getUpdatedTransactions(remoteTxs, localTxs) {
        return remoteTxs.filter((remoteTx) => {
            const isTxOutdated = localTxs.find((localTx) => {
                return (remoteTx.transactionHash === localTx.transactionHash &&
                    this.isTransactionOutdated(remoteTx, localTx));
            });
            return isTxOutdated;
        });
    }
    /**
     * Verifies if a local transaction is outdated with respect to the remote transaction.
     *
     * @param remoteTx - The remote transaction from Etherscan.
     * @param localTx - The local transaction.
     * @returns Whether the transaction is outdated.
     */
    isTransactionOutdated(remoteTx, localTx) {
        const statusOutdated = this.isStatusOutdated(remoteTx.transactionHash, localTx.transactionHash, remoteTx.status, localTx.status);
        const gasDataOutdated = this.isGasDataOutdated(remoteTx.transaction.gasUsed, localTx.transaction.gasUsed);
        return statusOutdated || gasDataOutdated;
    }
    /**
     * Verifies if the status of a local transaction is outdated with respect to the remote transaction.
     *
     * @param remoteTxHash - Remote transaction hash.
     * @param localTxHash - Local transaction hash.
     * @param remoteTxStatus - Remote transaction status.
     * @param localTxStatus - Local transaction status.
     * @returns Whether the status is outdated.
     */
    isStatusOutdated(remoteTxHash, localTxHash, remoteTxStatus, localTxStatus) {
        return remoteTxHash === localTxHash && remoteTxStatus !== localTxStatus;
    }
    /**
     * Verifies if the gas data of a local transaction is outdated with respect to the remote transaction.
     *
     * @param remoteGasUsed - Remote gas used in the transaction.
     * @param localGasUsed - Local gas used in the transaction.
     * @returns Whether the gas data is outdated.
     */
    isGasDataOutdated(remoteGasUsed, localGasUsed) {
        return remoteGasUsed !== localGasUsed;
    }
}
exports.TransactionController = TransactionController;
exports.default = TransactionController;
//# sourceMappingURL=TransactionController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\user\\AddressBookController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\user\AddressBookController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddressBookController = void 0;
const util_1 = require("../util");
const BaseController_1 = require("../BaseController");
/**
 * Controller that manages a list of recipient addresses associated with nicknames
 */
class AddressBookController extends BaseController_1.BaseController {
    /**
     * Creates an AddressBookController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'AddressBookController';
        this.defaultState = { addressBook: {} };
        this.initialize();
    }
    /**
     * Remove all contract entries.
     */
    clear() {
        this.update({ addressBook: {} });
    }
    /**
     * Remove a contract entry by address.
     *
     * @param chainId - Chain id identifies the current chain.
     * @param address - Recipient address to delete.
     * @returns Whether the entry was deleted.
     */
    delete(chainId, address) {
        address = (0, util_1.toChecksumHexAddress)(address);
        if (!(0, util_1.isValidHexAddress)(address) ||
            !this.state.addressBook[chainId] ||
            !this.state.addressBook[chainId][address]) {
            return false;
        }
        const addressBook = Object.assign({}, this.state.addressBook);
        delete addressBook[chainId][address];
        if (Object.keys(addressBook[chainId]).length === 0) {
            delete addressBook[chainId];
        }
        this.update({ addressBook });
        return true;
    }
    /**
     * Add or update a contact entry by address.
     *
     * @param address - Recipient address to add or update.
     * @param name - Nickname to associate with this address.
     * @param chainId - Chain id identifies the current chain.
     * @param memo - User's note about address.
     * @returns Boolean indicating if the address was successfully set.
     */
    set(address, name, chainId = '1', memo = '') {
        address = (0, util_1.toChecksumHexAddress)(address);
        if (!(0, util_1.isValidHexAddress)(address)) {
            return false;
        }
        const entry = {
            address,
            chainId,
            isEns: false,
            memo,
            name,
        };
        const ensName = (0, util_1.normalizeEnsName)(name);
        if (ensName) {
            entry.name = ensName;
            entry.isEns = true;
        }
        this.update({
            addressBook: Object.assign(Object.assign({}, this.state.addressBook), { [chainId]: Object.assign(Object.assign({}, this.state.addressBook[chainId]), { [address]: entry }) }),
        });
        return true;
    }
}
exports.AddressBookController = AddressBookController;
exports.default = AddressBookController;
//# sourceMappingURL=AddressBookController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\user\\PreferencesController.js", {"../BaseController":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\BaseController.js","../util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\user\PreferencesController.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferencesController = void 0;
const BaseController_1 = require("../BaseController");
const util_1 = require("../util");
/**
 * Controller that stores shared settings and exposes convenience methods
 */
class PreferencesController extends BaseController_1.BaseController {
    /**
     * Creates a PreferencesController instance.
     *
     * @param config - Initial options used to configure this controller.
     * @param state - Initial state to set on this controller.
     */
    constructor(config, state) {
        super(config, state);
        /**
         * Name of this controller used during composition
         */
        this.name = 'PreferencesController';
        this.defaultState = {
            featureFlags: {},
            frequentRpcList: [],
            identities: {},
            ipfsGateway: 'https://ipfs.io/ipfs/',
            lostIdentities: {},
            selectedAddress: '',
            useTokenDetection: true,
            useCollectibleDetection: false,
            openSeaEnabled: false,
        };
        this.initialize();
    }
    /**
     * Adds identities to state.
     *
     * @param addresses - List of addresses to use to generate new identities.
     */
    addIdentities(addresses) {
        const { identities } = this.state;
        addresses.forEach((address) => {
            address = (0, util_1.toChecksumHexAddress)(address);
            if (identities[address]) {
                return;
            }
            const identityCount = Object.keys(identities).length;
            identities[address] = {
                name: `Account ${identityCount + 1}`,
                address,
                importTime: Date.now(),
            };
        });
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Removes an identity from state.
     *
     * @param address - Address of the identity to remove.
     */
    removeIdentity(address) {
        address = (0, util_1.toChecksumHexAddress)(address);
        const { identities } = this.state;
        if (!identities[address]) {
            return;
        }
        delete identities[address];
        this.update({ identities: Object.assign({}, identities) });
        if (address === this.state.selectedAddress) {
            this.update({ selectedAddress: Object.keys(identities)[0] });
        }
    }
    /**
     * Associates a new label with an identity.
     *
     * @param address - Address of the identity to associate.
     * @param label - New label to assign.
     */
    setAccountLabel(address, label) {
        address = (0, util_1.toChecksumHexAddress)(address);
        const { identities } = this.state;
        identities[address] = identities[address] || {};
        identities[address].name = label;
        this.update({ identities: Object.assign({}, identities) });
    }
    /**
     * Enable or disable a specific feature flag.
     *
     * @param feature - Feature to toggle.
     * @param activated - Value to assign.
     */
    setFeatureFlag(feature, activated) {
        const oldFeatureFlags = this.state.featureFlags;
        const featureFlags = Object.assign(Object.assign({}, oldFeatureFlags), { [feature]: activated });
        this.update({ featureFlags: Object.assign({}, featureFlags) });
    }
    /**
     * Synchronizes the current identity list with new identities.
     *
     * @param addresses - List of addresses corresponding to identities to sync.
     * @returns Newly-selected address after syncing.
     */
    syncIdentities(addresses) {
        addresses = addresses.map((address) => (0, util_1.toChecksumHexAddress)(address));
        const { identities, lostIdentities } = this.state;
        const newlyLost = {};
        for (const identity in identities) {
            if (addresses.indexOf(identity) === -1) {
                newlyLost[identity] = identities[identity];
                delete identities[identity];
            }
        }
        if (Object.keys(newlyLost).length > 0) {
            for (const key in newlyLost) {
                lostIdentities[key] = newlyLost[key];
            }
        }
        this.update({
            identities: Object.assign({}, identities),
            lostIdentities: Object.assign({}, lostIdentities),
        });
        this.addIdentities(addresses);
        if (addresses.indexOf(this.state.selectedAddress) === -1) {
            this.update({ selectedAddress: addresses[0] });
        }
        return this.state.selectedAddress;
    }
    /**
     * Generates and stores a new list of stored identities based on address. If the selected address
     * is unset, or if it refers to an identity that was removed, it will be set to the first
     * identity.
     *
     * @param addresses - List of addresses to use as a basis for each identity.
     */
    updateIdentities(addresses) {
        addresses = addresses.map((address) => (0, util_1.toChecksumHexAddress)(address));
        const oldIdentities = this.state.identities;
        const identities = addresses.reduce((ids, address, index) => {
            ids[address] = oldIdentities[address] || {
                address,
                name: `Account ${index + 1}`,
                importTime: Date.now(),
            };
            return ids;
        }, {});
        let { selectedAddress } = this.state;
        if (!Object.keys(identities).includes(selectedAddress)) {
            selectedAddress = Object.keys(identities)[0];
        }
        this.update({ identities: Object.assign({}, identities), selectedAddress });
    }
    /**
     * Adds custom RPC URL to state.
     *
     * @param url - The custom RPC URL.
     * @param chainId - The chain ID of the network, as per EIP-155.
     * @param ticker - Currency ticker.
     * @param nickname - Personalized network name.
     * @param rpcPrefs - Personalized preferences.
     */
    addToFrequentRpcList(url, chainId, ticker, nickname, rpcPrefs) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        const newFrequestRpc = {
            rpcUrl: url,
            chainId,
            ticker,
            nickname,
            rpcPrefs,
        };
        frequentRpcList.push(newFrequestRpc);
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Removes custom RPC URL from state.
     *
     * @param url - Custom RPC URL.
     */
    removeFromFrequentRpcList(url) {
        const { frequentRpcList } = this.state;
        const index = frequentRpcList.findIndex(({ rpcUrl }) => {
            return rpcUrl === url;
        });
        if (index !== -1) {
            frequentRpcList.splice(index, 1);
        }
        this.update({ frequentRpcList: [...frequentRpcList] });
    }
    /**
     * Sets selected address.
     *
     * @param selectedAddress - Ethereum address.
     */
    setSelectedAddress(selectedAddress) {
        this.update({ selectedAddress: (0, util_1.toChecksumHexAddress)(selectedAddress) });
    }
    /**
     * Sets new IPFS gateway.
     *
     * @param ipfsGateway - IPFS gateway string.
     */
    setIpfsGateway(ipfsGateway) {
        this.update({ ipfsGateway });
    }
    /**
     * Toggle the token detection setting.
     *
     * @param useTokenDetection - Boolean indicating user preference on token detection.
     */
    setUseTokenDetection(useTokenDetection) {
        this.update({ useTokenDetection });
    }
    /**
     * Toggle the collectible detection setting.
     *
     * @param useCollectibleDetection - Boolean indicating user preference on collectible detection.
     */
    setUseCollectibleDetection(useCollectibleDetection) {
        if (useCollectibleDetection && !this.state.openSeaEnabled) {
            throw new Error('useCollectibleDetection cannot be enabled if openSeaEnabled is false');
        }
        this.update({ useCollectibleDetection });
    }
    /**
     * Toggle the opensea enabled setting.
     *
     * @param openSeaEnabled - Boolean indicating user preference on using OpenSea's API.
     */
    setOpenSeaEnabled(openSeaEnabled) {
        this.update({ openSeaEnabled });
        if (!openSeaEnabled) {
            this.update({ useCollectibleDetection: false });
        }
    }
}
exports.PreferencesController = PreferencesController;
exports.default = PreferencesController;
//# sourceMappingURL=PreferencesController.js.map
      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\util.js", {"./constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\smart-transactions-controller\\node_modules\\@metamask\\controllers\\dist\\constants.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","eth-ens-namehash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-ens-namehash\\index.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","eth-sig-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-sig-util\\dist\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethjs-unit":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethjs-unit\\lib\\index.js","fast-deep-equal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\fast-deep-equal\\index.js","jsonschema":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsonschema\\lib\\index.js","multiformats/cid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\multiformats\\cjs\\src\\cid.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\@metamask\smart-transactions-controller\node_modules\@metamask\controllers\dist\util.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTokenListSupportedForNetwork = exports.isTokenDetectionSupportedForNetwork = exports.SupportedTokenDetectionNetworks = exports.isValidJson = exports.isNonEmptyArray = exports.hasProperty = exports.isPlainObject = exports.getFormattedIpfsUrl = exports.addUrlProtocolPrefix = exports.getIpfsCIDv1AndPath = exports.removeIpfsProtocolPrefix = exports.validateMinimumIncrease = exports.isGasPriceValue = exports.isFeeMarketEIP1559Values = exports.validateGasValues = exports.getIncreasedPriceFromExisting = exports.getIncreasedPriceHex = exports.convertHexToDecimal = exports.isEIP1559Transaction = exports.query = exports.normalizeEnsName = exports.timeoutFetch = exports.fetchWithErrorHandling = exports.handleFetch = exports.successfulFetch = exports.isSmartContractCode = exports.validateTokenToWatch = exports.validateTypedSignMessageDataV3 = exports.validateTypedSignMessageDataV1 = exports.validateSignMessageData = exports.normalizeMessageData = exports.validateTransaction = exports.isValidHexAddress = exports.toChecksumHexAddress = exports.safelyExecuteWithTimeout = exports.safelyExecute = exports.normalizeTransaction = exports.toHex = exports.fromHex = exports.hexToText = exports.hexToBN = exports.handleTransactionFetch = exports.getEtherscanApiUrl = exports.getBuyURL = exports.weiHexToGweiDec = exports.gweiDecToWEIBN = exports.fractionBN = exports.BNToHex = void 0;
const ethereumjs_util_1 = require("ethereumjs-util");
const ethjs_unit_1 = require("ethjs-unit");
const eth_rpc_errors_1 = require("eth-rpc-errors");
const eth_ens_namehash_1 = __importDefault(require("eth-ens-namehash"));
const eth_sig_util_1 = require("eth-sig-util");
const jsonschema_1 = require("jsonschema");
const cid_1 = require("multiformats/cid");
const fast_deep_equal_1 = __importDefault(require("fast-deep-equal"));
const constants_1 = require("./constants");
const TIMEOUT_ERROR = new Error('timeout');
const hexRe = /^[0-9A-Fa-f]+$/gu;
const NORMALIZERS = {
    data: (data) => (0, ethereumjs_util_1.addHexPrefix)(data),
    from: (from) => (0, ethereumjs_util_1.addHexPrefix)(from).toLowerCase(),
    gas: (gas) => (0, ethereumjs_util_1.addHexPrefix)(gas),
    gasPrice: (gasPrice) => (0, ethereumjs_util_1.addHexPrefix)(gasPrice),
    nonce: (nonce) => (0, ethereumjs_util_1.addHexPrefix)(nonce),
    to: (to) => (0, ethereumjs_util_1.addHexPrefix)(to).toLowerCase(),
    value: (value) => (0, ethereumjs_util_1.addHexPrefix)(value),
    maxFeePerGas: (maxFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxFeePerGas),
    maxPriorityFeePerGas: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
    estimatedBaseFee: (maxPriorityFeePerGas) => (0, ethereumjs_util_1.addHexPrefix)(maxPriorityFeePerGas),
};
/**
 * Converts a BN object to a hex string with a '0x' prefix.
 *
 * @param inputBn - BN instance to convert to a hex string.
 * @returns A '0x'-prefixed hex string.
 */
function BNToHex(inputBn) {
    return (0, ethereumjs_util_1.addHexPrefix)(inputBn.toString(16));
}
exports.BNToHex = BNToHex;
/**
 * Used to multiply a BN by a fraction.
 *
 * @param targetBN - Number to multiply by a fraction.
 * @param numerator - Numerator of the fraction multiplier.
 * @param denominator - Denominator of the fraction multiplier.
 * @returns Product of the multiplication.
 */
function fractionBN(targetBN, numerator, denominator) {
    const numBN = new ethereumjs_util_1.BN(numerator);
    const denomBN = new ethereumjs_util_1.BN(denominator);
    return targetBN.mul(numBN).div(denomBN);
}
exports.fractionBN = fractionBN;
/**
 * Used to convert a base-10 number from GWEI to WEI. Can handle numbers with decimal parts.
 *
 * @param n - The base 10 number to convert to WEI.
 * @returns The number in WEI, as a BN.
 */
function gweiDecToWEIBN(n) {
    if (Number.isNaN(n)) {
        return new ethereumjs_util_1.BN(0);
    }
    const parts = n.toString().split('.');
    const wholePart = parts[0] || '0';
    let decimalPart = parts[1] || '';
    if (!decimalPart) {
        return (0, ethjs_unit_1.toWei)(wholePart, 'gwei');
    }
    if (decimalPart.length <= 9) {
        return (0, ethjs_unit_1.toWei)(`${wholePart}.${decimalPart}`, 'gwei');
    }
    const decimalPartToRemove = decimalPart.slice(9);
    const decimalRoundingDigit = decimalPartToRemove[0];
    decimalPart = decimalPart.slice(0, 9);
    let wei = (0, ethjs_unit_1.toWei)(`${wholePart}.${decimalPart}`, 'gwei');
    if (Number(decimalRoundingDigit) >= 5) {
        wei = wei.add(new ethereumjs_util_1.BN(1));
    }
    return wei;
}
exports.gweiDecToWEIBN = gweiDecToWEIBN;
/**
 * Used to convert values from wei hex format to dec gwei format.
 *
 * @param hex - The value in hex wei.
 * @returns The value in dec gwei as string.
 */
function weiHexToGweiDec(hex) {
    const hexWei = new ethereumjs_util_1.BN((0, ethereumjs_util_1.stripHexPrefix)(hex), 16);
    return (0, ethjs_unit_1.fromWei)(hexWei, 'gwei').toString(10);
}
exports.weiHexToGweiDec = weiHexToGweiDec;
/**
 * Return a URL that can be used to obtain ETH for a given network.
 *
 * @param networkCode - Network code of desired network.
 * @param address - Address to deposit obtained ETH.
 * @param amount - How much ETH is desired.
 * @returns URL to buy ETH based on network.
 */
function getBuyURL(networkCode = '1', address, amount = 5) {
    switch (networkCode) {
        case '1':
            return `https://buy.coinbase.com/?code=9ec56d01-7e81-5017-930c-513daa27bb6a&amount=${amount}&address=${address}&crypto_currency=ETH`;
        case '3':
            return 'https://faucet.metamask.io/';
        case '4':
            return 'https://www.rinkeby.io/';
        case '5':
            return 'https://goerli-faucet.slock.it/';
        case '42':
            return 'https://github.com/kovan-testnet/faucet';
        default:
            return undefined;
    }
}
exports.getBuyURL = getBuyURL;
/**
 * Return a URL that can be used to fetch ETH transactions.
 *
 * @param networkType - Network type of desired network.
 * @param urlParams - The parameters used to construct the URL.
 * @returns URL to fetch the access the endpoint.
 */
function getEtherscanApiUrl(networkType, urlParams) {
    let etherscanSubdomain = 'api';
    if (networkType !== constants_1.MAINNET) {
        etherscanSubdomain = `api-${networkType}`;
    }
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`;
    let url = `${apiUrl}/api?`;
    for (const paramKey in urlParams) {
        if (urlParams[paramKey]) {
            url += `${paramKey}=${urlParams[paramKey]}&`;
        }
    }
    url += 'tag=latest&page=1';
    return url;
}
exports.getEtherscanApiUrl = getEtherscanApiUrl;
/**
 * Handles the fetch of incoming transactions.
 *
 * @param networkType - Network type of desired network.
 * @param address - Address to get the transactions from.
 * @param txHistoryLimit - The maximum number of transactions to fetch.
 * @param opt - Object that can contain fromBlock and Etherscan service API key.
 * @returns Responses for both ETH and ERC20 token transactions.
 */
function handleTransactionFetch(networkType, address, txHistoryLimit, opt) {
    return __awaiter(this, void 0, void 0, function* () {
        // transactions
        const urlParams = {
            module: 'account',
            address,
            startBlock: opt === null || opt === void 0 ? void 0 : opt.fromBlock,
            apikey: opt === null || opt === void 0 ? void 0 : opt.etherscanApiKey,
            offset: txHistoryLimit.toString(),
            order: 'desc',
        };
        const etherscanTxUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'txlist' }));
        const etherscanTxResponsePromise = handleFetch(etherscanTxUrl);
        // tokens
        const etherscanTokenUrl = getEtherscanApiUrl(networkType, Object.assign(Object.assign({}, urlParams), { action: 'tokentx' }));
        const etherscanTokenResponsePromise = handleFetch(etherscanTokenUrl);
        let [etherscanTxResponse, etherscanTokenResponse] = yield Promise.all([
            etherscanTxResponsePromise,
            etherscanTokenResponsePromise,
        ]);
        if (etherscanTxResponse.status === '0' ||
            etherscanTxResponse.result.length <= 0) {
            etherscanTxResponse = { status: etherscanTxResponse.status, result: [] };
        }
        if (etherscanTokenResponse.status === '0' ||
            etherscanTokenResponse.result.length <= 0) {
            etherscanTokenResponse = {
                status: etherscanTokenResponse.status,
                result: [],
            };
        }
        return [etherscanTxResponse, etherscanTokenResponse];
    });
}
exports.handleTransactionFetch = handleTransactionFetch;
/**
 * Converts a hex string to a BN object.
 *
 * @param inputHex - Number represented as a hex string.
 * @returns A BN instance.
 */
function hexToBN(inputHex) {
    return new ethereumjs_util_1.BN((0, ethereumjs_util_1.stripHexPrefix)(inputHex), 16);
}
exports.hexToBN = hexToBN;
/**
 * A helper function that converts hex data to human readable string.
 *
 * @param hex - The hex string to convert to string.
 * @returns A human readable string conversion.
 */
function hexToText(hex) {
    try {
        const stripped = (0, ethereumjs_util_1.stripHexPrefix)(hex);
        const buff = Buffer.from(stripped, 'hex');
        return buff.toString('utf8');
    }
    catch (e) {
        /* istanbul ignore next */
        return hex;
    }
}
exports.hexToText = hexToText;
/**
 * Parses a hex string and converts it into a number that can be operated on in a bignum-safe,
 * base-10 way.
 *
 * @param value - A base-16 number encoded as a string.
 * @returns The number as a BN object in base-16 mode.
 */
function fromHex(value) {
    if (ethereumjs_util_1.BN.isBN(value)) {
        return value;
    }
    return new ethereumjs_util_1.BN(hexToBN(value).toString(10));
}
exports.fromHex = fromHex;
/**
 * Converts an integer to a hexadecimal representation.
 *
 * @param value - An integer, an integer encoded as a base-10 string, or a BN.
 * @returns The integer encoded as a hex string.
 */
function toHex(value) {
    if (typeof value === 'string' && (0, ethereumjs_util_1.isHexString)(value)) {
        return value;
    }
    const hexString = ethereumjs_util_1.BN.isBN(value)
        ? value.toString(16)
        : new ethereumjs_util_1.BN(value.toString(), 10).toString(16);
    return `0x${hexString}`;
}
exports.toHex = toHex;
/**
 * Normalizes properties on a Transaction object.
 *
 * @param transaction - Transaction object to normalize.
 * @returns Normalized Transaction object.
 */
function normalizeTransaction(transaction) {
    const normalizedTransaction = { from: '' };
    let key;
    for (key in NORMALIZERS) {
        if (transaction[key]) {
            normalizedTransaction[key] = NORMALIZERS[key](transaction[key]);
        }
    }
    return normalizedTransaction;
}
exports.normalizeTransaction = normalizeTransaction;
/**
 * Execute and return an asynchronous operation without throwing errors.
 *
 * @param operation - Function returning a Promise.
 * @param logError - Determines if the error should be logged.
 * @returns Promise resolving to the result of the async operation.
 */
function safelyExecute(operation, logError = false) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield operation();
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            return undefined;
        }
    });
}
exports.safelyExecute = safelyExecute;
/**
 * Execute and return an asynchronous operation with a timeout.
 *
 * @param operation - Function returning a Promise.
 * @param logError - Determines if the error should be logged.
 * @param timeout - Timeout to fail the operation.
 * @returns Promise resolving to the result of the async operation.
 */
function safelyExecuteWithTimeout(operation, logError = false, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            return yield Promise.race([
                operation(),
                new Promise((_, reject) => setTimeout(() => {
                    reject(TIMEOUT_ERROR);
                }, timeout)),
            ]);
        }
        catch (error) {
            /* istanbul ignore next */
            if (logError) {
                console.error(error);
            }
            return undefined;
        }
    });
}
exports.safelyExecuteWithTimeout = safelyExecuteWithTimeout;
/**
 * Convert an address to a checksummed hexidecimal address.
 *
 * @param address - The address to convert.
 * @returns A 0x-prefixed hexidecimal checksummed address.
 */
function toChecksumHexAddress(address) {
    const hexPrefixed = (0, ethereumjs_util_1.addHexPrefix)(address);
    if (!(0, ethereumjs_util_1.isHexString)(hexPrefixed)) {
        // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
        // but we shouldn't waste effort trying to change case on a clearly invalid
        // string. Instead just return the hex prefixed original string which most
        // closely mimics the original behavior.
        return hexPrefixed;
    }
    return (0, ethereumjs_util_1.toChecksumAddress)(hexPrefixed);
}
exports.toChecksumHexAddress = toChecksumHexAddress;
/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 *
 * @param possibleAddress - Input parameter to check against.
 * @param options - The validation options.
 * @param options.allowNonPrefixed - If true will first ensure '0x' is prepended to the string.
 * @returns Whether or not the input is a valid hex address.
 */
function isValidHexAddress(possibleAddress, { allowNonPrefixed = true } = {}) {
    const addressToCheck = allowNonPrefixed
        ? (0, ethereumjs_util_1.addHexPrefix)(possibleAddress)
        : possibleAddress;
    if (!(0, ethereumjs_util_1.isHexString)(addressToCheck)) {
        return false;
    }
    return (0, ethereumjs_util_1.isValidAddress)(addressToCheck);
}
exports.isValidHexAddress = isValidHexAddress;
/**
 * Validates a Transaction object for required properties and throws in
 * the event of any validation error.
 *
 * @param transaction - Transaction object to validate.
 */
function validateTransaction(transaction) {
    if (!transaction.from ||
        typeof transaction.from !== 'string' ||
        !isValidHexAddress(transaction.from)) {
        throw new Error(`Invalid "from" address: ${transaction.from} must be a valid string.`);
    }
    if (transaction.to === '0x' || transaction.to === undefined) {
        if (transaction.data) {
            delete transaction.to;
        }
        else {
            throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
        }
    }
    else if (transaction.to !== undefined &&
        !isValidHexAddress(transaction.to)) {
        throw new Error(`Invalid "to" address: ${transaction.to} must be a valid string.`);
    }
    if (transaction.value !== undefined) {
        const value = transaction.value.toString();
        if (value.includes('-')) {
            throw new Error(`Invalid "value": ${value} is not a positive number.`);
        }
        if (value.includes('.')) {
            throw new Error(`Invalid "value": ${value} number must be denominated in wei.`);
        }
        const intValue = parseInt(transaction.value, 10);
        const isValid = Number.isFinite(intValue) &&
            !Number.isNaN(intValue) &&
            !isNaN(Number(value)) &&
            Number.isSafeInteger(intValue);
        if (!isValid) {
            throw new Error(`Invalid "value": ${value} number must be a valid number.`);
        }
    }
}
exports.validateTransaction = validateTransaction;
/**
 * A helper function that converts rawmessageData buffer data to a hex, or just returns the data if
 * it is already formatted as a hex.
 *
 * @param data - The buffer data to convert to a hex.
 * @returns A hex string conversion of the buffer data.
 */
function normalizeMessageData(data) {
    try {
        const stripped = (0, ethereumjs_util_1.stripHexPrefix)(data);
        if (stripped.match(hexRe)) {
            return (0, ethereumjs_util_1.addHexPrefix)(stripped);
        }
    }
    catch (e) {
        /* istanbul ignore next */
    }
    return (0, ethereumjs_util_1.bufferToHex)(Buffer.from(data, 'utf8'));
}
exports.normalizeMessageData = normalizeMessageData;
/**
 * Validates a PersonalMessageParams and MessageParams objects for required properties and throws in
 * the event of any validation error.
 *
 * @param messageData - PersonalMessageParams object to validate.
 */
function validateSignMessageData(messageData) {
    const { from, data } = messageData;
    if (!from || typeof from !== 'string' || !isValidHexAddress(from)) {
        throw new Error(`Invalid "from" address: ${from} must be a valid string.`);
    }
    if (!data || typeof data !== 'string') {
        throw new Error(`Invalid message "data": ${data} must be a valid string.`);
    }
}
exports.validateSignMessageData = validateSignMessageData;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V1.
 *
 * @param messageData - TypedMessageParams object to validate.
 */
function validateTypedSignMessageDataV1(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || !Array.isArray(messageData.data)) {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    try {
        // typedSignatureHash will throw if the data is invalid.
        (0, eth_sig_util_1.typedSignatureHash)(messageData.data);
    }
    catch (e) {
        throw new Error(`Expected EIP712 typed data.`);
    }
}
exports.validateTypedSignMessageDataV1 = validateTypedSignMessageDataV1;
/**
 * Validates a TypedMessageParams object for required properties and throws in
 * the event of any validation error for eth_signTypedMessage_V3.
 *
 * @param messageData - TypedMessageParams object to validate.
 */
function validateTypedSignMessageDataV3(messageData) {
    if (!messageData.from ||
        typeof messageData.from !== 'string' ||
        !isValidHexAddress(messageData.from)) {
        throw new Error(`Invalid "from" address: ${messageData.from} must be a valid string.`);
    }
    if (!messageData.data || typeof messageData.data !== 'string') {
        throw new Error(`Invalid message "data": ${messageData.data} must be a valid array.`);
    }
    let data;
    try {
        data = JSON.parse(messageData.data);
    }
    catch (e) {
        throw new Error('Data must be passed as a valid JSON string.');
    }
    const validation = (0, jsonschema_1.validate)(data, eth_sig_util_1.TYPED_MESSAGE_SCHEMA);
    if (validation.errors.length > 0) {
        throw new Error('Data must conform to EIP-712 schema. See https://git.io/fNtcx.');
    }
}
exports.validateTypedSignMessageDataV3 = validateTypedSignMessageDataV3;
/**
 * Validates a ERC20 token to be added with EIP747.
 *
 * @param token - Token object to validate.
 */
function validateTokenToWatch(token) {
    const { address, symbol, decimals } = token;
    if (!address || !symbol || typeof decimals === 'undefined') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Must specify address, symbol, and decimals.`);
    }
    if (typeof symbol !== 'string') {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol: not a string.`);
    }
    if (symbol.length > 11) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid symbol "${symbol}": longer than 11 characters.`);
    }
    const numDecimals = parseInt(decimals, 10);
    if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid decimals "${decimals}": must be 0 <= 36.`);
    }
    if (!isValidHexAddress(address)) {
        throw eth_rpc_errors_1.ethErrors.rpc.invalidParams(`Invalid address "${address}".`);
    }
}
exports.validateTokenToWatch = validateTokenToWatch;
/**
 * Returns whether the given code corresponds to a smart contract.
 *
 * @param code - The potential smart contract code.
 * @returns Whether the code was smart contract code or not.
 */
function isSmartContractCode(code) {
    /* istanbul ignore if */
    if (!code) {
        return false;
    }
    // Geth will return '0x', and ganache-core v2.2.1 will return '0x0'
    const smartContractCode = code !== '0x' && code !== '0x0';
    return smartContractCode;
}
exports.isSmartContractCode = isSmartContractCode;
/**
 * Execute fetch and verify that the response was successful.
 *
 * @param request - Request information.
 * @param options - Fetch options.
 * @returns The fetch response.
 */
function successfulFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield fetch(request, options);
        if (!response.ok) {
            throw new Error(`Fetch failed with status '${response.status}' for request '${request}'`);
        }
        return response;
    });
}
exports.successfulFetch = successfulFetch;
/**
 * Execute fetch and return object response.
 *
 * @param request - The request information.
 * @param options - The fetch options.
 * @returns The fetch response JSON data.
 */
function handleFetch(request, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield successfulFetch(request, options);
        const object = yield response.json();
        return object;
    });
}
exports.handleFetch = handleFetch;
/**
 * Execute fetch and return object response, log if known error thrown, otherwise rethrow error.
 *
 * @param request - the request options object
 * @param request.url - The request url to query.
 * @param request.options - The fetch options.
 * @param request.timeout - Timeout to fail request
 * @param request.errorCodesToCatch - array of error codes for errors we want to catch in a particular context
 * @returns The fetch response JSON data or undefined (if error occurs).
 */
function fetchWithErrorHandling({ url, options, timeout, errorCodesToCatch, }) {
    return __awaiter(this, void 0, void 0, function* () {
        let result;
        try {
            if (timeout) {
                result = Promise.race([
                    yield handleFetch(url, options),
                    new Promise((_, reject) => setTimeout(() => {
                        reject(TIMEOUT_ERROR);
                    }, timeout)),
                ]);
            }
            else {
                result = yield handleFetch(url, options);
            }
        }
        catch (e) {
            logOrRethrowError(e, errorCodesToCatch);
        }
        return result;
    });
}
exports.fetchWithErrorHandling = fetchWithErrorHandling;
/**
 * Fetch that fails after timeout.
 *
 * @param url - Url to fetch.
 * @param options - Options to send with the request.
 * @param timeout - Timeout to fail request.
 * @returns Promise resolving the request.
 */
function timeoutFetch(url, options, timeout = 500) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.race([
            successfulFetch(url, options),
            new Promise((_, reject) => setTimeout(() => {
                reject(TIMEOUT_ERROR);
            }, timeout)),
        ]);
    });
}
exports.timeoutFetch = timeoutFetch;
/**
 * Normalizes the given ENS name.
 *
 * @param ensName - The ENS name.
 * @returns The normalized ENS name string.
 */
function normalizeEnsName(ensName) {
    if (ensName && typeof ensName === 'string') {
        try {
            const normalized = eth_ens_namehash_1.default.normalize(ensName.trim());
            // this regex is only sufficient with the above call to ensNamehash.normalize
            // TODO: change 7 in regex to 3 when shorter ENS domains are live
            if (normalized.match(/^(([\w\d-]+)\.)*[\w\d-]{7,}\.(eth|test)$/u)) {
                return normalized;
            }
        }
        catch (_) {
            // do nothing
        }
    }
    return null;
}
exports.normalizeEnsName = normalizeEnsName;
/**
 * Wrapper method to handle EthQuery requests.
 *
 * @param ethQuery - EthQuery object initialized with a provider.
 * @param method - Method to request.
 * @param args - Arguments to send.
 * @returns Promise resolving the request.
 */
function query(ethQuery, method, args = []) {
    return new Promise((resolve, reject) => {
        const cb = (error, result) => {
            if (error) {
                reject(error);
                return;
            }
            resolve(result);
        };
        if (typeof ethQuery[method] === 'function') {
            ethQuery[method](...args, cb);
        }
        else {
            ethQuery.sendAsync({ method, params: args }, cb);
        }
    });
}
exports.query = query;
/**
 * Checks if a transaction is EIP-1559 by checking for the existence of
 * maxFeePerGas and maxPriorityFeePerGas within its parameters.
 *
 * @param transaction - Transaction object to add.
 * @returns Boolean that is true if the transaction is EIP-1559 (has maxFeePerGas and maxPriorityFeePerGas), otherwise returns false.
 */
const isEIP1559Transaction = (transaction) => {
    const hasOwnProp = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
    return (hasOwnProp(transaction, 'maxFeePerGas') &&
        hasOwnProp(transaction, 'maxPriorityFeePerGas'));
};
exports.isEIP1559Transaction = isEIP1559Transaction;
/**
 * Converts valid hex strings to decimal numbers, and handles unexpected arg types.
 *
 * @param value - a string that is either a hexadecimal with `0x` prefix or a decimal string.
 * @returns a decimal number.
 */
const convertHexToDecimal = (value = '0x0') => {
    if ((0, ethereumjs_util_1.isHexString)(value)) {
        return parseInt(value, 16);
    }
    return Number(value) ? Number(value) : 0;
};
exports.convertHexToDecimal = convertHexToDecimal;
const getIncreasedPriceHex = (value, rate) => (0, ethereumjs_util_1.addHexPrefix)(`${parseInt(`${value * rate}`, 10).toString(16)}`);
exports.getIncreasedPriceHex = getIncreasedPriceHex;
const getIncreasedPriceFromExisting = (value, rate) => {
    return (0, exports.getIncreasedPriceHex)((0, exports.convertHexToDecimal)(value), rate);
};
exports.getIncreasedPriceFromExisting = getIncreasedPriceFromExisting;
const validateGasValues = (gasValues) => {
    Object.keys(gasValues).forEach((key) => {
        const value = gasValues[key];
        if (typeof value !== 'string' || !(0, ethereumjs_util_1.isHexString)(value)) {
            throw new TypeError(`expected hex string for ${key} but received: ${value}`);
        }
    });
};
exports.validateGasValues = validateGasValues;
const isFeeMarketEIP1559Values = (gasValues) => (gasValues === null || gasValues === void 0 ? void 0 : gasValues.maxFeePerGas) !== undefined ||
    (gasValues === null || gasValues === void 0 ? void 0 : gasValues.maxPriorityFeePerGas) !== undefined;
exports.isFeeMarketEIP1559Values = isFeeMarketEIP1559Values;
const isGasPriceValue = (gasValues) => (gasValues === null || gasValues === void 0 ? void 0 : gasValues.gasPrice) !== undefined;
exports.isGasPriceValue = isGasPriceValue;
/**
 * Validates that the proposed value is greater than or equal to the minimum value.
 *
 * @param proposed - The proposed value.
 * @param min - The minimum value.
 * @returns The proposed value.
 * @throws Will throw if the proposed value is too low.
 */
function validateMinimumIncrease(proposed, min) {
    const proposedDecimal = (0, exports.convertHexToDecimal)(proposed);
    const minDecimal = (0, exports.convertHexToDecimal)(min);
    if (proposedDecimal >= minDecimal) {
        return proposed;
    }
    const errorMsg = `The proposed value: ${proposedDecimal} should meet or exceed the minimum value: ${minDecimal}`;
    throw new Error(errorMsg);
}
exports.validateMinimumIncrease = validateMinimumIncrease;
/**
 * Removes IPFS protocol prefix from input string.
 *
 * @param ipfsUrl - An IPFS url (e.g. ipfs://{content id})
 * @returns IPFS content identifier and (possibly) path in a string
 * @throws Will throw if the url passed is not IPFS.
 */
function removeIpfsProtocolPrefix(ipfsUrl) {
    if (ipfsUrl.startsWith('ipfs://ipfs/')) {
        return ipfsUrl.replace('ipfs://ipfs/', '');
    }
    else if (ipfsUrl.startsWith('ipfs://')) {
        return ipfsUrl.replace('ipfs://', '');
    }
    // this method should not be used with non-ipfs urls (i.e. startsWith('ipfs://') === true)
    throw new Error('this method should not be used with non ipfs urls');
}
exports.removeIpfsProtocolPrefix = removeIpfsProtocolPrefix;
/**
 * Extracts content identifier and path from an input string.
 *
 * @param ipfsUrl - An IPFS URL minus the IPFS protocol prefix
 * @returns IFPS content identifier (cid) and sub path as string.
 * @throws Will throw if the url passed is not ipfs.
 */
function getIpfsCIDv1AndPath(ipfsUrl) {
    const url = removeIpfsProtocolPrefix(ipfsUrl);
    // check if there is a path
    // (CID is everything preceding first forward slash, path is everything after)
    const index = url.indexOf('/');
    const cid = index !== -1 ? url.substring(0, index) : url;
    const path = index !== -1 ? url.substring(index) : undefined;
    // We want to ensure that the CID is v1 (https://docs.ipfs.io/concepts/content-addressing/#identifier-formats)
    // because most cid v0s appear to be incompatible with IPFS subdomains
    return {
        cid: cid_1.CID.parse(cid).toV1().toString(),
        path,
    };
}
exports.getIpfsCIDv1AndPath = getIpfsCIDv1AndPath;
/**
 * Adds URL protocol prefix to input URL string if missing.
 *
 * @param urlString - An IPFS URL.
 * @returns A URL with a https:// prepended.
 */
function addUrlProtocolPrefix(urlString) {
    if (!urlString.match(/(^http:\/\/)|(^https:\/\/)/u)) {
        return `https://${urlString}`;
    }
    return urlString;
}
exports.addUrlProtocolPrefix = addUrlProtocolPrefix;
/**
 * Formats URL correctly for use retrieving assets hosted on IPFS.
 *
 * @param ipfsGateway - The users preferred IPFS gateway (full URL or just host).
 * @param ipfsUrl - The IFPS URL pointed at the asset.
 * @param subdomainSupported - Boolean indicating whether the URL should be formatted with subdomains or not.
 * @returns A formatted URL, with the user's preferred IPFS gateway and format (subdomain or not), pointing to an asset hosted on IPFS.
 */
function getFormattedIpfsUrl(ipfsGateway, ipfsUrl, subdomainSupported) {
    const { host, protocol, origin } = new URL(addUrlProtocolPrefix(ipfsGateway));
    if (subdomainSupported) {
        const { cid, path } = getIpfsCIDv1AndPath(ipfsUrl);
        return `${protocol}//${cid}.ipfs.${host}${path !== null && path !== void 0 ? path : ''}`;
    }
    const cidAndPath = removeIpfsProtocolPrefix(ipfsUrl);
    return `${origin}/ipfs/${cidAndPath}`;
}
exports.getFormattedIpfsUrl = getFormattedIpfsUrl;
/**
 * Determines whether a value is a "plain" object.
 *
 * @param value - A value to check
 * @returns True if the passed value is a plain object
 */
function isPlainObject(value) {
    return Boolean(value) && typeof value === 'object' && !Array.isArray(value);
}
exports.isPlainObject = isPlainObject;
const hasProperty = (object, key) => Reflect.hasOwnProperty.call(object, key);
exports.hasProperty = hasProperty;
/**
 * Type guard for {@link NonEmptyArray}.
 *
 * @template T - The non-empty array member type.
 * @param value - The value to check.
 * @returns Whether the value is a non-empty array.
 */
function isNonEmptyArray(value) {
    return Array.isArray(value) && value.length > 0;
}
exports.isNonEmptyArray = isNonEmptyArray;
/**
 * Type guard for {@link Json}.
 *
 * @param value - The value to check.
 * @returns Whether the value is valid JSON.
 */
function isValidJson(value) {
    try {
        return (0, fast_deep_equal_1.default)(value, JSON.parse(JSON.stringify(value)));
    }
    catch (_) {
        return false;
    }
}
exports.isValidJson = isValidJson;
/**
 * Networks where token detection is supported - Values are in decimal format
 */
var SupportedTokenDetectionNetworks;
(function (SupportedTokenDetectionNetworks) {
    SupportedTokenDetectionNetworks["mainnet"] = "1";
    SupportedTokenDetectionNetworks["bsc"] = "56";
    SupportedTokenDetectionNetworks["polygon"] = "137";
    SupportedTokenDetectionNetworks["avax"] = "43114";
})(SupportedTokenDetectionNetworks = exports.SupportedTokenDetectionNetworks || (exports.SupportedTokenDetectionNetworks = {}));
/**
 * Check if token detection is enabled for certain networks.
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports token detection
 */
function isTokenDetectionSupportedForNetwork(chainId) {
    return Object.values(SupportedTokenDetectionNetworks).includes(chainId);
}
exports.isTokenDetectionSupportedForNetwork = isTokenDetectionSupportedForNetwork;
/**
 * Check if token list polling is enabled for a given network.
 * Currently this method is used to support e2e testing for consumers of this package.
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports tokenlists
 */
function isTokenListSupportedForNetwork(chainId) {
    const chainIdDecimal = (0, exports.convertHexToDecimal)(chainId).toString();
    return (isTokenDetectionSupportedForNetwork(chainIdDecimal) ||
        chainIdDecimal === constants_1.GANACHE_CHAIN_ID);
}
exports.isTokenListSupportedForNetwork = isTokenListSupportedForNetwork;
/**
 * Utility method to log if error is a common fetch error and otherwise rethrow it.
 *
 * @param error - Caught error that we should either rethrow or log to console
 * @param codesToCatch - array of error codes for errors we want to catch and log in a particular context
 */
function logOrRethrowError(error, codesToCatch = []) {
    var _a;
    if (!error) {
        return;
    }
    const includesErrorCodeToCatch = codesToCatch.some((code) => { var _a; return (_a = error.message) === null || _a === void 0 ? void 0 : _a.includes(`Fetch failed with status '${code}'`); });
    if (error instanceof Error &&
        (includesErrorCodeToCatch ||
            ((_a = error.message) === null || _a === void 0 ? void 0 : _a.includes('Failed to fetch')) ||
            error === TIMEOUT_ERROR)) {
        console.error(error);
    }
    else {
        throw error;
    }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/smart-transactions-controller>@metamask/controllers",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcC9zY3JpcHRzL21ldGFtYXNrLWNvbnRyb2xsZXIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDAzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMDcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAwOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDA5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxMS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDEyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAxNy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDE4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMTkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDIxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyMy5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyNi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDI3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMjguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAyOS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzMi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDMzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzNS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wMzcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzAzOC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDM5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDYuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA0Ny5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDQ4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNDkuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1MC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDUxLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTIuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1My5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU0LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTUuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1Ni5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDU3LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNTguanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA1OS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYwLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjEuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2Mi5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDYzLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjQuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2NS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY2LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNjcuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA2OC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDY5LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzAuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3MS5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDcyLmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy8wNzMuanMiLCJhcHAvc2NyaXB0cy9taWdyYXRpb25zLzA3NC5qcyIsImFwcC9zY3JpcHRzL21pZ3JhdGlvbnMvMDc1LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy9mYWlsLXR4LmpzIiwiYXBwL3NjcmlwdHMvbWlncmF0aW9ucy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy93cmFwTmF0aXZlU3VwZXIuanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL3NyYy9oZWxwZXJzLmpzIiwibm9kZV9tb2R1bGVzL0BlbnNkb21haW5zL2NvbnRlbnQtaGFzaC9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQGVuc2RvbWFpbnMvY29udGVudC1oYXNoL3NyYy9wcm9maWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL2Rpc3QvYmFzZS1ldGgta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZy9kaXN0L2Jhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9iYXNlLWV0aC1rZXlyaW5nL25vZGVfbW9kdWxlcy9ybHAvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL2Rpc3QvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvQ29tcG9zZWRTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L01lcmdlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvT2JzZXJ2YWJsZVN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BrZXlzdG9uZWhxL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9Aa2V5c3RvbmVocS9tZXRhbWFzay1haXJnYXBwZWQta2V5cmluZy9ub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9jcmVhdGUtcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9mZXRjaC1jb25maWctZnJvbS1yZXEuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9kaXN0L2xvZ2dpbmctdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLXJld3JpdGUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Rpc3QvYmxvY2stcmVmLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2Jsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2ZldGNoLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L2luZmxpZ2h0LWNhY2hlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyQXNNaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3Byb3ZpZGVyRnJvbUVuZ2luZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC9wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9kaXN0L3JldHJ5T25FbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC91dGlscy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvZGlzdC93YWxsZXQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1hZGFwdGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtanNvbi1ycGMtaW5mdXJhL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWxpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWpzb24tcnBjLWluZnVyYS9ub2RlX21vZHVsZXMvZXRoanMtdXRpbC9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1qc29uLXJwYy1pbmZ1cmEvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL2V0aC1zaWctdXRpbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtYWRhcHRlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvaGRrZXkvbGliL2hka2V5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvZWxsaXB0aWMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcvbm9kZV9tb2R1bGVzL3NlY3AyNTZrMS9saWIvYXNzZXJ0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9ldGgtbGVkZ2VyLWJyaWRnZS1rZXlyaW5nL25vZGVfbW9kdWxlcy9zZWNwMjU2azEvbGliL2Rlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9lbGxpcHRpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svZXRoLWxlZGdlci1icmlkZ2Uta2V5cmluZy9ub2RlX21vZHVsZXMvc2VjcDI1NmsxL2xpYi9tZXNzYWdlcy5qc29uIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Db21wb3NlZFN0b3JlLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9Mb2NhbFN0b3JhZ2VTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvTWVyZ2VkU3RvcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L09ic2VydmFibGVTdG9yZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svb2JzLXN0b3JlL2Rpc3QvYXNTdHJlYW0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL29icy1zdG9yZS9ub2RlX21vZHVsZXMvdGhyb3VnaDIvdGhyb3VnaDIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3JwYy1tZXRob2RzL2Rpc3QvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL2Rpc3QvU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9kaXN0L2NvbnN0YW50cy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvZGlzdC90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvZGlzdC91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0Jhc2VDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvQmFzZUNvbnRyb2xsZXJWMi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L0NvbXBvc2FibGVDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvQ29udHJvbGxlck1lc3Nlbmdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fubm91bmNlbWVudC9Bbm5vdW5jZW1lbnRDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXBpcy9jcnlwdG8tY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2FwaXMvdG9rZW4tc2VydmljZS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2FwcHJvdmFsL0FwcHJvdmFsQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvQXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL0NvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9Db2xsZWN0aWJsZXNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL0N1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvU3RhbmRhcmRzL0NvbGxlY3RpYmxlU3RhbmRhcmRzL0VSQzExNTUvRVJDMTE1NVN0YW5kYXJkLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1N0YW5kYXJkcy9Db2xsZWN0aWJsZVN0YW5kYXJkcy9FUkM3MjEvRVJDNzIxU3RhbmRhcmQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvU3RhbmRhcmRzL0VSQzIwU3RhbmRhcmQuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvYXNzZXRzL1Rva2VuTGlzdENvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5SYXRlc0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9hc3NldHMvVG9rZW5zQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2Fzc2V0cy9hc3NldHNVdGlsLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvY29uc3RhbnRzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvZ2FzL0dhc0ZlZUNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9nYXMvZGV0ZXJtaW5lR2FzRmVlQ2FsY3VsYXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvZ2FzL2ZldGNoQmxvY2tGZWVIaXN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvZ2FzL2ZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L2dhcy9mZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnkvY2FsY3VsYXRlR2FzRmVlRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9nYXMvZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5L2ZldGNoTGF0ZXN0QmxvY2suanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9nYXMvZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5L21lZGlhbk9mLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvZ2FzL2dhcy11dGlsLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9rZXlyaW5nL0tleXJpbmdDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvbWVzc2FnZS1tYW5hZ2VyL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9tZXNzYWdlLW1hbmFnZXIvTWVzc2FnZU1hbmFnZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9tZXNzYWdlLW1hbmFnZXIvUGVyc29uYWxNZXNzYWdlTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L21lc3NhZ2UtbWFuYWdlci9UeXBlZE1lc3NhZ2VNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvbmV0d29yay9OZXR3b3JrQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvQ2F2ZWF0LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvUGVybWlzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL1Blcm1pc3Npb25Db250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9wZXJtaXNzaW9uLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9wZXJtaXNzaW9ucy9ycGMtbWV0aG9kcy9nZXRQZXJtaXNzaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3Blcm1pc3Npb25zL3JwYy1tZXRob2RzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvcnBjLW1ldGhvZHMvcmVxdWVzdFBlcm1pc3Npb25zLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvcGVybWlzc2lvbnMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC9yYXRlbGltaXQvUmF0ZUxpbWl0Q29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3N1YmplY3QtbWV0YWRhdGEvU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3N1YmplY3QtbWV0YWRhdGEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC90aGlyZC1wYXJ0eS9QaGlzaGluZ0NvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC90cmFuc2FjdGlvbi9UcmFuc2FjdGlvbkNvbnRyb2xsZXIuanMiLCJub2RlX21vZHVsZXMvQG1ldGFtYXNrL3NtYXJ0LXRyYW5zYWN0aW9ucy1jb250cm9sbGVyL25vZGVfbW9kdWxlcy9AbWV0YW1hc2svY29udHJvbGxlcnMvZGlzdC91c2VyL0FkZHJlc3NCb29rQ29udHJvbGxlci5qcyIsIm5vZGVfbW9kdWxlcy9AbWV0YW1hc2svc21hcnQtdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXIvbm9kZV9tb2R1bGVzL0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3VzZXIvUHJlZmVyZW5jZXNDb250cm9sbGVyLmpzIiwibm9kZV9tb2R1bGVzL0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlci9ub2RlX21vZHVsZXMvQG1ldGFtYXNrL2NvbnRyb2xsZXJzL2Rpc3QvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFFBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsTUFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGlCQUFBLE9BQUEsQ0FBQSxpQkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHlDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEscUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsc0JBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSx1QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwwQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHdCQUFBLE9BQUEsQ0FBQSx5QkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSx3QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx3QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGdCQUFBLE9BQUEsQ0FBQSxnQkFBQSxDQUFBLENBQUE7O0FBS0EsSUFBQSxrQkFBQSxPQUFBLENBQUEsaUJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxVQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsb0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsb0JBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSwwQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHFCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsNEJBQUEsT0FBQSxDQUFBLHdDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFlBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsV0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFdBQUEsT0FBQSxDQUFBLGlCQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGVBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQTs7QUFtQkEsSUFBQSwrQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSx5Q0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFFQSxJQUFBLGVBQUEsT0FBQSxDQUFBLG9DQUFBLENBQUEsQ0FBQTs7QUFLQSxJQUFBLFlBQUEsT0FBQSxDQUFBLGlDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFNBQUEsT0FBQSxDQUFBLDhCQUFBLENBQUEsQ0FBQTs7QUFLQSxJQUFBLFdBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLG1CQUFBLE9BQUEsQ0FBQSx5Q0FBQSxDQUFBLENBQUE7O0FBSUEsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQ0FBQSxDQUFBLENBQUE7O0FBSUEsSUFBQSxpQkFBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsa0JBQUEsT0FBQSxDQUFBLHNDQUFBLENBQUEsQ0FBQTs7QUFJQSxJQUFBLFFBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLE9BQUEsT0FBQSxDQUFBLDRCQUFBLENBQUEsQ0FBQTs7QUFLQSxJQUFBLGVBQUEsT0FBQSxDQUFBLG9DQUFBLENBQUEsQ0FBQTs7QUFFQSxJQUFBLGFBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGVBQUEsT0FBQSxDQUFBLG1DQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGdCQUFBLE9BQUEsQ0FBQSx3Q0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxVQUFBLE9BQUEsQ0FBQSwrQkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSwyQkFBQSxPQUFBLENBQUEsNENBQUEsQ0FBQSxDQUFBOztBQUlBLElBQUEsMkJBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQTs7QUFJQSxJQUFBLDZCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGlDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsa0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsdUJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSwwQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHVCQUFBLE9BQUEsQ0FBQSw2QkFBQSxDQUFBLENBQUE7O0FBR0EsSUFBQSwwQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw4QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHlCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsOEJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsa0NBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxlQUFBLE9BQUEsQ0FBQSxvQkFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxPQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLG1CQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsWUFBQSx1QkFBQSxDQUFBLE9BQUEsQ0FBQSx1QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsMkJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxZQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHlCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsa0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxTQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLHFCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsY0FBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwwQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFVBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsc0JBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSx3QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGtCQUFBLHVCQUFBLENBQUEsT0FBQSxDQUFBLHVCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEseUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsK0JBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSw4QkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQ0FBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLDBCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGdDQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsdUJBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNkJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxnQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSw0QkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLGdCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsVUFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSxxQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLDJCQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLDZCQUFBLENBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsc0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxnQkFBQSxzQkFBQSxDQUFBLE9BQUEsQ0FBQSwyQkFBQSxDQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLFdBQUEsT0FBQSxDQUFBLGVBQUEsQ0FBQSxDQUFBOztBQUNBLElBQUEsd0JBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEsNEJBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxnQkFBQSxPQUFBLENBQUEsMkJBQUEsQ0FBQSxDQUFBOztBQVdBLElBQUEscUNBQUEsc0JBQUEsQ0FBQSxPQUFBLENBQUEseUNBQUEsQ0FBQSxDQUFBLENBQUE7Ozs7Ozs7Ozs7QUFFTyxNQUFNLDZCQUE2Qjs7O0VBR3hDLGNBQWMsYUFIMEI7O0VBS3hDLHVCQUF1QixnQ0FBQTtDQUxsQjs7O0FBU1AsTUFBTSxvQkFBb0IsNEJBQTFCLENBQUE7O0FBRWUsaUNBQWlDLE9BQUEsUUFBakMsQ0FBOEM7Ozs7RUFJM0QsV0FBVyxPQUFPO0lBQUEsSUFBQSxpQkFBQSxDQUFBOztJQUNoQixLQUFBLEVBQUEsQ0FBQTs7SUFEZ0IsZUFBQSxDQUFBLElBQUEsRUFBQSxzQkFBQSxFQStySE0sWUFBYTtNQUNuQyxJQUFJO1FBQ0YsSUFBQSxxQkFBQSxrQkFBQSxDQUE0QyxRQUE1QyxDQUFBLENBQUE7T0FERixDQUVFLFlBQVk7UUFDWixJQUFJLEVBQUUsR0FBRyxZQUFZLFlBQUEsZ0NBQWpCLENBQUosRUFBdUQ7VUFDckQsTUFBTSxHQUFOLENBQUE7U0FDRDtPQUNGO0tBdHNIZSxDQUFBLENBQUE7O0lBQUEsZUFBQSxDQUFBLElBQUEsRUFBQSwwQkFBQSxFQXlzSFUsYUFBYztNQUN4QyxJQUFJO1FBQ0YsSUFBQSxxQkFBQSx5QkFBQSxDQUFtRCxTQUFuRCxDQUFBLENBQUE7T0FERixDQUVFLFlBQVk7UUFDWixJQUFJLEVBQUUsR0FBRyxZQUFZLFlBQUEsZ0NBQWpCLENBQUosRUFBdUQ7VUFDckQsTUFBTSxHQUFOLENBQUE7U0FDRDtPQUNGO0tBaHRIZSxDQUFBLENBQUE7O0lBQUEsZUFBQSxDQUFBLElBQUEsRUFBQSwwQkFBQSxFQW10SFUsV0FBWTtNQUN0QyxJQUFJO1FBQ0YsSUFBQSxxQkFBQSx5QkFBQSxDQUFtRCxPQUFuRCxDQUFBLENBQUE7T0FERixDQUVFLFlBQVk7UUFDWixJQUFJLEVBQUUsR0FBRyxZQUFZLFlBQUEsZ0NBQWpCLENBQUosRUFBdUQ7VUFDckQsTUFBTSxHQUFOLENBQUE7U0FDRDtPQUNGO0tBMXRIZSxDQUFBLENBQUE7O0lBQUEsZUFBQSxDQUFBLElBQUEsRUFBQSx3QkFBQSxFQTZ0SE8sZUFBZTtNQUN0QyxJQUFJO1FBQ0YsSUFBQSxtQkFBQSxPQUFBLENBQStCLEVBQS9CLEVBQW1DLEtBQW5DLENBQUEsQ0FBQTtPQURGLENBRUUsWUFBWTtRQUNaLElBQUksRUFBRSxHQUFHLFlBQVksWUFBQSw2QkFBakIsQ0FBSixFQUFvRDtVQUNsRCxNQUFNLEdBQU4sQ0FBQTtTQUNEO09BQ0Y7S0FwdUhlLENBQUEsQ0FBQTs7SUFBQSxlQUFBLENBQUEsSUFBQSxFQUFBLHVCQUFBLEVBdXVITSxlQUFlO01BQ3JDLElBQUk7UUFDRixJQUFBLG1CQUFBLE9BQUEsQ0FDRSxFQURGLEVBRUUsSUFBSSxhQUFBLGlCQUFKLENBQXFCLEtBQUssS0FBMUIsRUFBaUMsS0FBSyxRQUF0QyxFQUFnRCxLQUFLLEtBQXJELENBRkYsQ0FBQSxDQUFBO09BREYsQ0FLRSxZQUFZO1FBQ1osSUFBSSxFQUFFLEdBQUcsWUFBWSxZQUFBLDZCQUFqQixDQUFKLEVBQW9EO1VBQ2xELE1BQU0sR0FBTixDQUFBO1NBQ0Q7T0FDRjtLQWp2SGUsQ0FBQSxDQUFBOztJQUdoQixJQUFBLG9CQUFBLEdBQTJCLEVBQTNCLENBQUE7SUFFQSxJQUFBLFdBQUEsR0FBa0IsQ0FBQSxDQUFBLEVBQUEsT0FBQSxTQUFBLEVBQ2hCLElBQUEsa0JBQUEsS0FBQSxDQUE0QixJQUE1QixDQURnQixFQUVoQixLQUFBLFlBQUEsR0FBYyxHQUZFLENBQWxCLENBQUE7SUFJQSxJQUFBLEtBQUEsR0FBWSxJQUFaLENBQUE7SUFDQSxJQUFBLFVBQUEsR0FBaUIsSUFBSSxRQUFyQixDQUFBO0lBQ0EsSUFBQSxTQUFBLEdBQWdCLElBQUksU0FBcEIsQ0FBQTtJQUNBLElBQUEsb0JBQUEsR0FBMkIsSUFBSSxvQkFBL0IsQ0FBQTtJQUNBLE1BQU0sWUFBWSxJQUFJLFVBQUosSUFBa0IsRUFBcEMsQ0FBQTtJQUNBLE1BQU0sVUFBVSxJQUFBLFNBQUEsV0FBQSxFQUFoQixDQUFBO0lBQ0EsSUFBQSxvQkFBQSxDQUF5QixTQUF6QixDQUFBLENBZmdCOzs7SUFtQmhCLElBQUEsNEJBQUEsR0FBbUMsQ0FBbkMsQ0FBQTtJQUVBLElBQUEsd0JBQUEsR0FBK0IsSUFBSSx3QkFBbkMsQ0FBQTtJQUNBLElBQUEsdUJBQUEsR0FBOEIsSUFBSSx1QkFBbEMsQ0FBQTtJQUVBLElBQUEsb0JBQUEsR0FBMkIsSUFBSSxZQUFBLG9CQUFKLEVBQTNCLENBeEJnQjs7SUEyQmhCLElBQUEscUJBQUEsR0FBNEIsSUFBSSxXQUFoQyxDQTNCZ0I7O0lBOEJoQixJQUFBLE1BQUEsR0FBYSxJQUFJLDBCQUFBLFFBQUosQ0FBOEI7TUFDekMsT0FBTyxTQURrQztNQUV6QyxxQkFBcUIsSUFBQSxvQkFGb0I7TUFHekMsU0FBUyxJQUFBO0tBSEUsQ0FBYixDQTlCZ0I7OztJQXNDaEIsSUFBQSxZQUFBLEdBQW1CLEVBQW5CLENBdENnQjs7SUF5Q2hCLElBQUEsaUJBQUEsR0FBd0IsSUFBSSxlQUFBLE1BQUosRUFBeEIsQ0FBQTtJQUVBLElBQUEsVUFBQSxRQUFBLFlBQUEsWUFBQSxDQUFnRCxXQUFZO01BQzFELElBQUksT0FBTyxPQUFQLEtBQW1CLFFBQW5CLElBQStCLE9BQU8sS0FBSyxPQUEvQyxFQUF3RDtRQUN0RCxJQUFBLFNBQUEsdUJBQUEsRUFBQSxDQUFBO09BQ0Q7S0FISCxDQUFBLENBM0NnQjs7O0lBb0RoQixJQUFBLG1CQUFBLEdBQTBCLElBQUksWUFBQSxtQkFBSixDQUF1QjtNQUMvQyxXQUFXLElBQUEsb0JBQUEsY0FBQSxDQUF1QztRQUNoRCxNQUFNLG9CQUFBO09BREcsQ0FEb0M7TUFJL0MscUJBQXFCLElBQUkscUJBQUM7S0FKRixDQUExQixDQUFBO0lBT0EsSUFBQSxrQkFBQSxHQUF5QixJQUFJLFNBQUEsUUFBSixDQUFzQixTQUFTLGtCQUEvQixDQUF6QixDQUFBO0lBQ0EsSUFBQSxrQkFBQSxtQkFBQSxDQUEwQyxJQUFJLGdCQUE5QyxDQUFBLENBNURnQjs7SUErRGhCLElBQUEsbUJBQUEsRUFBQSxDQUFBO0lBQ0EsSUFBQSxTQUFBLEdBQ0UsSUFBQSxrQkFBQSwyQkFBQSxFQUFBLFNBREYsQ0FBQTtJQUVBLElBQUEsYUFBQSxHQUNFLElBQUEsa0JBQUEsMkJBQUEsRUFBQSxhQURGLENBQUE7SUFHQSxNQUFNLHFCQUFxQixJQUFBLG9CQUFBLGNBQUEsQ0FBdUM7TUFDaEUsTUFBTSxxQkFBQTtLQURtQixDQUEzQixDQUFBO0lBSUEsSUFBQSxvQkFBQSxHQUEyQixJQUFJLFlBQUEsb0JBQUosQ0FBd0I7TUFDakQsU0FBUyxDQUFBLENBQUEsRUFBQSx3QkFBQSxhQUFBLEVBQWEsSUFBQSxrQkFBQSxrQkFBQSxFQUFiLENBRHdDO01BRWpELGdDQUFnQyxTQUFTLG9CQUFULEdBQzVCLFNBQVMsb0JBQVQsK0JBRDRCLEdBRTVCLElBSjZDO01BS2pELHNCQUF1QixNQUFPO1FBQzVCLElBQUEsa0JBQUEsTUFBQSxVQUFBLENBQXdDLGdCQUFpQjtVQUN2RCxNQUFNLHVCQUF1QixFQUMzQixHQUFHLFlBRHdCO1lBRTNCLFVBQVUsRUFDUixHQUFHLFlBQVksU0FEUDtjQUVSLFNBQVMsQ0FBQSxDQUFBLEVBQUEsd0JBQUEsYUFBQSxFQUFhLFlBQVksU0FBWixRQUFiLENBQUE7YUFGRDtXQUZaLENBQUE7VUFPQSxPQUFPLEVBQUUsQ0FBQyxvQkFBRCxDQUFULENBQUE7U0FSRixDQUFBLENBQUE7T0FOK0M7TUFpQmpELFdBQVcsa0JBakJzQztNQWtCakQsT0FBTyxTQUFTLG9CQUFDO0tBbEJRLENBQTNCLENBQUE7SUFxQkEsSUFBQSxzQkFBQSxHQUE2QixJQUFJLFlBQUEsUUFBSixDQUEwQjtNQUNyRCxXQUFXLFNBQVMsc0JBRGlDO01BRXJELGNBQWMsSUFBSSxhQUZtQztNQUdyRCxXQUFXLElBQUksVUFIc0M7TUFJckQsU0FBUyxJQUFBLGtCQUo0QztNQUtyRCxxQkFBcUIsSUFBQSxvQkFMZ0M7TUFNckQsVUFBVSxJQUFBLFNBTjJDO01BT3JELHlCQUF5QixJQUFBLHdCQUFBLEtBQUEsQ0FBa0MsSUFBbEMsQ0FBQTtLQVBFLENBQTdCLENBQUE7SUFVQSxJQUFBLGlCQUFBLEdBQXdCLElBQUksWUFBQSxpQkFBSixDQUFxQjtNQUMzQywwQkFBMEIsSUFBQSxzQkFBQSxNQUFBLFVBQUEsS0FBQSxDQUN4QixJQUFBLHNCQUFBLE1BRHdCLENBRGlCO01BSTNDLHNCQUFzQixJQUFBLGtCQUFBLE1BQUEsVUFBQSxLQUFBLENBQ3BCLElBQUEsa0JBQUEsTUFEb0IsQ0FKcUI7TUFPM0MsUUFBUTtRQUFFLFVBQVUsSUFBQSxTQUFLO09BUGtCO01BUTNDLE9BQU8sU0FBUyxpQkFBQztLQVJLLENBQXhCLENBQUE7SUFXQSxJQUFBLHlCQUFBLEdBQWdDLElBQUksWUFBQSx5QkFBSixDQUM5QjtNQUNFLDBCQUEyQixZQUN6QixJQUFBLHNCQUFBLE1BQUEsVUFBQSxDQUEyQyxRQUEzQyxDQUZKO01BR0Usc0JBQXVCLE1BQ3JCLElBQUEsa0JBQUEsTUFBQSxVQUFBLENBQXdDLGdCQUFpQjtRQUN2RCxNQUFNLHVCQUF1QixFQUMzQixHQUFHLFlBRHdCO1VBRTNCLFVBQVUsRUFDUixHQUFHLFlBQVksU0FEUDtZQUVSLFNBQVMsQ0FBQSxDQUFBLEVBQUEsd0JBQUEsYUFBQSxFQUFhLFlBQVksU0FBWixRQUFiLENBQUE7V0FGRDtTQUZaLENBQUE7UUFPQSxPQUFPLEVBQUUsQ0FBQyxvQkFBRCxDQUFULENBQUE7T0FSRixDQUFBO0tBTDBCLEVBZ0I5QjtNQUNFLFVBQVUsSUFBQSxTQUFLO0tBakJhLEVBbUI5QixTQUFTLHlCQW5CcUIsQ0FBaEMsQ0FBQTtJQXNCQSxJQUFBLHVCQUFBLEdBQThCLElBQUksWUFBQSx1QkFBSixDQUM1QjtNQUNFLDBCQUNFLElBQUEsc0JBQUEsTUFBQSxVQUFBLEtBQUEsQ0FDRSxJQUFBLHNCQUFBLE1BREYsQ0FGSjtNQUtFLHNCQUFzQixJQUFBLGtCQUFBLE1BQUEsVUFBQSxLQUFBLENBQ3BCLElBQUEsa0JBQUEsTUFEb0IsQ0FMeEI7TUFRRSxvQkFDRSxJQUFBLHlCQUFBLG1CQUFBLEtBQUEsQ0FDRSxJQUFBLHlCQURGLENBVEo7TUFZRSxzQkFDRSxJQUFBLHlCQUFBLHFCQUFBLEtBQUEsQ0FDRSxJQUFBLHlCQURGLENBYko7TUFnQkUsbUJBQW1CLElBQUEseUJBQUEsa0JBQUEsS0FBQSxDQUNqQixJQUFBLHlCQURpQixDQWhCckI7TUFtQkUsa0JBQWtCLElBQUEseUJBQUEsaUJBQUEsS0FBQSxDQUNoQixJQUFBLHlCQURnQixDQW5CcEI7TUFzQkUscUJBQ0UsSUFBQSx5QkFBQSxvQkFBQSxLQUFBLENBQ0UsSUFBQSx5QkFERixDQXZCSjtNQTBCRSxvQkFDRSxJQUFBLHlCQUFBLG1CQUFBLEtBQUEsQ0FDRSxJQUFBLHlCQURGLENBM0JKO01BOEJFLG9CQUFvQixDQUFDOzs7Ozs7T0FBRCxLQUNsQixJQUFBLHNCQUFBLFdBQUEsQ0FBc0M7UUFDcEMsT0FBTyxZQUFBLFlBQUEsVUFENkI7UUFFcEMsVUFBVSxZQUFBLE1BQUEsV0FBQSxPQUYwQjtRQUdwQyxZQUFZO1VBQ1Ysd0JBQXdCLE9BRGQ7VUFFVixjQUFjLE1BRko7VUFHVixZQUFZLFlBQUEsWUFBQSxZQUhGO1VBSVYsZ0JBQWdCLFFBSk47VUFLVixNQUFBO1NBUmtDO1FBVXBDLHFCQUFxQjtVQUNuQixPQUFBO1NBRG1CO09BVnZCLENBQUE7S0FoQ3dCLEVBK0M1QixFQS9DNEIsRUFnRDVCLFNBQVMsdUJBaERtQixDQUE5QixDQUFBO0lBbURBLElBQUEsdUJBQUEsVUFBQSxDQUFzQyxPQUFPLElBQVAsWUFBdEMsQ0FBQSxDQUFBO0lBRUEsT0FBTyxJQUFQLGdCQUFBLEtBQ0csSUFBQSwrQkFBQSxHQUFzQyxJQUFJLFlBQUEsK0JBQUosQ0FDckM7TUFDRSwyQkFBNEIsWUFDMUIsSUFBQSx1QkFBQSxVQUFBLENBQXNDLFFBQXRDLENBRko7TUFHRSwwQkFDRSxJQUFBLHNCQUFBLE1BQUEsVUFBQSxLQUFBLENBQ0UsSUFBQSxzQkFBQSxNQURGLENBSko7TUFPRSxzQkFBc0IsSUFBQSxrQkFBQSxNQUFBLFVBQUEsS0FBQSxDQUNwQixJQUFBLGtCQUFBLE1BRG9CLENBUHhCO01BVUUsa0JBQWtCLE1BQU0sSUFBQSx1QkFBQSxjQVYxQjtNQVdFLHlCQUNFLElBQUEseUJBQUEsd0JBQUEsS0FBQSxDQUNFLElBQUEseUJBREYsQ0FaSjtNQWVFLGdCQUFnQixJQUFBLHVCQUFBLGVBQUEsS0FBQSxDQUNkLElBQUEsdUJBRGMsQ0FmbEI7TUFrQkUsc0JBQXNCLE1BQU0sSUFBQSx1QkFBQSxNQUE0QjtLQW5CckIsQ0FEekMsQ0FBQSxDQUFBO0lBd0JBLElBQUEsc0JBQUEsR0FBNkIsSUFBSSxhQUFBLFFBQUosQ0FBMEI7TUFDckQsU0FBQSxRQUFBLFFBRHFEO01BRXJELGtCQUFrQixJQUFBLHNCQUFBLE1BRm1DO01BR3JELG9CQUFvQixJQUFBLGtCQUFBLEdBQUEsS0FBQSxDQUNsQixJQUFBLGtCQURrQixFQUVsQixTQUFBLGVBQUEsbUJBRmtCLENBSGlDO01BT3JELHNCQUFzQixJQUFBLGtCQUFBLHFCQUFBLEtBQUEsQ0FDcEIsSUFBQSxrQkFEb0IsQ0FQK0I7TUFVckQsbUJBQW1CLElBQUEsa0JBQUEsa0JBQUEsS0FBQSxDQUNqQixJQUFBLGtCQURpQixDQVZrQztNQWFyRCxTQUFTLElBQUEsU0FBQSxXQUFBLEVBYjRDO01BY3JELGFBQWEsT0FBTyxJQUFQLHFCQWR3QztNQWVyRCxXQUFXLElBQUEsVUFmMEM7TUFnQnJELFdBQVcsU0FBUyxzQkFoQmlDO01BaUJyRCxrQkFBQSxRQUFBLGlCQUFBO0tBakIyQixDQUE3QixDQUFBO0lBb0JBLElBQUEsR0FBQSxDQUFRLFFBQVIsRUFBbUIsVUFBVztNQUM1QixJQUFBLHNCQUFBLDBCQUFBLENBQXFELE1BQXJELENBQUEsQ0FBQTtLQURGLENBQUEsQ0FBQTtJQUlBLE1BQU0sa0JBQWtCLElBQUEsb0JBQUEsY0FBQSxDQUF1QztNQUM3RCxNQUFNLGtCQUFBO0tBRGdCLENBQXhCLENBQUE7SUFJQSxNQUFNLGdCQUFnQixPQUFPLElBQVAsbUJBQUEsR0FDbEIsTUFBQSxxQkFEa0IsR0FFbEIsTUFBQSxpQkFGSixDQUFBO0lBSUEsSUFBQSxpQkFBQSxHQUF3QixJQUFJLFlBQUEsaUJBQUosQ0FBcUI7TUFDM0MsVUFBVSxLQURpQztNQUUzQyxXQUFXLGVBRmdDO01BRzNDLFVBQVUsTUFBQSxnQkFIaUM7TUFJM0MsYUFBYSxNQUNYLElBQUEsa0JBQUEsMkJBQUEsRUFBQSxTQUx5QztNQU0zQyxzQkFBc0IsSUFBQSxrQkFBQSxHQUFBLEtBQUEsQ0FDcEIsSUFBQSxrQkFEb0IsRUFFcEIsU0FBQSxlQUFBLG1CQUZvQixDQU5xQjtNQVUzQyx1Q0FDRSxJQUFBLGtCQUFBLHdCQUFBLEtBQUEsQ0FDRSxJQUFBLGtCQURGLENBWHlDO01BYzNDLHVDQUNFLElBQUEsc0NBQUEsS0FBQSxDQUFnRCxJQUFoRCxDQWZ5QztNQWdCM0MsbUJBQW9CLENBQUEsRUFBRSxhQUFjLENBQUEsOEJBQUEsQ0FoQk87TUFpQjNDLG9CQUFxQixDQUFBLEVBQUUsYUFBYyxDQUFBLHFDQUFBLENBakJNO01Ba0IzQyw0Q0FBNEMsTUFBTTtRQUNoRCxNQUFNLFVBQVUsSUFBQSxrQkFBQSxrQkFBQSxFQUFoQixDQUFBO1FBQ0EsT0FBTyxPQUFPLElBQVAsUUFBQSxJQUF1QixPQUFPLEtBQUssUUFBQSxVQUFBLFFBQTFDLENBQUE7T0FwQnlDO01Bc0IzQyxZQUFZLE1BQU07UUFDaEIsT0FBTyxPQUFPLElBQVAsUUFBQSxHQUNILFFBQUEsVUFBQSxRQURHLEdBRUgsSUFBQSxrQkFBQSxrQkFBQSxFQUZKLENBQUE7T0FHRDtLQTFCcUIsQ0FBeEIsQ0FBQTtJQTZCQSxJQUFBLGtCQUFBLEdBQXlCLElBQUkseUJBQUEsZ0JBQUosRUFBekIsQ0FBQTtJQUVBLElBQUEsbUJBQUEsR0FBMEIsSUFBSSxTQUFBLFFBQUosQ0FBdUI7TUFDL0MsbUJBQW1CLElBQUEsR0FBQSxLQUFBLENBQWEsSUFBYixFQUFtQixRQUFuQixDQUQ0QjtNQUUvQyxZQUFZLElBQUEsV0FBQSxLQUFBLENBQXFCLElBQXJCLENBRm1DO01BRy9DLFdBQVcsU0FBUyxtQkFIMkI7TUFJL0MsbUJBQW1CLE1BQU0sSUFBQSxVQUFBLEVBSnNCO01BSy9DLG1CQUFtQixJQUFJLHFCQUx3QjtNQU0vQyxrQkFBa0IsSUFBQSxzQkFBQSxNQU42QjtNQU8vQyxpQkFBaUIsSUFBQSxrQkFBQSxZQUFBLEVBQUE7S0FQTyxDQUExQixDQUFBO0lBVUEsTUFBTSx3QkFBd0IsSUFBQSxvQkFBQSxjQUFBLENBQXVDO01BQ25FLE1BQU0sd0JBQUE7S0FEc0IsQ0FBOUIsQ0FBQTtJQUdBLElBQUEsdUJBQUEsR0FBOEIsSUFBSSxZQUFBLHVCQUFKLENBQTJCO01BQ3ZELGdCQUFnQixJQUR1QztNQUV2RCxXQUFXLHFCQUY0QztNQUd2RCxPQUFPLEVBQ0wsR0FBRyxTQUFTLG1CQURQO1FBRUwsZ0JBQWdCLElBQUEsa0JBQUEsY0FBQSxTQUFBLEVBQUEsT0FBZ0Q7T0FGM0Q7S0FIcUIsQ0FBOUIsQ0FBQTtJQVNBLElBQUEsbUJBQUEsR0FBMEIsSUFBSSxZQUFBLG1CQUFKLEVBQTFCLENBQUE7SUFDQSxJQUFBLG1CQUFBLG9CQUFBLEVBQUEsQ0FBQTs7SUFDQSxJQUFJLE9BQU8sSUFBUCxRQUFKLEVBQXlCO01BQ3ZCLElBQUEsbUJBQUEsbUJBQUEsQ0FBMkMsQ0FBQSxHQUFJLEtBQUEsT0FBL0MsQ0FBQSxDQUFBO0tBQ0Q7O0lBRUQsSUFBQSx1QkFBQSxHQUE4QixJQUFJLFlBQUEsdUJBQUosQ0FDNUI7TUFBRSxrQkFBa0IsY0FBQSxpQkFBQTtLQURRLEVBRTVCLFNBQVMsdUJBRm1CLENBQTlCLENBalRnQjs7SUF1VGhCLElBQUEscUJBQUEsR0FBNEIsSUFBSSxZQUFBLHFCQUFKLENBQXlCO01BQ25ELHFCQUFzQixZQUNwQixJQUFBLGlCQUFBLFVBQUEsQ0FBZ0MsUUFBaEMsQ0FGaUQ7TUFHbkQsMkJBQTRCLFlBQzFCLElBQUEsb0JBQUEsVUFBQSxDQUNHLENBQUEsRUFBRSxJQUFBLHVCQUFBLEtBQWlDLENBQUEsWUFBQSxDQUR0QyxFQUVFLFFBRkYsQ0FKaUQ7TUFRbkQsc0JBQXVCLE1BQ3JCLElBQUEsa0JBQUEsTUFBQSxVQUFBLENBQXdDLGdCQUFpQjtRQUN2RCxNQUFNLHVCQUF1QixFQUMzQixHQUFHLFlBRHdCO1VBRTNCLFVBQVUsRUFDUixHQUFHLFlBQVksU0FEUDtZQUVSLFNBQVMsQ0FBQSxDQUFBLEVBQUEsd0JBQUEsYUFBQSxFQUFhLFlBQVksU0FBWixRQUFiLENBQUE7V0FGRDtTQUZaLENBQUE7UUFPQSxPQUFPLEVBQUUsQ0FBQyxvQkFBRCxDQUFULENBQUE7T0FSRixDQUFBO0tBVHdCLENBQTVCLENBQUE7SUFxQkEsSUFBQSxjQUFBLEdBQXFCLElBQUksSUFBQSxRQUFKLENBQWtCO01BQ3JDLFVBQVUsSUFBQSxTQUQyQjtNQUVyQyxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBRmtCO01BS3JDLG9CQUFvQixJQUFBLGtCQUFBLEdBQUEsS0FBQSxDQUNsQixJQUFBLGtCQURrQixFQUVsQixTQUFBLGVBQUEsbUJBRmtCLENBQUE7S0FMRCxDQUFyQixDQUFBO0lBV0EsSUFBQSwrQkFBQSxHQUFzQyxJQUFJLHFCQUFBLFFBQUosQ0FBbUM7TUFDdkUsY0FBYyxJQUFBLGFBRHlEO01BRXZFLG9CQUFvQixJQUFBLGtCQUFBLEdBQUEsS0FBQSxDQUNsQixJQUFBLGtCQURrQixFQUVsQixTQUFBLGVBQUEsbUJBRmtCLENBRm1EO01BTXZFLG1CQUFtQixJQUFBLGtCQUFBLGtCQUFBLEtBQUEsQ0FDakIsSUFBQSxrQkFEaUIsQ0FOb0Q7TUFTdkUsdUJBQXVCLElBQUEsc0JBVGdEO01BVXZFLFdBQVcsU0FBUywrQkFBQztLQVZlLENBQXRDLENBdlZnQjs7SUFxV2hCLElBQUEsZUFBQSxHQUFzQixJQUFJLGVBQUEsUUFBSixDQUFtQjtNQUN2QyxVQUFVLElBQUEsU0FENkI7TUFFdkMsY0FBYyxJQUFBLGFBRnlCO01BR3ZDLG1CQUFtQixJQUFBLGtCQUFBLGtCQUFBLEtBQUEsQ0FDakIsSUFBQSxrQkFEaUIsQ0FIb0I7TUFNdkMsc0JBQXNCLElBQUEsa0JBQUEscUJBQUEsS0FBQSxDQUNwQixJQUFBLGtCQURvQixDQUFBO0tBTkYsQ0FBdEIsQ0FyV2dCOztJQWlYaEIsSUFBQSxHQUFBLENBQVEsNkJBQVIsRUFBd0MsK0JBQWdDO01BQ3RFLElBQUksMkJBQTJCLEdBQUcsQ0FBbEMsRUFBcUM7UUFDbkMsSUFBQSxlQUFBLE1BQUEsRUFBQSxDQUFBO1FBQ0EsSUFBQSwrQkFBQSxNQUFBLEVBQUEsQ0FBQTtRQUNBLElBQUEsdUJBQUEsTUFBQSxFQUFBLENBQUE7O1FBQ0EsSUFBSSxJQUFBLHNCQUFBLE1BQUEsU0FBQSxFQUFBLGtCQUFKLEVBQW1FO1VBQ2pFLElBQUEsb0JBQUEsTUFBQSxFQUFBLENBQUE7U0FDRDtPQU5ILE1BT087UUFDTCxJQUFBLGVBQUEsS0FBQSxFQUFBLENBQUE7UUFDQSxJQUFBLCtCQUFBLEtBQUEsRUFBQSxDQUFBO1FBQ0EsSUFBQSx1QkFBQSxLQUFBLEVBQUEsQ0FBQTs7UUFDQSxJQUFJLElBQUEsc0JBQUEsTUFBQSxTQUFBLEVBQUEsa0JBQUosRUFBbUU7VUFDakUsSUFBQSxvQkFBQSxLQUFBLEVBQUEsQ0FBQTtTQUNEO09BQ0Y7S0FmSCxDQUFBLENBQUE7SUFrQkEsSUFBQSx5QkFBQSxHQUFnQyxJQUFJLGVBQUEsUUFBSixDQUE2QjtNQUMzRCxnQkFBZ0IsSUFBQSxlQUQyQztNQUUzRCxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBRndDO01BSzNELFdBQVcsU0FBUyx5QkFBQztLQUxTLENBQWhDLENBQUE7SUFRQSxJQUFBLHFCQUFBLEdBQTRCLElBQUksV0FBQSxRQUFKLENBQXlCO01BQ25ELFdBQVcsU0FBUyxxQkFBQztLQURLLENBQTVCLENBQUE7SUFJQSxJQUFBLGlCQUFBLElBQUEsR0FBQSxDQUE2Qix1QkFBN0IsRUFBc0QsWUFBWTtNQUNoRSxNQUFNLElBQUksVUFBSixFQUFOLENBQUE7S0FERixDQUFBLENBQUE7SUFJQSxNQUFNLHFCQUFxQixDQUN6QixpQkFBQSxRQUR5QixFQUV6Qix1QkFBQSxRQUZ5QixFQUd6QixrQkFBQSxRQUh5QixFQUl6Qix5QkFBQSxnQkFKeUIsQ0FBM0IsQ0FBQTtJQU1BLElBQUEsa0JBQUEsR0FBeUIsSUFBSSxxQkFBQSxRQUFKLENBQXNCO01BQzdDLGNBQWMsa0JBRCtCO01BRTdDLFdBQVcsU0FBUyxrQkFGeUI7TUFHN0MsV0FBVyxJQUFJLFVBQUosSUFBa0IsU0FBQTtLQUhOLENBQXpCLENBQUE7SUFLQSxJQUFBLGtCQUFBLFNBQUEsVUFBQSxDQUEyQyxTQUN6QyxJQUFBLDJCQUFBLENBQWdDLEtBQWhDLENBREYsQ0FBQSxDQUFBO0lBR0EsSUFBQSxrQkFBQSxHQUFBLENBQTBCLFFBQTFCLEVBQW9DLE1BQU0sSUFBQSxVQUFBLEVBQTFDLENBQUEsQ0FBQTtJQUNBLElBQUEsa0JBQUEsR0FBQSxDQUEwQixNQUExQixFQUFrQyxNQUFNLElBQUEsUUFBQSxFQUF4QyxDQUFBLENBQUE7O0lBRUEsTUFBTSxnQkFBZ0IsTUFDcEIsSUFBQSxzQkFBQSxNQUFBLFNBQUEsRUFBQSxXQURGLENBQUE7O0lBR0EsSUFBQSxxQkFBQSxHQUE0QixJQUFJLFlBQUEscUJBQUosQ0FBeUI7TUFDbkQsV0FBVyxJQUFBLG9CQUFBLGNBQUEsQ0FBdUM7UUFDaEQsTUFBTSxzQkFEMEM7UUFFaEQsZ0JBQWdCLENBQ2IsQ0FBQSxFQUFFLElBQUEsbUJBQUEsS0FBNkIsQ0FBQSxXQUFBLENBRGxCLEVBRWIsQ0FBQSxFQUFFLElBQUEsbUJBQUEsS0FBNkIsQ0FBQSxXQUFBLENBRmxCLEVBR2IsQ0FBQSxFQUFFLElBQUEsbUJBQUEsS0FBNkIsQ0FBQSxjQUFBLENBSGxCLEVBSWIsQ0FBQSxFQUFFLElBQUEsbUJBQUEsS0FBNkIsQ0FBQSxjQUFBLENBSmxCLENBQUE7T0FGUCxDQUR3QztNQVVuRCxPQUFPLFNBQVMscUJBVm1DO01BV25ELHNCQUFzQixDQUFBLENBQUEsRUFBQSxhQUFBLHdCQUFBLEVBQXdCO1FBQUUsYUFBQTtPQUExQixDQVg2QjtNQVluRCwwQkFBMEIsRUFDeEIsR0FBRyxDQUFBLENBQUEsRUFBQSxhQUFBLDRCQUFBLEVBQTRCO1VBQzdCLGFBRDZCO1VBRTdCLGdCQUFnQixJQUFBLGtCQUFBLFlBQUEsS0FBQSxDQUNkLElBQUEsa0JBRGMsQ0FGYTtVQUs3QiwwQ0FBMEMsQ0FDeEMsYUFBYSxFQUQyQixFQUV4QyxXQUFXLEVBRjZCLEtBR3JDO1lBQ0gsTUFBTSw0QkFBNEIsUUFBUSxPQUFSLENBQy9CLFdBQVksQ0FBQyxVQUFVLENBQUMsT0FBRCxDQURRLENBQWxDLENBQUE7WUFHQSxNQUFNLG9DQUNKLHlCQUF5QixJQUF6QixDQUNHLFdBQUQ7Y0FBQSxJQUFBLHFCQUFBLENBQUE7O2NBQUEsT0FBQSxDQUFBLHdCQUNFLElBQUEsa0JBQUEscUJBQUEsQ0FBNEMsT0FBNUMsQ0FERixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUNFLHFCQUFBLEtBREYsQ0FBQTthQURGLENBREYsQ0FBQTtZQU1BLE1BQU0sa0JBQWtCLE1BQU0sS0FBTixDQUFZLFVBQVUsSUFBSSxFQUExQixDQUFBLE9BQXhCLENBQUE7WUFFQSxNQUFNLHNCQUFzQixNQUFNLEtBQU4sQ0FDMUIsSUFBQSxlQUFBLE1BQUEsU0FBQSxFQUFBLFNBQUEsSUFBaUQsRUFEdkIsQ0FBQSxPQUE1QixDQUFBO1lBSUEsQ0FBQSxDQUFBLEVBQUEsUUFBQSxpQkFBQSxFQUNFLElBQUksS0FBSixDQUNHLENBQUEsbUVBQUEsRUFBcUUsUUFBUSxPQUFRLENBQUEsZUFBQSxFQUFpQixlQUFnQixDQUFBLHFCQUFBLEVBQXVCLGlDQUFrQyxDQUFBLDBFQUFBLEVBQTRFLG1CQUFvQixDQUFBLGlDQUFBLENBRGxSLENBREYsQ0FBQSxDQUFBO1dBS0Q7U0E3QkEsQ0FBQTtPQWI4QztNQTZDbkQscUJBQUEsYUFBQSxvQkFBQTtLQTdDMEIsQ0FBNUIsQ0FBQTtJQWdEQSxJQUFBLHdCQUFBLEdBQStCLElBQUksYUFBQSx3QkFBSixDQUE0QjtNQUN6RCxtQkFBbUIsSUFBSSxHQUFKLENBQVEsTUFBTSxLQUFOLENBQVksWUFBQSxrQkFBWixDQUFSLENBRHNDO01BRXpELFdBQVcsU0FBUyx3QkFBQztLQUZRLENBQS9CLENBQUE7SUFLQSxJQUFBLDBCQUFBLEdBQWlDLElBQUksWUFBQSwwQkFBSixDQUE4QjtNQUM3RCxXQUFXLElBQUEsb0JBQUEsY0FBQSxDQUF1QztRQUNoRCxNQUFNLDJCQUQwQztRQUVoRCxnQkFBZ0IsQ0FBRSxDQUFBLEVBQUUsSUFBQSxxQkFBQSxLQUErQixDQUFBLGVBQUEsQ0FBbkMsQ0FBQTtPQUZQLENBRGtEO01BSzdELE9BQU8sU0FBUywwQkFMNkM7TUFNN0QsbUJBQW1CLEdBQUE7S0FOWSxDQUFqQyxDQUFBO0lBU0EsSUFBQSx1QkFBQSxHQUE4QixJQUFJLGFBQUEsUUFBSixDQUEyQjtNQUN2RCxhQUFhLElBQUEsc0JBRDBDO01BRXZELGtCQUFrQixJQUFBLGlCQUZxQztNQUd2RCwwQkFBMEIsSUFBQSx5QkFINkI7TUFJdkQsU0FBUyxJQUFBLGtCQUo4QztNQUt2RCxpQkFBaUIsSUFBQSxrQkFBQSxTQUxzQztNQU12RCxXQUFXLElBQUEsb0JBTjRDO01BT3ZELHVCQUF1QixJQUFBLHNCQUFBLFdBQUEsS0FBQSxDQUNyQixJQUFBLHNCQURxQixDQUFBO0tBUEssQ0FBOUIsQ0FBQTtJQVlBLElBQUEsc0JBQUEsR0FBNkIsSUFBSSxZQUFBLHNCQUFKLENBQzNCLFNBRDJCLEVBRTNCLFNBQVMsc0JBRmtCLENBQTdCLENBQUE7SUFLQSxJQUFBLGdCQUFBLEdBQXVCLElBQUksTUFBQSxRQUFKLENBQW9CO01BQ3pDLFdBQVcsU0FBUyxnQkFEcUI7TUFFekMsa0JBQWtCLElBQUEsc0JBQUEsTUFBMkI7S0FGeEIsQ0FBdkIsQ0FBQTtJQUtBLElBQUEsaUJBQUEsR0FBd0IsSUFBSSxPQUFBLFFBQUosQ0FBcUI7TUFDM0MsdUJBQXVCLElBQUEsc0JBRG9CO01BRTNDLHVCQUF1QixJQUFBLHNCQUZvQjtNQUczQyx1QkFBdUIsSUFBQSxzQkFBQSxXQUFBLEtBQUEsQ0FDckIsSUFBQSxzQkFEcUIsQ0FBQTtLQUhELENBQXhCLENBQUE7SUFRQSxJQUFBLGFBQUEsR0FBb0IsSUFBSSxhQUFBLFFBQUosQ0FBMEI7TUFDNUMsV0FDRSxTQUFTLHNCQUFULElBQW1DLFNBQVMsbUJBRkY7TUFHNUMsc0JBQXNCLElBQUEscUJBQUEsS0FBQSxDQUErQixJQUEvQixDQUhzQjtNQUk1QyxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBSnlCO01BTzVDLHVDQUNFLElBQUEsa0JBQUEsd0JBQUEsS0FBQSxDQUNFLElBQUEsa0JBREYsQ0FSMEM7TUFXNUMsdUNBQ0UsSUFBQSxzQ0FBQSxLQUFBLENBQWdELElBQWhELENBWjBDO01BYTVDLGNBQWMsSUFBQSxrQkFBQSxhQWI4QjtNQWM1QyxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBZHlCO01BaUI1QyxrQkFBa0IsSUFBQSxzQkFBQSxNQWpCMEI7TUFrQjVDLGdCQUFnQixFQWxCNEI7TUFtQjVDLGlCQUFpQixJQUFBLGtCQUFBLGdCQUFBLEtBQUEsQ0FDZixJQUFBLGtCQURlLENBbkIyQjtNQXNCNUMsVUFBVSxJQUFBLFNBdEJrQztNQXVCNUMsY0FBYyxJQUFBLGFBdkI4QjtNQXdCNUMscUJBQXFCLElBQUEsc0JBQUEsb0JBQUEsS0FBQSxDQUNuQixJQUFBLHNCQURtQixDQXhCdUI7TUEyQjVDLHFCQUFxQixJQUFBLHNCQUFBLG9CQUFBLEtBQUEsQ0FDbkIsSUFBQSxzQkFEbUIsQ0EzQnVCO01BOEI1Qyx1QkFDRSxJQUFBLHNCQUFBLHNCQUFBLEtBQUEsQ0FDRSxJQUFBLHNCQURGLENBL0IwQztNQWtDNUMsc0JBQ0UsSUFBQSxzQkFBQSxxQkFBQSxLQUFBLENBQ0UsSUFBQSxzQkFERixDQW5DMEM7TUFzQzVDLHVCQUF1QixJQUFBLHNCQUFBLFdBQUEsS0FBQSxDQUNyQixJQUFBLHNCQURxQixDQXRDcUI7TUF5QzVDLHlCQUF5QixNQUN2QixJQUFBLHNCQUFBLE1BQUEseUJBMUMwQztNQTJDNUMsMkJBQ0UsSUFBQSxpQkFBQSxxQkFBQSxLQUFBLENBQWdELElBQUEsaUJBQWhELENBNUMwQztNQTZDNUMsZ0NBQ0UsSUFBQSwrQkFBQSxLQUFBLENBQXlDLElBQXpDLENBOUMwQztNQStDNUMsZ0JBQWdCLElBQUEsZUFBQSxLQUFBLENBQXlCLElBQXpCLENBL0M0QjtNQWdENUMsZ0JBQWdCLElBQUEsZUFBQSxLQUFBLENBQXlCLElBQXpCLENBaEQ0QjtNQWlENUMsNEJBQ0UsSUFBQSx5QkFBQSwyQkFBQSxLQUFBLENBQ0UsSUFBQSx5QkFERixDQUFBO0tBbERnQixDQUFwQixDQUFBO0lBc0RBLElBQUEsYUFBQSxHQUFBLENBQXFCLGlCQUFyQixFQUF3QyxNQUFNLElBQUkscUJBQUosRUFBOUMsQ0FBQSxDQUFBO0lBRUEsSUFBQSxhQUFBLEdBQUEsQ0FBc0IsQ0FBQSxnQkFBQSxDQUF0QixFQUF5Qyx3QkFBd0I7TUFDL0QsSUFDRSxNQUFNLEtBQUssWUFBQSxxQkFBQSxVQUFYLElBQ0EsTUFBTSxLQUFLLFlBQUEscUJBQUEsT0FGYixFQUdFO1FBQ0EsTUFBTSxTQUFTLElBQUEsYUFBQSxlQUFBLGVBQUEsQ0FBZ0QsSUFBaEQsQ0FBZixDQUFBO1FBQ0EsTUFBTSx3QkFDSixJQUFBLHNCQUFBLHlCQUFBLEVBREYsQ0FBQTtRQUVBLElBQUksV0FBVyxFQUFmLENBQUE7O1FBQ0EsSUFBSSxNQUFNLFFBQVYsRUFBb0I7VUFBQSxJQUFBLHFCQUFBLENBQUE7O1VBQ2xCLE1BQU0sY0FBYyxxQkFBcUIsS0FBckIsQ0FDakIsT0FBUSxNQUFNLFFBQU4sS0FBbUIsR0FBRyxRQURiLENBQXBCLENBQUE7VUFHQSxXQUFRLENBQUEsd0JBQUcsV0FBSCxLQUFBLElBQUEsSUFBRyxXQUFILEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUcsV0FBVyxTQUFkLE1BQUEsSUFBQSxJQUFBLHFCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEscUJBQUEsR0FBNEIsRUFBcEMsQ0FBQTtTQUNEOztRQUNELElBQUEsU0FBQSw0QkFBQSxDQUEwQyxNQUExQyxFQUFrRCxRQUFsRCxDQUFBLENBQUE7UUFFQSxNQUFNOztTQUFBLEdBQWdCLE1BQXRCLENBYkE7OztRQWlCQSxJQUNFLE1BQU0sS0FBTixLQUFnQixZQUFBLGtCQUFBLDJCQUFoQixJQUNBLE1BQU0sU0FBTixLQUFvQixTQUZ0QixFQUdFO1VBQUEsSUFBQSxnQkFBQSxFQUFBLHFCQUFBLENBQUE7O1VBQ0EsTUFBTTs7OztXQUFBLEdBSUYsTUFBTSxTQUpWLENBQUE7VUFLQSxNQUFNOztXQUFBLEdBQWMsTUFBcEIsQ0FBQTtVQUNBLE1BQU0sa0JBQWtCLENBQUEsQ0FBQSxFQUFBLGFBQUEsa0NBQUEsRUFBa0MsSUFBbEMsQ0FBeEIsQ0FQQTs7OztVQVdBLE1BQU0seUJBQXNCLENBQUEsbUJBQzFCLENBQUEsQ0FBQSxFQUFBLFVBQUEsZ0JBQUEsRUFBZ0IsZUFBaEIsQ0FEMEIsTUFBQSxJQUFBLElBQUEsZ0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxnQkFBQSxHQUUxQixDQUFBLENBQUEsRUFBQSx3QkFBQSxtQkFBQSxFQUFtQixlQUFuQixDQUZGLENBQUE7VUFHQSxNQUFNOztXQUFBLEdBQXNCLElBQUEsdUJBQUEsTUFBNUIsQ0FkQTs7VUFpQkEsTUFBTSxtQkFBbUIsZUFBSCxLQUFBLElBQUEsSUFBRyxlQUFILEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSx3QkFBRyxlQUFlLENBQUcsV0FBSCxDQUFsQixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFHLHFCQUFBLENBQ3ZCLE9BRHVCLENBQUEsS0FBQSxDQUd2QixDQUFDOzs7V0FBRCxLQUNFLENBQUEsQ0FBQSxFQUFBLFlBQUEsdUJBQUEsRUFBdUIsT0FBdkIsRUFBZ0MsZUFBaEMsQ0FBQSxJQUNBLE9BQU8sS0FBSyxzQkFMUyxDQUF6QixDQWpCQTs7VUEwQkEsSUFBSSxnQkFBSixFQUFzQjtZQUNwQixJQUFBLHVCQUFBLCtDQUFBLENBQ0UsZ0JBREYsRUFFRSxLQUZGLEVBR0U7Y0FBRSxXQUFGO2NBQWUsT0FBQTthQUhqQixDQUFBLENBQUE7V0FLRDtTQUNGOztRQUVELE1BQU0sZ0JBQWdCLE1BQU0sSUFBQSxTQUFBLEVBQTVCLENBQUE7O1FBRUEsSUFBSSxTQUFTLElBQUksU0FBUyxPQUFULEtBQXFCLEtBQXRDLEVBQTZDO1VBQUEsSUFBQSxxQkFBQSxDQUFBOztVQUMzQyxJQUFBLHNCQUFBLFdBQUEsQ0FDRTtZQUNFLE9BQU8sb0NBRFQ7WUFFRSxVQUFVLFlBQUEsTUFBQSxXQUFBLFdBRlo7WUFHRSxZQUFZO2NBQ1YsUUFBUSxjQURFO2NBRVYsY0FBWSxDQUFBLHdCQUFFLE1BQU0sZ0JBQVIsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBRSxxQkFBQSxPQUZKO2NBR1YsZ0JBQWdCLGFBQWEsT0FBYixPQUhOO2NBSVYsa0JBQWtCLE1BQU0sS0FBTixDQUFZLGFBQWEsU0FBekIsQ0FBQSxPQUFvQzthQUo1QztXQUpoQixFQVdFO1lBQ0UsYUFBYSxJQUFBO1dBWmpCLENBQUEsQ0FBQTtTQWVEO09BQ0Y7S0E5RUgsQ0FBQSxDQUFBO0lBaUZBLElBQUEsa0JBQUEsR0FBQSxDQUEwQixTQUFBLGVBQUEsbUJBQTFCLEVBQTZELFlBQVk7TUFDdkUsTUFBTTs7T0FBQSxHQUFhLElBQUEsa0JBQUEsa0JBQUEsRUFBbkIsQ0FBQTs7TUFDQSxJQUFJO1FBQ0YsTUFBTSxJQUFBLHVCQUFBLGtCQUFBLENBQThDLE1BQTlDLENBQU4sQ0FBQTtPQURGLENBRUUsY0FBYzs7UUFFZCxPQUFPLE1BQVAsQ0FBYyxLQUFkLENBQUEsQ0FBQTtPQUNEO0tBUEgsQ0FBQSxDQUFBO0lBVUEsSUFBQSxrQkFBQSxjQUFBLEVBQUEsQ0FBQTtJQUNBLElBQUEsZUFBQSxHQUFzQixJQUFJLGVBQUEsUUFBSixDQUFtQjtNQUN2QyxjQUFjLElBQUEsc0JBQUEsV0FBQSxLQUFBLENBQ1osSUFBQSxzQkFEWSxDQUFBO0tBRE0sQ0FBdEIsQ0FBQTtJQUtBLElBQUEsdUJBQUEsR0FBOEIsSUFBSSx1QkFBQSxRQUFKLENBQTJCO01BQ3ZELGNBQWMsSUFBQSxzQkFBQSxXQUFBLEtBQUEsQ0FDWixJQUFBLHNCQURZLENBQUE7S0FEYyxDQUE5QixDQUFBO0lBS0EsSUFBQSxzQkFBQSxHQUE2QixJQUFJLHNCQUFBLFFBQUosQ0FBMEI7TUFDckQsY0FBYyxJQUFBLHNCQUFBLFdBQUEsS0FBQSxDQUNaLElBQUEsc0JBRFksQ0FBQTtLQURhLENBQTdCLENBQUE7SUFLQSxJQUFBLDJCQUFBLEdBQWtDLElBQUksMkJBQUEsUUFBSixDQUErQjtNQUMvRCxjQUFjLElBQUEsc0JBQUEsV0FBQSxLQUFBLENBQ1osSUFBQSxzQkFEWSxDQUFBO0tBRGtCLENBQWxDLENBQUE7SUFLQSxJQUFBLG9CQUFBLEdBQTJCLElBQUksb0JBQUEsUUFBSixDQUF3QjtNQUNqRCxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBRDhCO01BSWpELGNBQWMsSUFBQSxzQkFBQSxXQUFBLEtBQUEsQ0FDWixJQUFBLHNCQURZLENBQUE7S0FKVyxDQUEzQixDQUFBO0lBU0EsSUFBQSxnQkFBQSxHQUF1QixJQUFJLE9BQUEsUUFBSixDQUFvQjtNQUN6QyxxQkFBcUIsSUFBQSxhQUFBLFVBQUEsb0JBQUEsS0FBQSxDQUNuQixJQUFBLGFBQUEsVUFEbUIsQ0FEb0I7TUFJekMsbUJBQW1CLElBQUEsa0JBSnNCO01BS3pDLFVBQVUsSUFBQSxTQUwrQjtNQU16QyxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBTnNCO01BU3pDLG9CQUFvQixNQUFNLElBQUEscUJBQUEsTUFUZTtNQVV6QyxtQkFBbUIsSUFBQSxrQkFBQSxrQkFBQSxLQUFBLENBQ2pCLElBQUEsa0JBRGlCLENBVnNCO01BYXpDLDJCQUNFLElBQUEsaUJBQUEscUJBQUEsS0FBQSxDQUFnRCxJQUFBLGlCQUFoRCxDQUFBO0tBZG1CLENBQXZCLENBQUE7SUFnQkEsSUFBQSw0QkFBQSxHQUFtQyxJQUFJLDRCQUFBLFFBQUosQ0FDakM7TUFDRSxzQkFBc0IsSUFBQSxrQkFBQSxNQUFBLFVBQUEsS0FBQSxDQUNwQixJQUFBLGtCQUFBLE1BRG9CLENBRHhCO01BSUUsWUFBWSxJQUFBLGtCQUFBLGdCQUFBLEtBQUEsQ0FDVixJQUFBLGtCQURVLENBSmQ7TUFPRSxjQUFjLElBQUEsYUFBQSxhQUFBLGFBQUEsS0FBQSxDQUNaLElBQUEsYUFBQSxhQURZLENBUGhCO01BVUUsNEJBQ0UsSUFBQSxhQUFBLDJCQUFBLEtBQUEsQ0FBa0QsSUFBQSxhQUFsRCxDQVhKO01BWUUsVUFBVSxJQUFBLFNBWlo7TUFhRSx1QkFBdUIsSUFBQSxzQkFBQSxXQUFBLEtBQUEsQ0FDckIsSUFBQSxzQkFEcUIsQ0FBQTtLQWRRLEVBa0JqQztNQUNFLG1CQUFtQixDQUFDLFFBQUEsVUFBQSxRQUFELEVBQW9CLFFBQUEsVUFBQSxPQUFwQixDQUFBO0tBbkJZLEVBcUJqQyxTQUFTLDRCQXJCd0IsQ0FBbkMsQ0Fwc0JnQjs7SUE2dEJoQixJQUFBLGtCQUFBLEdBQUEsQ0FBMEIsU0FBQSxlQUFBLG1CQUExQixFQUE2RCxNQUFNO01BQ2pFLElBQUEsZUFBQSxnQkFBQSxFQUFBLENBQUE7S0FERixDQUFBLENBN3RCZ0I7O0lBa3VCaEIsSUFBQSxrQkFBQSxHQUFBLENBQTBCLFNBQUEsZUFBQSxvQkFBMUIsRUFBOEQsTUFBTTtNQUNsRSxJQUFBLGFBQUEsZUFBQSxtQkFBQSxFQUFBLENBQUE7TUFDQSxJQUFBLDJCQUFBLGdCQUFBLEVBQUEsQ0FBQTtNQUNBLElBQUEsdUJBQUEsZ0JBQUEsRUFBQSxDQUFBO01BQ0EsSUFBQSxvQkFBQSxnQkFBQSxFQUFBLENBQUE7TUFDQSxJQUFBLHNCQUFBLGdCQUFBLEVBQUEsQ0FBQTtNQUNBLElBQUEsZUFBQSxnQkFBQSxFQUFBLENBQUE7S0FORixDQUFBLENBbHVCZ0I7O0lBNHVCaEIsSUFBQSxHQUFBLENBQVEsUUFBUixFQUFtQixZQUFhLElBQUEsZUFBQSxDQUFvQixRQUFwQixDQUFoQyxDQUFBLENBQUE7SUFFQSxJQUFBLE1BQUEsZ0JBQUEsQ0FBMkI7TUFDekIsb0JBQW9CLElBQUEsbUJBQUEsTUFESztNQUV6Qix1QkFBdUIsSUFBQSxhQUFBLE1BRkU7TUFHekIsbUJBQW1CLElBQUEsa0JBQUEsTUFITTtNQUl6Qix1QkFBdUIsSUFBQSxzQkFBQSxNQUpFO01BS3pCLHVCQUF1QixJQUFBLHNCQUFBLE1BTEU7TUFNekIsdUJBQXVCLElBQUEsc0JBTkU7TUFPekIsb0JBQW9CLElBQUEsdUJBUEs7TUFRekIsbUJBQW1CLElBQUEsa0JBQUEsTUFSTTtNQVN6QiwwQkFBMEIsSUFBQSx5QkFBQSxNQVREO01BVXpCLGlCQUFpQixJQUFBLGdCQUFBLE1BVlE7TUFXekIsc0JBQXNCLElBQUEscUJBQUEsTUFYRztNQVl6QixnQ0FBZ0MsSUFBQSwrQkFBQSxNQVpQO01BYXpCLHNCQUFzQixJQUFBLHFCQWJHO01BY3pCLHlCQUF5QixJQUFBLHdCQUFBLE1BZEE7TUFlekIsMkJBQTJCLElBQUEsMEJBZkY7TUFnQnpCLGtCQUFrQixJQUFBLGlCQWhCTztNQWlCekIsd0JBQXdCLElBQUEsdUJBakJDO01Ba0J6QixrQkFBa0IsSUFBQSxpQkFsQk87TUFtQnpCLHFCQUFxQixJQUFBLG9CQW5CSTtNQW9CekIsa0JBQWtCLElBQUEsaUJBcEJPO01BcUJ6Qiw2QkFBNkIsSUFBQSw0QkFyQko7TUFzQnpCLHdCQUF3QixJQUFBLHVCQUFLO0tBdEIvQixDQUFBLENBQUE7SUF5QkEsSUFBQSxTQUFBLEdBQWdCLElBQUksMEJBQUEsUUFBSixDQUE4QjtNQUM1QyxRQUFRO1FBQ04sb0JBQW9CLElBQUEsbUJBQUEsTUFEZDtRQUVOLG1CQUFtQixJQUFBLGtCQUFBLE1BRmI7UUFHTixnQkFBZ0IsSUFBQSxlQUFBLE1BSFY7UUFJTixjQUFjLElBQUEsYUFBQSxTQUpSO1FBS04sMEJBQTBCLElBQUEseUJBQUEsTUFMcEI7UUFNTixzQkFBc0IsSUFBQSxxQkFOaEI7UUFPTixnQkFBZ0IsSUFBQSxlQUFBLFNBUFY7UUFRTix3QkFBd0IsSUFBQSx1QkFBQSxTQVJsQjtRQVNOLHVCQUF1QixJQUFBLHNCQUFBLFNBVGpCO1FBVU4sNEJBQTRCLElBQUEsMkJBQUEsU0FWdEI7UUFXTixxQkFBcUIsSUFBQSxvQkFBQSxTQVhmO1FBWU4sbUJBQW1CLElBQUEsa0JBQUEsU0FaYjtRQWFOLHVCQUF1QixJQUFBLHNCQUFBLE1BYmpCO1FBY04sdUJBQXVCLElBQUEsc0JBQUEsTUFkakI7UUFlTix1QkFBdUIsSUFBQSxzQkFmakI7UUFnQk4sb0JBQW9CLElBQUEsdUJBaEJkO1FBaUJOLGlCQUFpQixJQUFBLGdCQUFBLE1BakJYO1FBa0JOLHNCQUFzQixJQUFBLHFCQUFBLE1BbEJoQjtRQW1CTixnQ0FDRSxJQUFBLCtCQUFBLE1BcEJJO1FBcUJOLHNCQUFzQixJQUFBLHFCQXJCaEI7UUFzQk4seUJBQXlCLElBQUEsd0JBQUEsTUF0Qm5CO1FBdUJOLDJCQUEyQixJQUFBLDBCQXZCckI7UUF3Qk4sa0JBQWtCLElBQUEsaUJBeEJaO1FBeUJOLGlCQUFpQixJQUFBLGdCQUFBLE1BekJYO1FBMEJOLGVBQWUsSUFBQSxjQUFBLE1BMUJUO1FBMkJOLG9CQUFvQixJQUFBLG1CQTNCZDtRQTRCTix3QkFBd0IsSUFBQSx1QkE1QmxCO1FBNkJOLGtCQUFrQixJQUFBLGlCQTdCWjtRQThCTixxQkFBcUIsSUFBQSxvQkE5QmY7UUErQk4sa0JBQWtCLElBQUEsaUJBL0JaO1FBZ0NOLDZCQUE2QixJQUFBLDRCQWhDdkI7UUFpQ04sd0JBQXdCLElBQUEsdUJBQUs7T0FsQ2E7TUFvQzVDLHFCQUFxQixJQUFBLG9CQUFLO0tBcENaLENBQWhCLENBQUE7SUFzQ0EsSUFBQSxTQUFBLFVBQUEsQ0FBd0IsSUFBQSxXQUFBLEtBQUEsQ0FBcUIsSUFBckIsQ0FBeEIsQ0FBQSxDQUFBO0lBRUEsTUFBTSxXQUFRLENBQUEsb0JBQUcsT0FBTyxJQUFQLEtBQUgsTUFBQSxJQUFBLElBQUEsaUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBRyxpQkFBQSxTQUFqQixDQUFBOztJQUNBLElBQ0UsUUFBUSxJQUNSLENBQUMsSUFBQSxXQUFBLEVBREQsSUFFQSxJQUFBLHFCQUFBLE1BQUEsU0FBQSxFQUFBLG9CQUhGLEVBSUU7TUFDQSxJQUFBLGVBQUEsQ0FBb0IsUUFBcEIsQ0FBQSxDQUFBO0tBcnpCYzs7O0lBeXpCaEIsSUFBQSxVQUFBLFFBQUEsZ0JBQUEsRUFBQSxLQUFBLENBQThDLENBQUM7O0tBQUQsS0FBWTtNQUN4RCxJQUFBLG1CQUFBLHNCQUFBLENBQ0UsRUFERjtNQUdFLElBQUEsVUFBQSxRQUFBLGVBQUEsS0FBMEMsU0FBMUMsR0FDSSxRQURKLEdBRUksU0FMTixDQUFBLENBQUE7S0FERixDQUFBLENBQUE7SUFVQSxJQUFBLGtDQUFBLEVBQUEsQ0FuMEJnQjs7OztJQXcwQmhCLElBQUEsa0JBQUEsR0FBeUIsSUFBQSx3QkFBQSxFQUF6QixDQXgwQmdCOztJQTIwQmhCLElBQUEsVUFBQSxRQUFBLGtCQUFBLFlBQUEsQ0FBcUQsd0JBQUEsa0JBQXJELENBQUEsQ0EzMEJnQjs7SUE2MEJoQixDQUFBLENBQUEsRUFBQSx3QkFBQSxnQ0FBQSxHQUFBLENBQUE7R0FDRDs7Ozs7Ozs7Ozs7Ozs7O0VBZUQsaUNBQWlDLEdBQUc7SUFDbEMsTUFBTSx1QkFBdUIsK0JBQStCO01BQzFELElBQUksSUFBQSxXQUFBLEVBQUosRUFBdUI7UUFDckIsSUFBQSxrQkFBQSxDQUF1QixNQUF2QixFQUErQjtVQUM3QixRQUFRLGFBQUEsbUJBQUEsZ0JBRHFCOzs7O1VBSzdCLFFBQ0UsV0FBVyxPQUFYLEdBQXFCLENBQXJCO1VBRUksV0FGSjs7VUFLSSxNQUFNLElBQUEscUJBQUEsQ0FBMEIsTUFBMUIsQ0FBQTtTQVhkLENBQUEsQ0FBQTtPQWFEOztNQUVELElBQUEsd0JBQUEsc0JBQUEsQ0FBbUQsTUFBbkQsRUFBMkQsV0FBM0QsQ0FBQSxDQUFBO0tBakJGLENBRGtDOzs7SUFzQmxDLElBQUksbUJBQUosQ0FBQTtJQUNBLElBQUEsc0JBQUEsTUFBQSxVQUFBLENBQTJDLE9BQU87O0tBQVAsS0FBK0I7TUFDeEUsSUFBSSxlQUFlLElBQUksZUFBZSxLQUFLLG1CQUEzQyxFQUFnRTtRQUM5RCxzQkFBc0IsZUFBdEIsQ0FBQTtRQUNBLE1BQU0sdUJBQXVCLENBQUEsQ0FBQSxFQUFBLGFBQUEsNkJBQUEsRUFDM0IsSUFBQSxxQkFBQSxNQUQyQixDQUE3QixDQUFBOztRQUlBLEtBQUssTUFBTSxrQkFBWCxJQUFpQyxvQkFBb0IsUUFBcEIsRUFBakMsRUFBaUU7VUFDL0QsSUFBSSxRQUFRLFNBQVIsQ0FBa0IsZUFBbEIsQ0FBSixFQUF3QztZQUN0QyxvQkFBb0IsQ0FBQyxNQUFELEVBQVMsUUFBVCxDQUFwQixDQUFBO1dBQ0Q7U0FDRjtPQUNGO0tBWkgsQ0FBQSxDQXZCa0M7OztJQXdDbEMsSUFBQSxvQkFBQSxVQUFBLENBQ0csQ0FBQSxFQUFFLElBQUEscUJBQUEsS0FBK0IsQ0FBQSxZQUFBLENBRHBDLEVBRUUsdUNBQXVDO01BQ3JDLE1BQU0sa0JBQWtCLENBQUEsQ0FBQSxFQUFBLGFBQUEsbUJBQUEsRUFBbUIsWUFBbkIsRUFBaUMsYUFBakMsQ0FBeEIsQ0FBQTs7TUFFQSxLQUFLLE1BQU0sa0JBQVgsSUFBaUMsZUFBZSxRQUFmLEVBQWpDLEVBQTREO1FBQzFELG9CQUFvQixDQUFDLE1BQUQsRUFBUyxRQUFULENBQXBCLENBQUE7T0FDRDtLQVBMLEVBU0UsYUFBQSw2QkFURixDQUFBLENBQUE7R0FZRDs7Ozs7O0VBS0Qsa0JBQWtCLEdBQUc7SUFDbkIsTUFBTSxVQUFVLElBQUEsU0FBQSxXQUFBLEVBQWhCLENBQUE7SUFDQSxNQUFNLGVBQWU7TUFDbkIsUUFBUTtRQUNOLGFBQWEsS0FEUDtRQUVOLG9CQUFxQixDQUFBLFVBQUEsRUFBWSxPQUFRLENBQUEsQ0FBQTtPQUh4QjtNQUtuQixPQUxtQjs7TUFPbkIsYUFBYSxPQUNYOztPQURXLEVBRVg7UUFBRSw0QkFBNEIsSUFBQTtPQUE5QixHQUF1QyxFQUY1QixLQUdSO1FBQ0gsSUFBSSxNQUFNLEtBQUssSUFBQSxnQkFBZixFQUFnQztVQUM5QixNQUFNLGtCQUNKLElBQUEsc0JBQUEsbUJBQUEsRUFERixDQUFBO1VBRUEsT0FBTyxlQUFlLEdBQUcsQ0FBQyxlQUFELENBQUgsR0FBdUIsRUFBN0MsQ0FBQTtTQUhGLE1BSU8sSUFBSSxJQUFBLFdBQUEsRUFBSixFQUF1QjtVQUM1QixPQUFPLE1BQU0sSUFBQSxxQkFBQSxDQUEwQixNQUExQixFQUFrQztZQUM3Qyx5QkFBQTtXQURXLENBQWIsQ0FBQTtTQUdEOztRQUNELE9BQU8sRUFBUCxDQVZHO09BVmM7O01BdUJuQixvQkFBb0IsSUFBQSx5QkFBQSxLQUFBLENBQW1DLElBQW5DLENBdkJEOztNQXlCbkIsdUJBQXVCLElBQUEsbUJBQUEsS0FBQSxDQUE2QixJQUE3QixDQXpCSjtNQTBCbkIscUJBQXFCLElBQUEsd0JBQUEsS0FBQSxDQUFrQyxJQUFsQyxDQTFCRjtNQTJCbkIsdUJBQXVCLElBQUEsd0JBQUEsS0FBQSxDQUFrQyxJQUFsQyxDQTNCSjtNQTRCbkIsdUJBQXVCLElBQUEsd0JBQUEsS0FBQSxDQUFrQyxJQUFsQyxDQTVCSjtNQTZCbkIsd0JBQXdCLElBQUEsMkJBQUEsS0FBQSxDQUFxQyxJQUFyQyxDQTdCTDtNQThCbkIsdUJBQXVCLElBQUEseUJBQUEsS0FBQSxDQUFtQyxJQUFuQyxDQTlCSjtNQStCbkIsNEJBQTRCLElBQUEsOEJBQUEsS0FBQSxDQUF3QyxJQUF4QyxDQS9CVDtNQWdDbkIsaUJBQWlCLElBQUEsZ0JBQUEsS0FBQSxDQUEwQixJQUExQixDQWhDRTtNQWlDbkIsNkJBQThCLFFBQzVCLElBQUEsYUFBQSxnQkFBQSxDQUFrQztRQUNoQyxnQkFBZ0I7VUFDZCxJQURjO1VBRWQsUUFBUSxZQUFBLHFCQUFBLFVBQXFCO1NBRmY7T0FEbEIsQ0FBQSxDQUtHLENBTEgsQ0FBQTtLQWxDSixDQUFBO0lBeUNBLE1BQU0sZ0JBQ0osSUFBQSxrQkFBQSxtQkFBQSxDQUEwQyxZQUExQyxDQURGLENBQUE7SUFFQSxPQUFPLGFBQVAsQ0FBQTtHQUNEOzs7Ozs7OztFQU9ELHVCQUF1QixHQUFHOztJQUV4QixNQUFNLG9CQUFvQixJQUFJLFNBQUEsZ0JBQUosRUFBMUIsQ0FBQTtJQUNBLE1BQU07O0tBQUEsR0FBd0IsSUFBOUIsQ0FId0I7O0lBTXhCLElBQUEsR0FBQSxDQUFRLFFBQVIsRUFBa0IsdUJBQWxCLENBQUEsQ0FBQTtJQUNBLHVCQUF1QixDQUFDLElBQUEsU0FBQSxFQUFELENBQXZCLENBQUE7O0lBRUEsMkNBQTJDO01BQ3pDLE1BQU0sVUFBVSxpQkFBaUIsa0JBQWpCLEVBQWhCLENBQUE7O01BQ0EsSUFBSSxRQUFRLFFBQVIsS0FBcUIsU0FBekIsRUFBb0M7UUFDbEMsaUJBQWlCLFNBQWpCLENBQTJCLGlCQUFpQixDQUFDLE9BQUQsRUFBVSxRQUFWLENBQTVDLENBQUEsQ0FBQTtPQUNEO0tBQ0Y7O0lBRUQsb0NBQW9DOzs7S0FBcEMsRUFBNkQ7TUFDM0QsT0FBTztRQUNMLFVBREs7UUFFTCxPQUZLO1FBR0wsZ0JBQWdCLE9BQUE7T0FIbEIsQ0FBQTtLQUtEOztJQUVELE9BQU8saUJBQVAsQ0FBQTtHQUNEOzs7Ozs7Ozs7Ozs7OztFQWFxQixzQkFBQSxTQUFTO0lBQzdCLE9BQU87TUFDTCxZQUFZLElBQUEsV0FBQSxFQURQO01BRUwsR0FBRyxJQUFBLHdCQUFBLEVBRkU7TUFHTCxVQUFVLE1BQU0sSUFBQSxxQkFBQSxDQUEwQixNQUExQixDQUFBO0tBSGxCLENBQUE7R0FLRDs7Ozs7Ozs7OztFQVNELHVCQUF1QixXQUFXO0lBQ2hDLE1BQU07O0tBQUEsR0FBYyxRQUFRLElBQUksSUFBQSxTQUFBLEVBQWhDLENBQUE7SUFDQSxPQUFPO01BQ0wsU0FBUyxJQUFBLGtCQUFBLGtCQUFBLEVBREo7TUFFTCxnQkFBZ0IsT0FBQTtLQUZsQixDQUFBO0dBdGdDeUQ7Ozs7Ozs7Ozs7O0VBcWhDM0QsUUFBUSxHQUFHO0lBQ1QsTUFBTTs7S0FBQSxHQUFZLElBQUEsa0JBQUEsTUFBQSxTQUFBLEVBQWxCLENBQUE7SUFDQSxNQUFNLGdCQUFnQixPQUFPLENBQUMsS0FBRCxDQUE3QixDQUFBO0lBRUEsT0FBTztNQUNMLGFBREs7TUFFTCxHQUFHLElBQUEsU0FBQSxhQUFBLEVBQUE7S0FGTCxDQUFBO0dBSUQ7Ozs7Ozs7Ozs7RUFTRCxNQUFNLEdBQUc7SUFDUCxNQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FBQSxHQXdCRixJQXhCSixDQUFBO0lBMEJBLE9BQU87O01BRUwsVUFBVSxJQUFBLFNBQUEsS0FBQSxDQUFtQixJQUFuQixDQUZMO01BR0wsb0JBQW9CLHNCQUFzQixtQkFBdEIsS0FBQSxDQUNsQixzQkFEa0IsQ0FIZjtNQU1MLGVBQWUscUJBQXFCLGNBQXJCLEtBQUEsQ0FDYixxQkFEYSxDQU5WO01BU0wsa0JBQWtCLHFCQUFxQixpQkFBckIsS0FBQSxDQUNoQixxQkFEZ0IsQ0FUYjtNQVlMLG1CQUFtQixxQkFBcUIsa0JBQXJCLEtBQUEsQ0FDakIscUJBRGlCLENBWmQ7TUFlTCxzQkFBc0IscUJBQXFCLHFCQUFyQixLQUFBLENBQ3BCLHFCQURvQixDQWZqQjtNQWtCTCw0QkFDRSxxQkFBcUIsMkJBQXJCLEtBQUEsQ0FDRSxxQkFERixDQW5CRztNQXNCTCxtQkFBbUIscUJBQXFCLGtCQUFyQixLQUFBLENBQ2pCLHFCQURpQixDQXRCZDtNQXlCTCxnQkFBZ0IscUJBQXFCLGVBQXJCLEtBQUEsQ0FDZCxxQkFEYyxDQXpCWDtNQTRCTCw2QkFDRSxxQkFBcUIsNEJBQXJCLEtBQUEsQ0FDRSxxQkFERixDQTdCRztNQWdDTCxrQkFBa0IscUJBQXFCLGlCQUFyQixLQUFBLENBQ2hCLHFCQURnQixDQWhDYjtNQW1DTCx1QkFBdUIsSUFBQSxzQkFBQSxLQUFBLENBQWdDLElBQWhDLENBbkNsQjtNQW9DTCx5QkFBeUIsSUFBQSx3QkFBQSxLQUFBLENBQWtDLElBQWxDLENBcENwQjtNQXFDTCx5QkFBeUIsSUFBQSx3QkFyQ3BCO01Bc0NMLHdCQUF3QixJQUFBLHVCQXRDbkI7TUF1Q0wsNENBQTRDLE1BQzFDLElBQUEsb0JBQUEsMEJBQUEsRUF4Q0c7O01BMkNMLGVBQWUsSUFBQSxjQUFBLEtBQUEsQ0FBd0IsSUFBeEIsQ0EzQ1Y7TUE0Q0wsa0JBQWtCLElBQUEsaUJBQUEsS0FBQSxDQUEyQixJQUEzQixDQTVDYjtNQTZDTCxjQUFjLElBQUEsYUFBQSxLQUFBLENBQXVCLElBQXZCLENBN0NUO01BOENMLGVBQWUsSUFBQSxjQUFBLEtBQUEsQ0FBd0IsSUFBeEIsQ0E5Q1Y7TUErQ0wsMkJBQTJCLElBQUEsMEJBQUEsS0FBQSxDQUFvQyxJQUFwQyxDQS9DdEI7O01Ba0RMLGlCQUFpQixJQUFBLGdCQUFBLEtBQUEsQ0FBMEIsSUFBMUIsQ0FsRFo7TUFtREwsY0FBYyxJQUFBLGFBQUEsS0FBQSxDQUF1QixJQUF2QixDQW5EVDtNQW9ETCxxQkFBcUIsSUFBQSxvQkFBQSxLQUFBLENBQThCLElBQTlCLENBcERoQjtNQXFETCw2QkFBNkIsSUFBQSw0QkFBQSxLQUFBLENBQXNDLElBQXRDLENBckR4QjtNQXNETCw4QkFDRSxJQUFBLDZCQUFBLEtBQUEsQ0FBdUMsSUFBdkMsQ0F2REc7TUF3REwsZ0NBQ0UsSUFBQSwrQkFBQSxLQUFBLENBQXlDLElBQXpDLENBekRHO01BMERMLG9DQUNFLElBQUEsbUNBQUEsS0FBQSxDQUE2QyxJQUE3QyxDQTNERzs7TUE4REwsNkJBQ0UsaUJBQWlCLGtCQUFqQixLQUFBLENBQXlDLGlCQUF6QyxDQS9ERztNQWdFTCwrQkFDRSxpQkFBaUIsb0JBQWpCLEtBQUEsQ0FBMkMsaUJBQTNDLENBakVHO01Ba0VMLHNCQUNFLGlCQUFpQixXQUFqQixLQUFBLENBQWtDLGlCQUFsQyxDQW5FRztNQW9FTCwyQkFDRSxpQkFBaUIsZ0JBQWpCLEtBQUEsQ0FBdUMsaUJBQXZDLENBckVHO01Bc0VMLDZCQUNFLGlCQUFpQixrQkFBakIsS0FBQSxDQUF5QyxpQkFBekMsQ0F2RUc7O01BMEVMLGlCQUFpQixJQUFBLGdCQUFBLEtBQUEsQ0FBMEIsSUFBMUIsQ0ExRVo7O01BNkVMLGdCQUFnQixJQUFBLGVBQUEsS0FBQSxDQUF5QixJQUF6QixDQTdFWDtNQThFTCxnQkFBZ0IsSUFBQSxlQUFBLEtBQUEsQ0FBeUIsSUFBekIsQ0E5RVg7O01BaUZMLGlCQUNFLGlCQUFpQixnQkFBakIsS0FBQSxDQUF1QyxpQkFBdkMsQ0FsRkc7TUFtRkwsNEJBQ0UsaUJBQWlCLDJCQUFqQixLQUFBLENBQWtELGlCQUFsRCxDQXBGRztNQXFGTCxjQUFjLElBQUEsYUFBQSxLQUFBLENBQXVCLElBQXZCLENBckZUO01Bc0ZMLHVCQUF1QixJQUFBLHNCQUFBLEtBQUEsQ0FBZ0MsSUFBaEMsQ0F0RmxCO01BdUZMLGNBQWMsSUFBQSxhQUFBLEtBQUEsQ0FBdUIsSUFBdkIsQ0F2RlQ7TUF3Rkwsa0JBQWtCLElBQUEsaUJBQUEsS0FBQSxDQUEyQixJQUEzQixDQXhGYjtNQXlGTCwyQkFBMkIsSUFBQSwwQkFBQSxLQUFBLENBQW9DLElBQXBDLENBekZ0Qjs7TUEyRkwsb0JBQW9CLHFCQUFxQixtQkFBckIsS0FBQSxDQUNsQixxQkFEa0IsQ0EzRmY7TUE4RkwsVUFBVSxnQkFBZ0IsU0FBaEIsS0FBQSxDQUErQixnQkFBL0IsQ0E5Rkw7TUErRkwsa0JBQ0UsZ0JBQWdCLGlCQUFoQixLQUFBLENBQXVDLGdCQUF2QyxDQWhHRztNQWlHTCxrQkFDRSxnQkFBZ0IsaUJBQWhCLEtBQUEsQ0FBdUMsZ0JBQXZDLENBbEdHO01BbUdMLGlCQUFpQixnQkFBZ0IsZ0JBQWhCLEtBQUEsQ0FBc0MsZ0JBQXRDLENBbkdaO01Bb0dMLGlCQUFpQixxQkFBcUIsZ0JBQXJCLEtBQUEsQ0FDZixxQkFEZSxDQXBHWjtNQXVHTCxnQkFBZ0IscUJBQXFCLGVBQXJCLEtBQUEsQ0FDZCxxQkFEYyxDQXZHWDtNQTBHTCxlQUFlLHFCQUFxQixjQUFyQixLQUFBLENBQ2IscUJBRGEsQ0ExR1Y7TUE4R0wsb0JBQW9CLHFCQUFxQixtQkFBckIsS0FBQSxDQUNsQixxQkFEa0IsQ0E5R2Y7TUFpSEwsOEJBQ0UscUJBQXFCLDZCQUFyQixLQUFBLENBQ0UscUJBREYsQ0FsSEc7TUFxSEwsbUJBQW1CLHFCQUFxQixrQkFBckIsS0FBQSxDQUNqQixxQkFEaUIsQ0FySGQ7TUF3SEwscUJBQXFCLHFCQUFxQixvQkFBckIsS0FBQSxDQUNuQixxQkFEbUIsQ0F4SGhCO01BMkhMLFVBQVUscUJBQXFCLFNBQXJCLEtBQUEsQ0FBb0MscUJBQXBDLENBM0hMO01BNEhMLGtDQUNFLHFCQUFxQixpQ0FBckIsS0FBQSxDQUNFLHFCQURGLENBN0hHOztNQWlJTCw0QkFBNEIsSUFBQSwyQkFBQSxLQUFBLENBQXFDLElBQXJDLENBakl2Qjs7TUFvSUwsZ0JBQWdCLHNCQUFzQixlQUF0QixLQUFBLENBQ2Qsc0JBRGMsQ0FwSVg7TUF3SUwsK0JBQ0Usc0JBQXNCLDhCQUF0QixLQUFBLENBQ0Usc0JBREYsQ0F6SUc7TUE2SUwsNEJBQ0Usc0JBQXNCLDJCQUF0QixLQUFBLENBQ0Usc0JBREYsQ0E5SUc7TUFrSkwsbUJBQW1CLHNCQUFzQixrQkFBdEIsS0FBQSxDQUNqQixzQkFEaUIsQ0FsSmQ7TUFzSkwsOENBQ0Usc0JBQXNCLDZDQUF0QixLQUFBLENBQ0Usc0JBREYsQ0F2Skc7TUEySkwsZ0RBQ0Usc0JBQXNCLCtDQUF0QixLQUFBLENBQ0Usc0JBREYsQ0E1Skc7TUFnS0wsb0JBQW9CLHNCQUFzQixtQkFBdEIsS0FBQSxDQUNsQixzQkFEa0IsQ0FoS2Y7O01BcUtMLGdCQUFnQixxQkFBcUIsSUFBckIsS0FBQSxDQUErQixxQkFBL0IsQ0FyS1g7TUFzS0wsdUJBQXVCLHFCQUFxQixPQUFyQixLQUFBLENBQ3JCLHFCQURxQixDQXRLbEI7O01BMktMLG1CQUNFLGtCQUFrQixrQkFBbEIsS0FBQSxDQUEwQyxrQkFBMUMsQ0E1S0c7TUE2S0wsNkJBQ0Usa0JBQWtCLDRCQUFsQixLQUFBLENBQW9ELGtCQUFwRCxDQTlLRztNQStLTCx1Q0FDRSxrQkFBa0Isc0NBQWxCLEtBQUEsQ0FDRSxrQkFERixDQWhMRztNQW1MTCx1Q0FDRSxrQkFBa0Isc0NBQWxCLEtBQUEsQ0FDRSxrQkFERixDQXBMRztNQXVMTCxvQ0FDRSxrQkFBa0IsbUNBQWxCLEtBQUEsQ0FDRSxrQkFERixDQXhMRztNQTJMTCxpQ0FDRSxrQkFBa0IsZ0NBQWxCLEtBQUEsQ0FDRSxrQkFERixDQTVMRztNQStMTCx5QkFDRSxrQkFBa0Isd0JBQWxCLEtBQUEsQ0FBZ0Qsa0JBQWhELENBaE1HO01BaU1MLHlDQUNFLGtCQUFrQix3Q0FBbEIsS0FBQSxDQUNFLGtCQURGLENBbE1HO01BcU1MLG1DQUNFLGtCQUFrQixrQ0FBbEIsS0FBQSxDQUNFLGtCQURGLENBdE1HO01BeU1MLGdDQUNFLGtCQUFrQiwrQkFBbEIsS0FBQSxDQUNFLGtCQURGLENBMU1HO01BNk1MLHlCQUNFLGtCQUFrQix3QkFBbEIsS0FBQSxDQUFnRCxrQkFBaEQsQ0E5TUc7O01BZ05MLDBCQUNFLGFBQWEsc0JBQWIsS0FBQSxDQUF5QyxhQUF6QyxDQWpORzs7TUFvTkwsV0FBVyxJQUFBLFVBQUEsS0FBQSxDQUFvQixJQUFwQixDQXBOTjtNQXFOTCwyQkFBMkIsSUFBQSwwQkFBQSxLQUFBLENBQW9DLElBQXBDLENBck50QjtNQXNOTCwwQkFBMEIsSUFBQSx5QkFBQSxLQUFBLENBQW1DLElBQW5DLENBdE5yQjtNQXVOTCxlQUFlLGlCQUFpQixjQUFqQixLQUFBLENBQXFDLGlCQUFyQyxDQXZOVjs7TUEwTkwsbUJBQW1CLFlBQVksa0JBQVosS0FBQSxDQUFvQyxZQUFwQyxDQTFOZDtNQTJOTCxtQkFBbUIsWUFBWSxrQkFBWixLQUFBLENBQW9DLFlBQXBDLENBM05kO01BNE5MLDZCQUNFLFlBQVksNEJBQVosS0FBQSxDQUE4QyxZQUE5QyxDQTdORztNQThOTCxrQ0FDRSxZQUFZLGlDQUFaLEtBQUEsQ0FBbUQsWUFBbkQsQ0EvTkc7TUFnT0wseUJBQXlCLElBQUEsd0JBQUEsS0FBQSxDQUFrQyxJQUFsQyxDQWhPcEI7TUFpT0wsMEJBQTBCLElBQUEseUJBQUEsS0FBQSxDQUFtQyxJQUFuQyxDQWpPckI7TUFrT0wsYUFBYSxJQUFBLFlBQUEsS0FBQSxDQUFzQixJQUF0QixDQWxPUjtNQW1PTCxjQUFjLElBQUEsYUFBQSxLQUFBLENBQXVCLElBQXZCLENBbk9UO01Bb09MLDBCQUNFLFlBQVkseUJBQVosS0FBQSxDQUEyQyxZQUEzQyxDQXJPRztNQXNPTCxnQ0FDRSxZQUFZLCtCQUFaLEtBQUEsQ0FBaUQsWUFBakQsQ0F2T0c7TUF3T0wsaUJBQWlCLFlBQVksZ0JBQVosS0FBQSxDQUFrQyxZQUFsQyxDQXhPWjtNQTBPTCxzQkFDRSxZQUFZLHFCQUFaLEtBQUEsQ0FBdUMsWUFBdkMsQ0EzT0c7TUE0T0wsMEJBQ0UsWUFBWSx5QkFBWixLQUFBLENBQTJDLFlBQTNDLENBN09HO01BOE9MLGtDQUNFLFlBQVksaUNBQVosS0FBQSxDQUFtRCxZQUFuRCxDQS9PRztNQWlQTCwrQkFDRSxZQUFZLDhCQUFaLEtBQUEsQ0FBZ0QsWUFBaEQsQ0FsUEc7TUFtUEwsdUJBQ0UsWUFBWSxzQkFBWixLQUFBLENBQXdDLFlBQXhDLENBcFBHO01Bc1BMLHlCQUNFLFlBQVksd0JBQVosS0FBQSxDQUEwQyxZQUExQyxDQXZQRzs7TUF5UEwsYUFBYSxJQUFBLFlBQUEsS0FBQSxDQUFzQixJQUF0QixDQXpQUjtNQTBQTCxlQUFlLElBQUEsY0FBQSxLQUFBLENBQXdCLElBQXhCLENBMVBWOztNQTZQTCxxQkFBcUIsSUFBQSxvQkFBQSxLQUFBLENBQThCLElBQTlCLENBN1BoQjtNQThQTCx1QkFBdUIsSUFBQSxzQkFBQSxLQUFBLENBQWdDLElBQWhDLENBOVBsQjs7TUFpUUwsa0JBQWtCLElBQUEsaUJBQUEsS0FBQSxDQUEyQixJQUEzQixDQWpRYjtNQWtRTCxvQkFBb0IsSUFBQSxtQkFBQSxLQUFBLENBQTZCLElBQTdCLENBbFFmOztNQXFRTCxnQkFBZ0IsSUFBQSxlQUFBLEtBQUEsQ0FBeUIsSUFBekIsQ0FyUVg7TUFzUUwsc0JBQXNCLElBQUEscUJBQUEsS0FBQSxDQUErQixJQUEvQixDQXRRakI7TUF1UUwsc0JBQXNCLElBQUEscUJBQUEsS0FBQSxDQUErQixJQUEvQixDQXZRakI7O01BMFFMLHFCQUFxQixJQUFBLG9CQUFBLEtBQUEsQ0FBOEIsSUFBOUIsQ0ExUWhCO01BMlFMLDJCQUEyQixJQUFBLDBCQUFBLEtBQUEsQ0FBb0MsSUFBcEMsQ0EzUXRCOztNQThRTCx1QkFDRSxvQkFBb0Isc0JBQXBCLEtBQUEsQ0FBZ0Qsb0JBQWhELENBL1FHO01BZ1JMLG9CQUNFLG9CQUFvQixtQkFBcEIsS0FBQSxDQUE2QyxvQkFBN0MsQ0FqUkc7TUFrUkwsc0JBQ0Usb0JBQW9CLHFCQUFwQixLQUFBLENBQStDLG9CQUEvQyxDQW5SRzs7TUFzUkwscUJBQ0UsZUFBZSxvQkFBZixLQUFBLENBQXlDLGVBQXpDLENBdlJHO01Bd1JMLGlDQUNFLGVBQWUsZ0NBQWYsS0FBQSxDQUFxRCxlQUFyRCxDQXpSRztNQTBSTCxnQ0FDRSxlQUFlLCtCQUFmLEtBQUEsQ0FBb0QsZUFBcEQsQ0EzUkc7O01BOFJMLHNCQUFzQixJQUFBLHFCQTlSakI7TUErUkwsMkJBQTJCLElBQUEseUJBL1J0QjtNQWdTTCwwQkFBMEIsSUFBQSx5QkFoU3JCO01BaVNMLEdBQUcsQ0FBQSxDQUFBLEVBQUEsYUFBQSxrQ0FBQSxFQUFrQyxvQkFBbEMsQ0FqU0U7O01BcVNMLG1CQUNFLGVBQWUsa0JBQWYsS0FBQSxDQUF1QyxlQUF2QyxDQXRTRztNQXVTTCx1QkFDRSxlQUFlLHNCQUFmLEtBQUEsQ0FBMkMsZUFBM0MsQ0F4U0c7TUF5U0wsaUJBQWlCLGVBQWUsZ0JBQWYsS0FBQSxDQUFxQyxlQUFyQyxDQXpTWjtNQTBTTCxnQkFBZ0IsZUFBZSxlQUFmLEtBQUEsQ0FBb0MsZUFBcEMsQ0ExU1g7TUEyU0wsa0JBQWtCLGVBQWUsaUJBQWYsS0FBQSxDQUFzQyxlQUF0QyxDQTNTYjtNQTRTTCxnQkFBZ0IsZUFBZSxlQUFmLEtBQUEsQ0FBb0MsZUFBcEMsQ0E1U1g7TUE2U0wsY0FBYyxlQUFlLGFBQWYsS0FBQSxDQUFrQyxlQUFsQyxDQTdTVDtNQThTTCxvQkFDRSxlQUFlLG1CQUFmLEtBQUEsQ0FBd0MsZUFBeEMsQ0EvU0c7TUFnVEwsb0JBQ0UsZUFBZSxtQkFBZixLQUFBLENBQXdDLGVBQXhDLENBalRHO01Ba1RMLHdCQUNFLGVBQWUsdUJBQWYsS0FBQSxDQUE0QyxlQUE1QyxDQW5URztNQW9UTCxnQ0FDRSxlQUFlLCtCQUFmLEtBQUEsQ0FBb0QsZUFBcEQsQ0FyVEc7TUFzVEwsbUJBQ0UsZUFBZSxrQkFBZixLQUFBLENBQXVDLGVBQXZDLENBdlRHO01Bd1RMLHNCQUNFLGVBQWUscUJBQWYsS0FBQSxDQUEwQyxlQUExQyxDQXpURztNQTBUTCw2QkFDRSxlQUFlLDRCQUFmLEtBQUEsQ0FBaUQsZUFBakQsQ0EzVEc7TUE0VEwscUJBQ0UsZUFBZSxvQkFBZixLQUFBLENBQXlDLGVBQXpDLENBN1RHO01BOFRMLGtCQUFrQixlQUFlLGlCQUFmLEtBQUEsQ0FBc0MsZUFBdEMsQ0E5VGI7TUErVEwsdUJBQ0UsZUFBZSxzQkFBZixLQUFBLENBQTJDLGVBQTNDLENBaFVHO01BaVVMLHdCQUNFLGVBQWUsdUJBQWYsS0FBQSxDQUE0QyxlQUE1QyxDQWxVRztNQW1VTCxrQkFBa0IsZUFBZSxpQkFBZixLQUFBLENBQXNDLGVBQXRDLENBblViO01Bb1VMLHNCQUNFLGVBQWUscUJBQWYsS0FBQSxDQUEwQyxlQUExQyxDQXJVRztNQXNVTCxzQkFDRSxlQUFlLHFCQUFmLEtBQUEsQ0FBMEMsZUFBMUMsQ0F2VUc7TUF3VUwsbUNBQ0UsZUFBZSxrQ0FBZixLQUFBLENBQXVELGVBQXZELENBelVHOztNQTRVTCxpQ0FDRSwyQkFBMkIsY0FBM0IsS0FBQSxDQUNFLDJCQURGLENBN1VHO01BZ1ZMLDJCQUEyQiwyQkFBMkIsUUFBM0IsS0FBQSxDQUN6QiwyQkFEeUIsQ0FoVnRCO01BbVZMLDJCQUEyQiwyQkFBMkIsVUFBM0IsS0FBQSxDQUN6QiwyQkFEeUIsQ0FuVnRCO01Bc1ZMLDBCQUNFLDJCQUEyQix5QkFBM0IsS0FBQSxDQUNFLDJCQURGLENBdlZHO01BMFZMLHdCQUNFLDJCQUEyQix1QkFBM0IsS0FBQSxDQUNFLDJCQURGLENBM1ZHO01BOFZMLGdDQUNFLDJCQUEyQixjQUEzQixLQUFBLENBQ0UsMkJBREYsQ0EvVkc7TUFrV0wsd0JBQ0UsMkJBQTJCLHVCQUEzQixLQUFBLENBQ0UsMkJBREYsQ0FuV0c7TUFzV0wsMEJBQ0UsMkJBQTJCLHlCQUEzQixLQUFBLENBQ0UsMkJBREYsQ0F2V0c7O01BNFdMLHVCQUF1QixxQkFBcUIsV0FBckIsS0FBQSxDQUNyQixxQkFEcUIsQ0E1V2xCO01BK1dMLHNCQUFzQixxQkFBcUIsVUFBckIsS0FBQSxDQUNwQixxQkFEb0IsQ0EvV2pCO01Ba1hMLHFCQUFxQixxQkFBcUIsb0JBQXJCLEtBQUEsQ0FDbkIscUJBRG1CLENBbFhoQjtNQXFYTCxxQkFBcUIscUJBQXFCLG9CQUFyQixLQUFBLENBQ25CLHFCQURtQixDQXJYaEI7TUF3WEwsdUJBQXVCLHFCQUFxQixzQkFBckIsS0FBQSxDQUNyQixxQkFEcUIsQ0F4WGxCOztNQTZYTCx3QkFBd0IsSUFBQSx1QkE3WG5CO01BOFhMLHVCQUF1QixJQUFBLHNCQTlYbEI7O01BaVlMLDJCQUEyQixzQkFBc0IsYUFBdEIsS0FBQSxDQUN6QixzQkFEeUIsQ0FqWXRCOztNQXNZTCxtQ0FDRSxnQkFBZ0Isa0NBQWhCLEtBQUEsQ0FDRSxnQkFERixDQXZZRztNQTJZTCxnQ0FDRSxnQkFBZ0IsaUJBQWhCLEtBQUEsQ0FBdUMsZ0JBQXZDLENBNVlHO01BOFlMLHVCQUNFLGdCQUFnQixnQkFBaEIsS0FBQSxDQUFzQyxnQkFBdEMsQ0EvWUc7TUFpWkwsMkJBQ0Usa0JBQWtCLGdCQUFsQixLQUFBLENBQXdDLGtCQUF4QyxDQWxaRztNQW9aTCxnQ0FDRSxrQkFBa0IsbUJBQWxCLEtBQUEsQ0FBMkMsa0JBQTNDLENBclpHOztNQXdaTCxnQkFBZ0IsZ0JBQWdCLGVBQWhCLEtBQUEsQ0FBcUMsZ0JBQXJDLENBeFpYO01BeVpMLGlCQUFpQixnQkFBZ0IsZ0JBQWhCLEtBQUEsQ0FBc0MsZ0JBQXRDLENBelpaOztNQTRaTCxpQkFBaUIsc0JBQXNCLGdCQUF0QixLQUFBLENBQ2Ysc0JBRGUsQ0E1Wlo7O01BaWFMLG9CQUFvQixPQUFPLElBQVAsZ0JBQUEsR0FDaEIsOEJBQThCLG1CQUE5QixLQUFBLENBQ0UsOEJBREYsQ0FEZ0IsR0FJaEIsSUFyYUM7OztNQXdhTCxtQkFDRSxnQkFBZ0Isa0JBQWhCLEtBQUEsQ0FBd0MsZ0JBQXhDLENBemFHO01BMGFMLG1CQUFtQixnQkFBZ0IsVUFBaEIsS0FBQSxDQUFnQyxnQkFBaEMsQ0ExYWQ7TUEyYUwsY0FBYyxnQkFBZ0IsYUFBaEIsS0FBQSxDQUFtQyxnQkFBbkMsQ0EzYVQ7TUE0YUwseUJBQ0Usd0JBQXdCLHdCQUF4QixLQUFBLENBQ0Usd0JBREYsQ0FBQTtLQTdhSixDQUFBO0dBaWJEOztFQUUrQixnQ0FBQSxnQ0FBZ0M7SUFBQSxJQUFBLGlCQUFBLEVBQUEsZ0JBQUEsQ0FBQTs7SUFDOUQsTUFBTSxVQUNKLE1BQU0sSUFBQSx5QkFBQSwyQkFBQSxDQUNKLE9BREksRUFFSixXQUZJLEVBR0osT0FISSxDQURSLENBQUE7SUFNQSxPQUFPLEVBQ0wsR0FBRyxPQURFO01BRUwsVUFBVSxPQUFGLEtBQUEsSUFBQSxJQUFFLE9BQUYsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxDQUFBLG9CQUFFLE9BQU8sU0FBVCxNQUFBLElBQUEsSUFBQSxpQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFFLGlCQUFBLFNBQUEsQ0FBNEIsRUFBNUIsQ0FGTDtNQUdMLFNBQVMsT0FBRixLQUFBLElBQUEsSUFBRSxPQUFGLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSxtQkFBRSxPQUFPLFFBQVQsTUFBQSxJQUFBLElBQUEsZ0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBRSxnQkFBQSxTQUFBLENBQTJCLEVBQTNCLENBQUE7S0FIWCxDQUFBO0dBMy9DeUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFtaEQ1QiwrQkFBQSxXQUFXO0lBQ3hDLE1BQU0sY0FBYyxNQUFNLElBQUEsaUJBQUEsUUFBQSxFQUExQixDQUFBOztJQUNBLElBQUk7TUFDRixJQUFJLEtBQUosQ0FBQTtNQUNBLE1BQU0sV0FBVyxNQUFNLElBQUEsa0JBQUEsWUFBQSxFQUF2QixDQUFBOztNQUNBLElBQUksUUFBUSxPQUFSLEdBQWtCLENBQXRCLEVBQXlCO1FBQ3ZCLFFBQVEsTUFBTSxJQUFBLGtCQUFBLFdBQUEsRUFBZCxDQUFBO09BREYsTUFFTztRQUNMLFFBQVEsTUFBTSxJQUFBLGtCQUFBLDBCQUFBLENBQ1osUUFEWSxDQUFkLENBQUE7UUFHQSxNQUFNLFlBQVksTUFBTSxJQUFBLGtCQUFBLFlBQUEsRUFBeEIsQ0FBQTtRQUNBLElBQUEsc0JBQUEsYUFBQSxDQUF3QyxTQUF4QyxDQUFBLENBQUE7UUFDQSxJQUFBLG9CQUFBLEVBQUEsQ0FBQTtPQUNEOztNQUVELE9BQU8sS0FBUCxDQUFBO0tBZEYsU0FlVTtNQUNSLFdBQVcsRUFBQSxDQUFBO0tBQ1o7R0FDRjs7RUFFOEIsK0JBQUEsOEJBQThCO0lBQzNELElBQUk7TUFDRixNQUFNLElBQUEsbUJBQUEsMEJBQUEsQ0FBa0Q7UUFDdEQsUUFBUSxVQUQ4QztRQUV0RCxNQUFNLHlCQUZnRDtRQUd0RCxhQUFhO1VBQ1gsU0FBUyxTQUFTLFFBRFA7VUFFWCxrQkFBa0IsU0FBUyxTQUFULGlCQUZQO1VBR1gsV0FBVyxTQUFTLFNBSFQ7VUFJWCxRQUFRLFNBQVMsT0FKTjtVQUtYLFFBQVEsU0FBUyxPQUxOO1VBTVgsVUFBVSxTQUFTLFNBQVQsU0FBbUI7U0FObEI7T0FIVCxDQUFOLENBQUE7S0FERixDQWFFLGNBQWM7TUFDZCxJQUNFLEVBQUUsZ0JBQWdCLElBQUksS0FBSyxRQUFMLEtBQWtCLDRCQUF4QyxDQURGLEVBRUU7UUFDQSxNQUFNLEtBQU4sQ0FBQTtPQUNEO0tBQ0Y7R0FDRjs7RUFFcUIsc0JBQUEsc0JBQXNCO0lBQzFDLE1BQU07Ozs7OztLQUFBLEdBQTJELFNBQWpFLENBQUE7SUFFQSxNQUFNLElBQUEsc0JBQUEscUJBQUEsQ0FDSixNQURJLEVBRUosT0FGSSxFQUdKLE1BSEksRUFJSixTQUpJLEVBS0o7TUFDRSxnQkFBQTtLQU5FLENBQU4sQ0FBQTtJQVVBLElBQUksWUFBSixDQUFBOztJQUNBLElBQUk7TUFDRixlQUFlLElBQUksR0FBSixDQUFRLE1BQVIsQ0FBQSxPQUFmLENBQUE7S0FERixDQUVFLE1BQU07S0FFUDs7SUFDRCxJQUFBLHNCQUFBLFdBQUEsQ0FBc0M7TUFDcEMsT0FBTyxzQkFENkI7TUFFcEMsVUFBVSxZQUFBLE1BQUEsV0FBQSxRQUYwQjtNQUdwQyxVQUFVO1FBQ1IsS0FBSyxZQUFBO09BSjZCO01BTXBDLFlBQVk7UUFDVixVQUFVLE9BREE7UUFFVixjQUFjLFNBRko7UUFHVixTQUFTLFlBSEM7UUFJVixRQUFRLE1BSkU7UUFLVixvQkFBb0IsZ0JBTFY7UUFNVixRQUFRLFlBQUEsTUFBQSxPQUFBLFFBQUEscUJBQXFCO09BWks7TUFjcEMscUJBQXFCO1FBQ25CLFNBQVMsWUFBQTtPQWZ5QjtNQWlCcEMsUUFBQTtLQWpCRixDQUFBLENBQUE7R0FtQkQ7Ozs7Ozs7Ozs7RUFTNkIsOEJBQUEsOEJBQThCO0lBQzFELE1BQU0sY0FBYyxNQUFNLElBQUEsaUJBQUEsUUFBQSxFQUExQixDQUFBOztJQUNBLElBQUk7TUFDRixJQUFJLFFBQUosRUFBYyxXQUFkLENBQUE7TUFFQSxNQUFNLHFCQUFxQixNQUFNLEtBQU4sQ0FBWSxpQkFBWixDQUEzQixDQUFBO01BRUEsTUFBTTs7T0FBQSxHQUF3QixJQUE5QixDQUxFOztNQVFGLElBQUEsc0JBQUEsYUFBQSxDQUF3QyxFQUF4QyxDQUFBLENBUkU7O01BV0YsSUFBQSxxQkFBQSxXQUFBLEVBQUEsQ0FYRTs7TUFlRixJQUFBLGVBQUEsY0FBQSxFQUFBLENBZkU7O01Ba0JGLElBQUEseUJBQUEsb0JBQUEsRUFBQSxDQWxCRTs7TUFxQkYsSUFBQSxhQUFBLGVBQUEsbUJBQUEsRUFBQSxDQXJCRTs7TUF3QkYsTUFBTSxRQUFRLE1BQU0saUJBQWlCLHlCQUFqQixDQUNsQixRQURrQixFQUVsQixrQkFGa0IsQ0FBcEIsQ0FBQTtNQUtBLE1BQU0sV0FBVyxJQUFJLFNBQUEsUUFBSixDQUFhLElBQUEsU0FBYixDQUFqQixDQUFBO01BQ0EsV0FBVyxNQUFNLGlCQUFpQixZQUFqQixFQUFqQixDQUFBO01BQ0EsY0FBYyxNQUFNLElBQUEsV0FBQSxDQUNsQixRQUFRLENBQUMsUUFBUSxPQUFSLEdBQWtCLENBQW5CLENBRFUsRUFFbEIsUUFGa0IsQ0FBcEIsQ0FBQTtNQUtBLE1BQU0sZ0JBQUEsR0FDSixpQkFBaUIsa0JBQWpCLENBQW9DLGFBQXBDLENBREYsQ0FBQTs7TUFFQSxJQUFJLENBQUMsY0FBTCxFQUFxQjtRQUNuQixNQUFNLElBQUksS0FBSixDQUFVLDJDQUFWLENBQU4sQ0FBQTtPQXZDQTs7O01BMkNGLE9BQU8sV0FBVyxLQUFLLEtBQXZCLEVBQThCO1FBQzVCLE1BQU0saUJBQWlCLGNBQWpCLENBQWdDLGNBQWhDLENBQU4sQ0FBQTtRQUNBLFdBQVcsTUFBTSxpQkFBaUIsWUFBakIsRUFBakIsQ0FBQTtRQUNBLGNBQWMsTUFBTSxJQUFBLFdBQUEsQ0FDbEIsUUFBUSxDQUFDLFFBQVEsT0FBUixHQUFrQixDQUFuQixDQURVLEVBRWxCLFFBRmtCLENBQXBCLENBQUE7T0E5Q0E7OztNQXFERixJQUFJLFFBQVEsT0FBUixHQUFrQixDQUFsQixJQUF1QixXQUFXLEtBQUssS0FBM0MsRUFBa0Q7UUFDaEQsTUFBTSxJQUFBLGNBQUEsQ0FBbUIsUUFBUSxDQUFDLFFBQVEsT0FBUixHQUFrQixDQUFuQixDQUEzQixDQUFOLENBQUE7UUFDQSxXQUFXLE1BQU0saUJBQWlCLFlBQWpCLEVBQWpCLENBQUE7T0F2REE7Ozs7OztNQThERixNQUFNLHNCQUNKLElBQUEsc0JBQUEsNkJBQUEsRUFERixDQUFBO01BRUEsSUFBQSw2QkFBQSxDQUFrQyxtQkFBbEMsQ0FBQSxDQWhFRTs7TUFtRUYsSUFBQSxzQkFBQSxhQUFBLENBQXdDLFFBQXhDLENBQUEsQ0FBQTtNQUNBLElBQUEsb0JBQUEsRUFBQSxDQUFBO01BQ0EsT0FBTyxLQUFQLENBQUE7S0FyRUYsU0FzRVU7TUFDUixXQUFXLEVBQUEsQ0FBQTtLQUNaO0dBQ0Y7Ozs7Ozs7OztFQVFELFVBQVUsb0JBQW9CO0lBQzVCLE9BQU8sSUFBSSxPQUFKLENBQVkscUJBQXFCO01BQ3RDLE1BQU0sU0FBUyxJQUFBLGVBQUEsTUFBQSxTQUFBLEVBQUEsU0FBQSxDQUE4QyxPQUE5QyxDQUFmLENBQUE7O01BRUEsSUFBSSxNQUFNLElBQUksTUFBTSxRQUFwQixFQUE4QjtRQUM1QixPQUFPLENBQUMsTUFBTSxRQUFQLENBQVAsQ0FBQTtPQURGLE1BRU87UUFDTCxRQUFRLFdBQVIsQ0FBb0IsT0FBcEIsRUFBNkIsb0JBQW9CO1VBQy9DLElBQUksS0FBSixFQUFXO1lBQ1QsTUFBTSxDQUFDLEtBQUQsQ0FBTixDQUFBOztZQUNBLFNBQUEsUUFBQSxNQUFBLENBQVUsS0FBVixDQUFBLENBQUE7V0FGRixNQUdPO1lBQ0wsT0FBTyxDQUFDLE9BQU8sSUFBSSxLQUFaLENBQVAsQ0FBQTtXQUNEO1NBTkgsQ0FBQSxDQUFBO09BUUQ7S0FkSSxDQUFQLENBQUE7R0FnQkQ7Ozs7Ozs7OztFQVFvQixxQkFBQSxHQUFHOztJQUV0QixNQUFNOzs7Ozs7S0FBQSxHQU1GLElBQUEsc0JBQUEsTUFBQSxTQUFBLEVBTkosQ0FBQTs7SUFRQSxNQUFNLG9DQUNKLENBQUMsaUJBQUQsSUFDQSxJQUFBLGtCQUFBLE1BQUEsU0FBQSxFQUFBLFNBQUEsUUFBQSxLQUNFLFFBQUEsVUFBQSxRQUhKLENBQUE7O0lBSUEsTUFBTTs7S0FBQSxHQUFnQixJQUFBLG9CQUFBLE1BQXRCLENBQUE7SUFDQSxNQUFNLDJCQUEyQixpQ0FBaUMsR0FDOUQsT0FBQSwwQkFEOEQsR0FFOUQsU0FGSixDQUFBO0lBSUEsTUFBTSxjQUFjO01BQ2xCLGFBRGtCO01BRWxCLGVBRmtCO01BR2xCLFVBSGtCO01BSWxCLGVBQUE7S0FKRixDQW5Cc0I7O0lBMkJ0QixNQUFNOzs7S0FBQSxHQUFrQyxJQUFBLGlCQUFBLE1BQXhDLENBM0JzQjs7SUE4QnRCLE1BQU0saUJBQWlCLEVBQXZCLENBQUE7SUFFQSxNQUFNLEtBQU4sQ0FBWSxTQUFaLENBQUEsUUFBQSxDQUFnQyxXQUFZO01BQzFDLGNBQWMsQ0FBQyxPQUFELENBQWQsR0FBMEIsRUFBMUIsQ0FBQTtNQUNBLE1BQU0sS0FBTixDQUFZLFNBQVMsQ0FBQyxPQUFELENBQXJCLENBQUEsUUFBQSxDQUF5QyxrQkFBbUI7UUFDMUQsTUFBTSw0QkFBNEIsQ0FBQSxDQUFBLEVBQUEsZUFBQSxxQkFBQSxFQUFxQixjQUFyQixDQUFsQyxDQUFBO1FBQ0EsY0FBYyxDQUFDLE9BQUQsQ0FBZCxDQUF3Qix5QkFBeEIsQ0FBQSxHQUFxRCxTQUFTLENBQUMsT0FBRCxDQUFULENBQ25ELHlCQURtRCxDQUFBLE9BQUEsQ0FFM0MsU0FBVTtVQUNsQixJQUFJLEtBQUssU0FBTCxLQUFtQixTQUF2QixFQUFrQztZQUFBLElBQUEsY0FBQSxDQUFBOzs7WUFFaEMsSUFDRSx3QkFBd0IsQ0FBQSxDQUFBLGlCQUFDLEtBQUssUUFBTixNQUFBLElBQUEsSUFBQSxjQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUMsY0FBQSxZQUFBLEVBQUQsQ0FBeEIsS0FDQSxTQUZGLEVBR0U7Y0FDQSxPQUFPLElBQVAsQ0FBQTthQUNEO1dBUEgsTUFRTyxJQUFJLEtBQUssU0FBTCxLQUFtQixLQUF2QixFQUE4QjtZQUNuQyxPQUFPLElBQVAsQ0FBQTtXQUNEOztVQUNELE9BQU8sS0FBUCxDQUFBO1NBZG1ELENBQXJELENBQUE7T0FGRixDQUFBLENBQUE7S0FGRixDQUFBLENBaENzQjs7SUF3RHRCLE1BQU0sV0FBQSxHQUFjLElBQUEsa0JBQUEsa0JBQUEsQ0FBeUMsYUFBekMsQ0FBcEIsQ0FBQTtJQUNBLE1BQU0sd0JBQ0osSUFBQSxrQkFBQSxrQkFBQSxDQUF5QyxpQkFBekMsQ0FERixDQUFBO0lBRUEsTUFBTSxhQUFhLE1BQU0sU0FBUyxZQUFULEVBQXpCLENBQUE7SUFDQSxNQUFNLCtCQUErQixNQUFNLE9BQU8sSUFBUCxDQUN6QyxxQkFBcUIsSUFBckIsQ0FBMkIsV0FBWSxPQUFPLFlBQVAsRUFBdkMsQ0FEeUMsQ0FBM0MsQ0FBQTtJQUdBLE1BQU0sd0JBQXdCLDRCQUE0QixPQUE1QixDQUM1QixtQkFBbUIsQ0FBQyxHQUFHLEdBQUosRUFBUyxHQUFHLFFBQVosQ0FEUyxFQUU1QixFQUY0QixDQUE5QixDQUFBO0lBSUEsTUFBTSxXQUFXO01BQ2YsSUFBSSxVQUFVLE9BQVYsQ0FDTSxlQUFlLFVBQVUsUUFBVixDQUFtQixJQUFuQixDQUFBLEtBQTZCLEdBRGxELENBQUEsSUFBQSxDQUVJLFdBQVksQ0FBQSxDQUFBLEVBQUEsZUFBQSxxQkFBQSxFQUFxQixPQUFyQixDQUZoQixDQURXO01BSWYsZUFBZSxxQkFBcUIsT0FBckIsQ0FDTCxlQUFlLHFCQUFxQixRQUFyQixDQUE4QixJQUE5QixDQUFBLEtBQXdDLEdBRGxELENBQUEsSUFBQSxDQUVQLFdBQVksQ0FBQSxDQUFBLEVBQUEsZUFBQSxxQkFBQSxFQUFxQixPQUFyQixDQUZMLENBSkE7TUFPZixRQUFRLEVBUE87TUFRZixRQUFRLEVBUk87TUFTZixTQUFTLEVBQUE7S0FUWCxDQW5Fc0I7O0lBaUZ0QixJQUFJOztLQUFBLEdBQW1CLElBQUEsYUFBQSxNQUFBLFNBQUEsRUFBdkIsQ0FqRnNCOztJQW1GdEIsZUFBZSxNQUFNLE9BQU4sQ0FBYyxZQUFkLENBQUEsT0FBQSxDQUFvQyxNQUFPO01BQ3hELE1BQU0sb0JBQW9CLENBQUEsQ0FBQSxFQUFBLGVBQUEscUJBQUEsRUFBcUIsRUFBRSxTQUFGLEtBQXJCLENBQTFCLENBQUE7TUFDQSxPQUFPLFFBQVEsR0FBUixTQUFBLENBQXFCLGlCQUFyQixDQUFQLENBQUE7S0FGYSxDQUFmLENBQUE7SUFLQSxPQUFPO01BQ0wsUUFESztNQUVMLFdBRks7TUFHTCxZQUhLO01BSUwsUUFBUTtRQUFFLFdBQVcsY0FBYjtRQUE2QixnQkFBQTtPQUpoQztNQUtMLFNBQVMsSUFBQSxrQkFBQSxNQUFBLFNBQUEsRUFBQTtLQUxYLENBQUE7R0FPRDs7Ozs7Ozs7Ozs7RUFVbUIsb0JBQUEsV0FBVztJQUM3QixNQUFNLElBQUEsa0JBQUEsZUFBQSxDQUFzQyxRQUF0QyxDQUFOLENBQUE7O0lBRUEsSUFBSTtNQUNGLE1BQU0sSUFBQSxhQUFBLG9CQUFBLEVBQU4sQ0FBQTtLQURGLENBRUUsY0FBYztNQUNkLFNBQUEsUUFBQSxNQUFBLENBQVUsa0NBQVYsRUFBOEMsS0FBOUMsQ0FBQSxDQUFBO0tBTjJCOzs7Ozs7SUFhN0IsTUFBTSxzQkFDSixJQUFBLHNCQUFBLDZCQUFBLEVBREYsQ0FBQTtJQUdBLElBQUEsNkJBQUEsQ0FBa0MsbUJBQWxDLENBQUEsQ0FBQTtJQUVBLE9BQU8sSUFBQSxrQkFBQSxXQUFBLEVBQVAsQ0FBQTtHQUNEOzs7Ozs7OztFQU9tQixvQkFBQSxXQUFXO0lBQzdCLE1BQU0sSUFBQSxrQkFBQSxlQUFBLENBQXNDLFFBQXRDLENBQU4sQ0FBQTtHQUNEOzs7Ozs7Ozs7Ozs7O0VBWUQsbUJBQW1CLEdBQUc7SUFDcEIsTUFBTTs7S0FBQSxHQUFpQixJQUFBLHNCQUFBLE1BQUEsU0FBQSxFQUF2QixDQUFBO0lBQ0EsTUFBTSxTQUFBLEdBQVksTUFBTSxLQUFOLENBQVksVUFBWixDQUFsQixDQUFBO0lBQ0EsSUFBQSxzQkFBQSxtQkFBQSxDQUE4QyxPQUE5QyxDQUFBLENBQUE7R0FDRDs7Ozs7O0VBS0QseUJBQXlCLEdBQUc7SUFDMUIsTUFBTSxTQUFBLEdBQVksSUFBQSxrQkFBQSxrQkFBQSxDQUF5QyxhQUF6QyxDQUFsQixDQUFBOztJQUNBLElBQUksQ0FBQyxPQUFPLFNBQVosRUFBdUI7TUFDckIsTUFBTSxJQUFJLEtBQUosQ0FBVSx1Q0FBVixDQUFOLENBQUE7S0FDRDs7SUFDRCxPQUFPLE9BQU8sU0FBZCxDQUFBO0dBMTNEeUQ7Ozs7O0VBaTREbEMseUJBQUEsYUFBYSxTQUFTLElBQXRCLEVBQTRCO0lBQ25ELElBQUksY0FBYyxJQUFsQixDQUFBOztJQUNBLFFBQVEsVUFBUjtXQUNPLGdCQUFBLGFBQUEsT0FBTDtRQUNFLGNBQWMsaUJBQUEsUUFBQSxLQUFkLENBQUE7UUFDQSxNQUFBOztXQUNHLGdCQUFBLGFBQUEsT0FBTDtRQUNFLGNBQWMsdUJBQUEsUUFBQSxLQUFkLENBQUE7UUFDQSxNQUFBOztXQUNHLGdCQUFBLGFBQUEsR0FBTDtRQUNFLGNBQWMseUJBQUEsZ0JBQUEsS0FBZCxDQUFBO1FBQ0EsTUFBQTs7V0FDRyxnQkFBQSxhQUFBLFFBQUw7UUFDRSxjQUFjLGtCQUFBLFFBQUEsS0FBZCxDQUFBO1FBQ0EsTUFBQTs7O1FBRUEsTUFBTSxJQUFJLEtBQUosQ0FDSix5REFESSxDQUFOLENBQUE7S0FkSjs7SUFrQkEsSUFBSSxTQUFBLEdBQVksTUFBTSxJQUFBLGtCQUFBLGtCQUFBLENBQXlDLFdBQXpDLENBQXRCLENBQUE7O0lBQ0EsSUFBSSxDQUFDLE9BQUwsRUFBYztNQUNaLFVBQVUsTUFBTSxJQUFBLGtCQUFBLGNBQUEsQ0FBcUMsV0FBckMsQ0FBaEIsQ0FBQTtLQUNEOztJQUNELElBQUksTUFBTSxJQUFJLE9BQU8sVUFBckIsRUFBaUM7TUFDL0IsT0FBTyxVQUFQLENBQWtCLE1BQWxCLENBQUEsQ0FBQTtLQUNEOztJQUNELElBQUksVUFBVSxLQUFLLGdCQUFBLGFBQUEsUUFBbkIsRUFBeUM7TUFDdkMsT0FBTyxRQUFQLEdBQWtCLFVBQWxCLENBQUE7S0FDRDs7SUFDRCxJQUFJLFVBQVUsS0FBSyxnQkFBQSxhQUFBLE9BQW5CLEVBQXdDO01BQ3RDLE1BQU0sUUFBUSxPQUFPLFNBQVAsRUFBZCxDQUFBO01BQ0EsSUFBQSxtQkFBQSxlQUFBLENBQXVDLEtBQXZDLENBQUEsQ0FBQTtLQUNEOztJQUVELE9BQU8sUUFBUCxHQUFrQixJQUFBLGtCQUFBLGtCQUFBLEVBQUEsS0FBbEIsQ0FBQTtJQUVBLE9BQU8sT0FBUCxDQUFBO0dBQ0Q7O0VBRW1DLG9DQUFBLEdBQUc7SUFDckMsTUFBTSxVQUFVLE1BQU0sSUFBQSxvQkFBQSxDQUF5QixnQkFBQSxhQUFBLE9BQXpCLENBQXRCLENBQUE7SUFDQSxPQUFPLE1BQU0sT0FBTyxlQUFQLEVBQWIsQ0FBQTtHQUNEOztFQUV1Qyx3Q0FBQSxHQUFHO0lBQ3pDLE1BQU0sc0JBQ0osSUFBQSxzQkFBQSw2QkFBQSxFQURGLENBQUE7SUFFQSxPQUFPLE1BQU0sSUFBQSw2QkFBQSxDQUFrQyxtQkFBbEMsQ0FBYixDQUFBO0dBQ0Q7Ozs7Ozs7Ozs7O0VBVW9CLHFCQUFBLDJCQUEyQjtJQUM5QyxNQUFNLFVBQVUsTUFBTSxJQUFBLG9CQUFBLENBQXlCLFVBQXpCLEVBQXFDLE1BQXJDLENBQXRCLENBQUE7SUFDQSxJQUFJLFdBQVcsRUFBZixDQUFBOztJQUNBLFFBQVEsSUFBUjtXQUNPLENBQUMsQ0FBTjtRQUNFLFdBQVcsTUFBTSxPQUFPLGdCQUFQLEVBQWpCLENBQUE7UUFDQSxNQUFBOztXQUNHLENBQUw7UUFDRSxXQUFXLE1BQU0sT0FBTyxZQUFQLEVBQWpCLENBQUE7UUFDQSxNQUFBOzs7UUFFQSxXQUFXLE1BQU0sT0FBTyxhQUFQLEVBQWpCLENBQUE7S0FYMEM7Ozs7SUFnQjlDLE1BQU0sY0FBYyxNQUFNLElBQUEsa0JBQUEsWUFBQSxFQUExQixDQUFBO0lBQ0EsTUFBTSxrQkFBa0IsQ0FDdEIsR0FBRyxJQUFJLEdBQUosQ0FDRCxXQUFXLE9BQVgsQ0FBbUIsUUFBUSxJQUFSLENBQWMsS0FBTSxDQUFDLFFBQUQsWUFBQSxFQUFwQixDQUFuQixDQURDLENBRG1CLENBQXhCLENBQUE7SUFLQSxJQUFBLGVBQUEsa0JBQUEsQ0FBc0MsZUFBdEMsQ0FBQSxDQUFBO0lBQ0EsT0FBTyxRQUFQLENBQUE7R0FDRDs7Ozs7Ozs7OztFQVN3Qix5QkFBQSxxQkFBcUI7SUFDNUMsTUFBTSxVQUFVLE1BQU0sSUFBQSxvQkFBQSxDQUF5QixVQUF6QixFQUFxQyxNQUFyQyxDQUF0QixDQUFBO0lBQ0EsT0FBTyxPQUFPLFdBQVAsRUFBUCxDQUFBO0dBQ0Q7Ozs7Ozs7OztFQVFpQixrQkFBQSxhQUFhO0lBQzdCLE1BQU0sVUFBVSxNQUFNLElBQUEsb0JBQUEsQ0FBeUIsVUFBekIsQ0FBdEIsQ0FBQTtJQUNBLE9BQU8sYUFBUCxFQUFBLENBQUE7SUFDQSxPQUFPLElBQVAsQ0FBQTtHQUNEOzs7Ozs7Ozs7O0VBU21CLG9CQUFBLFVBQVU7SUFDNUIsTUFBTSxVQUFVLE1BQU0sSUFBQSxrQkFBQSxxQkFBQSxDQUE0QyxPQUE1QyxDQUF0QixDQUFBOztJQUNBLFFBQVEsT0FBTyxLQUFmO1dBQ08sZ0JBQUEsY0FBQSxPQUFMO1dBQ0ssZ0JBQUEsY0FBQSxRQUFMO1dBQ0ssZ0JBQUEsY0FBQSxHQUFMO1dBQ0ssZ0JBQUEsY0FBQSxPQUFMO1FBQ0UsT0FBTyxVQUFQLENBQUE7O1dBQ0csZ0JBQUEsY0FBQSxTQUFMO1FBQ0UsT0FBTyxVQUFQLENBQUE7OztRQUVBLE9BQU8sVUFBUCxDQUFBO0tBVEo7R0FXRDs7Ozs7Ozs7Ozs7RUFVbUIsb0JBQUEsVUFBVTtJQUM1QixNQUFNLFVBQVUsTUFBTSxJQUFBLGtCQUFBLHFCQUFBLENBQTRDLE9BQTVDLENBQXRCLENBQUE7O0lBQ0EsUUFBUSxPQUFPLEtBQWY7V0FDTyxnQkFBQSxjQUFBLE9BQUw7UUFDRSxPQUFPLE9BQU8sU0FBUCxFQUFQLENBQUE7O1dBQ0csZ0JBQUEsY0FBQSxHQUFMO1FBQ0UsT0FBTyxPQUFPLFFBQVAsRUFBUCxDQUFBOztXQUNHLGdCQUFBLGNBQUEsT0FBTDs7UUFFRSxPQUFPLGdCQUFBLGFBQUEsT0FBUCxDQUFBOztXQUNHLGdCQUFBLGNBQUEsUUFBTDs7UUFFRSxPQUFPLGdCQUFBLGFBQUEsUUFBUCxDQUFBOzs7UUFFQSxPQUFPLEtBQVAsQ0FBQTtLQVpKO0dBY0Q7Ozs7Ozs7O0VBUUQsZUFBZSxpQ0FBaUM7SUFDOUMsT0FBUSxDQUFBLEVBQUUsSUFBSSxDQUFDLENBQUQsQ0FBSixZQUFBLEVBQXNCLENBQUEsRUFBRSxJQUFJLE1BQUosQ0FBVyxDQUFYLENBQWMsQ0FBQSxDQUFBLEVBQzlDLFFBQVEsQ0FBQyxLQUFELEVBQVEsRUFBUixDQUFSLEdBQXNCLENBQ3ZCLENBQUEsQ0FBQSxFQUFHLGlCQUFpQixJQUFJLEVBQUcsQ0FBQSxDQUZyQixLQUFBLEVBQVAsQ0FBQTtHQUdEOzs7Ozs7Ozs7Ozs7RUFXZ0MsaUNBQUEsK0NBSy9CO0lBQ0EsTUFBTSxVQUFVLE1BQU0sSUFBQSxvQkFBQSxDQUF5QixVQUF6QixFQUFxQyxNQUFyQyxDQUF0QixDQUFBO0lBRUEsT0FBTyxtQkFBUCxDQUEyQixLQUEzQixDQUFBLENBQUE7SUFDQSxNQUFNLGNBQWMsTUFBTSxJQUFBLGtCQUFBLFlBQUEsRUFBMUIsQ0FBQTtJQUNBLE1BQU0sV0FBVyxNQUFNLElBQUEsa0JBQUEsY0FBQSxDQUFxQyxPQUFyQyxDQUF2QixDQUFBO0lBQ0EsTUFBTSxjQUFjLE1BQU0sSUFBQSxrQkFBQSxZQUFBLEVBQTFCLENBQUE7SUFDQSxJQUFBLHNCQUFBLGFBQUEsQ0FBd0MsV0FBeEMsQ0FBQSxDQUFBO0lBQ0EsV0FBVyxRQUFYLENBQXFCLFdBQVk7TUFDL0IsSUFBSSxDQUFDLFdBQVcsU0FBWCxDQUFxQixPQUFyQixDQUFMLEVBQW9DO1FBQ2xDLE1BQU0sUUFBUSxJQUFBLGdCQUFBLENBQ1osVUFBVSxLQUFLLGdCQUFBLGFBQUEsR0FBZixHQUFpQyxPQUFPLFFBQVAsRUFBakMsR0FBcUQsVUFEekMsRUFFWixLQUZZLEVBR1osaUJBSFksQ0FBZCxDQURrQzs7UUFPbEMsSUFBQSxzQkFBQSxnQkFBQSxDQUEyQyxPQUEzQyxFQUFvRCxLQUFwRCxDQUFBLENBUGtDOztRQVNsQyxJQUFBLHNCQUFBLG1CQUFBLENBQThDLE9BQTlDLENBQUEsQ0FBQTtPQUNEO0tBWEgsQ0FBQSxDQUFBO0lBY0EsTUFBTTs7S0FBQSxHQUFpQixJQUFBLHNCQUFBLE1BQUEsU0FBQSxFQUF2QixDQUFBO0lBQ0EsT0FBTyxFQUFFLEdBQUcsUUFBTDtNQUFlLFVBQUE7S0FBdEIsQ0FBQTtHQS9rRXlEOzs7Ozs7Ozs7Ozs7RUE0bEV4QyxtQkFBQSxlQUFlO0lBQ2hDLE1BQU0sZ0JBQUEsR0FDSixJQUFBLGtCQUFBLGtCQUFBLENBQXlDLGFBQXpDLENBREYsQ0FBQTs7SUFFQSxJQUFJLENBQUMsY0FBTCxFQUFxQjtNQUNuQixNQUFNLElBQUksS0FBSixDQUFVLDJDQUFWLENBQU4sQ0FBQTtLQUNEOztJQUNELE1BQU07O0tBQUEsR0FBd0IsSUFBOUIsQ0FBQTtJQUNBLE1BQU07O0tBQUEsR0FDSixJQUFBLHNCQUFBLE1BQUEsU0FBQSxFQURGLENBQUE7O0lBR0EsSUFBSSxNQUFNLEtBQU4sQ0FBWSxhQUFaLENBQUEsT0FBQSxLQUFzQyxZQUExQyxFQUF3RDtNQUN0RCxNQUFNLGNBQWMsTUFBTSxpQkFBaUIsWUFBakIsRUFBMUIsQ0FBQTtNQUNBLE1BQU0sV0FBVyxNQUFNLGlCQUFpQixjQUFqQixDQUFnQyxjQUFoQyxDQUF2QixDQUFBO01BQ0EsTUFBTSxjQUFjLE1BQU0saUJBQWlCLFlBQWpCLEVBQTFCLENBQUE7TUFFQSxNQUFNLElBQUEsaUJBQUEsRUFBTixDQUFBO01BRUEsSUFBQSxzQkFBQSxhQUFBLENBQXdDLFdBQXhDLENBQUEsQ0FBQTtNQUNBLFdBQVcsUUFBWCxDQUFxQixXQUFZO1FBQy9CLElBQUksQ0FBQyxXQUFXLFNBQVgsQ0FBcUIsT0FBckIsQ0FBTCxFQUFvQztVQUNsQyxJQUFBLHNCQUFBLG1CQUFBLENBQThDLE9BQTlDLENBQUEsQ0FBQTtTQUNEO09BSEgsQ0FBQSxDQUFBO01BTUEsTUFBTTs7T0FBQSxHQUFpQixJQUFBLHNCQUFBLE1BQUEsU0FBQSxFQUF2QixDQUFBO01BQ0EsT0FBTyxFQUFFLEdBQUcsUUFBTDtRQUFlLFVBQUE7T0FBdEIsQ0FBQTtLQUNEOztJQUVELE9BQU8sRUFDTCxHQUFHLGlCQUFpQixTQUFqQixTQUFBLEVBREU7TUFFTCxZQUFZLGFBQUE7S0FGZCxDQUFBO0dBSUQ7Ozs7Ozs7Ozs7Ozs7RUFZcUIsc0JBQUEsR0FBRztJQUN2QixNQUFNLGdCQUFBLEdBQ0osSUFBQSxrQkFBQSxrQkFBQSxDQUF5QyxhQUF6QyxDQURGLENBQUE7O0lBRUEsSUFBSSxDQUFDLGNBQUwsRUFBcUI7TUFDbkIsTUFBTSxJQUFJLEtBQUosQ0FBVSwyQ0FBVixDQUFOLENBQUE7S0FDRDs7SUFFRCxNQUFNLGFBQWEsTUFBTSxjQUFjLFVBQWQsRUFBekIsQ0FBQTtJQUNBLE1BQU0scUJBQXFCLE1BQU0sS0FBTixDQUFZLFVBQVUsU0FBdEIsQ0FBM0IsQ0FBQTtJQUVBLE1BQU0sV0FBVyxNQUFNLGNBQWMsWUFBZCxFQUF2QixDQUFBOztJQUNBLElBQUksUUFBUSxPQUFSLEdBQWtCLENBQXRCLEVBQXlCO01BQ3ZCLE1BQU0sSUFBSSxLQUFKLENBQVUsd0NBQVYsQ0FBTixDQUFBO0tBQ0Q7O0lBRUQsSUFBSTtNQUNGLE1BQU0sbUJBQUEsUUFBQSxlQUFBLENBQWtDLFFBQWxDLEVBQTRDLGtCQUE1QyxDQUFOLENBQUE7TUFDQSxPQUFPLEtBQUssS0FBTCxDQUFXLGtCQUFrQixPQUFsQixFQUFYLENBQVAsQ0FBQTtLQUZGLENBR0UsWUFBWTtNQUNaLFNBQUEsUUFBQSxNQUFBLENBQVUsR0FBRyxRQUFiLENBQUEsQ0FBQTs7TUFDQSxNQUFNLEdBQU4sQ0FBQTtLQUNEO0dBQ0Y7Ozs7Ozs7Ozs7RUFTaUIsa0JBQUEsR0FBRztJQUNuQixNQUFNLGtCQUFrQixJQUFBLHNCQUFBLG1CQUFBLEVBQXhCLENBQUE7SUFDQSxJQUFBLGFBQUEsaUJBQUEsQ0FBbUMsZUFBbkMsQ0FBQSxDQUFBO0lBQ0EsSUFBQSxrQkFBQSxnQkFBQSxFQUFBLENBQUE7SUFFQSxPQUFPLGVBQVAsQ0FBQTtHQUNEOzs7Ozs7Ozs7Ozs7RUFXeUIsMEJBQUEsU0FFeEI7SUFBRSw0QkFBNEIsSUFBQTtHQUE5QixHQUF1QyxFQUZmLEVBR3hCO0lBQ0EsSUFBSTtNQUNGLE9BQU8sTUFBTSxJQUFBLHFCQUFBLHdCQUFBLENBQ1gsTUFEVyxFQUVYLFlBQUEsa0JBQUEsYUFGVyxDQUFiLENBQUE7S0FERixDQUtFLGNBQWM7TUFDZCxJQUNFLHlCQUF5QixJQUN6QixLQUFLLEtBQUwsS0FBZSxhQUFBLFdBQUEsU0FBQSxhQUZqQixFQUdFO1FBQ0EsT0FBTyxFQUFQLENBQUE7T0FDRDs7TUFDRCxNQUFNLEtBQU4sQ0FBQTtLQUNEO0dBQ0Y7Ozs7Ozs7Ozs7Ozs7RUFZRCwyQkFBMkIsZ0JBQWdCO0lBQ3pDLElBQUEscUJBQUEsMEJBQUEsQ0FDRSxZQUFBLFlBQUEseUJBREYsRUFFRyxvQkFDQyxhQUFBLHVCQUFBLENBQ0UsWUFBQSxZQUFBLHlCQURGLENBQUEsY0FBQSxDQUVnQixhQUZoQixFQUUrQixnQkFGL0IsQ0FISixDQUFBLENBQUE7R0FPRDs7Ozs7Ozs7RUFPa0IsbUJBQUEsVUFBVTs7SUFFM0IsSUFBQSw0QkFBQSxDQUFpQyxPQUFqQyxDQUFBLENBRjJCOztJQUkzQixJQUFBLHNCQUFBLGNBQUEsQ0FBeUMsT0FBekMsQ0FBQSxDQUoyQjs7SUFNM0IsSUFBQSxlQUFBLGNBQUEsQ0FBa0MsQ0FBQyxPQUFELENBQWxDLENBQUEsQ0FBQTtJQUVBLE1BQU0sVUFBVSxNQUFNLElBQUEsa0JBQUEscUJBQUEsQ0FBNEMsT0FBNUMsQ0FBdEIsQ0FSMkI7O0lBVTNCLE1BQU0sSUFBQSxrQkFBQSxjQUFBLENBQXFDLE9BQXJDLENBQU4sQ0FBQTtJQUNBLE1BQU0seUJBQXlCLE9BQU8sR0FBRyxNQUFNLE9BQU8sWUFBUCxFQUFULEdBQWlDLEVBQXZFLENBQUE7O0lBQ0EsSUFBSSxDQUFBLHNCQUFzQixLQUFBLElBQXRCLElBQUEsc0JBQXNCLEtBQUEsS0FBQSxDQUF0QixHQUFBLEtBQUEsQ0FBQSxHQUFBLHNCQUFzQixPQUF0QixNQUFtQyxDQUF2QyxFQUEwQztNQUFBLElBQUEsZ0JBQUEsQ0FBQTs7TUFDeEMsQ0FBQSxtQkFBQSxPQUFPLFFBQVAsTUFBQSxJQUFBLElBQUEsZ0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxnQkFBQSxLQUFBLENBQUEsT0FBTyxDQUFBLENBQUE7S0FDUjs7SUFFRCxPQUFPLE9BQVAsQ0FBQTtHQUNEOzs7Ozs7Ozs7OztFQVU4QiwrQkFBQSxpQkFBaUI7SUFDOUMsTUFBTSxhQUFhLE1BQU0sd0JBQUEsUUFBQSxjQUFBLENBQThCLFFBQTlCLEVBQXdDLElBQXhDLENBQXpCLENBQUE7SUFDQSxNQUFNLFVBQVUsTUFBTSxJQUFBLGtCQUFBLGNBQUEsQ0FDcEIsaUJBRG9CLEVBRXBCLENBQUMsVUFBRCxDQUZvQixDQUF0QixDQUFBO0lBSUEsTUFBTSxjQUFBLEdBQWlCLE1BQU0sT0FBTyxZQUFQLEVBQTdCLENBTjhDOztJQVE5QyxNQUFNLGNBQWMsTUFBTSxJQUFBLGtCQUFBLFlBQUEsRUFBMUIsQ0FBQTtJQUNBLElBQUEsc0JBQUEsYUFBQSxDQUF3QyxXQUF4QyxDQUFBLENBVDhDOztJQVc5QyxNQUFNLElBQUEsc0JBQUEsbUJBQUEsQ0FBOEMsWUFBOUMsQ0FBTixDQUFBO0dBM3dFeUQ7Ozs7Ozs7Ozs7Ozs7RUF5eEU3Qiw4QkFBQSxnQkFBZ0I7SUFDNUMsT0FBTyxNQUFNLElBQUEsYUFBQSx5QkFBQSxDQUEyQyxRQUEzQyxFQUFxRCxHQUFyRCxDQUFiLENBQUE7R0ExeEV5RDs7Ozs7Ozs7Ozs7OztFQXd5RW5DLHdCQUFBLGlCQUFpQjtJQUN2QyxNQUFNLE9BQU8sQ0FBQSxDQUFBLEVBQUEsZUFBQSxpQkFBQSxFQUFpQixTQUFTLEtBQTFCLENBQWIsQ0FBQTtJQUNBLElBQUksT0FBSixDQUZ1Qzs7OztJQU12QyxJQUFJLElBQUksT0FBSixLQUFnQixFQUFoQixJQUFzQixJQUFJLE9BQUosS0FBZ0IsRUFBMUMsRUFBOEM7TUFDNUMsVUFBVSxJQUFBLGVBQUEsMEJBQUEsQ0FBOEMsU0FBOUMsRUFBeUQsR0FBekQsQ0FBVixDQUFBO01BQ0EsSUFBQSxXQUFBLEVBQUEsQ0FBQTtNQUNBLElBQUEsS0FBQSxxQkFBQSxFQUFBLENBQUE7S0FIRixNQUlPO01BQ0wsTUFBTSxhQUFBLFVBQUEsSUFBQSxjQUFBLENBQ0osd0NBREksQ0FBTixDQUFBO0tBR0Q7O0lBQ0QsT0FBTyxNQUFNLE9BQWIsQ0FBQTtHQUNEOzs7Ozs7Ozs7RUFTZ0IsaUJBQUEsWUFBWTtJQUMzQixTQUFBLFFBQUEsS0FBQSxDQUFTLGtDQUFULENBQUEsQ0FBQTs7SUFDQSxNQUFNLFFBQVEsU0FBUyxXQUF2QixDQUFBOztJQUNBLElBQUk7OztNQUdGLE1BQU0saUJBQWlCLE1BQU0sSUFBQSxlQUFBLGVBQUEsQ0FDM0IsU0FEMkIsQ0FBN0IsQ0FBQTtNQUdBLE1BQU0sU0FBUyxNQUFNLElBQUEsa0JBQUEsWUFBQSxDQUFtQyxjQUFuQyxDQUFyQixDQUFBO01BQ0EsSUFBQSxlQUFBLG1CQUFBLENBQXVDLEtBQXZDLEVBQThDLE1BQTlDLENBQUEsQ0FBQTtNQUNBLE9BQU8sSUFBQSxTQUFBLEVBQVAsQ0FBQTtLQVJGLENBU0UsY0FBYztNQUNkLFNBQUEsUUFBQSxLQUFBLENBQVMsc0NBQVQsRUFBaUQsS0FBakQsQ0FBQSxDQUFBOztNQUNBLElBQUEsZUFBQSxhQUFBLENBQWlDLEtBQWpDLEVBQXdDLEtBQXhDLENBQUEsQ0FBQTtNQUNBLE1BQU0sS0FBTixDQUFBO0tBQ0Q7R0FDRjs7Ozs7Ozs7RUFPRCxhQUFhLFFBQVE7SUFDbkIsTUFBTTs7S0FBQSxHQUFxQixJQUEzQixDQUFBO0lBQ0EsY0FBYyxVQUFkLENBQXlCLEtBQXpCLENBQUEsQ0FBQTtJQUNBLE9BQU8sSUFBQSxTQUFBLEVBQVAsQ0FBQTtHQTUxRXlEOzs7Ozs7Ozs7Ozs7OztFQTIyRTNCLGdDQUFBLGlCQUFpQjtJQUMvQyxNQUFNLFVBQVUsSUFBQSx1QkFBQSwwQkFBQSxDQUNkLFNBRGMsRUFFZCxHQUZjLENBQWhCLENBQUE7SUFJQSxJQUFBLFdBQUEsRUFBQSxDQUFBO0lBQ0EsSUFBQSxLQUFBLHFCQUFBLEVBQUEsQ0FBQTtJQUNBLE9BQU8sT0FBUCxDQUFBO0dBQ0Q7Ozs7Ozs7Ozs7RUFTd0IseUJBQUEsWUFBWTtJQUNuQyxTQUFBLFFBQUEsS0FBQSxDQUFTLDBDQUFULENBQUEsQ0FBQTs7SUFDQSxNQUFNLFFBQVEsU0FBUyxXQUF2QixDQUZtQzs7O0lBS25DLElBQUk7TUFDRixNQUFNLGlCQUFpQixNQUFNLElBQUEsdUJBQUEsZUFBQSxDQUMzQixTQUQyQixDQUE3QixDQUFBO01BR0EsTUFBTSxTQUFTLE1BQU0sSUFBQSxrQkFBQSxvQkFBQSxDQUNuQixjQURtQixDQUFyQixDQUpFOzs7TUFTRixJQUFBLHVCQUFBLG1CQUFBLENBQStDLEtBQS9DLEVBQXNELE1BQXRELENBQUEsQ0FBQTtNQUNBLE9BQU8sSUFBQSxTQUFBLEVBQVAsQ0FBQTtLQVZGLENBV0UsY0FBYztNQUNkLFNBQUEsUUFBQSxLQUFBLENBQVMsOENBQVQsRUFBeUQsS0FBekQsQ0FBQSxDQUFBOztNQUNBLElBQUEsdUJBQUEsYUFBQSxDQUF5QyxLQUF6QyxFQUFnRCxLQUFoRCxDQUFBLENBQUE7TUFDQSxNQUFNLEtBQU4sQ0FBQTtLQUNEO0dBQ0Y7Ozs7Ozs7O0VBT0QscUJBQXFCLFFBQVE7SUFDM0IsTUFBTSxpQkFBaUIsSUFBQSx1QkFBdkIsQ0FBQTtJQUNBLGNBQWMsVUFBZCxDQUF5QixLQUF6QixDQUFBLENBQUE7SUFDQSxPQUFPLElBQUEsU0FBQSxFQUFQLENBQUE7R0EzNUV5RDs7Ozs7Ozs7Ozs7RUF1NkU3Qiw4QkFBQSxpQkFBaUI7SUFDN0MsTUFBTSxVQUFVLElBQUEsc0JBQUEsMEJBQUEsQ0FDZCxTQURjLEVBRWQsR0FGYyxDQUFoQixDQUFBO0lBSUEsSUFBQSxXQUFBLEVBQUEsQ0FBQTtJQUNBLElBQUEsS0FBQSxxQkFBQSxFQUFBLENBQUE7SUFDQSxPQUFPLE9BQVAsQ0FBQTtHQUNEOzs7Ozs7Ozs7RUFReUIsMEJBQUEsWUFBWTtJQUNwQyxTQUFBLFFBQUEsS0FBQSxDQUFTLDJDQUFULENBQUEsQ0FEb0M7OztJQUdwQyxNQUFNLFFBQVEsU0FBUyxXQUF2QixDQUFBO0lBQ0EsTUFBTSxNQUFNLElBQUEsc0JBQUEsT0FBQSxDQUFrQyxLQUFsQyxDQUFaLENBQUE7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sV0FBVyxDQUFBLENBQUEsRUFBQSxlQUFBLGVBQUEsRUFBZSxTQUFTLEtBQXhCLENBQWpCLENBQUE7TUFDQSxNQUFNLE9BQU8sTUFBTSxLQUFOLENBQVksUUFBWixFQUFzQixLQUF0QixDQUFiLENBQUE7TUFDQSxTQUFTLEtBQVQsR0FBaUIsSUFBSSxNQUFKLENBQVcsSUFBSSxTQUFKLENBQWMsTUFBZCxDQUFYLENBQWpCLENBQUE7TUFFQSxHQUFHLFFBQUgsR0FBYyxNQUFNLElBQUEsa0JBQUEsZUFBQSxDQUFzQyxTQUF0QyxDQUFwQixDQUFBO0tBTEYsQ0FNRSxVQUFVO01BQ1YsR0FBRyxNQUFILEdBQVksQ0FBQyxRQUFiLENBQUE7S0FDRDs7SUFDRCxJQUFBLHNCQUFBLFdBQUEsQ0FBc0MsR0FBdEMsQ0FBQSxDQUFBOztJQUVBLE9BQU8sSUFBQSxTQUFBLEVBQVAsQ0FBQTtHQUNEOzs7Ozs7Ozs7O0VBU21CLG9CQUFBLFlBQVk7SUFDOUIsU0FBQSxRQUFBLEtBQUEsQ0FBUyxxQ0FBVCxDQUFBLENBQUE7O0lBQ0EsTUFBTSxRQUFRLFNBQVMsV0FBdkIsQ0FGOEI7OztJQUs5QixJQUFJO01BQ0YsTUFBTSxpQkFBaUIsTUFBTSxJQUFBLHNCQUFBLGVBQUEsQ0FDM0IsU0FEMkIsQ0FBN0IsQ0FBQTtNQUlBLE1BQU0sV0FBVyxDQUFBLENBQUEsRUFBQSxlQUFBLGVBQUEsRUFBZSxjQUFjLEtBQTdCLENBQWpCLENBQUE7TUFDQSxNQUFNLE9BQU8sTUFBTSxLQUFOLENBQVksUUFBWixFQUFzQixLQUF0QixDQUFiLENBQUE7TUFDQSxjQUFjLEtBQWQsR0FBc0IsSUFBSSxNQUFKLENBQVcsSUFBSSxTQUFKLENBQWMsTUFBZCxDQUFYLENBQXRCLENBUEU7O01BVUYsTUFBTSxVQUFVLE1BQU0sSUFBQSxrQkFBQSxlQUFBLENBQ3BCLGNBRG9CLENBQXRCLENBVkU7O01BY0YsSUFBQSxzQkFBQSxzQkFBQSxDQUFpRCxLQUFqRCxFQUF3RCxPQUF4RCxDQUFBLENBQUE7S0FkRixDQWVFLGNBQWM7TUFDZCxTQUFBLFFBQUEsS0FBQSxDQUFTLDBDQUFULEVBQXFELEtBQXJELENBQUEsQ0FBQTs7TUFDQSxJQUFBLHNCQUFBLGFBQUEsQ0FBd0MsS0FBeEMsRUFBK0MsS0FBL0MsQ0FBQSxDQUFBO0tBQ0Q7O0lBQ0QsT0FBTyxJQUFBLFNBQUEsRUFBUCxDQUFBO0dBQ0Q7Ozs7Ozs7O0VBT0Qsb0JBQW9CLFFBQVE7SUFDMUIsTUFBTSxpQkFBaUIsSUFBQSxzQkFBdkIsQ0FBQTtJQUNBLGNBQWMsVUFBZCxDQUF5QixLQUF6QixDQUFBLENBQUE7SUFDQSxPQUFPLElBQUEsU0FBQSxFQUFQLENBQUE7R0FwL0V5RDs7Ozs7Ozs7Ozs7RUFnZ0Z4QixtQ0FBQSxpQkFBaUI7SUFDbEQsTUFBTSxVQUFVLFNBQWhCLENBQUE7SUFDQSxNQUFNLFVBQVUsTUFBTSxJQUFBLGtCQUFBLHFCQUFBLENBQTRDLE9BQTVDLENBQXRCLENBQUE7O0lBRUEsUUFBUSxPQUFPLEtBQWY7V0FDTyxnQkFBQSxjQUFBLE9BQUw7UUFBMkI7VUFDekIsT0FBTyxJQUFJLE9BQUosQ0FBWSxlQUFlO1lBQ2hDLE1BQU0sQ0FDSixJQUFJLEtBQUosQ0FBVSxxREFBVixDQURJLENBQU4sQ0FBQTtXQURLLENBQVAsQ0FBQTtTQUtEOztXQUVJLGdCQUFBLGNBQUEsT0FBTDtRQUEyQjtVQUN6QixPQUFPLElBQUksT0FBSixDQUFZLGVBQWU7WUFDaEMsTUFBTSxDQUNKLElBQUksS0FBSixDQUFVLHFEQUFWLENBREksQ0FBTixDQUFBO1dBREssQ0FBUCxDQUFBO1NBS0Q7O1dBRUksZ0JBQUEsY0FBQSxRQUFMO1FBQTRCO1VBQzFCLE9BQU8sSUFBSSxPQUFKLENBQVksZUFBZTtZQUNoQyxNQUFNLENBQ0osSUFBSSxLQUFKLENBQVUsc0RBQVYsQ0FESSxDQUFOLENBQUE7V0FESyxDQUFQLENBQUE7U0FLRDs7V0FFSSxnQkFBQSxjQUFBLEdBQUw7UUFBdUI7VUFDckIsT0FBTyxPQUFPLE9BQVAsQ0FDTCxJQUFJLEtBQUosQ0FBVSwwREFBVixDQURLLENBQVAsQ0FBQTtTQUdEOzs7UUFFUTtVQUNQLE1BQU0sVUFDSixJQUFBLDJCQUFBLDBCQUFBLENBQ0UsU0FERixFQUVFLEdBRkYsQ0FERixDQUFBO1VBS0EsSUFBQSxXQUFBLEVBQUEsQ0FBQTtVQUNBLElBQUEsS0FBQSxxQkFBQSxFQUFBLENBQUE7VUFDQSxPQUFPLE9BQVAsQ0FBQTtTQUNEO0tBeENIO0dBMENEOzs7Ozs7Ozs7O0VBU3dCLHlCQUFBLFlBQVk7SUFDbkMsU0FBQSxRQUFBLEtBQUEsQ0FBUywwQ0FBVCxDQUFBLENBQUE7O0lBQ0EsTUFBTSxRQUFRLFNBQVMsV0FBdkIsQ0FGbUM7OztJQUtuQyxJQUFJO01BQ0YsTUFBTSxTQUFTLE1BQU0sSUFBQSwyQkFBQSxlQUFBLENBQ25CLFNBRG1CLENBQXJCLENBREU7O01BTUYsTUFBTSxZQUFZLE1BQU0sSUFBQSxrQkFBQSx1QkFBQSxDQUN0QixNQUFNLEtBRGdCLENBQXhCLENBTkU7OztNQVlGLElBQUEsMkJBQUEscUJBQUEsQ0FBcUQsS0FBckQsRUFBNEQsU0FBNUQsQ0FBQSxDQUFBO0tBWkYsQ0FhRSxjQUFjO01BQ2QsU0FBQSxRQUFBLEtBQUEsQ0FDRSx5REFERixFQUVFLEtBRkYsQ0FBQSxDQUFBOztNQUlBLElBQUEsMkJBQUEsYUFBQSxDQUE2QyxLQUE3QyxFQUFvRCxLQUFwRCxDQUFBLENBQUE7S0FDRDs7SUFDRCxPQUFPLElBQUEsU0FBQSxFQUFQLENBQUE7R0FDRDs7Ozs7Ozs7RUFPRCx5QkFBeUIsUUFBUTtJQUMvQixNQUFNLGlCQUFpQixJQUFBLDJCQUF2QixDQUFBO0lBQ0EsY0FBYyxVQUFkLENBQXlCLEtBQXpCLENBQUEsQ0FBQTtJQUNBLE9BQU8sSUFBQSxTQUFBLEVBQVAsQ0FBQTtHQTNsRnlEOzs7Ozs7Ozs7OztFQXVtRjNELHVCQUF1QiwwQkFBMEI7SUFDL0MsTUFBTSxVQUFVLElBQUEsb0JBQUEsMEJBQUEsQ0FDZCxTQURjLEVBRWQsR0FGYyxFQUdkLE9BSGMsQ0FBaEIsQ0FBQTtJQUtBLElBQUEsV0FBQSxFQUFBLENBQUE7SUFDQSxJQUFBLEtBQUEscUJBQUEsRUFBQSxDQUFBO0lBQ0EsT0FBTyxPQUFQLENBQUE7R0FDRDs7Ozs7Ozs7OztFQVNxQixzQkFBQSxZQUFZO0lBQ2hDLFNBQUEsUUFBQSxLQUFBLENBQVMsd0NBQVQsQ0FBQSxDQUFBOztJQUNBLE1BQU0sUUFBUSxTQUFTLFdBQXZCLENBQUE7SUFDQSxNQUFNOztLQUFBLEdBQWMsU0FBcEIsQ0FBQTs7SUFDQSxJQUFJO01BQ0YsTUFBTSxpQkFBaUIsTUFBTSxJQUFBLG9CQUFBLGVBQUEsQ0FDM0IsU0FEMkIsQ0FBN0IsQ0FERTs7TUFNRixJQUFJLE9BQU8sS0FBSyxJQUFoQixFQUFzQjs7UUFFcEIsSUFBSSxPQUFPLGNBQWMsS0FBckIsS0FBK0IsUUFBbkMsRUFBNkM7VUFDM0MsY0FBYyxLQUFkLEdBQXNCLElBQUksTUFBSixDQUFXLGNBQWMsS0FBekIsQ0FBdEIsQ0FBQTtTQUNEO09BQ0Y7O01BRUQsTUFBTSxZQUFZLE1BQU0sSUFBQSxrQkFBQSxpQkFBQSxDQUN0QixjQURzQixFQUV0QjtRQUFFLE9BQUE7T0FGb0IsQ0FBeEIsQ0FBQTtNQUlBLElBQUEsb0JBQUEsbUJBQUEsQ0FBNEMsS0FBNUMsRUFBbUQsU0FBbkQsQ0FBQSxDQUFBO01BQ0EsT0FBTyxJQUFBLFNBQUEsRUFBUCxDQUFBO0tBbEJGLENBbUJFLGNBQWM7TUFDZCxTQUFBLFFBQUEsS0FBQSxDQUFTLGdEQUFULEVBQTJELEtBQTNELENBQUEsQ0FBQTs7TUFDQSxJQUFBLG9CQUFBLGFBQUEsQ0FBc0MsS0FBdEMsRUFBNkMsS0FBN0MsQ0FBQSxDQUFBO01BQ0EsTUFBTSxLQUFOLENBQUE7S0FDRDtHQUNGOzs7Ozs7OztFQU9ELGtCQUFrQixRQUFRO0lBQ3hCLE1BQU0saUJBQWlCLElBQUEsb0JBQXZCLENBQUE7SUFDQSxjQUFjLFVBQWQsQ0FBeUIsS0FBekIsQ0FBQSxDQUFBO0lBQ0EsT0FBTyxJQUFBLFNBQUEsRUFBUCxDQUFBO0dBQ0Q7Ozs7OztFQUswQywyQ0FBQSxHQUFHO0lBQzVDLE9BQU8sSUFBUCxDQUFBO0dBdHFGeUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUEwckY5Qiw2QkFBQSwyQ0FBMkM7SUFDdEUsTUFBTSxJQUFBLGFBQUEsd0JBQUEsQ0FDSixZQURJLEVBRUosaUJBRkksRUFHSixPQUhJLENBQU4sQ0FBQTtJQUtBLE1BQU0sUUFBUSxNQUFNLElBQUEsU0FBQSxFQUFwQixDQUFBO0lBQ0EsT0FBTyxLQUFQLENBQUE7R0FDRDs7Ozs7Ozs7Ozs7Ozs7OztFQWU2Qiw4QkFBQSwyQ0FBMkM7SUFDdkUsTUFBTSxJQUFBLGFBQUEseUJBQUEsQ0FDSixZQURJLEVBRUosaUJBRkksRUFHSixPQUhJLENBQU4sQ0FBQTtJQUtBLE1BQU0sUUFBUSxNQUFNLElBQUEsU0FBQSxFQUFwQixDQUFBO0lBQ0EsT0FBTyxLQUFQLENBQUE7R0FDRDs7RUFFRCxXQUFXLG9CQUFvQjtJQUM3QixPQUFPLElBQUksT0FBSixDQUFZLHFCQUFxQjtNQUN0QyxPQUFPLElBQUEsYUFBQSxVQUFBLE1BQUEsWUFBQSxDQUNMLGlCQURLLEVBRUwsY0FBYztRQUNaLElBQUksR0FBSixFQUFTO1VBQ1AsT0FBTyxNQUFNLENBQUMsR0FBRCxDQUFiLENBQUE7U0FDRDs7UUFFRCxPQUFPLE9BQU8sQ0FBQyxHQUFHLFNBQUgsQ0FBYSxFQUFiLENBQUQsQ0FBZCxDQUFBO09BUEcsQ0FBUCxDQUFBO0tBREssQ0FBUCxDQUFBO0dBNXRGeUQ7Ozs7Ozs7OztFQWl2RjNELHFCQUFxQixHQUFHO0lBQ3RCLElBQUEsc0JBQUEscUJBQUEsQ0FBZ0QsSUFBaEQsQ0FBQSxDQUFBO0lBQ0EsSUFBQSxXQUFBLEVBQUEsQ0FBQTtHQUNEOzs7Ozs7RUFLRCx1QkFBdUIsR0FBRztJQUN4QixJQUFBLHNCQUFBLHFCQUFBLENBQWdELEtBQWhELENBQUEsQ0FBQTtJQUNBLElBQUEsV0FBQSxFQUFBLENBQUE7R0EzdkZ5RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMHhGM0QsMkJBQTJCLENBQUM7Ozs7R0FBRCxFQUE0QztJQUNyRSxNQUFNOztLQUFBLEdBQXFCLElBQUEsc0JBQUEsTUFBQSxTQUFBLEVBQTNCLENBQUE7O0lBRUEsSUFBSSxZQUFKLENBQUE7O0lBQ0EsSUFBSSxXQUFKLEVBQWlCO01BQ2YsZUFBZSxXQUFmLENBQUE7S0FERixNQUVPLElBQUksTUFBTSxHQUFOLElBQWEsTUFBTSxHQUFOLEtBQWMsSUFBQSxVQUFBLFFBQUEsR0FBL0IsRUFBMEQ7TUFDL0QsZUFBZSxJQUFBLGNBQUEsVUFBZixDQUFBO0tBREssTUFFQTtNQUNMLGVBQWUsSUFBQSxjQUFBLFFBQWYsQ0FBQTtLQUNEOztJQUVELElBQUksTUFBTSxJQUFWLEVBQWdCO01BQ2QsTUFBTTs7T0FBQSxHQUFlLElBQUksR0FBSixDQUFRLE1BQU0sSUFBZCxDQUFyQixDQUFBO01BQ0EsTUFBTSw0QkFBNEIsSUFBQSxtQkFBQSxZQUFBLEVBQWxDLENBQUE7O01BQ0EsSUFBSSx5QkFBSixFQUErQjtRQUM3QixJQUFBLG1CQUFBLG9CQUFBLEVBQUEsQ0FBQTtPQUpZOzs7TUFPZCxNQUFNLHVCQUF1QixJQUFBLG1CQUFBLEtBQUEsQ0FBNkIsUUFBN0IsQ0FBN0IsQ0FBQTs7TUFDQSxJQUFJLGNBQWMsSUFBSSxvQkFBSixLQUFBLElBQUEsSUFBSSxvQkFBSixLQUFBLEtBQUEsQ0FBQSxJQUFJLG9CQUFvQixPQUExQyxFQUFvRDtRQUNsRCxJQUFBLG9CQUFBLENBQ0UsZ0JBREYsRUFFRSxRQUZGLEVBR0Usb0JBSEYsQ0FBQSxDQUFBO1FBS0EsT0FBQTtPQUNEO0tBM0JrRTs7O0lBK0JyRSxNQUFNLE1BQU0sQ0FBQSxDQUFBLEVBQUEsWUFBQSxlQUFBLEVBQWUsZ0JBQWYsQ0FBWixDQS9CcUU7O0lBa0NyRSxJQUFBLHdCQUFBLENBQ0UsR0FBRyxhQUFILENBQWlCLG1CQUFqQixDQURGLEVBRUUsTUFGRixFQUdFLFlBSEYsQ0FBQSxDQWxDcUU7O0lBeUNyRSxJQUFJLE1BQU0sSUFBVixFQUFnQjs7TUFFZCxJQUFBLGtCQUFBLENBQXVCLEdBQUcsYUFBSCxDQUFpQixjQUFqQixDQUF2QixDQUFBLENBQUE7S0FDRDtHQUNGOzs7Ozs7Ozs7Ozs7RUFXRCx5QkFBeUIsMkJBQTJCOztJQUVsRCxNQUFNLE1BQU0sQ0FBQSxDQUFBLEVBQUEsWUFBQSxlQUFBLEVBQWUsZ0JBQWYsQ0FBWixDQUZrRDs7SUFJbEQsSUFBQSwwQkFBQSxDQUErQixHQUFHLGFBQUgsQ0FBaUIsWUFBakIsQ0FBL0IsQ0FBQSxDQUFBO0lBQ0EsSUFBQSx3QkFBQSxDQUNFLEdBQUcsYUFBSCxDQUFpQixVQUFqQixDQURGLEVBRUUsTUFGRixFQUdFLElBQUEsY0FBQSxTQUhGLENBQUEsQ0FBQTtHQUtEOzs7Ozs7Ozs7RUFRRCwwQkFBMEIsQ0FBQzs7R0FBRCxFQUF1QjtJQUMvQyxNQUFNOztLQUFBLEdBQXFCLElBQUEsc0JBQUEsTUFBQSxTQUFBLEVBQTNCLENBQUE7O0lBRUEsSUFBSSxDQUFDLGNBQUwsRUFBcUI7TUFDbkIsT0FBQTtLQUo2Qzs7O0lBUS9DLE1BQU0sTUFBTSxDQUFBLENBQUEsRUFBQSxZQUFBLGVBQUEsRUFBZSxnQkFBZixDQUFaLENBQUE7SUFDQSxNQUFNLGlCQUFpQixHQUFHLGFBQUgsQ0FBaUIsaUJBQWpCLENBQXZCLENBVCtDOztJQVkvQyxjQUFjLEdBQWQsQ0FDRSxNQURGLEVBRUUsQ0FBQSxDQUFBLEVBQUEscUJBQUEsUUFBQSxFQUNFO01BQUUsd0JBQXdCLElBQUEsdUJBQUEsS0FBQSxDQUFpQyxJQUFqQyxDQUFBO0tBRDVCLEVBRUUsY0FGRixDQUZGLENBQUEsQ0FBQTtHQU9EOzs7Ozs7Ozs7Ozs7OztFQWFELG1CQUFtQixtREFBbUQ7SUFDcEUsTUFBTSxjQUFjLFNBQUEsd0JBQUEsQ0FBd0Isb0JBQXhCLEtBQUEsSUFBQSxJQUF3QixvQkFBeEIsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBd0Isb0JBQW9CLEtBQTVDLENBQXBCLENBQUE7SUFFQSxNQUFNLE1BQU0sQ0FBQSxDQUFBLEVBQUEsWUFBQSxlQUFBLEVBQWUsZ0JBQWYsQ0FBWixDQUFBO0lBQ0EsTUFBTSxpQkFBaUIsR0FBRyxhQUFILENBQWlCLFVBQWpCLENBQXZCLENBQUE7SUFDQSxjQUFjLE1BQWQsQ0FBcUI7TUFBRSxRQUFGO01BQVksV0FBQTtLQUFqQyxDQUFBLENBQUE7R0FDRDs7Ozs7Ozs7RUFPRCx5QkFBeUIsWUFBWTtJQUNuQyxNQUFNLE1BQU0sSUFBQSxPQUFBLEVBQVosQ0FEbUM7O0lBSW5DLElBQUEsNEJBQUEsSUFBb0MsQ0FBcEMsQ0FBQTtJQUNBLElBQUEsS0FBQSxDQUFVLDZCQUFWLEVBQXlDLElBQUEsNEJBQXpDLENBQUEsQ0FMbUM7O0lBUW5DLFNBQVMsR0FBVCxDQUNFLE1BREYsRUFFRSxDQUFBLENBQUEsRUFBQSxxQkFBQSxRQUFBLEVBQ0UsR0FERixFQUVFLFNBRkYsRUFHRSxJQUFBLE1BSEYsRUFJRSxJQUFBLHFCQUpGLENBRkYsQ0FBQSxDQUFBOztJQVNBLE1BQU0sZUFBZ0IsVUFBVztNQUMvQixJQUFJLFNBQVMsZUFBVCxNQUFKLEVBQW9DO1FBQ2xDLE9BQUE7T0FGNkI7OztNQUsvQixTQUFTLE1BQVQsQ0FBZ0I7UUFDZCxTQUFTLEtBREs7UUFFZCxRQUFRLFlBRk07UUFHZCxRQUFRLENBQUMsTUFBRCxDQUFBO09BSFYsQ0FBQSxDQUFBO0tBTEYsQ0FBQTs7SUFXQSxJQUFBLEdBQUEsQ0FBUSxRQUFSLEVBQWtCLFlBQWxCLENBQUEsQ0FBQTtJQUNBLFNBQVMsR0FBVCxDQUFhLEtBQWIsRUFBb0IsTUFBTTtNQUN4QixJQUFBLDRCQUFBLElBQW9DLENBQXBDLENBQUE7TUFDQSxJQUFBLEtBQUEsQ0FDRSw2QkFERixFQUVFLElBQUEsNEJBRkYsQ0FBQSxDQUFBO01BSUEsSUFBQSxlQUFBLENBQW9CLFFBQXBCLEVBQThCLFlBQTlCLENBQUEsQ0FBQTtLQU5GLENBQUEsQ0FBQTtHQVFEOzs7Ozs7Ozs7O0VBU0QsdUJBQXVCLGlDQUFpQztJQUN0RCxJQUFJLE1BQUosQ0FBQTs7SUFDQSxJQUFJLFdBQVcsS0FBSyxJQUFBLGNBQUEsU0FBcEIsRUFBNEM7TUFDMUMsU0FBUyxJQUFBLGdCQUFULENBQUE7S0FERixNQUdLO01BQ0gsU0FBUyxJQUFJLEdBQUosQ0FBUSxNQUFNLElBQWQsQ0FBQSxPQUFULENBQUE7S0FDRDs7SUFFRCxJQUFJLE1BQU0sR0FBTixJQUFhLE1BQU0sR0FBTixLQUFjLElBQUEsVUFBQSxRQUFBLEdBQS9CLEVBQTBEO01BQ3hELElBQUEsMEJBQUEsbUJBQUEsQ0FBa0Q7UUFDaEQsTUFEZ0Q7UUFFaEQsYUFBYSxNQUFNLEdBRjZCO1FBR2hELGFBQWEsSUFBQSxjQUFBLFVBQWM7T0FIN0IsQ0FBQSxDQUFBO0tBS0Q7O0lBRUQsSUFBSSxLQUFKLENBQUE7O0lBQ0EsSUFBSSxNQUFNLElBQU4sSUFBYyxNQUFNLElBQU4sR0FBbEIsRUFBaUM7TUFDL0IsUUFBUSxNQUFNLElBQU4sR0FBUixDQUFBO0tBQ0Q7O0lBRUQsTUFBTSxTQUFTLElBQUEsb0JBQUEsQ0FBeUI7TUFDdEMsTUFEc0M7TUFFdEMsTUFGc0M7TUFHdEMsV0FIc0M7TUFJdEMsS0FBQTtLQUphLENBQWYsQ0F0QnNEOztJQThCdEQsTUFBTSxpQkFBaUIsQ0FBQSxDQUFBLEVBQUEsYUFBQSxRQUFBLEVBQW1CO01BQUUsTUFBQTtLQUFyQixDQUF2QixDQUFBO0lBRUEsTUFBTSxlQUFlLElBQUEsY0FBQSxDQUFtQixNQUFuQixFQUEyQjtNQUFFLE1BQUE7S0FBN0IsQ0FBckIsQ0FBQTtJQUVBLENBQUEsQ0FBQSxFQUFBLEtBQUEsUUFBQSxFQUFLLFNBQUwsRUFBZ0IsY0FBaEIsRUFBZ0MsU0FBaEMsRUFBNEMsT0FBUTs7TUFFbEQsTUFBTSxZQUFOLFFBQUEsQ0FBNEIsT0FBUTtRQUNsQyxJQUFJLEdBQUcsUUFBSCxJQUFlLE9BQU8sR0FBRyxRQUFWLEtBQXVCLFVBQTFDLEVBQXNEO1VBQ3BELEdBQUcsUUFBSCxFQUFBLENBQUE7U0FDRDtPQUhILENBQUEsQ0FBQTs7TUFLQSxZQUFZLElBQUksSUFBQSxpQkFBQSxDQUFzQixNQUF0QixFQUE4QixZQUE5QixDQUFoQixDQUFBOztNQUNBLElBQUksR0FBSixFQUFTO1FBQ1AsU0FBQSxRQUFBLE1BQUEsQ0FBVSxHQUFWLENBQUEsQ0FBQTtPQUNEO0tBVkgsQ0FBQSxDQUFBO0dBWUQ7Ozs7Ozs7Ozs7OztFQVlELG1CQUFtQixDQUFDOzs7OztHQUFELEVBQXlDOztJQUUxRCxNQUFNLFNBQVMsSUFBSSxjQUFBLGNBQUosRUFBZixDQUFBO0lBQ0EsTUFBTTs7O0tBQUEsR0FBNkIsSUFBbkMsQ0FIMEQ7O0lBTTFELE1BQU0sbUJBQW1CLENBQUEsQ0FBQSxFQUFBLGtCQUFBLFFBQUEsRUFBdUI7TUFBRSxRQUFGO01BQVksWUFBQTtLQUFuQyxDQUF6QixDQU4wRDs7SUFTMUQsTUFBTSxzQkFBc0IsQ0FBQSxDQUFBLEVBQUEsb0JBQUEsUUFBQSxFQUEwQjtNQUNwRCxRQURvRDtNQUVwRCxZQUFBO0tBRjBCLENBQTVCLENBQUE7SUFJQSxtQkFBbUIsT0FBbkIsR0FBQSxDQUE4QixjQUE5QixFQUErQyxXQUM3QyxNQUFNLEtBQU4sQ0FBWSxjQUFaLEVBQTRCLE9BQTVCLENBREYsQ0FBQSxDQWIwRDs7SUFrQjFELE1BQU0sS0FBTixDQUFZLENBQUEsQ0FBQSxFQUFBLHVCQUFBLFFBQUEsRUFBdUI7TUFBRSxNQUFBO0tBQXpCLENBQVosQ0FBQSxDQWxCMEQ7O0lBcUIxRCxJQUFJLEtBQUosRUFBVztNQUNULE1BQU0sS0FBTixDQUFZLENBQUEsQ0FBQSxFQUFBLHNCQUFBLFFBQUEsRUFBc0I7UUFBRSxLQUFBO09BQXhCLENBQVosQ0FBQSxDQUFBO0tBdEJ3RDs7O0lBMEIxRCxNQUFNLEtBQU4sQ0FBWSxDQUFBLENBQUEsRUFBQSx1QkFBQSxRQUFBLEVBQXVCO01BQUUsTUFBQTtLQUF6QixDQUFaLENBQUEsQ0FBQTtJQUNBLE1BQU0sS0FBTixDQUFZLElBQUEsd0JBQUEsaUJBQUEsRUFBWixDQUFBLENBQUE7SUFFQSxNQUFNLEtBQU4sQ0FDRSxDQUFBLENBQUEsRUFBQSxrQ0FBQSxRQUFBLEVBQWtDO01BQ2hDLFlBQVksSUFBQSxzQkFBQSxXQUFBLEtBQUEsQ0FDVixJQUFBLHNCQURVLENBRG9CO01BSWhDLGlCQUFpQixJQUFBLHNCQUFBLE1BQUEsU0FBQSxLQUFBLENBQ2YsSUFBQSxzQkFBQSxNQURlLENBQUE7S0FKbkIsQ0FERixDQUFBLENBN0IwRDs7SUF5QzFELElBQUksV0FBVyxLQUFLLElBQUEsY0FBQSxRQUFwQixFQUEyQztNQUN6QyxNQUFNLEtBQU4sQ0FDRSxDQUFBLENBQUEsRUFBQSwyQkFBQSxRQUFBLEVBQTJCO1FBQ3pCLFVBQVUsTUFBTSxJQURTO1FBRXpCLG9CQUFvQixJQUFBLHFCQUFBLG1CQUEwQjtPQUZoRCxDQURGLENBQUEsQ0FBQTtLQTFDd0Q7OztJQW1EMUQsTUFBTSxLQUFOLENBQ0UsQ0FBQSxDQUFBLEVBQUEsb0JBQUEsdUJBQUEsRUFBdUI7TUFDckIsTUFEcUI7TUFHckIsV0FIcUI7O01BTXJCLG9CQUNFLElBQUEsMEJBQUEsbUJBQUEsS0FBQSxDQUNFLElBQUEsMEJBREYsQ0FQbUI7TUFVckIsa0JBQWtCLElBQUEsaUJBQUEsS0FBQSxDQUEyQixJQUEzQixDQVZHO01BV3JCLGtCQUFrQixJQUFBLG1CQUFBLGlCQUFBLEtBQUEsQ0FDaEIsSUFBQSxtQkFEZ0IsQ0FYRztNQWNyQix5QkFBeUIsSUFBQSxpQkFBQSxXQUFBLEtBQUEsQ0FDdkIsSUFBQSxpQkFEdUIsQ0FkSjtNQWlCckIscUJBQ0UsSUFBQSxtQkFBQSwwQkFBQSxLQUFBLENBQ0UsSUFBQSxtQkFERixDQWxCbUI7TUFxQnJCLGFBQWEsSUFBQSxzQkFBQSxXQUFBLEtBQUEsQ0FDWCxJQUFBLHNCQURXLENBckJROztNQTBCckIsYUFBYSxJQUFBLHFCQUFBLEtBQUEsQ0FBK0IsSUFBL0IsRUFBcUMsTUFBckMsQ0ExQlE7TUEyQnJCLHlCQUF5QixJQUFBLHFCQUFBLGVBQUEsS0FBQSxDQUN2QixJQUFBLHFCQUR1QixFQUV2QixNQUZ1QixDQTNCSjtNQStCckIsZUFBZSxJQUFBLHFCQUFBLGNBQUEsS0FBQSxDQUNiLElBQUEscUJBRGEsRUFFYixNQUZhLENBL0JNO01BbUNyQiwyQkFDRSxJQUFBLHFCQUFBLG1CQUFBLEtBQUEsQ0FDRSxJQUFBLHFCQURGLEVBRUU7UUFBRSxNQUFBO09BRkosRUFHRTtRQUFFLGNBQWMsRUFBQTtPQUhsQixDQXBDbUI7TUF5Q3JCLDZCQUNFLElBQUEscUJBQUEsbUJBQUEsS0FBQSxDQUNFLElBQUEscUJBREYsRUFFRTtRQUFFLE1BQUE7T0FGSixDQTFDbUI7O01BZ0RyQixjQUFjLE9BQU87Ozs7OztPQUFBLEdBTWpCLEVBTlUsS0FNSDtRQUNULE1BQU0sSUFBQSxzQkFBQSxxQkFBQSxDQUNKLE1BREksRUFFSixPQUZJLEVBR0osTUFISSxFQUlKLFNBSkksRUFLSjtVQUNFLGdCQUFBO1NBTkUsQ0FBTixDQUFBO09BdkRtQjtNQWlFckIsaUJBQWlCLElBQUEsZ0JBQUEsS0FBQSxDQUEwQixJQUExQixDQWpFSTtNQWtFckIsbUJBQW1CLElBQUEsa0JBQUEsa0JBQUEsS0FBQSxDQUNqQixJQUFBLGtCQURpQixDQWxFRTtNQXFFckIsa0JBQWtCLElBQUEsa0JBQUEsaUJBQUEsS0FBQSxDQUNoQixJQUFBLGtCQURnQixDQXJFRztNQXdFckIsaUJBQWlCLElBQUEsa0JBQUEsZ0JBQUEsS0FBQSxDQUNmLElBQUEsa0JBRGUsQ0F4RUk7TUEyRXJCLGlCQUFpQixDQUFDOzs7OztPQUFELEtBQTJDO1FBQzFELElBQUEsa0JBQUEsYUFBQSxDQUNFLE1BREYsRUFFRSxPQUZGLEVBR0UsTUFIRixFQUlFLFFBSkYsQ0FBQSxDQUFBO09BNUVtQjs7TUFxRnJCLHVCQUF1QixJQUFBLGdCQUFBLHNCQUFBLEtBQUEsQ0FDckIsSUFBQSxnQkFEcUIsQ0FyRkY7TUF3RnJCLDBCQUNFLElBQUEsZ0JBQUEseUJBQUEsS0FBQSxDQUNFLElBQUEsZ0JBREYsQ0FBQTtLQXpGSixDQURGLENBQUEsQ0FuRDBEOztJQXFKMUQsTUFBTSxLQUFOLENBQVksZ0JBQVosQ0FBQSxDQUFBO0lBQ0EsTUFBTSxLQUFOLENBQVksbUJBQW1CLFdBQS9CLENBQUEsQ0FBQTs7SUFDQSxJQUFJLFdBQVcsS0FBSyxJQUFBLGNBQUEsU0FBcEIsRUFBNEM7O01BRTFDLE1BQU0sS0FBTixDQUNFLElBQUEscUJBQUEsMkJBQUEsQ0FBcUQ7UUFDbkQsTUFBQTtPQURGLENBREYsQ0FBQSxDQUFBO0tBekp3RDs7O0lBaUsxRCxNQUFNLEtBQU4sQ0FBWSxDQUFBLENBQUEsRUFBQSxxQkFBQSxxQkFBQSxFQUFxQixRQUFyQixDQUFaLENBQUEsQ0FBQTtJQUNBLE9BQU8sTUFBUCxDQUFBO0dBQ0Q7Ozs7Ozs7Ozs7Ozs7O0VBYUQsaUJBQWlCLFlBQVk7SUFDM0IsTUFBTSxlQUFlLENBQUEsQ0FBQSxFQUFBLFNBQUEsY0FBQSxFQUFjLElBQUEsa0JBQWQsQ0FBckIsQ0FBQTtJQUVBLENBQUEsQ0FBQSxFQUFBLEtBQUEsUUFBQSxFQUFLLFlBQUwsRUFBbUIsU0FBbkIsRUFBK0IsT0FBUTtNQUNyQyxZQUFZLFFBQVosRUFBQSxDQUFBOztNQUNBLElBQUksR0FBSixFQUFTO1FBQ1AsU0FBQSxRQUFBLE1BQUEsQ0FBVSxHQUFWLENBQUEsQ0FBQTtPQUNEO0tBSkgsQ0FBQSxDQUFBO0dBTUQ7Ozs7Ozs7Ozs7Ozs7RUFZRCxhQUFhLFNBQVM7O0dBQVQsRUFBcUI7SUFDaEMsSUFBSSxNQUFNLEtBQUssSUFBQSxnQkFBZixFQUFnQztNQUM5QixPQUFPLElBQVAsQ0FBQTtLQUNEOztJQUVELElBQUksQ0FBQyxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBTCxFQUErQjtNQUM3QixJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBQSxHQUEyQixFQUEzQixDQUFBO0tBQ0Q7O0lBRUQsTUFBTSxLQUFLLENBQUEsQ0FBQSxFQUFBLE9BQUEsUUFBQSxHQUFYLENBQUE7SUFDQSxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBQSxDQUF5QixFQUF6QixDQUFBLEdBQStCO01BQzdCLE1BQUE7S0FERixDQUFBO0lBSUEsT0FBTyxFQUFQLENBQUE7R0FDRDs7Ozs7Ozs7OztFQVNELGdCQUFnQixhQUFhO0lBQzNCLE1BQU0sY0FBYyxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBcEIsQ0FBQTs7SUFDQSxJQUFJLENBQUMsV0FBTCxFQUFrQjtNQUNoQixPQUFBO0tBQ0Q7O0lBRUQsT0FBTyxXQUFXLENBQUMsRUFBRCxDQUFsQixDQUFBOztJQUVBLElBQUksTUFBTSxLQUFOLENBQVksV0FBWixDQUFBLE9BQUEsS0FBb0MsQ0FBeEMsRUFBMkM7TUFDekMsT0FBTyxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBUCxDQUFBO0tBQ0Q7R0FDRjs7Ozs7Ozs7OztFQVNELG9CQUFvQixTQUFTO0lBQzNCLE1BQU0sY0FBYyxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBcEIsQ0FBQTs7SUFDQSxJQUFJLENBQUMsV0FBTCxFQUFrQjtNQUNoQixPQUFBO0tBQ0Q7O0lBRUQsTUFBTSxLQUFOLENBQVksV0FBWixDQUFBLFFBQUEsQ0FBa0MsTUFBTztNQUN2QyxJQUFBLGlCQUFBLENBQXNCLE1BQXRCLEVBQThCLEVBQTlCLENBQUEsQ0FBQTtLQURGLENBQUEsQ0FBQTtHQUdEOzs7Ozs7Ozs7Ozs7Ozs7RUFjRCxpQkFBaUIsa0JBQWtCO0lBQ2pDLE1BQU0sY0FBYyxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBcEIsQ0FBQTs7SUFFQSxJQUFJLFdBQUosRUFBaUI7TUFDZixNQUFNLE9BQU4sQ0FBYyxXQUFkLENBQUEsUUFBQSxDQUFvQyxRQUFTO1FBQzNDLElBQUksSUFBSSxPQUFSLEVBQWlCO1VBQ2YsSUFBSSxPQUFKLEtBQUEsQ0FBaUIsY0FBakIsRUFBaUMsT0FBakMsQ0FBQSxDQUFBO1NBQ0Q7T0FISCxDQUFBLENBQUE7S0FLRDtHQUNGOzs7Ozs7Ozs7Ozs7Ozs7O0VBZUQsb0JBQW9CLFVBQVU7SUFDNUIsTUFBTSxhQUNKLE9BQU8sT0FBUCxLQUFtQixVQUFuQixHQUNLLFVBQVcsT0FBTyxDQUFDLE1BQUQsQ0FEdkIsR0FFSSxNQUFNLE9BSFosQ0FBQTtJQUtBLE1BQU0sS0FBTixDQUFZLElBQUEsWUFBWixDQUFBLFFBQUEsQ0FBdUMsVUFBVztNQUNoRCxNQUFNLE9BQU4sQ0FBYyxJQUFBLFlBQUEsQ0FBaUIsTUFBakIsQ0FBZCxDQUFBLFFBQUEsQ0FBZ0QsY0FBZ0I7UUFDOUQsSUFBSSxJQUFJLE9BQVIsRUFBaUI7VUFDZixJQUFJLE9BQUosS0FBQSxDQUFpQixjQUFqQixFQUFpQyxNQUFNLFVBQVUsQ0FBQyxNQUFELENBQWpELENBQUEsQ0FBQTtTQUNEO09BSEgsQ0FBQSxDQUFBO0tBREYsQ0FBQSxDQUFBO0dBaHlHeUQ7Ozs7Ozs7Ozs7O0VBa3pHM0IsZ0NBQUEsUUFBUTtJQUN0QyxNQUFNOztLQUFBLEdBQWUsS0FBckIsQ0FBQTtJQUNBLE1BQU0sWUFBWSxRQUFRLE9BQVIsQ0FDaEIsTUFBTTs7S0FBTixLQUF1QixHQUFHLE9BQUgsQ0FBVyxRQUFYLENBRFAsRUFFaEIsRUFGZ0IsQ0FBbEIsQ0FBQTs7SUFLQSxJQUFJLENBQUMsU0FBUyxPQUFkLEVBQXVCO01BQ3JCLE9BQUE7S0FSb0M7OztJQVl0QyxJQUFBLHNCQUFBLGNBQUEsQ0FBeUMsU0FBekMsQ0FBQSxDQUFBO0lBQ0EsSUFBQSxlQUFBLGtCQUFBLENBQXNDLFNBQXRDLENBQUEsQ0FBQTtHQUNEOzs7Ozs7OztFQU9ELFNBQVMsR0FBRztJQUNWLElBQUEscUJBQUEsQ0FBMEIsZ0JBQWtCO01BQzFDLE9BQU87UUFDTCxRQUFRLGFBQUEsbUJBQUEsbUJBREg7UUFFTCxRQUFRO1VBQ04sWUFBWSxJQUROO1VBRU4sVUFBVSxNQUFNLElBQUEscUJBQUEsQ0FBMEIsTUFBMUIsQ0FBQTtTQUZWO09BRlYsQ0FBQTtLQURGLENBQUEsQ0FEVTs7OztJQWNWLElBQUEsS0FBQSxDQUFVLFFBQVYsQ0FBQSxDQUFBO0dBQ0Q7Ozs7Ozs7RUFNRCxPQUFPLEdBQUc7SUFDUixJQUFBLHFCQUFBLENBQTBCO01BQ3hCLFFBQVEsYUFBQSxtQkFBQSxtQkFEZ0I7TUFFeEIsUUFBUTtRQUNOLFlBQVksS0FBQTtPQUROO0tBRlYsQ0FBQSxDQURROzs7O0lBV1IsSUFBQSxLQUFBLENBQVUsTUFBVixDQUFBLENBQUE7R0FDRDs7Ozs7Ozs7Ozs7RUFVRCxjQUFjLFdBQVc7SUFDdkIsSUFBQSx3QkFBQSxHQUErQixRQUFRLFdBQVIsSUFBdUIsSUFBQSxjQUF0RCxDQUFBO0lBQ0EsSUFBQSxxQkFBQSxDQUEwQjtNQUN4QixRQUFRLGFBQUEsbUJBQUEsYUFEZ0I7TUFFeEIsUUFBUSxJQUFBLHdCQUFBLENBQTZCLFFBQTdCLENBQUE7S0FGVixDQUFBLENBQUE7R0FwM0d5RDs7Ozs7Ozs7O0VBaTRHM0QsaUJBQWlCLEdBQUc7SUFDbEIsSUFBQSxLQUFBLENBQVUsUUFBVixFQUFvQixJQUFBLFNBQUEsRUFBcEIsQ0FBQSxDQUFBO0dBQ0Q7Ozs7OztFQUtELFVBQVUsR0FBRztJQUNYLE9BQU8sSUFBQSxrQkFBQSxTQUFBLFNBQUEsRUFBQSxXQUFQLENBQUE7R0F6NEd5RDs7Ozs7RUFnNUczRCw4QkFBOEIsVUFBVTtJQUN0QyxPQUFPLElBQUEsNEJBQUEsZ0JBQUEsQ0FBaUQ7TUFDdEQsYUFBYSxPQUR5QztNQUV0RCxRQUFRLFNBQUE7S0FGSCxDQUFQLENBQUE7R0FJRDs7Ozs7Ozs7O0VBUW9CLHFCQUFBLFVBQVU7SUFDN0IsTUFBTTs7O0tBQUEsR0FDSixNQUFNLElBQUEsYUFBQSxhQUFBLGFBQUEsQ0FBNEMsT0FBNUMsQ0FEUixDQUFBO0lBRUEsTUFBTSxlQUFlLFlBQVksT0FBWixpQkFBckIsQ0FBQTtJQUVBLFdBQVcsRUFBQSxDQUFBO0lBQ1gsT0FBTyxZQUFQLENBQUE7R0FDRDs7Ozs7Ozs7O0VBUWlCLGtCQUFBLFVBQVU7SUFDMUIsTUFBTSxZQUFZLE1BQU0sSUFBQSxhQUFBLGFBQUEsYUFBQSxDQUN0QixPQURzQixDQUF4QixDQUFBO0lBR0EsU0FBUyxZQUFULEVBQUEsQ0FBQTtJQUNBLE9BQU8sU0FBUyxVQUFoQixDQUFBO0dBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFrQjRCLDZCQUFBLHlCQUF5QixZQUFZLEtBQXJDLEVBQTRDO0lBQ3ZFLE1BQU07O0tBQUEsR0FBa0IsSUFBQSxzQkFBQSxNQUF4QixDQUFBOztJQUVBLElBQUksQ0FBQyxXQUFXLENBQUMsVUFBRCxDQUFoQixFQUE4QjtNQUM1QixPQUFBO0tBQ0Q7O0lBRUQsS0FBSyxNQUFNLE9BQVgsSUFBc0IsTUFBTSxLQUFOLENBQVksV0FBVyxDQUFDLFVBQUQsQ0FBdkIsQ0FBdEIsRUFBNEQ7TUFDMUQsTUFBTSxRQUFRLFdBQVcsQ0FBQyxVQUFELENBQVgsQ0FBd0IsT0FBeEIsQ0FBZCxDQUFBO01BQ0EsSUFBQSxzQkFBQSxJQUFBLENBQ0UsT0FERixFQUVFLEtBQUssS0FGUCxFQUdFLFVBSEYsRUFJRSxLQUFLLEtBSlAsQ0FBQSxDQUFBOztNQU1BLElBQUksQ0FBQyxTQUFMLEVBQWdCO1FBQ2QsSUFBQSxzQkFBQSxPQUFBLENBQWtDLFVBQWxDLEVBQThDLE9BQTlDLENBQUEsQ0FBQTtPQUNEO0tBQ0Y7R0F0OUd3RDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBMCtHaEMsMkJBQUEsa0JBR3pCLFNBQVMsS0FIZ0Isc0JBTXpCO0lBQ0EsSUFBQSxrQkFBQSxhQUFBLENBQ0UsTUFERixFQUVFLE9BRkYsRUFHRSxNQUhGLEVBSUUsUUFKRixFQUtFLFFBTEYsQ0FBQSxDQUFBO0lBT0EsTUFBTSxJQUFBLHNCQUFBLFVBQUEsQ0FBcUM7TUFDekMsTUFEeUM7TUFFekMsT0FGeUM7TUFHekMsTUFIeUM7TUFJekMsUUFKeUM7TUFLekMsUUFBQTtLQUxJLENBQU4sQ0FBQTtJQU9BLE9BQU8sTUFBUCxDQUFBO0dBQ0Q7Ozs7Ozs7Ozs7Ozs7RUFZaUIsa0JBQUEsa0JBR2hCLFNBQVMsS0FITyxFQUloQixXQUFXLEVBSkssRUFLaEIsV0FBVyxFQUxLLEVBTWhCO0lBQ0EsTUFBTSx3QkFDSixJQUFBLHNCQUFBLHlCQUFBLEVBREYsQ0FBQTtJQUVBLE1BQU0sY0FBYyxxQkFBcUIsS0FBckIsQ0FDakIsT0FBUSxNQUFNLEtBQUssR0FBRyxPQURMLENBQXBCLENBQUE7O0lBSUEsSUFBSSxXQUFKLEVBQWlCO01BQ2YsSUFBQSxrQkFBQSxhQUFBLENBQ0UsV0FBVyxPQURiLEVBRUUsV0FBVyxRQUZiLEVBR0UsV0FBVyxPQUhiLEVBSUUsV0FBVyxTQUpiLEVBS0UsUUFMRixDQUFBLENBQUE7S0FERixNQVFPO01BQ0wsSUFBQSxrQkFBQSxhQUFBLENBQ0UsTUFERixFQUVFLE9BRkYsRUFHRSxNQUhGLEVBSUUsUUFKRixFQUtFLFFBTEYsQ0FBQSxDQUFBO01BT0EsTUFBTSxJQUFBLHNCQUFBLHFCQUFBLENBQ0osTUFESSxFQUVKLE9BRkksRUFHSixNQUhJLEVBSUosUUFKSSxFQUtKLFFBTEksQ0FBTixDQUFBO0tBT0Q7O0lBQ0QsT0FBTyxNQUFQLENBQUE7R0FDRDs7Ozs7Ozs7RUFPaUIsa0JBQUEsU0FBUztJQUN6QixNQUFNLElBQUEsc0JBQUEsMEJBQUEsQ0FBcUQsTUFBckQsQ0FBTixDQUFBO0dBQ0Q7Ozs7Ozs7Ozs7RUFTRCxlQUFlLFVBQVU7SUFDdkIsTUFBTSx3QkFDSixJQUFBLHNCQUFBLHlCQUFBLEVBREYsQ0FBQTs7SUFFQSxLQUFLLE1BQU0sZUFBWCxJQUE4QixxQkFBOUIsRUFBcUQ7TUFDbkQsS0FBSyxNQUFNLEdBQVgsSUFBa0IsTUFBTSxLQUFOLENBQVksT0FBWixDQUFsQixFQUF3QztRQUN0QyxJQUFJLGVBQWUsQ0FBQyxHQUFELENBQWYsS0FBeUIsT0FBTyxDQUFDLEdBQUQsQ0FBcEMsRUFBMkM7VUFDekMsT0FBTyxlQUFQLENBQUE7U0FDRDtPQUNGO0tBQ0Y7O0lBQ0QsT0FBTyxJQUFQLENBQUE7R0FDRDs7Ozs7Ozs7RUFPaUMsa0NBQUEsZ0JBQWdCO0lBQ2hELE1BQU0sZUFDSixJQUFBLHNCQUFBLDZCQUFBLEVBREYsQ0FBQTtJQUVBLE1BQU0sV0FDSixJQUFBLHNCQUFBLDZCQUFBLENBQXdELGFBQXhELENBREYsQ0FBQTtJQUdBLE1BQU0sVUFBVSxNQUFNLElBQUEsb0JBQUEsQ0FBeUIsZ0JBQUEsYUFBQSxPQUF6QixDQUF0QixDQUFBOztJQUNBLElBQUksT0FBSixLQUFBLElBQUEsSUFBSSxPQUFKLEtBQUEsS0FBQSxDQUFBLElBQUksT0FBTyxzQkFBWCxFQUFvQztNQUNsQyxPQUFPLE9BQU8sc0JBQVAsQ0FBOEIsUUFBOUIsQ0FBQSxNQUFBLENBQStDLEtBQU07OztRQUcxRCxJQUFBLHNCQUFBLDZCQUFBLENBQXdELFlBQXhELENBQUEsQ0FBQTtRQUNBLE1BQU0sQ0FBTixDQUFBO09BSkssQ0FBUCxDQUFBO0tBTUQ7O0lBRUQsT0FBTyxTQUFQLENBQUE7R0FDRDs7Ozs7Ozs7O0VBUUQsbUJBQW1CLFlBQVk7SUFDN0IsSUFBSSxFQUFFLGVBQUEsSUFBbUIsU0FBckIsQ0FBSixFQUFxQztNQUNuQyxNQUFNLFVBQVUsSUFBQSxTQUFBLFdBQUEsRUFBaEIsQ0FBQTtNQUNBLFNBQVMsY0FBVCxHQUEwQjtRQUN4QixPQUR3QjtRQUV4QixNQUFNLElBQUksSUFBSixFQUFBO09BRlIsQ0FBQTtLQUlEO0dBdG5Id0Q7Ozs7Ozs7Ozs7O0VBZ29IM0MsZ0JBQUEsT0FBTztJQUNyQixJQUFBLGNBQUEsR0FBcUIsSUFBckIsQ0FBQTtJQUNBLElBQUEsdUJBQUEsT0FBQSxHQUFxQyxJQUFyQyxDQUFBO0dBQ0Q7Ozs7Ozs7OztFQU9ELGNBQWMsR0FBRztJQUNmLElBQUk7TUFDRixJQUFBLGlCQUFBLFlBQUEsRUFBQSxDQUFBO01BQ0EsSUFBQSxtQkFBQSxtQkFBQSxFQUFBLENBQUE7S0FGRixDQUdFLGNBQWM7TUFDZCxPQUFPLE1BQVAsQ0FBYyxLQUFkLENBQUEsQ0FBQTtLQUNEO0dBQ0Y7Ozs7Ozs7OztFQVFELHVCQUF1QixrQkFBa0I7SUFDdkMsTUFBTSwyQkFDSixJQUFBLGdDQUFBLENBQWdDLGVBQWhDLENBREYsQ0FBQTtJQUVBLE1BQU0sNEJBQ0osSUFBQSxtQkFBQSxNQUFBLFNBQUEsRUFBQSxDQUF5Qyx3QkFBekMsQ0FERixDQUFBO0lBRUEseUJBQXlCLFFBQXpCLENBQW1DLGdCQUFpQjtNQUNsRCxJQUFBLGlCQUFBLGlCQUFBLENBQXVDLFlBQXZDLENBQUEsQ0FBQTtNQUNBLElBQUEsbUJBQUEsbUJBQUEsQ0FDRSxZQURGLEVBRUUsd0JBRkYsQ0FBQSxDQUFBO0tBRkYsQ0FBQSxDQUFBO0dBT0Q7Ozs7Ozs7O0VBT0Qsc0JBQXNCLFdBQVc7SUFDL0IsT0FBTyxJQUFBLG1CQUFBLE9BQUEsQ0FBK0IsUUFBL0IsQ0FBUCxDQUFBO0dBQ0Q7Ozs7OztFQUtELFNBQVMsR0FBRztJQUFBLElBQUEscUJBQUEsQ0FBQTs7SUFDVixNQUFNLGVBQUEsR0FBa0IsSUFBQSxrQkFBQSxrQkFBQSxDQUN0QixnQkFBQSxjQUFBLE9BRHNCLENBQXhCLENBQUE7O0lBR0EsSUFBSSxhQUFKLEVBQW1CO01BQ2pCLGFBQWEsUUFBYixFQUFBLENBQUE7S0FDRDs7SUFFRCxNQUFNLGVBQUEsR0FBa0IsSUFBQSxrQkFBQSxrQkFBQSxDQUN0QixnQkFBQSxjQUFBLE9BRHNCLENBQXhCLENBQUE7SUFHQSxhQUFhLEtBQUEsSUFBYixJQUFBLGFBQWEsS0FBQSxLQUFBLENBQWIsR0FBQSxLQUFBLENBQUEsR0FBQSxDQUFBLHdCQUFBLGFBQWEsUUFBYixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLHFCQUFBLEtBQUEsQ0FBQSxhQUFhLENBQUEsQ0FBQTtJQUViLE9BQU8sSUFBQSxrQkFBQSxVQUFBLEVBQVAsQ0FBQTtHQUNEOztDQWpzSDBEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSjdEOztBQUVBLE1BQU0sT0FBTyxHQUFHLENBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsSUFBSSxhQUFhLENBQUMsSUFBZCxDQUFtQixNQUFuQixDQUEwQixRQUExQixDQUFtQyxJQUFuQyxLQUE0QyxXQUFoRCxFQUE2RDtRQUMzRCxhQUFhLENBQUMsSUFBZCxDQUFtQixNQUFuQixDQUEwQixRQUExQixDQUFtQyxJQUFuQyxHQUEwQyxLQUExQztRQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE1BQW5CLENBQTBCLFFBQTFCLENBQW1DLFNBQW5DLEdBQ0UsMEJBREY7TUFFRDtJQUNGLENBTkQsQ0FNRSxPQUFPLENBQVAsRUFBVSxDQUNWO0lBQ0Q7O0lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixhQUFoQixDQUFQO0VBQ0Q7O0FBaEJZLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSmY7O0FBRUEsTUFBTSxPQUFPLEdBQUcsQ0FBaEI7QUFDQSxNQUFNLFVBQVUsR0FBRyxpQ0FBbkI7QUFDQSxNQUFNLFVBQVUsR0FBRyw4QkFBbkI7ZUFFZTtFQUNiLE9BRGE7O0VBR2IsT0FBTyxDQUFDLHFCQUFELEVBQXdCO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCOztJQUNBLElBQUk7TUFDRixJQUFJLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE1BQW5CLENBQTBCLFFBQTFCLENBQW1DLFNBQW5DLEtBQWlELFVBQXJELEVBQWlFO1FBQy9ELGFBQWEsQ0FBQyxJQUFkLENBQW1CLE1BQW5CLENBQTBCLFFBQTFCLENBQW1DLFNBQW5DLEdBQStDLFVBQS9DO01BQ0Q7SUFDRixDQUpELENBSUUsT0FBTyxDQUFQLEVBQVUsQ0FDVjtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTmY7O0FBRUEsTUFBTSxPQUFPLEdBQUcsQ0FBaEI7ZUFFZTtFQUNiLE9BRGE7O0VBR2IsT0FBTyxDQUFDLGFBQUQsRUFBZ0I7SUFDckIsTUFBTSxpQkFBaUIsR0FBRyxJQUFBLGlCQUFBLEVBQVUsYUFBVixDQUExQjtJQUNBLGlCQUFpQixDQUFDLElBQWxCLENBQXVCLE9BQXZCLEdBQWlDLE9BQWpDOztJQUNBLElBQUk7TUFDRixJQUFJLGlCQUFpQixDQUFDLElBQWxCLENBQXVCLE1BQXZCLENBQThCLFFBQTlCLENBQXVDLElBQXZDLEtBQWdELEtBQXBELEVBQTJEO1FBQ3pELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsaUJBQWhCLENBQVA7TUFDRDs7TUFDRCxRQUFRLGlCQUFpQixDQUFDLElBQWxCLENBQXVCLE1BQXZCLENBQThCLFFBQTlCLENBQXVDLFNBQS9DO1FBQ0UsS0FBSyw4QkFBTDtVQUNFLGlCQUFpQixDQUFDLElBQWxCLENBQXVCLE1BQXZCLENBQThCLFFBQTlCLEdBQXlDO1lBQ3ZDLElBQUksRUFBRTtVQURpQyxDQUF6QztVQUdBOztRQUNGLEtBQUssMEJBQUw7VUFDRSxpQkFBaUIsQ0FBQyxJQUFsQixDQUF1QixNQUF2QixDQUE4QixRQUE5QixHQUF5QztZQUN2QyxJQUFJLEVBQUU7VUFEaUMsQ0FBekM7VUFHQTtRQUNGO01BWEY7SUFhRCxDQWpCRCxDQWlCRSxPQUFPLENBQVAsRUFBVSxDQUNWO0lBQ0Q7O0lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixpQkFBaEIsQ0FBUDtFQUNEOztBQTNCWSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0VmOztBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQSxNQUFNLE9BQU8sR0FBRyxDQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixPQUFPLENBQUMscUJBQUQsRUFBd0I7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtNQUNBLE1BQU0sUUFBUSxHQUFHLGtDQUFrQyxDQUFDLEtBQUQsQ0FBbkQ7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsd0JBQXVCLEdBQUcsQ0FBQyxLQUFNLEVBQS9DO0lBQ0Q7O0lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixhQUFoQixDQUFQO0VBQ0Q7O0FBZFksQzs7O0FBaUJmLFNBQVMsa0NBQVQsQ0FBNEMsS0FBNUMsRUFBbUQ7RUFDakQsTUFBTTtJQUFFO0VBQUYsSUFBYSxLQUFuQjtFQUNBLE1BQU0sUUFBUSxHQUFHLEVBQ2YsR0FBRyxLQURZO0lBRWYsaUJBQWlCLEVBQUU7TUFDakIsS0FBSyxFQUFFLEtBQUssQ0FBQyxLQURJO01BRWpCLGVBQWUsRUFBRSxNQUFNLENBQUMsZUFGUDtNQUdqQixlQUFlLEVBQUUsS0FBSyxDQUFDO0lBSE47RUFGSixDQUFqQjtFQVFBLE9BQU8sUUFBUSxDQUFDLEtBQWhCO0VBQ0EsT0FBTyxRQUFRLENBQUMsZUFBaEI7RUFDQSxPQUFPLFFBQVEsQ0FBQyxNQUFULENBQWdCLGVBQXZCO0VBRUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0Q7O0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLENBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLEtBQUQsQ0FBN0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLFlBQVQsQ0FBc0IsS0FBdEIsRUFBNkI7RUFDM0IsTUFBTSxlQUFlLEdBQUcsS0FBSyxDQUFDLGlCQUE5QixDQUQyQixDQUczQjs7RUFDQSxNQUFNLFFBQVEsR0FBRyxFQUNmLEdBQUcsS0FEWTtJQUVmLHFCQUFxQixFQUFFO01BQ3JCLGVBQWUsRUFBRSxlQUFlLENBQUM7SUFEWjtFQUZSLENBQWpCLENBSjJCLENBVzNCOztFQUNBLE9BQU8sUUFBUSxDQUFDLGlCQUFULENBQTJCLGVBQWxDO0VBRUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0Q7O0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLENBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsRUFDZixHQUFHLEtBRFk7SUFFZixrQkFBa0IsRUFBRTtNQUNsQixZQUFZLEVBQUUsS0FBSyxDQUFDLFlBQU4sSUFBc0IsRUFEbEI7TUFFbEIsYUFBYSxFQUFFLEtBQUssQ0FBQyxhQUFOLElBQXVCO0lBRnBCO0VBRkwsQ0FBakI7RUFPQSxPQUFPLFFBQVEsQ0FBQyxZQUFoQjtFQUNBLE9BQU8sUUFBUSxDQUFDLGFBQWhCO0VBRUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqQ0Q7O0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLENBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsRUFDZixHQUFHLEtBRFk7SUFFZixnQkFBZ0IsRUFBRTtNQUNoQixXQUFXLEVBQUUsS0FBSyxDQUFDLFdBQU4sSUFBcUI7SUFEbEI7RUFGSCxDQUFqQjtFQU1BLE9BQU8sUUFBUSxDQUFDLFdBQWhCO0VBRUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkQ7O0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLENBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsSUFBQSxhQUFBLEVBQU0sRUFBTixFQUFVLEtBQVYsRUFBaUI7SUFDaEMsa0JBQWtCLEVBQUU7TUFDbEIsZUFBZSxFQUFFLEtBQUssQ0FBQyxXQUFOLElBQXFCLEtBQUssQ0FBQyxZQUEzQixJQUEyQyxLQUQxQztNQUVsQixjQUFjLEVBQUUsS0FBSyxDQUFDLGNBRko7TUFHbEIsY0FBYyxFQUFFLEtBQUssQ0FBQztJQUhKO0VBRFksQ0FBakIsQ0FBakI7RUFPQSxPQUFPLFFBQVEsQ0FBQyxXQUFoQjtFQUNBLE9BQU8sUUFBUSxDQUFDLFlBQWhCO0VBQ0EsT0FBTyxRQUFRLENBQUMsY0FBaEI7RUFDQSxPQUFPLFFBQVEsQ0FBQyxjQUFoQjtFQUVBLE9BQU8sUUFBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkNEOztBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixPQUFPLENBQUMscUJBQUQsRUFBd0I7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtNQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO01BQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDRCxDQUpELENBSUUsT0FBTyxHQUFQLEVBQVk7TUFDWixPQUFPLENBQUMsSUFBUixDQUFjLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBeEQ7SUFDRDs7SUFDRCxPQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLGFBQWhCLENBQVA7RUFDRDs7QUFkWSxDOzs7QUFpQmYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU0sUUFBUSxHQUFHLElBQUEsYUFBQSxFQUFNLEVBQU4sRUFBVSxLQUFWLEVBQWlCO0lBQ2hDLG9CQUFvQixFQUFFO01BQ3BCLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxnQkFBTixJQUEwQjtJQUR4QjtFQURVLENBQWpCLENBQWpCO0VBS0EsT0FBTyxRQUFRLENBQUMsZ0JBQWhCO0VBRUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QkQ7O0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7RUFDQSxPQUFPLFFBQVEsQ0FBQyxPQUFoQjtFQUNBLE9BQU8sUUFBUSxDQUFDLHFCQUFoQjtFQUNBLE9BQU8sUUFBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUJEOztBQU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixPQUFPLENBQUMscUJBQUQsRUFBd0I7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtNQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO01BQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDRCxDQUpELENBSUUsT0FBTyxHQUFQLEVBQVk7TUFDWixPQUFPLENBQUMsSUFBUixDQUFjLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBeEQ7SUFDRDs7SUFDRCxPQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLGFBQWhCLENBQVA7RUFDRDs7QUFkWSxDOzs7QUFpQmYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQWpCO0VBQ0EsUUFBUSxDQUFDLGdCQUFULENBQTBCLFdBQTFCLENBQXNDLE9BQXRDLENBQStDLE1BQUQsSUFBWTtJQUN4RCxJQUFJLE1BQU0sQ0FBQyxJQUFYLEVBQWlCO01BQ2YsTUFBTSxDQUFDLElBQVAsR0FBYyxFQUFkO0lBQ0Q7RUFDRixDQUpEO0VBS0EsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkQ7O0FBTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7RUFDQSxNQUFNO0lBQUU7RUFBRixJQUFhLFFBQW5COztFQUNBLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxRQUFyQixFQUErQjtJQUM3QixJQUFJLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBQWhCLEtBQXlCLFNBQTdCLEVBQXdDO01BQ3RDLFFBQVEsQ0FBQyxNQUFULENBQWdCLFFBQWhCLENBQXlCLElBQXpCLEdBQWdDLFNBQWhDO0lBQ0Q7RUFDRjs7RUFDRCxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCRDs7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7ZUFFZTtFQUNiLE9BRGE7O0VBR2IsT0FBTyxDQUFDLHFCQUFELEVBQXdCO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCOztJQUNBLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7TUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtNQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0QsQ0FKRCxDQUlFLE9BQU8sR0FBUCxFQUFZO01BQ1osT0FBTyxDQUFDLElBQVIsQ0FBYyx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQXhEO0lBQ0Q7O0lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixhQUFoQixDQUFQO0VBQ0Q7O0FBZFksQzs7O0FBaUJmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFqQjtFQUNBLFFBQVEsQ0FBQyxpQkFBVCxHQUE2QixFQUE3QjtFQUNBLFFBQVEsQ0FBQyxpQkFBVCxDQUEyQixRQUEzQixHQUFzQyxRQUFRLENBQUMsTUFBVCxDQUFnQixRQUF0RDtFQUNBLE9BQU8sUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsUUFBdkI7RUFDQSxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCRDs7QUFDQTs7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixPQUFPLENBQUMscUJBQUQsRUFBd0I7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtNQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO01BQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDRCxDQUpELENBSUUsT0FBTyxHQUFQLEVBQVk7TUFDWixPQUFPLENBQUMsSUFBUixDQUFjLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBeEQ7SUFDRDs7SUFDRCxPQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLGFBQWhCLENBQVA7RUFDRDs7QUFkWSxDOzs7QUFpQmYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQWpCO0VBQ0EsTUFBTTtJQUFFO0VBQUYsSUFBNEIsUUFBbEM7O0VBQ0EsSUFBSSxxQkFBcUIsSUFBSSxxQkFBcUIsQ0FBQyxZQUFuRCxFQUFpRTtJQUMvRCxNQUFNO01BQUU7SUFBRixJQUFtQixxQkFBekI7SUFDQSxRQUFRLENBQUMscUJBQVQsQ0FBK0IsWUFBL0IsR0FBOEMsWUFBWSxDQUFDLEdBQWIsQ0FBa0IsTUFBRCxJQUFZO01BQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBWixFQUFpQjtRQUNmLE9BQU8sTUFBUDtNQUNELENBRkQsTUFFTyxJQUFJLE1BQU0sQ0FBQyxHQUFQLENBQVcsT0FBWCxLQUF1Qix3QkFBM0IsRUFBcUQ7UUFDMUQsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsaUNBQUEsQ0FBcUIsTUFBckM7TUFDRDs7TUFDRCxPQUFPLE1BQVA7SUFDRCxDQVA2QyxDQUE5QztFQVFEOztFQUNELE9BQU8sUUFBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDckNEOztBQUNBOztBQVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7RUFDQSxNQUFNO0lBQUU7RUFBRixJQUE0QixRQUFsQzs7RUFDQSxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQW5ELEVBQWlFO0lBQy9ELE1BQU07TUFBRTtJQUFGLElBQW1CLFFBQVEsQ0FBQyxxQkFBbEM7SUFFQSxRQUFRLENBQUMscUJBQVQsQ0FBK0IsWUFBL0IsR0FBOEMsWUFBWSxDQUFDLEdBQWIsQ0FBa0IsTUFBRCxJQUFZO01BQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBWixFQUFpQjtRQUNmLE9BQU8sTUFBUDtNQUNEOztNQUNELElBQ0UsTUFBTSxDQUFDLEdBQVAsS0FBZSxzREFEakIsRUFFRTtRQUNBLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLGlDQUFBLENBQXFCLFNBQXJDO1FBQ0EsT0FBTyxNQUFNLENBQUMsR0FBZDtNQUNEOztNQUNELE9BQU8sTUFBUDtJQUNELENBWDZDLENBQTlDO0VBWUQ7O0VBQ0QsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQ0Q7O0FBQ0E7O0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7RUFDQSxNQUFNO0lBQUU7RUFBRixJQUE0QixRQUFsQzs7RUFDQSxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQW5ELEVBQWlFO0lBQy9ELE1BQU07TUFBRTtJQUFGLElBQW1CLFFBQVEsQ0FBQyxxQkFBbEM7SUFDQSxRQUFRLENBQUMscUJBQVQsQ0FBK0IsWUFBL0IsR0FBOEMsWUFBWSxDQUFDLEdBQWIsQ0FBa0IsTUFBRCxJQUFZO01BQ3pFLElBQUksQ0FBQyxNQUFNLENBQUMsTUFBUixLQUFtQixpQ0FBQSxDQUFxQixNQUE1QyxFQUFvRDtRQUNsRCxPQUFPLE1BQVA7TUFDRDs7TUFDRCxJQUFJLE1BQU0sQ0FBQyxVQUFQLEdBQW9CLENBQXBCLElBQXlCLE1BQU0sQ0FBQyxVQUFQLEdBQW9CLENBQWpELEVBQW9EO1FBQ2xELE1BQU0sQ0FBQyxNQUFQLEdBQWdCLGlDQUFBLENBQXFCLFNBQXJDO1FBQ0EsT0FBTyxNQUFNLENBQUMsR0FBZDtNQUNEOztNQUNELE9BQU8sTUFBUDtJQUNELENBVDZDLENBQTlDO0VBVUQ7O0VBQ0QsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2Q0QsSUFBQSxVQUFBLE9BQUEsQ0FBQSxRQUFBLENBQUEsQ0FBQTs7QUFDQSxJQUFBLHlCQUFBLE9BQUEsQ0FBQSwwREFBQSxDQUFBLENBQUE7Ozs7Ozs7QUFLQSxNQUFNLFVBQVUsRUFBaEIsQ0FBQTtlQUVlO0VBQ2IsT0FEYTs7RUFHYixPQUFPLHdCQUF3QjtJQUM3QixNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQUEsRUFBVSxxQkFBVixDQUF0QixDQUFBO0lBQ0EsYUFBYSxLQUFiLFFBQUEsR0FBNkIsT0FBN0IsQ0FBQTs7SUFDQSxJQUFJO01BQ0YsTUFBTSxRQUFRLGFBQWEsS0FBM0IsQ0FBQTtNQUNBLE1BQU0sV0FBVyxjQUFjLENBQUMsS0FBRCxDQUEvQixDQUFBO01BQ0EsYUFBYSxLQUFiLEdBQXFCLFFBQXJCLENBQUE7S0FIRixDQUlFLFlBQVk7TUFDWixPQUFPLEtBQVAsQ0FBYyxDQUFBLG9CQUFBLEVBQXNCLE9BQVEsQ0FBQSxFQUFFLEdBQUcsTUFBTyxDQUFBLENBQXhELENBQUEsQ0FBQTtLQUNEOztJQUNELE9BQU8sT0FBTyxRQUFQLENBQWdCLGFBQWhCLENBQVAsQ0FBQTtHQUNEOzs7OztBQUdILCtCQUErQjtFQUM3QixNQUFNLFdBQVcsS0FBakIsQ0FBQTtFQUNBLE1BQU07O0dBQUEsR0FBNEIsUUFBbEMsQ0FBQTs7RUFDQSxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixhQUFsRCxFQUFpRTtJQUMvRCxNQUFNOztLQUFBLEdBQW1CLFFBQVEsc0JBQWpDLENBQUE7SUFDQSxRQUFRLHNCQUFSLGFBQUEsR0FBOEMsWUFBWSxJQUFaLENBQWtCLFVBQVc7O01BRXpFLElBQUksQ0FBQyxNQUFNLFFBQVAsSUFBbUIsTUFBTSxRQUFOLE9BQUEsS0FBMEIsQ0FBakQsRUFBb0Q7UUFDbEQsTUFBTSxXQUFXLENBQUEsQ0FBQSxFQUFBLHNCQUFBLG1CQUFBLEVBQW1CLE1BQW5CLENBQWpCLENBQUE7UUFDQSxNQUFNLFFBQU4sR0FBaUIsQ0FBQyxRQUFELENBQWpCLENBQUE7UUFDQSxPQUFPLE1BQVAsQ0FBQTtPQUx1RTs7O01BUXpFLE1BQU0sYUFBYSxDQUFBLENBQUEsRUFBQSxzQkFBQSw0QkFBQSxFQUE0QixNQUFNLFFBQWxDLENBQUE7YUFBQSxDQUVSLFNBQVU7UUFDakIsT0FBTyxDQUFDLEtBQUssUUFBTCxDQUFjLEtBQWQsQ0FBRCxJQUF5QixLQUFLLE9BQUwsR0FBZSxDQUEvQyxDQUFBO09BSGUsQ0FBbkIsQ0FBQTtNQUtBLE1BQU0sUUFBTixHQUFpQixVQUFqQixDQUFBO01BQ0EsT0FBTyxNQUFQLENBQUE7S0FkNEMsQ0FBOUMsQ0FBQTtHQWdCRDs7RUFDRCxPQUFPLFFBQVAsQ0FBQTtDQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9DRDs7QUFDQTs7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixPQUFPLENBQUMscUJBQUQsRUFBd0I7SUFDN0IsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtNQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO01BQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDRCxDQUpELENBSUUsT0FBTyxHQUFQLEVBQVk7TUFDWixPQUFPLENBQUMsSUFBUixDQUFjLHVCQUFzQixPQUFRLEdBQUUsR0FBRyxDQUFDLEtBQU0sRUFBeEQ7SUFDRDs7SUFDRCxPQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLGFBQWhCLENBQVA7RUFDRDs7QUFkWSxDOzs7QUFpQmYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQWpCO0VBQ0EsTUFBTTtJQUFFO0VBQUYsSUFBNEIsUUFBbEM7O0VBQ0EsSUFBSSxxQkFBcUIsSUFBSSxxQkFBcUIsQ0FBQyxZQUFuRCxFQUFpRTtJQUMvRCxNQUFNO01BQUU7SUFBRixJQUFtQixRQUFRLENBQUMscUJBQWxDO0lBRUEsUUFBUSxDQUFDLHFCQUFULENBQStCLFlBQS9CLEdBQThDLFlBQVksQ0FBQyxHQUFiLENBQzVDLENBQUMsTUFBRCxFQUFTLENBQVQsRUFBWSxNQUFaLEtBQXVCO01BQ3JCLElBQUksTUFBTSxDQUFDLE1BQVAsS0FBa0IsaUNBQUEsQ0FBcUIsU0FBM0MsRUFBc0Q7UUFDcEQsT0FBTyxNQUFQO01BQ0Q7O01BRUQsTUFBTSxZQUFZLEdBQUcsTUFBTSxDQUN4QixNQURrQixDQUNWLEVBQUQsSUFBUSxFQUFFLENBQUMsTUFBSCxLQUFjLGlDQUFBLENBQXFCLFNBRGhDLEVBRWxCLE1BRmtCLENBRVYsRUFBRCxJQUFRLEVBQUUsQ0FBQyxRQUFILENBQVksSUFBWixLQUFxQixNQUFNLENBQUMsUUFBUCxDQUFnQixJQUZsQyxFQUdsQixNQUhrQixDQUloQixFQUFELElBQVEsRUFBRSxDQUFDLGlCQUFILENBQXFCLElBQXJCLEtBQThCLE1BQU0sQ0FBQyxpQkFBUCxDQUF5QixJQUo5QyxDQUFyQjtNQU1BLE1BQU0scUJBQXFCLEdBQUcsZUFBZSxDQUFDLFlBQUQsQ0FBN0M7TUFFQSxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQ3RCLE1BRGdCLENBQ1IsRUFBRCxJQUFRLEVBQUUsQ0FBQyxNQUFILEtBQWMsaUNBQUEsQ0FBcUIsU0FEbEMsRUFFaEIsTUFGZ0IsQ0FFUixFQUFELElBQVEsRUFBRSxDQUFDLFFBQUgsQ0FBWSxJQUFaLEtBQXFCLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBRnBDLEVBR2hCLE1BSGdCLENBSWQsRUFBRCxJQUFRLEVBQUUsQ0FBQyxpQkFBSCxDQUFxQixJQUFyQixLQUE4QixNQUFNLENBQUMsaUJBQVAsQ0FBeUIsSUFKaEQsQ0FBbkI7TUFNQSxNQUFNLHNCQUFzQixHQUFHLHdCQUF3QixDQUNyRCxVQURxRCxFQUVyRCxxQkFGcUQsQ0FBdkQ7TUFLQSxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsR0FBTCxDQUNmLHNCQURlLEVBRWYscUJBRmUsQ0FBakI7O01BS0EsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVAsQ0FBZ0IsS0FBakIsRUFBd0IsRUFBeEIsQ0FBUixHQUFzQyxRQUFRLEdBQUcsQ0FBckQsRUFBd0Q7UUFDdEQsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsaUNBQUEsQ0FBcUIsTUFBckM7UUFDQSxNQUFNLENBQUMsR0FBUCxHQUFhO1VBQ1gsT0FBTyxFQUFFLGdCQURFO1VBRVgsSUFBSSxFQUFFO1FBRkssQ0FBYjtNQUlEOztNQUNELE9BQU8sTUFBUDtJQUNELENBdEMyQyxDQUE5QztFQXdDRDs7RUFDRCxPQUFPLFFBQVA7QUFDRDs7QUFFRCxTQUFTLHdCQUFULENBQWtDLE1BQWxDLEVBQTBDLFVBQTFDLEVBQXNEO0VBQ3BELE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFQLENBQVksTUFBRCxJQUFZO0lBQ3BDLE1BQU07TUFBRTtJQUFGLElBQVksTUFBTSxDQUFDLFFBQXpCO0lBQ0EsT0FBTyxRQUFRLENBQUMsS0FBRCxFQUFRLEVBQVIsQ0FBZjtFQUNELENBSGMsQ0FBZjtFQUtBLElBQUksT0FBTyxHQUFHLFVBQWQ7O0VBQ0EsT0FBTyxNQUFNLENBQUMsUUFBUCxDQUFnQixPQUFoQixDQUFQLEVBQWlDO0lBQy9CLE9BQU8sSUFBSSxDQUFYO0VBQ0Q7O0VBRUQsT0FBTyxPQUFQO0FBQ0Q7O0FBRUQsU0FBUyxlQUFULENBQXlCLE1BQXpCLEVBQWlDO0VBQy9CLE1BQU0sTUFBTSxHQUFHLE1BQU0sQ0FBQyxHQUFQLENBQVksTUFBRCxJQUFZO0lBQ3BDLE1BQU07TUFBRTtJQUFGLElBQVksTUFBTSxDQUFDLFFBQXpCO0lBQ0EsT0FBTyxRQUFRLENBQUMsS0FBSyxJQUFJLEtBQVYsRUFBaUIsRUFBakIsQ0FBZjtFQUNELENBSGMsQ0FBZjtFQUlBLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsS0FBVCxDQUFlLElBQWYsRUFBcUIsTUFBckIsQ0FBckI7RUFDQSxPQUFPLFlBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzVGRDs7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7O0VBQ0EsSUFBSSxjQUFjLFFBQWQsSUFBMEIsRUFBRSxtQkFBbUIsUUFBUSxDQUFDLFFBQTlCLENBQTlCLEVBQXVFO0lBQ3JFLFFBQVEsQ0FBQyxRQUFULENBQWtCLGFBQWxCLEdBQWtDO01BQ2hDLE9BQU8sRUFBRSxRQUR1QjtNQUVoQyxJQUFJLEVBQUUsSUFBSSxDQUFDLEdBQUw7SUFGMEIsQ0FBbEM7RUFJRDs7RUFDRCxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDRDs7QUFOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7ZUFFZTtFQUNiLE9BRGE7O0VBR2IsT0FBTyxDQUFDLHFCQUFELEVBQXdCO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCOztJQUNBLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7TUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtNQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0QsQ0FKRCxDQUlFLE9BQU8sR0FBUCxFQUFZO01BQ1osT0FBTyxDQUFDLElBQVIsQ0FBYyx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQXhEO0lBQ0Q7O0lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixhQUFoQixDQUFQO0VBQ0Q7O0FBZFksQzs7O0FBaUJmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFqQjtFQUNBLE9BQU8sUUFBUSxDQUFDLG1CQUFoQjtFQUNBLE9BQU8sUUFBUSxDQUFDLFlBQWhCO0VBQ0EsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxQkQ7O0FBQ0E7O0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7RUFDQSxNQUFNO0lBQUU7RUFBRixJQUE0QixRQUFsQzs7RUFDQSxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQW5ELEVBQWlFO0lBQy9ELE1BQU07TUFBRTtJQUFGLElBQW1CLFFBQVEsQ0FBQyxxQkFBbEM7SUFFQSxRQUFRLENBQUMscUJBQVQsQ0FBK0IsWUFBL0IsR0FBOEMsWUFBWSxDQUFDLEdBQWIsQ0FBa0IsTUFBRCxJQUFZO01BQ3pFLElBQ0UsTUFBTSxDQUFDLE1BQVAsS0FBa0IsaUNBQUEsQ0FBcUIsU0FBdkMsSUFDQSxNQUFNLENBQUMsYUFGVCxFQUdFO1FBQ0EsT0FBTyxNQUFQO01BQ0Q7O01BQ0QsTUFBTSxDQUFDLGFBQVAsR0FBdUIsSUFBSSxJQUFKLEdBQVcsT0FBWCxFQUF2QjtNQUNBLE9BQU8sTUFBUDtJQUNELENBVDZDLENBQTlDO0VBVUQ7O0VBQ0QsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q0Q7O0FBQ0E7O0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE9BQU8sQ0FBQyxxQkFBRCxFQUF3QjtJQUM3QixNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3Qjs7SUFDQSxJQUFJO01BQ0YsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO01BQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNELENBSkQsQ0FJRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtJQUNEOztJQUNELE9BQU8sT0FBTyxDQUFDLE9BQVIsQ0FBZ0IsYUFBaEIsQ0FBUDtFQUNEOztBQWRZLEM7OztBQWlCZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7RUFFQSxNQUFNO0lBQUU7RUFBRixJQUE0QixRQUFsQzs7RUFDQSxJQUFJLHFCQUFxQixJQUFJLHFCQUFxQixDQUFDLFlBQW5ELEVBQWlFO0lBQy9ELE1BQU07TUFBRTtJQUFGLElBQW1CLFFBQVEsQ0FBQyxxQkFBbEM7O0lBRUEsSUFBSSxZQUFZLENBQUMsTUFBYixJQUF1QixFQUEzQixFQUErQjtNQUM3QixPQUFPLFFBQVA7SUFDRDs7SUFFRCxNQUFNLGFBQWEsR0FBRyxZQUFZLENBQUMsT0FBYixFQUF0QjtJQUNBLElBQUksU0FBUyxHQUFHLElBQWhCOztJQUNBLE9BQU8sYUFBYSxDQUFDLE1BQWQsR0FBdUIsRUFBdkIsSUFBNkIsU0FBcEMsRUFBK0M7TUFDN0MsTUFBTSxPQUFPLEdBQUcsYUFBYSxDQUFDLFNBQWQsQ0FBeUIsTUFBRCxJQUFZO1FBQ2xELE9BQ0UsTUFBTSxDQUFDLE1BQVAsS0FBa0IsaUNBQUEsQ0FBcUIsTUFBdkMsSUFDQSxNQUFNLENBQUMsTUFBUCxLQUFrQixpQ0FBQSxDQUFxQixRQUR2QyxJQUVBLE1BQU0sQ0FBQyxNQUFQLEtBQWtCLGlDQUFBLENBQXFCLFNBRnZDLElBR0EsTUFBTSxDQUFDLE1BQVAsS0FBa0IsaUNBQUEsQ0FBcUIsT0FKekM7TUFNRCxDQVBlLENBQWhCOztNQVFBLElBQUksT0FBTyxHQUFHLENBQWQsRUFBaUI7UUFDZixTQUFTLEdBQUcsS0FBWjtNQUNELENBRkQsTUFFTztRQUNMLGFBQWEsQ0FBQyxNQUFkLENBQXFCLE9BQXJCLEVBQThCLENBQTlCO01BQ0Q7SUFDRjs7SUFFRCxRQUFRLENBQUMscUJBQVQsQ0FBK0IsWUFBL0IsR0FBOEMsYUFBYSxDQUFDLE9BQWQsRUFBOUM7RUFDRDs7RUFDRCxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3JERDs7QUFDQTs7QUFSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFWWSxDOzs7QUFhZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7O0VBQ0EsSUFBSSxDQUFDLFFBQVEsQ0FBQyxxQkFBZCxFQUFxQztJQUNuQyxPQUFPLFFBQVA7RUFDRDs7RUFDRCxNQUFNO0lBQUU7RUFBRixJQUFtQixRQUFRLENBQUMscUJBQWxDO0VBQ0EsUUFBUSxDQUFDLHFCQUFULENBQStCLFlBQS9CLEdBQThDLFlBQVksQ0FBQyxHQUFiLENBQzVDLENBQUMsTUFBRCxFQUFTLENBQVQsS0FBZTtJQUNiLElBQ0UsTUFBTSxDQUFDLE1BQVAsS0FBa0IsaUNBQUEsQ0FBcUIsVUFBdkMsSUFDQSxNQUFNLENBQUMsUUFEUCxJQUVBLE1BQU0sQ0FBQyxRQUFQLENBQWdCLElBSGxCLEVBSUU7TUFDQSxNQUFNLENBQUMsUUFBUCxDQUFnQixJQUFoQixHQUF1QixNQUFNLENBQUMsUUFBUCxDQUFnQixJQUFoQixDQUFxQixXQUFyQixFQUF2QjtJQUNEOztJQUNELE9BQU8sTUFBUDtFQUNELENBVjJDLENBQTlDO0VBWUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0Q0Q7O0FBQ0E7O0FBQ0E7O0FBUkE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVZZLEM7OztBQWFmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFqQjs7RUFFQSxJQUFJLFFBQVEsQ0FBQyxxQkFBYixFQUFvQztJQUNsQyxJQUFJLFFBQVEsQ0FBQyxxQkFBVCxDQUErQixZQUFuQyxFQUFpRDtNQUMvQyxNQUFNO1FBQUU7TUFBRixJQUFtQixRQUFRLENBQUMscUJBQWxDO01BQ0EsUUFBUSxDQUFDLHFCQUFULENBQStCLFlBQS9CLEdBQThDLFlBQVksQ0FBQyxHQUFiLENBQzNDLE1BQUQsSUFBWTtRQUNWLElBQUksTUFBTSxDQUFDLE1BQVAsS0FBa0IsaUNBQUEsQ0FBcUIsVUFBM0MsRUFBdUQ7VUFDckQsT0FBTyxNQUFQO1FBQ0Q7O1FBQ0QsTUFBTSxDQUFDLFFBQVAsR0FBa0IsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFFBQVIsQ0FBbkM7UUFDQSxPQUFPLE1BQVA7TUFDRCxDQVAyQyxDQUE5QztJQVNEO0VBQ0Y7O0VBRUQsT0FBTyxRQUFQO0FBQ0Q7O0FBRUQsU0FBUyxpQkFBVCxDQUEyQixRQUEzQixFQUFxQztFQUNuQztFQUNBLE1BQU0sU0FBUyxHQUFHO0lBQ2hCLElBQUksRUFBRyxJQUFELElBQVUsSUFBQSxrQkFBQSxFQUFhLElBQWIsRUFBbUIsV0FBbkIsRUFEQTtJQUVoQixFQUFFLEVBQUUsTUFBTSxJQUFBLGtCQUFBLEVBQWEsUUFBUSxDQUFDLEVBQXRCLEVBQTBCLFdBQTFCLEVBRk07SUFHaEIsS0FBSyxFQUFHLEtBQUQsSUFBVyxJQUFBLGtCQUFBLEVBQWEsS0FBYixDQUhGO0lBSWhCLEtBQUssRUFBRyxLQUFELElBQVcsSUFBQSxrQkFBQSxFQUFhLEtBQWIsQ0FKRjtJQUtoQixJQUFJLEVBQUcsSUFBRCxJQUFVLElBQUEsa0JBQUEsRUFBYSxJQUFiLENBTEE7SUFNaEIsR0FBRyxFQUFHLEdBQUQsSUFBUyxJQUFBLGtCQUFBLEVBQWEsR0FBYixDQU5FO0lBT2hCLFFBQVEsRUFBRyxRQUFELElBQWMsSUFBQSxrQkFBQSxFQUFhLFFBQWI7RUFQUixDQUFsQixDQUZtQyxDQVluQzs7RUFDQSxNQUFNLGtCQUFrQixHQUFHLEVBQTNCO0VBQ0EsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLEVBQXVCLE9BQXZCLENBQWdDLEdBQUQsSUFBUztJQUN0QyxJQUFJLFFBQVEsQ0FBQyxHQUFELENBQVosRUFBbUI7TUFDakIsa0JBQWtCLENBQUMsR0FBRCxDQUFsQixHQUEwQixTQUFTLENBQUMsR0FBRCxDQUFULENBQWUsUUFBUSxDQUFDLEdBQUQsQ0FBdkIsQ0FBMUI7SUFDRDtFQUNGLENBSkQ7RUFNQSxPQUFPLGtCQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1REQ7O0FBUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7ZUFFZTtFQUNiLE9BRGE7O0VBRWIsT0FBTyxDQUFDLHFCQUFELEVBQXdCO0lBQzdCLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCOztJQUNBLElBQUk7TUFDRixNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7TUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNELENBSEQsQ0FHRSxPQUFPLEdBQVAsRUFBWTtNQUNaLE9BQU8sQ0FBQyxJQUFSLENBQWMsdUJBQXNCLE9BQVEsR0FBRSxHQUFHLENBQUMsS0FBTSxFQUF4RDtNQUNBLE9BQU8sT0FBTyxDQUFDLE1BQVIsQ0FBZSxHQUFmLENBQVA7SUFDRDs7SUFDRCxPQUFPLE9BQU8sQ0FBQyxPQUFSLENBQWdCLGFBQWhCLENBQVA7RUFDRDs7QUFiWSxDOzs7QUFnQmYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQVAsSUFBNEIsQ0FBQyxLQUFLLENBQUMscUJBQXZDLEVBQThEO0lBQzVELE9BQU8sS0FBUDtFQUNEOztFQUVELElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQU4sQ0FBd0IsZUFBN0IsRUFBOEM7SUFDNUMsT0FBTyxLQUFQO0VBQ0Q7O0VBRUQsS0FBSyxDQUFDLHFCQUFOLENBQTRCLFVBQTVCLEdBQXlDLE1BQU0sQ0FBQyxJQUFQLENBQ3ZDLEtBQUssQ0FBQyxpQkFBTixDQUF3QixlQURlLEVBRXZDLE1BRnVDLENBRWhDLENBQUMsVUFBRCxFQUFhLE9BQWIsS0FBeUI7SUFDaEMsVUFBVSxDQUFDLE9BQUQsQ0FBVixHQUFzQjtNQUNwQixJQUFJLEVBQUUsS0FBSyxDQUFDLGlCQUFOLENBQXdCLGVBQXhCLENBQXdDLE9BQXhDLENBRGM7TUFFcEI7SUFGb0IsQ0FBdEI7SUFJQSxPQUFPLFVBQVA7RUFDRCxDQVJ3QyxFQVF0QyxFQVJzQyxDQUF6QztFQVNBLE9BQU8sS0FBSyxDQUFDLGlCQUFOLENBQXdCLGVBQS9CO0VBQ0EsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Q0Q7O0FBQ0E7O0FBUEE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO2VBRWU7RUFDYixPQURhOztFQUdiLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVZZLEM7OztBQWFmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixNQUFNLFFBQVEsR0FBRyxLQUFqQjs7RUFFQSxJQUFJLFFBQVEsQ0FBQyxxQkFBYixFQUFvQztJQUNsQyxJQUFJLFFBQVEsQ0FBQyxxQkFBVCxDQUErQixZQUFuQyxFQUFpRDtNQUMvQyxNQUFNO1FBQUU7TUFBRixJQUFtQixRQUFRLENBQUMscUJBQWxDO01BQ0EsUUFBUSxDQUFDLHFCQUFULENBQStCLFlBQS9CLEdBQThDLFlBQVksQ0FBQyxNQUFiLENBQzNDLE1BQUQsSUFBWSxNQUFNLENBQUMsTUFBUCxLQUFrQixpQ0FBQSxDQUFxQixRQURQLENBQTlDO0lBR0Q7RUFDRjs7RUFFRCxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CRDs7QUFOQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0EsTUFBTSxPQUFPLEdBQUcsRUFBaEI7ZUFFZTtFQUNiLE9BRGE7O0VBR2IsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVlksQzs7O0FBYWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQWpCOztFQUVBLElBQUksUUFBUSxDQUFDLHFCQUFiLEVBQW9DO0lBQ2xDLElBQ0UsUUFBUSxDQUFDLHFCQUFULENBQStCLE1BQS9CLElBQ0EsUUFBUSxDQUFDLHFCQUFULENBQStCLFVBRmpDLEVBR0U7TUFDQSxNQUFNO1FBQUUsVUFBRjtRQUFjO01BQWQsSUFBeUIsUUFBUSxDQUFDLHFCQUF4QztNQUNBLFFBQVEsQ0FBQyxxQkFBVCxDQUErQixhQUEvQixHQUErQyxFQUEvQztNQUNBLE1BQU0sQ0FBQyxJQUFQLENBQVksVUFBWixFQUF3QixPQUF4QixDQUFpQyxRQUFELElBQWM7UUFDNUMsUUFBUSxDQUFDLHFCQUFULENBQStCLGFBQS9CLENBQTZDLFFBQTdDLElBQXlEO1VBQ3ZELE9BQU8sRUFBRTtRQUQ4QyxDQUF6RDtNQUdELENBSkQ7TUFLQSxRQUFRLENBQUMscUJBQVQsQ0FBK0IsTUFBL0IsR0FBd0MsRUFBeEM7SUFDRDtFQUNGOztFQUVELE9BQU8sUUFBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUNEOztBQUNBOzs7O0FBRkE7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFoQixDLENBRUE7O0FBQ0EsTUFBTSxPQUFPLEdBQUcsSUFBaEI7QUFDQSxNQUFNLE9BQU8sR0FBRyxLQUFLLE9BQXJCO0FBQ0EsTUFBTSxLQUFLLEdBQUcsS0FBSyxPQUFuQjtBQUNBLE1BQU0saUJBQWlCLEdBQUcsS0FBSyxLQUEvQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2VBRWU7RUFDYixPQURhO0VBR2IsT0FBTyxFQUFFLElBQUEsZUFBQSxFQUNQLE9BRE8sRUFFUCx1Q0FGTyxFQUdOLE1BQUQsSUFBWTtJQUNWLE1BQU0sVUFBVSxHQUFHLE1BQU0sQ0FBQyxNQUFQLEtBQWtCLGlDQUFBLENBQXFCLFFBQTFEO0lBQ0EsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLGFBQTNCO0lBQ0EsTUFBTSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUwsRUFBWjtJQUNBLE9BQU8sVUFBVSxJQUFJLEdBQUcsR0FBRyxXQUFOLEdBQW9CLGlCQUF6QztFQUNELENBUk07QUFISSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1hmOztBQVBBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFWWSxDOzs7QUFhZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7O0VBQ0EsSUFBSSxLQUFLLENBQUMscUJBQVYsRUFBaUM7SUFDL0IsTUFBTTtNQUFFO0lBQUYsSUFBNEIsUUFBUSxDQUFDLHFCQUEzQzs7SUFDQSxJQUFJLHFCQUFKLEVBQTJCO01BQ3pCLHFCQUFxQixDQUFDLE9BQXRCLENBQThCLENBQUMsR0FBRCxFQUFNLEtBQU4sS0FBZ0I7UUFDNUM7UUFDQSxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTCxDQUFQLElBQXdCLE1BQU0sQ0FBQyxLQUFQLENBQWEsUUFBUSxDQUFDLEdBQUcsQ0FBQyxPQUFMLENBQXJCLENBQTVCLEVBQWlFO1VBQy9ELE9BQU8scUJBQXFCLENBQUMsS0FBRCxDQUFyQixDQUE2QixPQUFwQztRQUNEO01BQ0YsQ0FMRDtNQU1BLFFBQVEsQ0FBQyxxQkFBVCxDQUErQixxQkFBL0IsR0FDRSxxQkFERjtJQUVEO0VBQ0Y7O0VBQ0QsSUFBSSxLQUFLLENBQUMsaUJBQVYsRUFBNkI7SUFDM0IsSUFDRSxRQUFRLENBQUMsaUJBQVQsQ0FBMkIsT0FBM0IsSUFDQTtJQUNBLE1BQU0sQ0FBQyxLQUFQLENBQWEsUUFBUSxDQUFDLFFBQVEsQ0FBQyxpQkFBVCxDQUEyQixPQUE1QixDQUFyQixDQUhGLEVBSUU7TUFDQSxPQUFPLFFBQVEsQ0FBQyxpQkFBVCxDQUEyQixPQUFsQztJQUNEOztJQUVELElBQ0UsUUFBUSxDQUFDLGlCQUFULENBQTJCLFFBQTNCLElBQ0EsUUFBUSxDQUFDLGlCQUFULENBQTJCLFFBQTNCLENBQW9DLE9BRHBDLElBRUE7SUFDQSxNQUFNLENBQUMsS0FBUCxDQUFhLFFBQVEsQ0FBQyxRQUFRLENBQUMsaUJBQVQsQ0FBMkIsUUFBM0IsQ0FBb0MsT0FBckMsQ0FBckIsQ0FKRixFQUtFO01BQ0EsT0FBTyxRQUFRLENBQUMsaUJBQVQsQ0FBMkIsUUFBM0IsQ0FBb0MsT0FBM0M7SUFDRDtFQUNGOztFQUVELE9BQU8sUUFBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUREOztBQURBO0FBR0EsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBR2IsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVlksQzs7O0FBYWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU07SUFBRSxpQkFBRjtJQUFxQjtFQUFyQixJQUErQyxLQUFyRDs7RUFFQSxJQUFJLGlCQUFpQixJQUFJLHFCQUF6QixFQUFnRDtJQUM5QyxNQUFNO01BQUU7SUFBRixJQUFZLGlCQUFsQjtJQUNBLHFCQUFxQixDQUFDLG1CQUF0QixHQUE0QyxPQUFPLENBQUMsS0FBRCxDQUFuRDtFQUNEOztFQUVELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0JEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLGNBQWMsQ0FBQyxLQUFELENBQW5DO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBUlksQzs7O0FBV2YsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU07SUFBRTtFQUFGLElBQTRCLEtBQWxDOztFQUVBLElBQUkscUJBQUosRUFBMkI7SUFDekIsTUFBTTtNQUFFO0lBQUYsSUFBYSxxQkFBcUIsQ0FBQyxZQUF0QixJQUFzQyxFQUF6RCxDQUR5QixDQUV6QjtJQUNBOztJQUNBLHFCQUFxQixDQUFDLG9CQUF0QixHQUE2QyxNQUE3QztFQUNEOztFQUVELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJEOztBQVBBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtlQUVlO0VBQ2IsT0FEYTs7RUFHYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFWWSxDOzs7QUFhZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakIsQ0FENkIsQ0FFN0I7O0VBQ0EsSUFBSSxLQUFLLENBQUMsZ0JBQVYsRUFBNEI7SUFDMUIsT0FBTyxRQUFRLENBQUMsZ0JBQWhCO0VBQ0Q7O0VBQ0QsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQkQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVJZLEM7OztBQVdmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixNQUFNO0lBQUU7RUFBRixJQUE0QixLQUFsQzs7RUFFQSxJQUFJLHFCQUFKLEVBQTJCO0lBQ3pCLE1BQU0sWUFBWSxHQUFHLHFCQUFxQixDQUFDLFlBQXRCLElBQXNDLEVBQTNEOztJQUVBLElBQ0UsQ0FBQyxZQUFZLENBQUMsV0FBZCxJQUNBLE9BQU8scUJBQXFCLENBQUMsbUJBQTdCLEtBQXFELFdBRnZELEVBR0U7TUFDQTtNQUNBLHFCQUFxQixDQUFDLG1CQUF0QixHQUE0QyxJQUE1QztNQUNBLFlBQVksQ0FBQyxXQUFiLEdBQTJCLElBQTNCO0lBQ0Q7RUFDRjs7RUFFRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCRDs7QUFQQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7ZUFFZTtFQUNiLE9BRGE7O0VBR2IsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsYUFBYSxDQUFDLElBQWYsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsSUFDRSxLQUFLLENBQUMscUJBQU4sSUFDQSxLQUFLLENBQUMscUJBQU4sQ0FBNEIsU0FBNUIsS0FBMEMsU0FGNUMsRUFHRTtJQUNBLE9BQU8sS0FBSyxDQUFDLHFCQUFOLENBQTRCLFNBQW5DO0VBQ0Q7O0VBQ0QsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5QkQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTTtJQUFFO0VBQUYsSUFBNEIsS0FBbEM7O0VBRUEsSUFBSSxxQkFBSixFQUEyQjtJQUN6QixNQUFNLFlBQVksR0FBRyxxQkFBcUIsQ0FBQyxZQUF0QixJQUFzQyxFQUEzRDs7SUFFQSxJQUFJLE9BQU8sWUFBWSxDQUFDLFdBQXBCLEtBQW9DLFdBQXhDLEVBQXFEO01BQ25ELE9BQU8sWUFBWSxDQUFDLFdBQXBCO0lBQ0Q7RUFDRjs7RUFFRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzlCRDs7QUFDQTs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsSUFBSSxLQUFLLENBQUMscUJBQVYsRUFBaUM7SUFDL0IsTUFBTSxFQUFFLEdBQUcsS0FBSyxDQUFDLHFCQUFOLENBQTRCLFdBQXZDO0lBRUEsTUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFKLEVBQWpCO0lBQ0EsTUFBTSxjQUFjLEdBQUcsRUFBdkIsQ0FKK0IsQ0FNL0I7O0lBQ0EsTUFBTSxDQUFDLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLE9BQWxCLENBQTJCLENBQUQsSUFBTztNQUMvQixRQUFRLENBQUMsR0FBVCxDQUFhLENBQUMsQ0FBQyxPQUFmO0lBQ0QsQ0FGRCxFQVArQixDQVcvQjs7SUFDQSxLQUFLLE1BQU0sRUFBWCxJQUFpQixRQUFRLENBQUMsTUFBVCxFQUFqQixFQUFvQztNQUNsQztNQUNBLGNBQWMsQ0FBQyxFQUFELENBQWQsR0FBcUIsRUFBckI7O01BQ0EsS0FBSyxNQUFNLE9BQVgsSUFBc0IsRUFBdEIsRUFBMEI7UUFDeEIsSUFBSSxFQUFFLENBQUMsT0FBRCxDQUFGLENBQVksT0FBWixLQUF3QixFQUE1QixFQUFnQztVQUM5QixFQUFFLENBQUMsT0FBRCxDQUFGLENBQVksS0FBWixHQUFvQixLQUFwQjs7VUFDQSxJQUFJLGlCQUFBLENBQUssZ0JBQUwsQ0FBc0IsRUFBRSxDQUFDLE9BQUQsQ0FBRixDQUFZLElBQWxDLENBQUosRUFBNkM7WUFDM0MsRUFBRSxDQUFDLE9BQUQsQ0FBRixDQUFZLEtBQVosR0FBb0IsSUFBcEI7VUFDRDs7VUFDRCxjQUFjLENBQUMsRUFBRCxDQUFkLENBQW1CLE9BQW5CLElBQThCLEVBQUUsQ0FBQyxPQUFELENBQWhDO1FBQ0Q7TUFDRjtJQUNGOztJQUVELEtBQUssQ0FBQyxxQkFBTixDQUE0QixXQUE1QixHQUEwQyxjQUExQztFQUNEOztFQUVELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcEREOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLGNBQWMsQ0FBQyxLQUFELENBQW5DO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBUlksQzs7O0FBV2YsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU07SUFBRSxnQkFBZ0IsRUFBRSxxQkFBcUIsR0FBRztFQUE1QyxJQUFtRCxLQUF6RDtFQUNBLE1BQU07SUFBRSxPQUFPLEdBQUc7RUFBWixJQUFtQixxQkFBekI7O0VBRUEsSUFBSSxPQUFPLENBQUMsaUJBQVosRUFBK0I7SUFDN0IsT0FBTyxLQUFQO0VBQ0Q7O0VBRUQsT0FBTyxFQUNMLEdBQUcsS0FERTtJQUVMLGdCQUFnQixFQUFFLEVBQ2hCLEdBQUcscUJBRGE7TUFFaEIsT0FBTyxFQUFFLEVBQ1AsR0FBRyxPQURJO1FBRVAsaUJBQWlCLEVBQUU7TUFGWjtJQUZPO0VBRmIsQ0FBUDtBQVVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcENELElBQUEsVUFBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxrQkFBQSxPQUFBLENBQUEseUNBQUEsQ0FBQSxDQUFBOztBQUVBLE1BQU0sVUFBVSxFQUFoQixDQUFBO0FBRUEsTUFBTSwwQkFBMEIsNENBQWhDLENBQUE7QUFDQSxNQUFNLHNCQUFzQixLQUE1QixDQUFBO0FBQ0EsTUFBTSxtQkFBbUIsS0FBekIsQ0FBQTs7QUFFQSxrQkFBa0IsUUFBUSxFQUExQixFQUE4QjtFQUM1QixPQUNFLEtBQUssSUFDTCxPQUFPLEtBQVAsS0FBaUIsUUFEakIsSUFFQSxLQUFLLE9BQUwsS0FBaUIsbUJBRmpCLElBR0EsQ0FBQSxDQUFBLEVBQUEsZUFBQSxxQkFBQSxFQUFxQixLQUFLLFFBQTFCLENBQUEsS0FBd0MsdUJBSjFDLENBQUE7Q0FNRDs7Ozs7Ozs7OztlQVNjO0VBQ2IsT0FEYTs7RUFFYixhQUFBLHdCQUFxQztJQUNuQyxNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQUEsRUFBVSxxQkFBVixDQUF0QixDQUFBO0lBQ0EsYUFBYSxLQUFiLFFBQUEsR0FBNkIsT0FBN0IsQ0FBQTtJQUNBLE1BQU0sUUFBUSxhQUFhLEtBQTNCLENBQUE7SUFDQSxhQUFhLEtBQWIsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkMsQ0FBQTtJQUNBLE9BQU8sYUFBUCxDQUFBO0dBQ0Q7Ozs7O0FBR0gsK0JBQStCO0VBQzdCLE1BQU07O0dBQUEsR0FBNEIsS0FBbEMsQ0FBQTs7RUFFQSxJQUFJLHFCQUFKLEVBQTJCO0lBQ3pCLE1BQU0sU0FBUyxxQkFBcUIsT0FBckIsSUFBZ0MsRUFBL0MsQ0FBQTs7SUFDQSxJQUFJLEtBQUssUUFBTCxDQUFjLE1BQWQsQ0FBSixFQUEyQjtNQUN6QixLQUFLLE1BQU0sS0FBWCxJQUFvQixNQUFwQixFQUE0QjtRQUMxQixJQUFJLFFBQVEsQ0FBQyxLQUFELENBQVosRUFBcUI7VUFDbkIsS0FBSyxPQUFMLEdBQWUsZ0JBQWYsQ0FBQTtTQUNEO09BQ0Y7S0FDRjs7SUFFRCxNQUFNLGdCQUFnQixxQkFBcUIsY0FBckIsSUFBdUMsRUFBN0QsQ0FBQTs7SUFDQSxJQUFJLGFBQWEsSUFBSSxPQUFPLGFBQVAsS0FBeUIsUUFBOUMsRUFBd0Q7TUFDdEQsS0FBSyxNQUFNLE9BQVgsSUFBc0IsTUFBTSxLQUFOLENBQVksYUFBWixDQUF0QixFQUFrRDtRQUNoRCxNQUFNLGdCQUFnQixhQUFhLENBQUMsT0FBRCxDQUFuQyxDQUFBOztRQUNBLElBQUksYUFBYSxJQUFJLE9BQU8sYUFBUCxLQUF5QixRQUE5QyxFQUF3RDtVQUN0RCxLQUFLLE1BQU0sT0FBWCxJQUFzQixNQUFNLEtBQU4sQ0FBWSxhQUFaLENBQXRCLEVBQWtEO1lBQ2hELE1BQU0sa0JBQWtCLGFBQWEsQ0FBQyxPQUFELENBQXJDLENBQUE7O1lBQ0EsSUFBSSxLQUFLLFFBQUwsQ0FBYyxlQUFkLENBQUosRUFBb0M7Y0FDbEMsS0FBSyxNQUFNLEtBQVgsSUFBb0IsZUFBcEIsRUFBcUM7Z0JBQ25DLElBQUksUUFBUSxDQUFDLEtBQUQsQ0FBWixFQUFxQjtrQkFDbkIsS0FBSyxPQUFMLEdBQWUsZ0JBQWYsQ0FBQTtpQkFDRDtlQUNGO2FBQ0Y7V0FDRjtTQUNGO09BQ0Y7S0FDRjtHQUNGOztFQUVELE9BQU8sS0FBUCxDQUFBO0NBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEVEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVJZLEM7OztBQVdmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixPQUFPLEtBQUssQ0FBQywwQkFBYjtFQUNBLE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkJEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLGNBQWMsQ0FBQyxLQUFELENBQW5DO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBUlksQzs7O0FBV2YsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLElBQUksS0FBSyxDQUFDLHFCQUFOLElBQStCLEtBQUssQ0FBQyxxQkFBTixDQUE0QixXQUEvRCxFQUE0RTtJQUMxRSxLQUFLLENBQUMscUJBQU4sQ0FBNEIsV0FBNUIsQ0FBd0MsaUJBQXhDLEdBQ0UsS0FBSyxDQUFDLHFCQUFOLENBQTRCLFdBQTVCLENBQXdDLG1CQUQxQztJQUVBLE9BQU8sS0FBSyxDQUFDLHFCQUFOLENBQTRCLFdBQTVCLENBQXdDLG1CQUEvQztFQUNEOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsSUFBSSxLQUFLLENBQUMsa0JBQVYsRUFBOEI7SUFDNUIsS0FBSyxDQUFDLGtCQUFOLENBQXlCLGtDQUF6QixHQUE4RCxLQUE5RDtFQUNELENBRkQsTUFFTztJQUNMLEtBQUssQ0FBQyxrQkFBTixHQUEyQjtNQUN6QixrQ0FBa0MsRUFBRTtJQURYLENBQTNCO0VBR0Q7O0VBQ0QsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1QkQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFBQTs7RUFDN0IsSUFBSSxLQUFKLGFBQUksS0FBSix3Q0FBSSxLQUFLLENBQUUscUJBQVgsa0RBQUksc0JBQThCLGlCQUFsQyxFQUFxRDtJQUNuRCxPQUFPLEtBQUssQ0FBQyxxQkFBTixDQUE0QixpQkFBbkM7RUFDRDs7RUFDRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCRDs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVJZLEM7OztBQVdmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3QixJQUNFLFFBQU8sS0FBUCxhQUFPLEtBQVAsZ0RBQU8sS0FBSyxDQUFFLGtCQUFkLDBEQUFPLHNCQUEyQiw2QkFBbEMsTUFDQSxXQUZGLEVBR0U7SUFDQSxPQUFPLEtBQUssQ0FBQyxrQkFBTixDQUF5Qiw2QkFBaEM7RUFDRDs7RUFDRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzFCRCxJQUFBLFVBQUEsT0FBQSxDQUFBLFFBQUEsQ0FBQSxDQUFBOztBQUVBLE1BQU0sVUFBVSxFQUFoQixDQUFBOzs7OztlQUtlO0VBQ2IsT0FEYTs7RUFFYixhQUFBLHdCQUFxQztJQUNuQyxNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQUEsRUFBVSxxQkFBVixDQUF0QixDQUFBO0lBQ0EsYUFBYSxLQUFiLFFBQUEsR0FBNkIsT0FBN0IsQ0FBQTtJQUNBLE1BQU0sUUFBUSxhQUFhLEtBQTNCLENBQUE7SUFDQSxhQUFhLEtBQWIsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkMsQ0FBQTtJQUNBLE9BQU8sYUFBUCxDQUFBO0dBQ0Q7Ozs7QUFHSCxNQUFNLG1CQUFtQixDQUFDLFNBQUQsRUFBWSxnQkFBWixDQUF6QixDQUFBOztBQUVBLCtCQUErQjtFQUFBLElBQUEscUJBQUEsQ0FBQTs7RUFDN0IsSUFBSSxnQkFBZ0IsU0FBaEIsQ0FBMEIsS0FBMUIsS0FBQSxJQUFBLElBQTBCLEtBQTFCLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEsQ0FBQSx3QkFBMEIsS0FBSyxzQkFBL0IsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBMEIscUJBQUEsWUFBMUIsQ0FBSixFQUEwRTtJQUN4RSxLQUFLLHNCQUFMLFlBQUEsR0FBMEMsV0FBMUMsQ0FBQTtHQUNEOztFQUNELE9BQU8sS0FBUCxDQUFBO0NBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekJEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLGNBQWMsQ0FBQyxLQUFELENBQW5DO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBUlksQzs7O0FBV2YsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLElBQUksUUFBTyxLQUFQLGFBQU8sS0FBUCx1QkFBTyxLQUFLLENBQUUsZ0JBQWQsTUFBbUMsV0FBdkMsRUFBb0Q7SUFDbEQsT0FBTyxLQUFLLENBQUMsZ0JBQWI7RUFDRDs7RUFDRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZCRDs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVJZLEM7OztBQVdmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3QixNQUFNLFlBQVksR0FBRyxLQUFILGFBQUcsS0FBSCxnREFBRyxLQUFLLENBQUUscUJBQVYsMERBQUcsc0JBQThCLFlBQW5EOztFQUNBLElBQUksS0FBSyxDQUFDLE9BQU4sQ0FBYyxZQUFkLENBQUosRUFBaUM7SUFDL0IsWUFBWSxDQUFDLE9BQWIsQ0FBc0IsV0FBRCxJQUFpQjtNQUNwQyxJQUFJLE9BQU8sV0FBVyxDQUFDLGlCQUFuQixLQUF5QyxRQUE3QyxFQUF1RDtRQUNyRCxXQUFXLENBQUMsaUJBQVosR0FDRSxXQUFXLENBQUMsaUJBQVosQ0FBOEIsUUFBOUIsRUFERjtNQUVEO0lBQ0YsQ0FMRDtFQU1EOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JELElBQUEsVUFBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUE7O0FBRUEsTUFBTSxVQUFVLEVBQWhCLENBQUE7Ozs7Ozs7Ozs7Ozs7O2VBY2U7RUFDYixPQURhOztFQUViLGFBQUEsd0JBQXFDO0lBQ25DLE1BQU0sZ0JBQWdCLENBQUEsQ0FBQSxFQUFBLE9BQUEsVUFBQSxFQUFVLHFCQUFWLENBQXRCLENBQUE7SUFDQSxhQUFhLEtBQWIsUUFBQSxHQUE2QixPQUE3QixDQUFBO0lBQ0EsTUFBTSxRQUFRLGFBQWEsS0FBM0IsQ0FBQTtJQUNBLGFBQWEsS0FBYixHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQyxDQUFBO0lBQ0EsT0FBTyxhQUFQLENBQUE7R0FDRDs7OztBQUdILE1BQU0sV0FBVyxpQkFBakIsQ0FBQTtBQUNBLE1BQU0sZUFBZSwwQkFBckIsQ0FBQTs7QUFFQSx3QkFBd0IsUUFBUSxFQUFoQyxFQUFvQztFQUFBLElBQUEscUJBQUEsRUFBQSxzQkFBQSxFQUFBLHNCQUFBLEVBQUEscUJBQUEsRUFBQSxxQkFBQSxFQUFBLHFCQUFBLEVBQUEscUJBQUEsRUFBQSxzQkFBQSxFQUFBLHFCQUFBLENBQUE7OztFQUVsQyxDQUFBLHdCQUFPLEtBQUssa0JBQVosTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxJQUFBLEdBQUEsT0FBTyxxQkFBQSxTQUFQLENBRmtDOztFQUtsQyxNQUFNLFdBQVcsQ0FBQSxDQUFBLHlCQUFBLEtBQUssa0JBQUwsTUFBQSxJQUFBLElBQUEsc0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxzQkFBQSxTQUFBLEtBQXFDLEVBQXRELENBQUE7RUFDQSxNQUFNLGdDQUNKLFFBQVEsS0FBUixLQUFrQixLQUFsQixLQUNDLE9BQU8sUUFBUSxRQUFmLEtBQTRCLFFBQTVCLElBQ0MsQ0FBQyxZQUFZLEtBQVosQ0FBa0IsUUFBUSxRQUExQixDQUZILENBREYsQ0FBQTs7RUFJQSxJQUFJLDZCQUE2QixJQUFJLFFBQVEsS0FBUixLQUFrQixXQUF2RCxFQUFvRTtJQUNsRSxLQUFLLGtCQUFMLFNBQUEsR0FBbUM7TUFDakMsTUFBTSxTQUQyQjtNQUVqQyxRQUFRLEVBRnlCO01BR2pDLFNBQVMsS0FId0I7TUFJakMsVUFBVSxFQUp1QjtNQUtqQyxVQUFVLEVBTHVCO01BTWpDLFFBQVEsS0FBQTtLQU5WLENBQUE7R0FERixNQVNPLElBQUEsQ0FBQSx5QkFBSSxLQUFLLGtCQUFULE1BQUEsSUFBQSxJQUFBLHNCQUFBLEtBQUEsS0FBQSxDQUFBLElBQUksc0JBQUEsU0FBSixFQUF1QztJQUFBLElBQUEsc0JBQUEsRUFBQSxzQkFBQSxDQUFBOztJQUM1QyxJQUFJLFdBQUEsSUFBZSxLQUFLLGtCQUFMLFNBQW5CLEVBQXFEO01BQ25ELE1BQU0sU0FBUyxLQUFLLGtCQUFMLFNBQUEsVUFBZixDQUFBO01BQ0EsS0FBSyxrQkFBTCxTQUFBLE9BQUEsR0FBMEMsTUFBMUMsQ0FBQTtLQUNEOztJQUNELENBQUEseUJBQU8sS0FBSyxrQkFBWixNQUFBLElBQUEsSUFBQSxzQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUFBLHlCQUFPLHNCQUFBLFNBQVAsTUFBQSxJQUFBLElBQUEsc0JBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxJQUFBLEdBQUEsT0FBTyxzQkFBQSxVQUFQLENBQUE7R0F4QmdDOzs7RUE0QmxDLElBQUksQ0FBQyxLQUFLLHNCQUFWLEVBQWtDO0lBQ2hDLEtBQUssc0JBQUwsR0FBOEIsRUFBOUIsQ0FBQTtHQUNEOztFQUNELElBQUksQ0FBQyxLQUFLLHNCQUFMLHNCQUFMLEVBQXdEO0lBQ3RELEtBQUssc0JBQUwsc0JBQUEsR0FBb0QsRUFBcEQsQ0FBQTtHQUNEOztFQUNELEtBQUssc0JBQUwsc0JBQUEsUUFBQSxDQUEwRDtJQUN4RCxRQUFRLHVCQURnRDtJQUV4RCxTQUFTLE9BRitDO0lBR3hELFFBQVEsS0FIZ0Q7SUFJeEQsVUFBVSxnQkFKOEM7SUFLeEQsVUFBVSxFQUFBO0dBTFosQ0FBQSxDQWxDa0M7O0VBMkNsQyxDQUFBLHdCQUFPLEtBQUsseUJBQVosTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxJQUFBLEdBQUEsT0FBTyxxQkFBQSxlQUFQLENBM0NrQzs7RUE4Q2xDLE1BQU0sZUFBWSxDQUFBLHdCQUFHLEtBQUssc0JBQVIsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBRyxxQkFBQSxhQUFyQixDQUFBOztFQUNBLElBQUksS0FBSyxRQUFMLENBQWMsWUFBZCxDQUFKLEVBQWlDO0lBQy9CLFlBQVksUUFBWixDQUFzQixlQUFnQjtNQUNwQyxNQUFNLG9CQUFvQixXQUFILEtBQUEsSUFBQSxJQUFHLFdBQUgsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBRyxXQUFXLGtCQUFyQyxDQUFBOztNQUNBLElBQ0UsT0FBTyxpQkFBUCxLQUE2QixRQUE3QixJQUNBLFFBQVEsS0FBUixDQUFjLGlCQUFkLENBRkYsRUFHRTtRQUNBLFdBQVcsa0JBQVgsR0FBZ0MsUUFBUSxDQUN0QyxpQkFEc0MsRUFFdEMsRUFGc0MsQ0FBUixTQUFBLENBR3JCLEVBSHFCLENBQWhDLENBQUE7T0FJRDtLQVZILENBQUEsQ0FBQTtHQWhEZ0M7OztFQStEbEMsTUFBTSxjQUFjLENBQUEsQ0FBQSx3QkFBQSxLQUFLLHNCQUFMLE1BQUEsSUFBQSxJQUFBLHFCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUEscUJBQUEsWUFBQSxLQUE0QyxFQUFoRSxDQUFBO0VBQ0EsTUFBTSxLQUFOLENBQVksV0FBWixDQUFBLFFBQUEsQ0FBa0MsY0FBZTtJQUMvQyxJQUFJLFNBQUEsS0FBQSxDQUFlLFVBQWYsQ0FBSixFQUFnQztNQUM5QixNQUFNLFVBQVcsQ0FBQSxFQUFBLEVBQUksUUFBUSxDQUFDLFVBQUQsRUFBYSxFQUFiLENBQVIsU0FBQSxDQUFrQyxFQUFsQyxDQUFzQyxDQUFBLENBQTNELENBQUE7TUFDQSxjQUFjLENBQUMsV0FBVyxDQUFDLFVBQUQsQ0FBWixFQUEwQixPQUExQixDQUFkLENBQUE7O01BRUEsSUFBSSxXQUFXLENBQUMsT0FBRCxDQUFmLEVBQTBCO1FBQ3hCLG9CQUFvQixDQUFDLFdBQUQsRUFBYyxVQUFkLEVBQTBCLE9BQTFCLENBQXBCLENBQUE7T0FERixNQUVPO1FBQ0wsV0FBVyxDQUFDLE9BQUQsQ0FBWCxHQUF1QixXQUFXLENBQUMsVUFBRCxDQUFsQyxDQUFBO09BQ0Q7O01BQ0QsT0FBTyxXQUFXLENBQUMsVUFBRCxDQUFsQixDQUFBO0tBQ0Q7R0FYSCxDQUFBLENBaEVrQzs7RUErRWxDLENBQUEsd0JBQU8sS0FBSywrQkFBWixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUEsR0FBQSxDQUFBLHlCQUFPLHFCQUFBLHFDQUFQLE1BQUEsSUFBQSxJQUFBLHNCQUFBLEtBQUEsS0FBQSxDQUFBLEdBQUEsSUFBQSxHQUFBLE9BQU8sc0JBQUEsVUFBUCxDQS9Fa0M7O0VBbUZsQyxNQUFNLGdCQUFhLENBQUEsd0JBQUcsS0FBSyxzQkFBUixNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFHLHFCQUFBLGNBQXRCLENBQUE7O0VBQ0EsSUFBSSxhQUFKLEVBQW1CO0lBQ2pCLE1BQU0sS0FBTixDQUFZLGFBQVosQ0FBQSxRQUFBLENBQW9DLFdBQVk7TUFBQSxJQUFBLHFCQUFBLEVBQUEsc0JBQUEsQ0FBQTs7TUFDOUMsTUFBTSxrQkFBa0IsQ0FBQSxDQUFBLHdCQUFBLGFBQWEsQ0FBQyxPQUFELENBQWIsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxxQkFBQSxVQUFBLEtBQXFDLEVBQTdELENBQUE7O01BRUEsSUFBSSxlQUFlLE9BQWYsR0FBeUIsQ0FBN0IsRUFBZ0M7UUFDOUIsTUFBTSxZQUFZLGFBQWEsQ0FBQyxPQUFELENBQWIsSUFBQSxJQUE4QixFQUFoRCxDQUFBOztRQUVBLElBQUksU0FBUyxPQUFULEdBQW1CLENBQXZCLEVBQTBCO1VBQ3hCLGFBQWEsQ0FBQyxPQUFELENBQWIsSUFBQSxHQUE2QixnQkFBZ0IsQ0FDM0MsZUFEMkMsRUFFM0MsU0FGMkMsQ0FBN0MsQ0FBQTtTQURGLE1BS087VUFDTCxhQUFhLENBQUMsT0FBRCxDQUFiLElBQUEsR0FBNkIsZUFBN0IsQ0FBQTtTQUNEO09BQ0Y7O01BQ0QsQ0FBQSx5QkFBTyxhQUFhLENBQUMsT0FBRCxDQUFwQixNQUFBLElBQUEsSUFBQSxzQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLElBQUEsR0FBQSxPQUFPLHNCQUFBLFVBQVAsQ0FBQTtLQWZGLENBQUEsQ0FBQTtHQWlCRDs7RUFFRCxPQUFPLEtBQVAsQ0FBQTtDQUNEOzs7Ozs7Ozs7O0FBU0QsbUVBQW1FO0VBQ2pFLE1BQU0sb0JBQW9CLFdBQVcsQ0FBQyxVQUFELENBQVgsSUFBMkIsRUFBckQsQ0FEaUU7O0VBR2pFLE1BQU0sYUFBYSxFQUFFLEdBQUcsV0FBVyxDQUFDLFVBQUQsQ0FBQTtHQUFuQyxDQUhpRTs7RUFNakUsTUFBTSxLQUFOLENBQVksaUJBQVosQ0FBQSxRQUFBLENBQXdDLFdBQVk7SUFDbEQsSUFBSSxVQUFVLENBQUMsT0FBRCxDQUFWLElBQXVCLE9BQU8sVUFBVSxDQUFDLE9BQUQsQ0FBakIsS0FBK0IsUUFBMUQsRUFBb0U7TUFDbEUsTUFBTSxjQUFjLEVBQXBCLENBRGtFOzs7TUFLbEUsSUFBSSxHQUFKLENBQVEsQ0FDTixHQUFHLE1BQU0sS0FBTixDQUFZLFVBQVUsQ0FBQyxPQUFELENBQXRCLENBREcsRUFFTixHQUFHLE1BQU0sS0FBTixDQUFZLGlCQUFpQixDQUFDLE9BQUQsQ0FBakIsSUFBOEIsRUFBMUMsQ0FGRyxDQUFSLENBQUEsUUFBQSxDQUdZLE9BQVE7UUFBQSxJQUFBLHFCQUFBLENBQUE7OztRQUVsQixXQUFXLENBQUMsR0FBRCxDQUFYLEdBQ0UsVUFBVSxDQUFDLE9BQUQsQ0FBVixDQUFvQixHQUFwQixDQUFBLEtBQUEsQ0FBQSx3QkFBNEIsaUJBQWlCLENBQUMsT0FBRCxDQUE3QyxNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUE0QixxQkFBQSxDQUE2QixHQUE3QixDQUE1QixDQUFBLElBQWlFLEVBRG5FLENBQUE7T0FMRixDQUFBLENBQUE7TUFTQSxVQUFVLENBQUMsT0FBRCxDQUFWLEdBQXNCLFdBQXRCLENBQUE7S0FkRixNQWVPLElBQ0wsaUJBQWlCLENBQUMsT0FBRCxDQUFqQixJQUNBLE9BQU8saUJBQWlCLENBQUMsT0FBRCxDQUF4QixLQUFzQyxRQUZqQyxFQUdMOzs7TUFHQSxVQUFVLENBQUMsT0FBRCxDQUFWLEdBQXNCLGlCQUFpQixDQUFDLE9BQUQsQ0FBdkMsQ0FBQTtLQUNEO0dBdkJILENBQUEsQ0FBQTtFQTBCQSxXQUFXLENBQUMsVUFBRCxDQUFYLEdBQTBCLFVBQTFCLENBQUE7Q0FDRDs7Ozs7Ozs7OztBQVNELGlEQUFpRDtFQUMvQyxNQUFNLE9BQU4sQ0FBYyxjQUFkLENBQUEsUUFBQSxDQUF1QyxTQUFVO0lBQy9DLElBQUksS0FBSyxJQUFJLE9BQU8sS0FBUCxLQUFpQixRQUE5QixFQUF3QztNQUN0QyxLQUFLLFFBQUwsR0FBZ0IsT0FBaEIsQ0FBQTtLQUNEO0dBSEgsQ0FBQSxDQUFBO0NBS0Q7Ozs7Ozs7Ozs7O0FBVUQsc0RBQXNEO0VBQ3BELE1BQU0scUJBQXFCLGVBQWUsQ0FBQyxlQUFELENBQTFDLENBQUE7RUFDQSxNQUFNLGVBQWUsZUFBZSxDQUFDLFNBQUQsQ0FBcEMsQ0FBQTtFQUVBLE1BQU0sZUFBZSxFQUFyQixDQUFBO0VBQ0EsSUFBSSxHQUFKLENBQVEsQ0FDTixHQUFHLE1BQU0sS0FBTixDQUFZLGtCQUFaLENBREcsRUFFTixHQUFHLE1BQU0sS0FBTixDQUFZLFlBQVosQ0FGRyxDQUFSLENBQUEsUUFBQSxDQUdZLGdCQUFpQjtJQUMzQixZQUFZLEtBQVosQ0FBa0IsRUFDaEIsR0FBRyxrQkFBa0IsQ0FBQyxZQUFELENBREw7TUFFaEIsR0FBRyxZQUFZLENBQUMsWUFBRCxDQUFBO0tBRmpCLENBQUEsQ0FBQTtHQUpGLENBQUEsQ0FBQTtFQVVBLE9BQU8sWUFBUCxDQUFBOztFQUVBLGdDQUFnQztJQUM5QixPQUFPLEtBQUssT0FBTCxDQUFhLGdCQUFnQjtNQUNsQyxJQUFJLEtBQUssS0FBQSxJQUFMLElBQUEsS0FBSyxLQUFBLEtBQUEsQ0FBTCxJQUFBLEtBQUssUUFBTCxJQUFrQixRQUFPLEtBQVAsS0FBQSxJQUFBLElBQU8sS0FBUCxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFPLEtBQUssUUFBWixDQUFBLEtBQTBCLFFBQWhELEVBQTBEO1FBQ3hELEdBQUcsQ0FBQyxLQUFLLFFBQU4sQ0FBSCxHQUFxQixLQUFyQixDQUFBO09BQ0Q7O01BQ0QsT0FBTyxHQUFQLENBQUE7S0FKSyxFQUtKLEVBTEksQ0FBUCxDQUFBO0dBTUQ7Q0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuT0Q7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBSyxHQUFHLEVBQWhDLEVBQW9DO0VBQ2xDLElBQUksS0FBSyxDQUFDLHFCQUFWLEVBQWlDO0lBQUE7O0lBQy9CLE1BQU07TUFBRSxhQUFGO01BQWlCLHdCQUFqQjtNQUEyQztJQUEzQyxJQUNKLEtBQUssQ0FBQyxxQkFEUjtJQUVBLEtBQUssQ0FBQyxxQkFBTiw0QkFBOEIsS0FBSyxDQUFDLHFCQUFwQyx5RUFBNkQsRUFBN0Q7O0lBRUEsSUFBSSxhQUFhLEtBQUssU0FBdEIsRUFBaUM7TUFDL0IsS0FBSyxDQUFDLHFCQUFOLENBQTRCLGFBQTVCLEdBQTRDLGFBQTVDO01BQ0EsT0FBTyxLQUFLLENBQUMscUJBQU4sQ0FBNEIsYUFBbkM7SUFDRDs7SUFFRCxJQUFJLHdCQUF3QixLQUFLLFNBQWpDLEVBQTRDO01BQzFDLEtBQUssQ0FBQyxxQkFBTixDQUE0Qix3QkFBNUIsR0FDRSx3QkFERjtNQUVBLE9BQU8sS0FBSyxDQUFDLHFCQUFOLENBQTRCLHdCQUFuQztJQUNEOztJQUVELElBQUksb0JBQW9CLEtBQUssU0FBN0IsRUFBd0M7TUFDdEMsS0FBSyxDQUFDLHFCQUFOLENBQTRCLG9CQUE1QixHQUFtRCxvQkFBbkQ7TUFDQSxPQUFPLEtBQUssQ0FBQyxxQkFBTixDQUE0QixvQkFBbkM7SUFDRDtFQUNGOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekNEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUEsTUFBTSx5QkFBeUIsR0FBRyxDQUNoQyw2Q0FEZ0MsRUFFaEMsOEJBRmdDLEVBR2hDLGFBSGdDLEVBSWhDLHNDQUpnQyxFQUtoQyx1QkFMZ0MsRUFNaEMsa0NBTmdDLEVBT2hDLGlEQVBnQyxFQVFoQyxrQ0FSZ0MsRUFTaEMsbUJBVGdDLENBQWxDO0FBWUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUVBLHlCQUF5QixDQUFDLE9BQTFCLENBQW1DLEdBQUQ7TUFBQTs7TUFBQSwrQkFDaEMsTUFBTSxDQUFDLFlBRHlCLHlEQUNoQyxxQkFBcUIsVUFBckIsQ0FBZ0MsR0FBaEMsQ0FEZ0M7SUFBQSxDQUFsQztJQUlBLE9BQU8sYUFBUDtFQUNEOztBQVhZLEM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkJmOztBQUNBOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLGNBQWMsQ0FBQyxLQUFELENBQW5DO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBUlksQzs7O0FBV2YsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQUE7O0VBQzdCLE1BQU07SUFBRSxPQUFGO0lBQVc7RUFBWCxJQUFvQixDQUFBLEtBQUssU0FBTCxJQUFBLEtBQUssV0FBTCxxQ0FBQSxLQUFLLENBQUUsaUJBQVAsZ0ZBQTBCLFFBQTFCLEtBQXNDLEVBQWhFO0VBQ0EsTUFBTSxXQUFXLDRCQUFHLDBCQUFBLENBQWtCLElBQWxCLENBQUgsMERBQUcsc0JBQXlCLE9BQTdDOztFQUVBLElBQUksV0FBVyxJQUFJLE9BQU8sS0FBSyxXQUEvQixFQUE0QztJQUMxQyxLQUFLLENBQUMsaUJBQU4sQ0FBd0IsUUFBeEIsQ0FBaUMsT0FBakMsR0FBMkMsV0FBM0M7RUFDRDs7RUFDRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNCRDs7QUFDQTs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVJZLEM7OztBQVdmLFNBQVMsY0FBVCxDQUF3QixLQUFLLEdBQUcsRUFBaEMsRUFBb0M7RUFDbEMsSUFBSSxLQUFLLENBQUMscUJBQVYsRUFBaUM7SUFDL0IsTUFBTTtNQUFFLGFBQUY7TUFBaUIsbUJBQWpCO01BQXNDO0lBQXRDLElBQ0osS0FBSyxDQUFDLHFCQURSO0lBR0EsTUFBTSxnQkFBZ0IsR0FBRyxFQUF6QjtJQUNBLE1BQU0sc0JBQXNCLEdBQUcsRUFBL0I7O0lBRUEsSUFBSSxhQUFhLElBQUksTUFBTSxDQUFDLElBQVAsQ0FBWSxhQUFaLEVBQTJCLE1BQTNCLEdBQW9DLENBQXpELEVBQTREO01BQzFELEtBQUssTUFBTSxPQUFYLElBQXNCLE1BQU0sQ0FBQyxJQUFQLENBQVksYUFBWixDQUF0QixFQUFrRDtRQUNoRCxnQkFBZ0IsQ0FBQyxPQUFELENBQWhCLEdBQTRCLEVBQTVCOztRQUNBLElBQUksYUFBYSxDQUFDLE9BQUQsQ0FBYixDQUF1QixzQkFBQSxDQUFjLEdBQXJDLENBQUosRUFBK0M7VUFDN0MscUJBQXFCLENBQUMsT0FBdEIsQ0FBK0IsTUFBRCxJQUFZO1lBQ3hDLGdCQUFnQixDQUFDLE9BQUQsQ0FBaEIsQ0FBMEIsTUFBTSxDQUFDLE9BQWpDLElBQ0UsYUFBYSxDQUFDLE9BQUQsQ0FBYixDQUF1QixzQkFBQSxDQUFjLEdBQXJDLENBREY7VUFFRCxDQUhEO1FBSUQ7O1FBQ0QsS0FBSyxNQUFNLFlBQVgsSUFBMkIsTUFBTSxDQUFDLElBQVAsQ0FBWSxhQUFhLENBQUMsT0FBRCxDQUF6QixDQUEzQixFQUFnRTtVQUM5RCxRQUFRLFlBQVI7WUFDRSxLQUFLLHNCQUFBLENBQWMsT0FBbkI7Y0FDRSxnQkFBZ0IsQ0FBQyxPQUFELENBQWhCLENBQTBCLGtCQUFBLENBQVUsT0FBcEMsSUFDRSxhQUFhLENBQUMsT0FBRCxDQUFiLENBQXVCLHNCQUFBLENBQWMsT0FBckMsQ0FERjtjQUVBOztZQUNGLEtBQUssU0FBTDtjQUNFLGdCQUFnQixDQUFDLE9BQUQsQ0FBaEIsQ0FBMEIsS0FBMUIsSUFBbUMsYUFBYSxDQUFDLE9BQUQsQ0FBYixDQUF1QixPQUExRDtjQUNBOztZQUNGLEtBQUssU0FBTDtjQUNFLGdCQUFnQixDQUFDLE9BQUQsQ0FBaEIsQ0FBMEIsS0FBMUIsSUFBbUMsYUFBYSxDQUFDLE9BQUQsQ0FBYixDQUF1QixPQUExRDtjQUNBOztZQUNGLEtBQUssc0JBQUEsQ0FBYyxNQUFuQjtjQUNFLGdCQUFnQixDQUFDLE9BQUQsQ0FBaEIsQ0FBMEIsa0JBQUEsQ0FBVSxNQUFwQyxJQUNFLGFBQWEsQ0FBQyxPQUFELENBQWIsQ0FBdUIsc0JBQUEsQ0FBYyxNQUFyQyxDQURGO2NBRUE7O1lBQ0YsS0FBSyxPQUFMO2NBQ0UsZ0JBQWdCLENBQUMsT0FBRCxDQUFoQixDQUEwQixNQUExQixJQUFvQyxhQUFhLENBQUMsT0FBRCxDQUFiLENBQXVCLEtBQTNEO2NBQ0E7O1lBQ0Y7Y0FDRTtVQW5CSjtRQXFCRDtNQUNGOztNQUNELEtBQUssQ0FBQyxxQkFBTixDQUE0QixhQUE1QixHQUE0QyxnQkFBNUM7SUFDRDs7SUFFRCxJQUFJLG1CQUFtQixJQUFJLE1BQU0sQ0FBQyxJQUFQLENBQVksbUJBQVosRUFBaUMsTUFBakMsR0FBMEMsQ0FBckUsRUFBd0U7TUFDdEUsS0FBSyxNQUFNLE9BQVgsSUFBc0IsTUFBTSxDQUFDLElBQVAsQ0FBWSxtQkFBWixDQUF0QixFQUF3RDtRQUN0RCxzQkFBc0IsQ0FBQyxPQUFELENBQXRCLEdBQWtDLEVBQWxDOztRQUNBLElBQUksbUJBQW1CLENBQUMsT0FBRCxDQUFuQixDQUE2QixzQkFBQSxDQUFjLEdBQTNDLENBQUosRUFBcUQ7VUFDbkQscUJBQXFCLENBQUMsT0FBdEIsQ0FBK0IsTUFBRCxJQUFZO1lBQ3hDLHNCQUFzQixDQUFDLE9BQUQsQ0FBdEIsQ0FBZ0MsTUFBTSxDQUFDLE9BQXZDLElBQ0UsbUJBQW1CLENBQUMsT0FBRCxDQUFuQixDQUE2QixzQkFBQSxDQUFjLEdBQTNDLENBREY7VUFFRCxDQUhEO1FBSUQ7O1FBQ0QsS0FBSyxNQUFNLFlBQVgsSUFBMkIsTUFBTSxDQUFDLElBQVAsQ0FBWSxtQkFBbUIsQ0FBQyxPQUFELENBQS9CLENBQTNCLEVBQXNFO1VBQ3BFLFFBQVEsWUFBUjtZQUNFLEtBQUssc0JBQUEsQ0FBYyxPQUFuQjtjQUNFLHNCQUFzQixDQUFDLE9BQUQsQ0FBdEIsQ0FBZ0Msa0JBQUEsQ0FBVSxPQUExQyxJQUNFLG1CQUFtQixDQUFDLE9BQUQsQ0FBbkIsQ0FBNkIsc0JBQUEsQ0FBYyxPQUEzQyxDQURGO2NBRUE7O1lBQ0YsS0FBSyxTQUFMO2NBQ0Usc0JBQXNCLENBQUMsT0FBRCxDQUF0QixDQUFnQyxLQUFoQyxJQUNFLG1CQUFtQixDQUFDLE9BQUQsQ0FBbkIsQ0FBNkIsT0FEL0I7Y0FFQTs7WUFDRixLQUFLLFNBQUw7Y0FDRSxzQkFBc0IsQ0FBQyxPQUFELENBQXRCLENBQWdDLEtBQWhDLElBQ0UsbUJBQW1CLENBQUMsT0FBRCxDQUFuQixDQUE2QixPQUQvQjtjQUVBOztZQUNGLEtBQUssc0JBQUEsQ0FBYyxNQUFuQjtjQUNFLHNCQUFzQixDQUFDLE9BQUQsQ0FBdEIsQ0FBZ0Msa0JBQUEsQ0FBVSxNQUExQyxJQUNFLG1CQUFtQixDQUFDLE9BQUQsQ0FBbkIsQ0FBNkIsc0JBQUEsQ0FBYyxNQUEzQyxDQURGO2NBRUE7O1lBQ0YsS0FBSyxPQUFMO2NBQ0Usc0JBQXNCLENBQUMsT0FBRCxDQUF0QixDQUFnQyxNQUFoQyxJQUNFLG1CQUFtQixDQUFDLE9BQUQsQ0FBbkIsQ0FBNkIsS0FEL0I7Y0FFQTs7WUFDRjtjQUNFO1VBdEJKO1FBd0JEO01BQ0Y7O01BQ0QsS0FBSyxDQUFDLHFCQUFOLENBQTRCLG1CQUE1QixHQUFrRCxzQkFBbEQ7SUFDRDtFQUNGOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMUdEOztBQUNBOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLGNBQWMsQ0FBQyxLQUFELENBQW5DO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBUlksQzs7O0FBV2YsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQUE7O0VBQzdCLE1BQU0sWUFBWSxHQUFHLEtBQUgsYUFBRyxLQUFILGdEQUFHLEtBQUssQ0FBRSxxQkFBViwwREFBRyxzQkFBOEIsWUFBbkQ7RUFDQSxNQUFNLG9CQUFvQixHQUN4QixLQUR3QixhQUN4QixLQUR3QixnREFDeEIsS0FBSyxDQUFFLDhCQURpQiwwREFDeEIsc0JBQXVDLG9CQUR6Qzs7RUFFQSxJQUFJLEtBQUssQ0FBQyxPQUFOLENBQWMsWUFBZCxDQUFKLEVBQWlDO0lBQy9CLFlBQVksQ0FBQyxPQUFiLENBQXNCLFdBQUQsSUFBaUI7TUFDcEMsSUFBSSxXQUFKLEVBQWlCO1FBQ2YsSUFDRSxXQUFXLENBQUMsSUFBWixLQUFxQiw4QkFBQSxDQUFrQixLQUF2QyxJQUNBLFdBQVcsQ0FBQyxJQUFaLEtBQXFCLDhCQUFBLENBQWtCLE1BRnpDLEVBR0U7VUFDQSxXQUFXLENBQUMsSUFBWixHQUFtQixXQUFXLENBQUMsbUJBQS9CO1FBQ0Q7O1FBQ0QsT0FBTyxXQUFXLENBQUMsbUJBQW5CO01BQ0Q7SUFDRixDQVZEO0VBV0Q7O0VBQ0QsSUFBSSxvQkFBSixFQUEwQjtJQUN4QixNQUFNLDJCQUEyQixHQUFHLE1BQU0sQ0FBQyxPQUFQLENBQWUsb0JBQWYsQ0FBcEM7SUFDQSwyQkFBMkIsQ0FBQyxPQUE1QixDQUFvQyxDQUFDLENBQUMsR0FBRCxFQUFNLFdBQU4sQ0FBRCxLQUF3QjtNQUMxRCxJQUFJLFdBQUosRUFBaUI7UUFDZixPQUFPLFdBQVcsQ0FBQyxtQkFBbkI7UUFDQSxLQUFLLENBQUMsOEJBQU4sQ0FBcUMsb0JBQXJDLENBQTBELEdBQTFELElBQWlFLEVBQy9ELEdBQUcsV0FENEQ7VUFFL0QsSUFBSSxFQUFFLDhCQUFBLENBQWtCO1FBRnVDLENBQWpFO01BSUQ7SUFDRixDQVJEO0VBU0Q7O0VBQ0QsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNqREQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7O0FBRUEsU0FBUyxlQUFULENBQXlCLFFBQXpCLEVBQW1DO0VBQ2pDLE9BQ0UsT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQ0MsT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLFFBQVEsQ0FBQyxLQUFULENBQWUsYUFBZixDQUZuQztBQUlEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFUWSxDOzs7QUFZZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxRQUFRLEdBQUcsS0FBakI7O0VBRUEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxxQkFBZCxFQUFxQztJQUNuQyxPQUFPLFFBQVA7RUFDRDs7RUFFRCxNQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMscUJBQVQsQ0FBK0IsTUFBL0IsSUFBeUMsRUFBeEQsQ0FQNkIsQ0FRN0I7O0VBQ0EsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxDQUFDO0lBQUU7RUFBRixDQUFELEtBQ2hDLGVBQWUsQ0FBQyxRQUFELENBREcsQ0FBcEI7O0VBR0EsS0FBSyxNQUFNLEtBQVgsSUFBb0IsV0FBcEIsRUFBaUM7SUFDL0I7SUFDQSxJQUFJLE9BQU8sS0FBSyxDQUFDLFFBQWIsS0FBMEIsUUFBOUIsRUFBd0M7TUFDdEM7TUFDQSxLQUFLLENBQUMsUUFBTixHQUFpQixRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVAsQ0FBekI7SUFDRDtFQUNGOztFQUNELFFBQVEsQ0FBQyxxQkFBVCxDQUErQixNQUEvQixHQUF3QyxXQUF4QztFQUVBLE1BQU07SUFBRTtFQUFGLElBQW9CLFFBQVEsQ0FBQyxxQkFBbkM7O0VBQ0EsSUFBSSxhQUFhLElBQUksT0FBTyxhQUFQLEtBQXlCLFFBQTlDLEVBQXdEO0lBQ3RELEtBQUssTUFBTSxPQUFYLElBQXNCLE1BQU0sQ0FBQyxJQUFQLENBQVksYUFBWixDQUF0QixFQUFrRDtNQUNoRCxNQUFNLGFBQWEsR0FBRyxhQUFhLENBQUMsT0FBRCxDQUFuQzs7TUFDQSxJQUFJLGFBQWEsSUFBSSxPQUFPLGFBQVAsS0FBeUIsUUFBOUMsRUFBd0Q7UUFDdEQsS0FBSyxNQUFNLE9BQVgsSUFBc0IsTUFBTSxDQUFDLElBQVAsQ0FBWSxhQUFaLENBQXRCLEVBQWtEO1VBQ2hELE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxPQUFELENBQWIsSUFBMEIsRUFBbEQsQ0FEZ0QsQ0FFaEQ7O1VBQ0EsTUFBTSxvQkFBb0IsR0FBRyxlQUFlLENBQUMsTUFBaEIsQ0FBdUIsQ0FBQztZQUFFO1VBQUYsQ0FBRCxLQUNsRCxlQUFlLENBQUMsUUFBRCxDQURZLENBQTdCLENBSGdELENBTWhEOztVQUNBLEtBQUssTUFBTSxLQUFYLElBQW9CLG9CQUFwQixFQUEwQztZQUN4QyxJQUFJLE9BQU8sS0FBSyxDQUFDLFFBQWIsS0FBMEIsUUFBOUIsRUFBd0M7Y0FDdEM7Y0FDQSxLQUFLLENBQUMsUUFBTixHQUFpQixRQUFRLENBQUMsS0FBSyxDQUFDLFFBQVAsQ0FBekI7WUFDRDtVQUNGOztVQUNELGFBQWEsQ0FBQyxPQUFELENBQWIsR0FBeUIsb0JBQXpCO1FBQ0Q7TUFDRjtJQUNGO0VBQ0Y7O0VBQ0QsUUFBUSxDQUFDLHFCQUFULENBQStCLGFBQS9CLEdBQStDLGFBQS9DO0VBRUEsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRUQ7O0FBQ0E7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOztBQVdmLE1BQU0sb0JBQW9CLEdBQUcsU0FBN0I7QUFFQSwwQkFBQSxDQUFrQixPQUFsQixHQUE0QjtFQUMxQixTQUFTLEVBQUUsR0FEZTtFQUUxQixPQUFPLEVBQUUsS0FGaUI7RUFHMUIsTUFBTSxFQUFFO0FBSGtCLENBQTVCO0FBS0EsMEJBQUEsQ0FBa0IsT0FBbEIsR0FBNEI7RUFDMUIsU0FBUyxFQUFFLEdBRGU7RUFFMUIsT0FBTyxFQUFFLEtBRmlCO0VBRzFCLE1BQU0sRUFBRTtBQUhrQixDQUE1QjtBQUtBLDBCQUFBLENBQWtCLEtBQWxCLEdBQTBCO0VBQ3hCLFNBQVMsRUFBRSxJQURhO0VBRXhCLE9BQU8sRUFBRSxNQUZlO0VBR3hCLE1BQU0sRUFBRTtBQUhnQixDQUExQjs7QUFNQSxTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFBQTs7RUFDN0IsSUFDRSxLQURGLGFBQ0UsS0FERix3Q0FDRSxLQUFLLENBQUUsOEJBRFQsa0RBQ0Usc0JBQXVDLG9DQUR6QyxFQUVFO0lBQ0EsS0FBSyxDQUFDLDhCQUFOLENBQXFDLG1DQUFyQyxHQUNFLElBQUEsZUFBQSxFQUNFLEtBQUssQ0FBQyw4QkFBTixDQUNHLG9DQUZMLEVBR0U7SUFDQTtJQUNBO0lBQ0EsQ0FBQyxDQUFELEVBQUksR0FBSjtNQUFBOztNQUFBLDBEQUFZLDBCQUFBLENBQWtCLEdBQWxCLENBQVosMkRBQVksdUJBQXdCLE9BQXBDLHlFQUErQyxvQkFBL0M7SUFBQSxDQU5GLENBREYsQ0FEQSxDQVVBO0lBQ0E7SUFDQTtJQUNBOztJQUNBLE9BQU8sS0FBSyxDQUFDLDhCQUFOLENBQ0osbUNBREksQ0FDZ0Msb0JBRGhDLENBQVA7SUFFQSxPQUFPLEtBQUssQ0FBQyw4QkFBTixDQUNKLG9DQURIO0VBRUQ7O0VBQ0QsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM1REQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUVBLE1BQU07TUFBRTtJQUFGLElBQTRCLGFBQWEsQ0FBQyxJQUFoRDs7SUFFQSxJQUFJLEtBQUssQ0FBQyxPQUFOLENBQWMscUJBQWQsYUFBYyxxQkFBZCx1QkFBYyxxQkFBcUIsQ0FBRSxNQUFyQyxDQUFKLEVBQWtEO01BQ2hELHFCQUFxQixDQUFDLE1BQXRCLEdBQStCLHFCQUFxQixDQUFDLE1BQXRCLENBQTZCLE1BQTdCLENBQzdCLENBQUM7UUFBRTtNQUFGLENBQUQsS0FBaUIsT0FEWSxDQUEvQjtJQUdEOztJQUVELElBQ0UscUJBQXFCLFNBQXJCLElBQUEscUJBQXFCLFdBQXJCLElBQUEscUJBQXFCLENBQUUsYUFBdkIsSUFDQSxPQUFPLHFCQUFxQixDQUFDLGFBQTdCLEtBQStDLFFBRmpELEVBR0U7TUFDQSxNQUFNLENBQUMsSUFBUCxDQUFZLHFCQUFxQixDQUFDLGFBQWxDLEVBQWlELE9BQWpELENBQTBELE9BQUQsSUFBYTtRQUNwRSxNQUFNLE1BQU0sR0FBRyxNQUFNLENBQUMsSUFBUCxDQUNiLHFCQUFxQixDQUFDLGFBQXRCLENBQW9DLE9BQXBDLENBRGEsQ0FBZjtRQUdBLE1BQU0sQ0FBQyxPQUFQLENBQWdCLEtBQUQsSUFBVztVQUN4QixxQkFBcUIsQ0FBQyxhQUF0QixDQUFvQyxPQUFwQyxFQUE2QyxLQUE3QyxJQUNFLHFCQUFxQixDQUFDLGFBQXRCLENBQW9DLE9BQXBDLEVBQTZDLEtBQTdDLEVBQW9ELE1BQXBELENBQ0UsQ0FBQztZQUFFO1VBQUYsQ0FBRCxLQUFpQixPQURuQixDQURGO1FBSUQsQ0FMRDtNQU1ELENBVkQ7SUFXRDs7SUFFRCxJQUNFLHFCQUFxQixTQUFyQixJQUFBLHFCQUFxQixXQUFyQixJQUFBLHFCQUFxQixDQUFFLFdBQXZCLElBQ0EsZUFBZSxxQkFBcUIsQ0FBQyxXQUZ2QyxFQUdFO01BQ0EsT0FBTyxxQkFBcUIsQ0FBQyxXQUF0QixDQUFrQyxTQUF6QztJQUNEOztJQUVELE9BQU8sYUFBUDtFQUNEOztBQXZDWSxDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RmOztBQUNBOzs7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFBQTs7RUFDN0IsSUFDRSxLQUFLLFNBQUwsSUFBQSxLQUFLLFdBQUwsNkJBQUEsS0FBSyxDQUFFLHFCQUFQLHdFQUE4QixZQUE5QixJQUNBLEtBQUssQ0FBQyxPQUFOLENBQWMsS0FBSyxDQUFDLHFCQUFOLENBQTRCLFlBQTFDLENBREEsSUFFQSxDQUFDLEtBQUssQ0FBQyxxQkFBTixDQUE0QixZQUE1QixDQUF5QyxJQUF6QyxDQUNFLElBQUQsSUFDRSxPQUFPLElBQVAsS0FBZ0IsUUFBaEIsSUFBNEIsT0FBTyxJQUFJLENBQUMsUUFBWixLQUF5QixXQUZ4RCxDQUhILEVBT0U7SUFDQSxLQUFLLENBQUMscUJBQU4sQ0FBNEIsWUFBNUIsR0FBMkMsSUFBQSxhQUFBLEVBQ3pDLEtBQUssQ0FBQyxxQkFBTixDQUE0QixZQURhLEVBRXpDO0lBQ0E7SUFDQyxFQUFELElBQVE7TUFDTixJQUFJLE9BQU8sRUFBRSxDQUFDLEVBQVYsS0FBaUIsV0FBakIsSUFBZ0MsRUFBRSxDQUFDLEVBQUgsS0FBVSxJQUE5QyxFQUFvRDtRQUNsRDtRQUNBO1FBQ0EsRUFBRSxDQUFDLEVBQUgsR0FBUSxJQUFBLGlCQUFBLEdBQVI7TUFDRDs7TUFDRCxPQUFPLEVBQUUsQ0FBQyxFQUFWO0lBQ0QsQ0FYd0MsQ0FBM0M7RUFhRDs7RUFDRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzNDRDs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixjQUFjLENBQUMsS0FBRCxDQUFuQztJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVJZLEM7OztBQVdmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3Qix5QkFBTyxLQUFLLENBQUMsa0JBQWIsK0RBQU8sc0JBQTBCLCtCQUFqQztFQUVBLE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJEOztBQVFBOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsY0FBYyxDQUFDLEtBQUQsQ0FBbkM7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFSWSxDOzs7QUFXZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFBQTs7RUFDN0IsTUFBTSxZQUFZLEdBQUcsS0FBSCxhQUFHLEtBQUgsZ0RBQUcsS0FBSyxDQUFFLHFCQUFWLDBEQUFHLHNCQUE4QixZQUFuRDs7RUFDQSxJQUFJLElBQUEscUJBQUEsRUFBYyxZQUFkLENBQUosRUFBaUM7SUFDL0IsTUFBTSx5QkFBeUIsR0FBRyxJQUFBLGVBQUEsRUFDaEMsTUFBTSxDQUFDLE1BQVAsQ0FBYyxZQUFkLENBRGdDLEVBRS9CLEVBQUQsSUFBUTtNQUFBOztNQUNOLE9BQVEsR0FBRCxnQkFBRyxFQUFFLENBQUMsUUFBTixpREFBRyxhQUFhLEtBQU0sSUFBdEIsZUFBeUIsRUFBRSxDQUFDLE9BQTVCLHFEQUF1QyxFQUFFLENBQUMsaUJBQWtCLEVBQW5FO0lBQ0QsQ0FKK0IsQ0FBbEM7SUFPQSxNQUFNLGNBQWMsR0FBRyxJQUFBLGNBQUEsRUFBTyx5QkFBUCxFQUFtQyxLQUFELElBQVc7TUFDbEUsT0FBTyxLQUFLLENBQUMsSUFBTixDQUNKLEVBQUQsSUFDRSxFQUFFLENBQUMsSUFBSCxLQUFZLDhCQUFBLENBQWtCLE1BQTlCLElBQ0EsRUFBRSxDQUFDLElBQUgsS0FBWSw4QkFBQSxDQUFrQixLQUgzQixDQUFQO0lBS0QsQ0FOc0IsQ0FBdkI7SUFPQSxLQUFLLENBQUMscUJBQU4sQ0FBNEIsWUFBNUIsR0FBMkMsSUFBQSxhQUFBLEVBQ3pDLElBQUEsY0FBQSxFQUFPLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxjQUFkLENBQVYsQ0FEeUMsRUFFeEMsRUFBRCxJQUFRLEVBQUUsQ0FBQyxFQUY4QixDQUEzQztFQUlEOztFQUVELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbkREOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBQ0EsTUFBTSx3QkFBd0IsR0FBRyxDQUFqQztBQUNBLE1BQU0seUJBQXlCLEdBQUcsWUFBbEM7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVRZLEM7OztBQVlmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3QixNQUFNLGFBQWEsR0FBRyxLQUFILGFBQUcsS0FBSCxnREFBRyxLQUFLLENBQUUsc0JBQVYsMERBQUcsc0JBQStCLGFBQXJEOztFQUNBLElBQUksSUFBQSxxQkFBQSxFQUFjLGFBQWQsQ0FBSixFQUFrQztJQUFBOztJQUNoQyxJQUNFLDBCQUFBLGFBQWEsQ0FBQyx3QkFBRCxDQUFiLGdGQUF5QyxJQUF6QyxNQUNBLHlCQUZGLEVBR0U7TUFDQSxPQUFPLEtBQUssQ0FBQyxzQkFBTixDQUE2QixhQUE3QixDQUNMLHdCQURLLENBQVA7SUFHRDtFQUNGOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbENEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFUWSxDOzs7QUFZZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsTUFBTSxXQUFXLEdBQUcsSUFBSSxJQUFKLEdBQVcsT0FBWCxFQUFwQjs7RUFDQSxJQUFJLEtBQUssQ0FBQyxrQkFBVixFQUE4QjtJQUM1QixLQUFLLENBQUMsa0JBQU4sQ0FBeUIsa0NBQXpCLEdBQThELEtBQTlEO0lBQ0EsS0FBSyxDQUFDLGtCQUFOLENBQXlCLCtCQUF6QixHQUEyRCxXQUEzRDtFQUNELENBSEQsTUFHTztJQUNMLEtBQUssQ0FBQyxrQkFBTixHQUEyQjtNQUN6QixrQ0FBa0MsRUFBRSxLQURYO01BRXpCLCtCQUErQixFQUFFO0lBRlIsQ0FBM0I7RUFJRDs7RUFDRCxPQUFPLEtBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQy9CRDs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVFksQzs7O0FBWWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLElBQUksS0FBSyxDQUFDLHFCQUFWLEVBQWlDO0lBQy9CLE1BQU07TUFBRTtJQUFGLElBQTJCLEtBQUssQ0FBQyxxQkFBdkM7O0lBQ0EsSUFBSSxvQkFBb0IsS0FBSyxTQUE3QixFQUF3QztNQUN0QyxPQUFPLEtBQUssQ0FBQyxxQkFBTixDQUE0QixvQkFBbkM7SUFDRDtFQUNGOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDM0JEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFUWSxDOzs7QUFZZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFBQTs7RUFDN0IsTUFBTSxhQUFhLEdBQUcsS0FBSCxhQUFHLEtBQUgsZ0RBQUcsS0FBSyxDQUFFLHFCQUFWLDBEQUFHLHNCQUE4QixhQUFwRDtFQUNBLE1BQU0sbUJBQW1CLEdBQUcsS0FBSCxhQUFHLEtBQUgsaURBQUcsS0FBSyxDQUFFLHFCQUFWLDJEQUFHLHVCQUE4QixtQkFBMUQ7RUFFQSxNQUFNLFlBQVksR0FBRyxFQUFyQjs7RUFDQSxJQUFJLGFBQUosRUFBbUI7SUFDakIsTUFBTSxDQUFDLElBQVAsQ0FBWSxhQUFaLEVBQTJCLE9BQTNCLENBQW9DLGNBQUQsSUFBb0I7TUFDckQsTUFBTSxDQUFDLElBQVAsQ0FBWSxhQUFhLENBQUMsY0FBRCxDQUF6QixFQUEyQyxPQUEzQyxDQUFvRCxPQUFELElBQWE7UUFDOUQsTUFBTSxXQUFXLEdBQUcsYUFBYSxDQUFDLGNBQUQsQ0FBYixDQUE4QixPQUE5QixDQUFwQjs7UUFDQSxJQUFJLFlBQVksQ0FBQyxPQUFELENBQVosS0FBMEIsU0FBOUIsRUFBeUM7VUFDdkMsWUFBWSxDQUFDLE9BQUQsQ0FBWixHQUF3QjtZQUFFLENBQUMsY0FBRCxHQUFrQjtVQUFwQixDQUF4QjtRQUNELENBRkQsTUFFTztVQUNMLFlBQVksQ0FBQyxPQUFELENBQVosR0FBd0IsRUFDdEIsR0FBRyxZQUFZLENBQUMsT0FBRCxDQURPO1lBRXRCLENBQUMsY0FBRCxHQUFrQjtVQUZJLENBQXhCO1FBSUQ7TUFDRixDQVZEO0lBV0QsQ0FaRDtFQWFEOztFQUVELE1BQU0sbUJBQW1CLEdBQUcsRUFBNUI7O0VBQ0EsSUFBSSxtQkFBSixFQUF5QjtJQUN2QixNQUFNLENBQUMsSUFBUCxDQUFZLG1CQUFaLEVBQWlDLE9BQWpDLENBQTBDLGNBQUQsSUFBb0I7TUFDM0QsTUFBTSxDQUFDLElBQVAsQ0FBWSxtQkFBbUIsQ0FBQyxjQUFELENBQS9CLEVBQWlELE9BQWpELENBQTBELE9BQUQsSUFBYTtRQUNwRSxNQUFNLGtCQUFrQixHQUFHLG1CQUFtQixDQUFDLGNBQUQsQ0FBbkIsQ0FBb0MsT0FBcEMsQ0FBM0I7O1FBQ0EsSUFBSSxtQkFBbUIsQ0FBQyxPQUFELENBQW5CLEtBQWlDLFNBQXJDLEVBQWdEO1VBQzlDLG1CQUFtQixDQUFDLE9BQUQsQ0FBbkIsR0FBK0I7WUFDN0IsQ0FBQyxjQUFELEdBQWtCO1VBRFcsQ0FBL0I7UUFHRCxDQUpELE1BSU87VUFDTCxtQkFBbUIsQ0FBQyxPQUFELENBQW5CLEdBQStCLEVBQzdCLEdBQUcsbUJBQW1CLENBQUMsT0FBRCxDQURPO1lBRTdCLENBQUMsY0FBRCxHQUFrQjtVQUZXLENBQS9CO1FBSUQ7TUFDRixDQVpEO0lBYUQsQ0FkRDtFQWVEOztFQUVELElBQUksS0FBSyxDQUFDLGdCQUFWLEVBQTRCO0lBQzFCLEtBQUssQ0FBQyxnQkFBTixDQUF1QixTQUF2QixHQUFtQyxZQUFuQztJQUNBLEtBQUssQ0FBQyxnQkFBTixDQUF1QixnQkFBdkIsR0FBMEMsbUJBQTFDO0VBQ0QsQ0FIRCxNQUdPO0lBQ0wsS0FBSyxDQUFDLGdCQUFOLEdBQXlCO01BQ3ZCLFNBQVMsRUFBRSxZQURZO01BRXZCLGdCQUFnQixFQUFFO0lBRkssQ0FBekI7RUFJRDs7RUFFTSxLQUFQLGFBQU8sS0FBUCwrQ0FBTyxLQUFLLENBQUUscUJBQWQsZ0VBQU8sdUJBQThCLG1CQUFyQztFQUNPLEtBQVAsYUFBTyxLQUFQLCtDQUFPLEtBQUssQ0FBRSxxQkFBZCxnRUFBTyx1QkFBOEIsYUFBckM7RUFDTyxLQUFQLGFBQU8sS0FBUCwrQ0FBTyxLQUFLLENBQUUscUJBQWQsZ0VBQU8sdUJBQThCLFdBQXJDO0VBQ08sS0FBUCxhQUFPLEtBQVAsK0NBQU8sS0FBSyxDQUFFLHFCQUFkLGdFQUFPLHVCQUE4QixZQUFyQztFQUNPLEtBQVAsYUFBTyxLQUFQLCtDQUFPLEtBQUssQ0FBRSxxQkFBZCxnRUFBTyx1QkFBOEIsTUFBckM7RUFDTyxLQUFQLGFBQU8sS0FBUCwrQ0FBTyxLQUFLLENBQUUscUJBQWQsZ0VBQU8sdUJBQThCLGVBQXJDO0VBRUEsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RUQ7O0FBQ0E7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQSxNQUFNLFVBQVUsR0FBRyxXQUFuQixDLENBQWdDOztBQUVoQztBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVRZLEM7OztBQVlmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3QixNQUFNLFlBQVksR0FBRyxLQUFILGFBQUcsS0FBSCxnREFBRyxLQUFLLENBQUUscUJBQVYsMERBQUcsc0JBQThCLFlBQW5EOztFQUNBLElBQUksSUFBQSxxQkFBQSxFQUFjLFlBQWQsQ0FBSixFQUFpQztJQUMvQixLQUFLLE1BQU0sRUFBWCxJQUFpQixNQUFNLENBQUMsTUFBUCxDQUFjLFlBQWQsQ0FBakIsRUFBOEM7TUFDNUMsSUFBSSxFQUFFLENBQUMsSUFBSCxLQUFZLFVBQWhCLEVBQTRCO1FBQzFCLEVBQUUsQ0FBQyxJQUFILEdBQVUsOEJBQUEsQ0FBa0IsV0FBNUI7TUFDRDs7TUFDRCxJQUFJLEVBQUUsQ0FBQyxPQUFQLEVBQWdCO1FBQ2QsRUFBRSxDQUFDLE9BQUgsQ0FBVyxHQUFYLENBQWdCLE9BQUQsSUFBYTtVQUMxQixJQUFJLE9BQU8sQ0FBQyxJQUFSLElBQWdCLE9BQU8sQ0FBQyxJQUFSLEtBQWlCLFVBQXJDLEVBQWlEO1lBQy9DLE9BQU8sQ0FBQyxJQUFSLEdBQWUsOEJBQUEsQ0FBa0IsV0FBakM7VUFDRDs7VUFDRCxPQUFPLE9BQVA7UUFDRCxDQUxEO01BTUQ7SUFDRjtFQUNGOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDeENEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFUWSxDOzs7QUFZZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsSUFBSSxLQUFLLENBQUMscUJBQVYsRUFBaUM7SUFBQTs7SUFDL0IsTUFBTTtNQUFFLG1CQUFGO01BQXVCO0lBQXZCLElBQ0osS0FBSyxDQUFDLHFCQURSO0lBRUEsS0FBSyxDQUFDLG9CQUFOLDRCQUE2QixLQUFLLENBQUMsb0JBQW5DLHlFQUEyRCxFQUEzRDs7SUFFQSxJQUFJLG1CQUFtQixLQUFLLFNBQTVCLEVBQXVDO01BQ3JDLEtBQUssQ0FBQyxvQkFBTixDQUEyQixtQkFBM0IsR0FBaUQsbUJBQWpEO01BQ0EsT0FBTyxLQUFLLENBQUMscUJBQU4sQ0FBNEIsbUJBQW5DO0lBQ0Q7O0lBQ0QsSUFBSSxpQkFBaUIsS0FBSyxTQUExQixFQUFxQztNQUNuQyxLQUFLLENBQUMsb0JBQU4sQ0FBMkIsaUJBQTNCLEdBQStDLGlCQUEvQztNQUNBLE9BQU8sS0FBSyxDQUFDLHFCQUFOLENBQTRCLGlCQUFuQztJQUNEO0VBQ0Y7O0VBRUQsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQ0Q7O0FBQ0E7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVRZLEM7OztBQVlmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3QixNQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxTQUFQLENBQWlCLEdBQWpCLEdBQ3pCLHVDQUFBLENBQXVCLE1BREUsR0FFekIsdUNBQUEsQ0FBdUIsR0FGM0I7RUFHQSxNQUFNLGFBQWEsR0FBRyxPQUFPLDBCQUFDLEtBQUssQ0FBQyxxQkFBUCwwREFBQyxzQkFBNkIsYUFBOUIsQ0FBN0I7RUFDQSxNQUFNLFFBQVEsR0FBRyxFQUNmLEdBQUcsS0FEWTtJQUVmLHFCQUFxQixFQUFFLEVBQ3JCLElBQUcsS0FBSCxhQUFHLEtBQUgsdUJBQUcsS0FBSyxDQUFFLHFCQUFWLENBRHFCO01BRXJCLG1CQUFtQixFQUFFLGFBQWEsR0FDOUIsdUNBQUEsQ0FBdUIsSUFETyxHQUU5QjtJQUppQjtFQUZSLENBQWpCO0VBU0EsT0FBTyxRQUFRLENBQUMscUJBQVQsQ0FBK0IsYUFBdEM7RUFDQSxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3BDRDs7QUFDQTs7QUFDQTs7OztBQUVBLE1BQU0sMEJBQTBCLEdBQUksU0FBRCxJQUNqQyxJQUFJLGtCQUFKLENBQWMsU0FBUyxJQUFJLEtBQTNCLEVBQWtDLEVBQWxDLEVBQXNDLEVBQXRDLENBQXlDLENBQXpDLENBREY7O0FBR0EsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVFksQzs7O0FBWWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQUE7O0VBQzdCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQSxLQUFLLFNBQUwsSUFBQSxLQUFLLFdBQUwsWUFBQSxLQUFLLENBQUUscUJBQVAsS0FBZ0MsRUFBOUQ7RUFDQSxNQUFNLFdBQVcsR0FBRyxxQkFBcUIsQ0FBQyxXQUF0QixJQUFxQyxFQUF6RDs7RUFFQSxJQUFJLFdBQVcsQ0FBQyxnQkFBaEIsRUFBa0M7SUFDaEMsT0FBTyxLQUFQO0VBQ0Q7O0VBRUQsTUFBTSxZQUFZLEdBQUcsQ0FBQSxLQUFLLFNBQUwsSUFBQSxLQUFLLFdBQUwscUNBQUEsS0FBSyxDQUFFLHFCQUFQLGdGQUE4QixZQUE5QixLQUE4QyxFQUFuRTtFQUNBLE1BQU0sUUFBUSxHQUFHLDBCQUFBLEtBQUssQ0FBQyxpQkFBTixnRkFBeUIsUUFBekIsS0FBcUMsRUFBdEQ7RUFDQSxNQUFNLGNBQWMsR0FBRywwQkFBQSxLQUFLLENBQUMsd0JBQU4sZ0ZBQWdDLGNBQWhDLEtBQWtELEVBQXpFOztFQUVBLE1BQU0seUJBQXlCLEdBQUcsb0JBQUEsQ0FBWSxRQUFaLENBQXFCLFFBQXJCLGFBQXFCLFFBQXJCLHVCQUFxQixRQUFRLENBQUUsT0FBL0IsQ0FBbEM7O0VBQ0EsTUFBTSw4QkFBOEIsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFjLFlBQWQsRUFBNEIsSUFBNUIsQ0FDckMsQ0FBQztJQUFFO0VBQUYsQ0FBRCxLQUFpQixvQkFBQSxDQUFZLFFBQVosQ0FBcUIsT0FBckIsQ0FEb0IsQ0FBdkM7O0VBR0EsTUFBTSwrQkFBK0IsR0FBRyxvQkFBQSxDQUFZLElBQVosQ0FBa0IsT0FBRCxJQUFhO0lBQ3BFLE1BQU0sc0JBQXNCLEdBQUcsTUFBTSxDQUFDLE1BQVAsQ0FBYyxjQUFjLENBQUMsT0FBRCxDQUFkLElBQTJCLEVBQXpDLENBQS9CO0lBQ0EsTUFBTSx5Q0FBeUMsR0FDN0Msc0JBQXNCLENBQUMsSUFBdkIsQ0FBNEIsMEJBQTVCLENBREY7SUFFQSxPQUFPLHlDQUFQO0VBQ0QsQ0FMdUMsQ0FBeEM7O0VBTUEsTUFBTSxtQkFBbUIsR0FDdkIseUJBQXlCLElBQ3pCLDhCQURBLElBRUEsK0JBSEY7RUFLQSxNQUFNLFFBQVEsR0FBRyxFQUNmLEdBQUcsS0FEWTtJQUVmLHFCQUFxQixFQUFFLEVBQ3JCLEdBQUcscUJBRGtCO01BRXJCLFdBQVcsRUFBRSxFQUNYLEdBQUcsV0FEUTtRQUVYLGdCQUFnQixFQUFFO01BRlA7SUFGUTtFQUZSLENBQWpCO0VBV0EsT0FBTyxRQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRUQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVFksQzs7O0FBWWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU07SUFDSixxQkFBcUIsR0FBRyxFQURwQjtJQUVKLG1CQUFtQixHQUFHLEVBRmxCO0lBR0osR0FBRztFQUhDLElBSUYsS0FKSjtFQU1BLE1BQU07SUFDSixjQUFjLEdBQUcsRUFEYjtJQUVKLGtCQUFrQixHQUFHLEVBRmpCO0lBR0osY0FBYyxHQUFHO0VBSGIsSUFJRixtQkFKSjtFQU1BLE9BQU8sRUFDTCxHQUFHLGNBREU7SUFFTCxvQkFBb0IsRUFBRSw0QkFBNEIsQ0FBQyxxQkFBRCxDQUY3QztJQUdMLHVCQUF1QixFQUFFO01BQ3ZCLHFCQUFxQixFQUFFLGNBREE7TUFFdkIsaUJBQWlCLEVBQUU7SUFGSSxDQUhwQjtJQU9MLHlCQUF5QixFQUN2QixpQ0FBaUMsQ0FBQyxjQUFEO0VBUjlCLENBQVA7QUFVRDs7QUFFRCxTQUFTLDRCQUFULENBQXNDLHFCQUF0QyxFQUE2RDtFQUMzRCxNQUFNO0lBQUUsT0FBTyxHQUFHO0VBQVosSUFBbUIscUJBQXpCO0VBRUE7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0VBRUUsTUFBTSxZQUFZLEdBQUcsY0FBckI7RUFDQSxNQUFNLGVBQWUsR0FBRywwQkFBeEI7RUFDQSxNQUFNLGVBQWUsR0FBRyxpQkFBeEI7RUFFQSxNQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsT0FBUCxDQUFlLE9BQWYsRUFBd0IsTUFBeEIsQ0FDZixDQUFDLFdBQUQsRUFBYyxDQUFDLE1BQUQsRUFBUyxXQUFULENBQWQsS0FBd0M7SUFDdEMsTUFBTTtNQUNKLFdBQVcsRUFBRSxDQUFDLHFCQUFEO0lBRFQsSUFFRixXQUZKLENBRHNDLENBS3RDO0lBQ0E7O0lBQ0EsTUFBTSxTQUFTLEdBQUcscUJBQXFCLENBQUMsT0FBdEIsQ0FBOEIsSUFBOUIsQ0FDZixNQUFELElBQVksTUFBTSxDQUFDLElBQVAsS0FBZ0IsZUFEWixDQUFsQjtJQUlBLE1BQU0sYUFBYSxHQUFHLEVBQ3BCLEdBQUcscUJBRGlCO01BRXBCLE9BQU8sRUFBRSxDQUFDO1FBQUUsSUFBSSxFQUFFLGVBQVI7UUFBeUIsS0FBSyxFQUFFLFNBQVMsQ0FBQztNQUExQyxDQUFEO0lBRlcsQ0FBdEIsQ0FYc0MsQ0FnQnRDOztJQUNBLE9BQU8sYUFBYSxDQUFDLFVBQUQsQ0FBcEI7SUFFQSxXQUFXLENBQUMsTUFBRCxDQUFYLEdBQXNCO01BQ3BCLE1BRG9CO01BRXBCLFdBQVcsRUFBRTtRQUNYLENBQUMsWUFBRCxHQUFnQjtNQURMO0lBRk8sQ0FBdEI7SUFNQSxPQUFPLFdBQVA7RUFDRCxDQTNCYyxFQTRCZixFQTVCZSxDQUFqQjtFQStCQSxPQUFPO0lBQ0w7RUFESyxDQUFQO0FBR0Q7O0FBRUQsU0FBUyxpQ0FBVCxDQUEyQyxjQUEzQyxFQUEyRDtFQUN6RDtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUVFLE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxPQUFQLENBQWUsY0FBZixFQUErQixNQUEvQixDQUN0QixDQUFDLFdBQUQsRUFBYyxDQUFDLE1BQUQsRUFBUyxRQUFULENBQWQsS0FBcUM7SUFDbkMsTUFBTTtNQUNKLElBQUksR0FBRyxJQURIO01BRUosSUFBSSxHQUFHLElBRkg7TUFHSixXQUFXLEdBQUcsSUFIVjtNQUlKLEdBQUc7SUFKQyxJQUtGLFFBTEosQ0FEbUMsQ0FRbkM7O0lBQ0EsT0FBTyxLQUFLLENBQUMsV0FBYjtJQUNBLE9BQU8sS0FBSyxDQUFDLElBQWI7O0lBRUEsSUFBSSxNQUFKLEVBQVk7TUFDVixXQUFXLENBQUMsTUFBRCxDQUFYLEdBQXNCO1FBQ3BCLElBRG9CO1FBRXBCLE9BQU8sRUFBRSxJQUZXO1FBR3BCLFdBSG9CO1FBSXBCLEdBQUcsS0FKaUI7UUFLcEI7TUFMb0IsQ0FBdEI7SUFPRDs7SUFDRCxPQUFPLFdBQVA7RUFDRCxDQXZCcUIsRUF3QnRCLEVBeEJzQixDQUF4QjtFQTJCQSxPQUFPO0lBQ0w7RUFESyxDQUFQO0FBR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvSkQ7O0FBQ0E7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVRZLEM7OztBQVlmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUFBOztFQUM3QixJQUFJLFFBQU8sS0FBUCxhQUFPLEtBQVAsZ0RBQU8sS0FBSyxDQUFFLHlCQUFkLDBEQUFPLHNCQUFrQyxlQUF6QyxNQUE2RCxRQUFqRSxFQUEyRTtJQUN6RSxNQUFNO01BQ0oseUJBQXlCLEVBQUU7UUFBRTtNQUFGO0lBRHZCLElBRUYsS0FGSixDQUR5RSxDQUt6RTs7SUFDQSxNQUFNLENBQUMsTUFBUCxDQUFjLGVBQWQsRUFBK0IsT0FBL0IsQ0FBd0MsUUFBRCxJQUFjO01BQ25ELElBQ0UsUUFBUSxJQUNSLE9BQU8sUUFBUCxLQUFvQixRQURwQixJQUVBLENBQUMsS0FBSyxDQUFDLE9BQU4sQ0FBYyxRQUFkLENBSEgsRUFJRTtRQUNBLFFBQVEsQ0FBQyxXQUFULEdBQXVCLFFBQVEsQ0FBQyxXQUFULEdBQ25CLGtCQUFBLENBQWMsU0FESyxHQUVuQixrQkFBQSxDQUFjLE9BRmxCO01BR0Q7SUFDRixDQVZEO0VBV0Q7O0VBQ0QsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN4Q0Q7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVFksQzs7O0FBWWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQUE7O0VBQzdCLElBQUksS0FBSyxDQUFDLE9BQU4sQ0FBYyxLQUFkLGFBQWMsS0FBZCxnREFBYyxLQUFLLENBQUUsdUJBQXJCLDBEQUFjLHNCQUFnQyxxQkFBOUMsQ0FBSixFQUEwRTtJQUN4RSxNQUFNO01BQ0osdUJBQXVCLEVBQUU7UUFBRTtNQUFGO0lBRHJCLElBRUYsS0FGSixDQUR3RSxDQUt4RTs7SUFDQSxxQkFBcUIsQ0FBQyxPQUF0QixDQUErQixRQUFELElBQWM7TUFDMUMsSUFDRSxRQUFRLElBQ1IsT0FBTyxRQUFQLEtBQW9CLFFBRHBCLElBRUEsQ0FBQyxLQUFLLENBQUMsT0FBTixDQUFjLFFBQWQsQ0FISCxFQUlFO1FBQ0EsT0FBTyxRQUFRLENBQUMsT0FBaEI7UUFDQSxPQUFPLFFBQVEsQ0FBQyxRQUFoQjtNQUNEO0lBQ0YsQ0FURDtFQVVEOztFQUNELE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdkNEOztBQUVBLE1BQU0sT0FBTyxHQUFHLEVBQWhCO0FBRUE7QUFDQTtBQUNBOztlQUNlO0VBQ2IsT0FEYTs7RUFFYixNQUFNLE9BQU4sQ0FBYyxxQkFBZCxFQUFxQztJQUNuQyxNQUFNLGFBQWEsR0FBRyxJQUFBLGlCQUFBLEVBQVUscUJBQVYsQ0FBdEI7SUFDQSxhQUFhLENBQUMsSUFBZCxDQUFtQixPQUFuQixHQUE2QixPQUE3QjtJQUNBLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtJQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELENBQS9CO0lBQ0EsYUFBYSxDQUFDLElBQWQsR0FBcUIsUUFBckI7SUFDQSxPQUFPLGFBQVA7RUFDRDs7QUFUWSxDOzs7QUFZZixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsRUFBK0I7RUFDN0IsSUFBSSxLQUFLLENBQUMsc0JBQVYsRUFBa0M7SUFDaEMsS0FBSyxDQUFDLHNCQUFOLEdBQStCO01BQzdCLGFBQWEsRUFBRSxLQUFLLENBQUMsc0JBQU4sQ0FBNkI7SUFEZixDQUEvQjtJQUdBLE9BQU8sS0FBSyxDQUFDLHNCQUFiO0VBQ0Q7O0VBQ0QsT0FBTyxLQUFQO0FBQ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMzQkQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVRZLEM7OztBQVlmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixNQUFNLHFCQUFxQixHQUFHLENBQUEsS0FBSyxTQUFMLElBQUEsS0FBSyxXQUFMLFlBQUEsS0FBSyxDQUFFLHFCQUFQLEtBQWdDLEVBQTlEO0VBRUEsT0FBTyxFQUNMLEdBQUcsS0FERTtJQUVMLHFCQUFxQixFQUFFLEVBQ3JCLEdBQUcscUJBRGtCO01BRXJCLGVBQWUsRUFBRTtJQUZJO0VBRmxCLENBQVA7QUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdCRDs7QUFFQSxNQUFNLE9BQU8sR0FBRyxFQUFoQjtBQUVBO0FBQ0E7QUFDQTs7ZUFDZTtFQUNiLE9BRGE7O0VBRWIsTUFBTSxPQUFOLENBQWMscUJBQWQsRUFBcUM7SUFDbkMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7SUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhLENBQUMsSUFBNUI7SUFDQSxNQUFNLFFBQVEsR0FBRyxjQUFjLENBQUMsS0FBRCxDQUEvQjtJQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0EsT0FBTyxhQUFQO0VBQ0Q7O0FBVFksQzs7O0FBWWYsU0FBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCO0VBQzdCLE1BQU0scUJBQXFCLEdBQUcsQ0FBQSxLQUFLLFNBQUwsSUFBQSxLQUFLLFdBQUwsWUFBQSxLQUFLLENBQUUscUJBQVAsS0FBZ0MsRUFBOUQ7RUFFQSxPQUFPLEVBQ0wsR0FBRyxLQURFO0lBRUwscUJBQXFCLEVBQUUsRUFDckIsR0FBRyxxQkFEa0I7TUFFckIsZUFBZSxFQUFFO0lBRkk7RUFGbEIsQ0FBUDtBQU9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN0JELElBQUEsVUFBQSxPQUFBLENBQUEsUUFBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxhQUFBLHNCQUFBLENBQUEsT0FBQSxDQUFBLGNBQUEsQ0FBQSxDQUFBLENBQUE7O0FBQ0EsSUFBQSxXQUFBLE9BQUEsQ0FBQSxtQ0FBQSxDQUFBLENBQUE7Ozs7QUFFQSxNQUFNLFVBQVUsRUFBaEIsQ0FBQTs7QUFFQSxNQUFNLDZCQUE4QixhQUNsQyxJQUFJLFVBQUEsUUFBSixDQUFjLFNBQVMsSUFBSSxLQUEzQixFQUFrQyxFQUFsQyxDQUFBLEdBQUEsQ0FBeUMsQ0FBekMsQ0FERixDQUFBOztBQUdBLE1BQU0sK0JBQStCLENBQUMsS0FBRCxFQUFRLE1BQVIsRUFBZ0IsS0FBaEIsQ0FBckMsQ0FBQTtBQUNBLE1BQU0sOEJBQThCO0VBQ2xDLE9BQU87SUFDTCxRQUFRLENBQUEsQ0FBQSxFQUFBLFFBQUEsVUFBQSxFQUFVO01BQUUsU0FBUyxTQUFBO0tBQXJCLENBREg7SUFFTCxVQUFVLFNBRkw7SUFHTCxRQUFRLFlBQUE7R0FKd0I7RUFNbEMsUUFBUTtJQUNOLFFBQVEsQ0FBQSxDQUFBLEVBQUEsUUFBQSxVQUFBLEVBQVU7TUFBRSxTQUFTLE9BQUE7S0FBckIsQ0FERjtJQUVOLFVBQVUsT0FGSjtJQUdOLFFBQVEsVUFBQTtHQVR3QjtFQVdsQyxPQUFPO0lBQ0wsUUFBUSxDQUFBLENBQUEsRUFBQSxRQUFBLFVBQUEsRUFBVTtNQUFFLFNBQVMsU0FBQTtLQUFyQixDQURIO0lBRUwsVUFBVSxTQUZMO0lBR0wsUUFBUSxZQUFBO0dBSEg7Q0FYVCxDQUFBOzs7Ozs7O2VBdUJlO0VBQ2IsT0FEYTs7RUFFYixhQUFBLHdCQUFxQztJQUNuQyxNQUFNLGdCQUFnQixDQUFBLENBQUEsRUFBQSxPQUFBLFVBQUEsRUFBVSxxQkFBVixDQUF0QixDQUFBO0lBQ0EsYUFBYSxLQUFiLFFBQUEsR0FBNkIsT0FBN0IsQ0FBQTtJQUNBLE1BQU0sUUFBUSxhQUFhLEtBQTNCLENBQUE7SUFDQSxNQUFNLFdBQVcsY0FBYyxDQUFDLEtBQUQsQ0FBL0IsQ0FBQTtJQUNBLGFBQWEsS0FBYixHQUFxQixRQUFyQixDQUFBO0lBQ0EsT0FBTyxhQUFQLENBQUE7R0FDRDs7Ozs7QUFHSCwrQkFBK0I7RUFBQSxJQUFBLHFCQUFBLEVBQUEscUJBQUEsRUFBQSxxQkFBQSxDQUFBOztFQUM3QixNQUFNLHdCQUF3QixDQUFBLEtBQUssS0FBQSxJQUFMLElBQUEsS0FBSyxLQUFBLEtBQUEsQ0FBTCxHQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUssc0JBQUwsS0FBZ0MsRUFBOUQsQ0FBQTtFQUNBLE1BQU0sY0FBYyxxQkFBcUIsWUFBckIsSUFBcUMsRUFBekQsQ0FBQTtFQUNBLE1BQU0sb0JBQW9CLENBQUEsS0FBSyxLQUFBLElBQUwsSUFBQSxLQUFLLEtBQUEsS0FBQSxDQUFMLEdBQUEsS0FBQSxDQUFBLEdBQUEsS0FBSyxrQkFBTCxLQUE0QixFQUF0RCxDQUFBO0VBQ0EsTUFBTSxXQUFXLENBQUEsaUJBQWlCLEtBQUEsSUFBakIsSUFBQSxpQkFBaUIsS0FBQSxLQUFBLENBQWpCLEdBQUEsS0FBQSxDQUFBLEdBQUEsaUJBQWlCLFNBQWpCLEtBQStCLEVBQWhELENBQUE7RUFFQSxNQUFNLCtCQUErQiw0QkFBNEIsT0FBNUIsQ0FDbEMsV0FBWSxPQUFPLE1BQUssUUFBTCxLQUFBLElBQUEsSUFBSyxRQUFMLEtBQUEsS0FBQSxDQUFBLEdBQUEsS0FBQSxDQUFBLEdBQUssUUFBUSxRQUFiLENBRGUsQ0FBckMsQ0FONkI7OztFQVk3QixJQUNFLENBQUMsV0FBVyxpQkFBWixJQUNBLDRCQUE0QixPQUE1QixLQUF3QyxDQUYxQyxFQUdFO0lBQ0EsT0FBTyxLQUFQLENBQUE7R0FDRDs7RUFFRCxNQUFNLGVBQWUsQ0FBQSxLQUFLLEtBQUEsSUFBTCxJQUFBLEtBQUssS0FBQSxLQUFBLENBQUwsR0FBQSxLQUFBLENBQUEsR0FBQSxDQUFBLHdCQUFBLEtBQUssc0JBQUwsTUFBQSxJQUFBLElBQUEscUJBQUEsS0FBQSxLQUFBLENBQUEsR0FBQSxLQUFBLENBQUEsR0FBQSxxQkFBQSxhQUFBLEtBQThDLEVBQW5FLENBQUE7RUFDQSxNQUFNLGlCQUFpQixDQUFBLENBQUEsd0JBQUEsS0FBSyx5QkFBTCxNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLEtBQUEsQ0FBQSxHQUFBLHFCQUFBLGVBQUEsS0FBa0QsRUFBekUsQ0FBQTtFQUVBLE1BQU0sc0RBQXNELE1BQU0sT0FBTixDQUMxRCxZQUQwRCxDQUFBLE9BQUEsQ0FHbEQsQ0FBQzs7R0FBRCxLQUFpQiw0QkFBNEIsU0FBNUIsQ0FBc0MsT0FBdEMsQ0FIaUMsQ0FBQSxJQUFBLENBSXJELENBQUM7O0dBQUQsS0FBaUIsT0FKb0MsQ0FBNUQsQ0FBQTtFQUtBLE1BQU0sbURBQ0osNEJBQTRCLE9BQTVCLENBQXFDLFdBQVk7SUFDL0MsTUFBTSx5QkFBeUIsTUFBTSxPQUFOLENBQzdCLGNBQWMsQ0FBQyxPQUFELENBQWQsSUFBMkIsRUFERSxDQUEvQixDQUFBO0lBR0EsTUFBTSw0Q0FDSixzQkFBc0IsS0FBdEIsQ0FBNEIsMEJBQTVCLENBREYsQ0FBQTtJQUVBLE9BQU8seUNBQVAsQ0FBQTtHQU5GLENBREYsQ0FBQTtFQVNBLE1BQU0scUNBQXFDLENBQUEsQ0FBQSxFQUFBLE9BQUEsS0FBQSxFQUFLLENBQzlDLEdBQUcsZ0RBRDJDLEVBRTlDLEdBQUcsbURBRjJDLEVBRzlDLEdBQUcsNEJBSDJDLENBQUwsQ0FBM0MsQ0FBQTtFQU1BLE1BQU0sMkJBQXdCLENBQUEsd0JBQzVCLHFCQUFxQixzQkFETyxNQUFBLElBQUEsSUFBQSxxQkFBQSxLQUFBLEtBQUEsQ0FBQSxHQUFBLHFCQUFBLEdBQ21CLEVBRGpELENBQUE7RUFHQSxrQ0FBa0MsUUFBbEMsQ0FBNEMsV0FBWTtJQUN0RCxJQUNFLENBQUMsd0JBQXdCLEtBQXhCLENBQ0UsY0FBZSxVQUFVLFFBQVYsS0FBdUIsT0FEeEMsQ0FESCxFQUlFO01BQ0Esd0JBQXdCLFFBQXhCLENBQWlDO1FBQy9CLFFBQVEsMkJBQTJCLENBQUMsT0FBRCxDQUEzQixPQUR1QjtRQUUvQixPQUYrQjtRQUcvQixRQUFRLDJCQUEyQixDQUFDLE9BQUQsQ0FBM0IsT0FIdUI7UUFJL0IsVUFBVSwyQkFBMkIsQ0FBQyxPQUFELENBQTNCLFNBSnFCO1FBSy9CLFVBQVUsRUFBQTtPQUxaLENBQUEsQ0FBQTtLQU9EO0dBYkgsQ0FBQSxDQUFBOztFQWdCQSxJQUFJLHdCQUF3QixPQUE1QixFQUFxQztJQUNuQyxxQkFBcUIsc0JBQXJCLEdBQThDLHdCQUE5QyxDQUFBO0dBQ0Q7O0VBRUQsSUFBSSw0QkFBNEIsT0FBaEMsRUFBeUM7SUFDdkMsTUFBTSx5QkFBeUIsNEJBQTRCLENBQUMsQ0FBRCxDQUEzRCxDQUFBO0lBQ0EsaUJBQWlCLFNBQWpCLEdBQTZCLEVBQzNCLEdBQUcsaUJBQWlCLFNBRE87TUFFM0IsTUFBTSxLQUZxQjtNQUczQixRQUFRLDJCQUEyQixDQUFDLHNCQUFELENBQTNCLE9BSG1CO01BSTNCLFNBQVMsc0JBSmtCO01BSzNCLFVBQVUsMkJBQTJCLENBQUMsc0JBQUQsQ0FBM0IsU0FMaUI7TUFNM0IsUUFBUSwyQkFBMkIsQ0FBQyxzQkFBRCxDQUEzQixPQUFvRDtLQU45RCxDQUFBO0dBUUQ7O0VBRUQsT0FBTyxFQUNMLEdBQUcsS0FERTtJQUVMLHVCQUF1QixFQUNyQixHQUFHLHFCQUFBO0tBSEE7SUFLTCxtQkFBbUIsRUFDakIsR0FBRyxpQkFBQTtLQURjO0dBTHJCLENBQUE7Q0FTRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuSUQ7O0FBRUEsTUFBTSxPQUFPLEdBQUcsRUFBaEI7QUFFQTtBQUNBO0FBQ0E7O2VBQ2U7RUFDYixPQURhOztFQUViLE1BQU0sT0FBTixDQUFjLHFCQUFkLEVBQXFDO0lBQ25DLE1BQU0sYUFBYSxHQUFHLElBQUEsaUJBQUEsRUFBVSxxQkFBVixDQUF0QjtJQUNBLGFBQWEsQ0FBQyxJQUFkLENBQW1CLE9BQW5CLEdBQTZCLE9BQTdCO0lBQ0EsTUFBTSxLQUFLLEdBQUcsYUFBYSxDQUFDLElBQTVCO0lBQ0EsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLEtBQUQsQ0FBL0I7SUFDQSxhQUFhLENBQUMsSUFBZCxHQUFxQixRQUFyQjtJQUNBLE9BQU8sYUFBUDtFQUNEOztBQVRZLEM7OztBQVlmLFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQjtFQUM3QixPQUFPLEtBQUssQ0FBQyxrQkFBYjtFQUNBLE9BQU8sS0FBUDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJEOztBQUNBOztBQUVlLFNBQVMsV0FBVCxDQUFxQixPQUFyQixFQUE4QixNQUE5QixFQUFzQyxTQUF0QyxFQUFpRDtFQUM5RCxPQUFPLFVBQVUscUJBQVYsRUFBaUM7SUFDdEMsTUFBTSxhQUFhLEdBQUcsSUFBQSxpQkFBQSxFQUFVLHFCQUFWLENBQXRCO0lBQ0EsYUFBYSxDQUFDLElBQWQsQ0FBbUIsT0FBbkIsR0FBNkIsT0FBN0I7O0lBQ0EsSUFBSTtNQUNGLE1BQU0sS0FBSyxHQUFHLGFBQWEsQ0FBQyxJQUE1QjtNQUNBLE1BQU0sUUFBUSxHQUFHLGNBQWMsQ0FBQyxLQUFELEVBQVEsU0FBUixFQUFtQixNQUFuQixDQUEvQjtNQUNBLGFBQWEsQ0FBQyxJQUFkLEdBQXFCLFFBQXJCO0lBQ0QsQ0FKRCxDQUlFLE9BQU8sR0FBUCxFQUFZO01BQ1osT0FBTyxDQUFDLElBQVIsQ0FBYyx1QkFBc0IsT0FBUSxHQUFFLEdBQUcsQ0FBQyxLQUFNLEVBQXhEO0lBQ0Q7O0lBQ0QsT0FBTyxPQUFPLENBQUMsT0FBUixDQUFnQixhQUFoQixDQUFQO0VBQ0QsQ0FYRDtBQVlEOztBQUVELFNBQVMsY0FBVCxDQUF3QixLQUF4QixFQUErQixTQUEvQixFQUEwQyxNQUExQyxFQUFrRDtFQUNoRCxNQUFNLFFBQVEsR0FBRyxLQUFqQjtFQUNBLE1BQU07SUFBRTtFQUFGLElBQTRCLFFBQWxDOztFQUNBLElBQUkscUJBQXFCLElBQUkscUJBQXFCLENBQUMsWUFBbkQsRUFBaUU7SUFDL0QsTUFBTTtNQUFFO0lBQUYsSUFBbUIscUJBQXpCO0lBRUEsUUFBUSxDQUFDLHFCQUFULENBQStCLFlBQS9CLEdBQThDLFlBQVksQ0FBQyxHQUFiLENBQWtCLE1BQUQsSUFBWTtNQUN6RSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQUQsQ0FBZCxFQUF3QjtRQUN0QixPQUFPLE1BQVA7TUFDRDs7TUFFRCxNQUFNLENBQUMsTUFBUCxHQUFnQixpQ0FBQSxDQUFxQixNQUFyQztNQUNBLE1BQU0sQ0FBQyxHQUFQLEdBQWE7UUFDWCxPQUFPLEVBQUUsTUFERTtRQUVYLElBQUksRUFBRyxnREFBK0MsTUFBTztNQUZsRCxDQUFiO01BS0EsT0FBTyxNQUFQO0lBQ0QsQ0FaNkMsQ0FBOUM7RUFhRDs7RUFDRCxPQUFPLFFBQVA7QUFDRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2hDRDs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7OztBQWhGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE2RUEsTUFBTSxVQUFVLEdBQUcsQ0FDakIsU0FEaUIsRUFFakIsVUFGaUIsRUFHakIsVUFIaUIsRUFJakIsVUFKaUIsRUFLakIsVUFMaUIsRUFNakIsVUFOaUIsRUFPakIsVUFQaUIsRUFRakIsVUFSaUIsRUFTakIsVUFUaUIsRUFVakIsV0FWaUIsRUFXakIsV0FYaUIsRUFZakIsV0FaaUIsRUFhakIsV0FiaUIsRUFjakIsV0FkaUIsRUFlakIsV0FmaUIsRUFnQmpCLFdBaEJpQixFQWlCakIsV0FqQmlCLEVBa0JqQixXQWxCaUIsRUFtQmpCLFdBbkJpQixFQW9CakIsV0FwQmlCLEVBcUJqQixXQXJCaUIsRUFzQmpCLFdBdEJpQixFQXVCakIsV0F2QmlCLEVBd0JqQixXQXhCaUIsRUF5QmpCLFdBekJpQixFQTBCakIsV0ExQmlCLEVBMkJqQixXQTNCaUIsRUE0QmpCLFdBNUJpQixFQTZCakIsV0E3QmlCLEVBOEJqQixXQTlCaUIsRUErQmpCLFdBL0JpQixFQWdDakIsV0FoQ2lCLEVBaUNqQixXQWpDaUIsRUFrQ2pCLFdBbENpQixFQW1DakIsV0FuQ2lCLEVBb0NqQixXQXBDaUIsRUFxQ2pCLFdBckNpQixFQXNDakIsV0F0Q2lCLEVBdUNqQixXQXZDaUIsRUF3Q2pCLFdBeENpQixFQXlDakIsV0F6Q2lCLEVBMENqQixXQTFDaUIsRUEyQ2pCLFdBM0NpQixFQTRDakIsV0E1Q2lCLEVBNkNqQixXQTdDaUIsRUE4Q2pCLFdBOUNpQixFQStDakIsV0EvQ2lCLEVBZ0RqQixXQWhEaUIsRUFpRGpCLFdBakRpQixFQWtEakIsV0FsRGlCLEVBbURqQixXQW5EaUIsRUFvRGpCLFdBcERpQixFQXFEakIsV0FyRGlCLEVBc0RqQixXQXREaUIsRUF1RGpCLFdBdkRpQixFQXdEakIsV0F4RGlCLEVBeURqQixXQXpEaUIsRUEwRGpCLFdBMURpQixFQTJEakIsV0EzRGlCLEVBNERqQixXQTVEaUIsRUE2RGpCLFdBN0RpQixFQThEakIsV0E5RGlCLEVBK0RqQixXQS9EaUIsRUFnRWpCLFdBaEVpQixFQWlFakIsV0FqRWlCLEVBa0VqQixXQWxFaUIsRUFtRWpCLFdBbkVpQixFQW9FakIsV0FwRWlCLEVBcUVqQixXQXJFaUIsRUFzRWpCLFdBdEVpQixFQXVFakIsV0F2RWlCLEVBd0VqQixXQXhFaUIsRUF5RWpCLFdBekVpQixFQTBFakIsV0ExRWlCLENBQW5CO2VBNkVlLFU7Ozs7Ozs7Ozs7Ozs7QUMvSmY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hlQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3BQQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3B1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMzb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3B1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDM05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1T0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3ekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDak1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25oQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2w1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ2xQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJiYWNrZ3JvdW5kLTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgcHVtcCBmcm9tICdwdW1wJztcbmltcG9ydCB7IE9ic2VydmFibGVTdG9yZSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUnO1xuaW1wb3J0IHsgc3RvcmVBc1N0cmVhbSB9IGZyb20gJ0BtZXRhbWFzay9vYnMtc3RvcmUvZGlzdC9hc1N0cmVhbSc7XG5pbXBvcnQgeyBKc29uUnBjRW5naW5lIH0gZnJvbSAnanNvbi1ycGMtZW5naW5lJztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBjcmVhdGVFbmdpbmVTdHJlYW0gZnJvbSAnanNvbi1ycGMtbWlkZGxld2FyZS1zdHJlYW0vZW5naW5lU3RyZWFtJztcbmltcG9ydCBjcmVhdGVGaWx0ZXJNaWRkbGV3YXJlIGZyb20gJ2V0aC1qc29uLXJwYy1maWx0ZXJzJztcbmltcG9ydCBjcmVhdGVTdWJzY3JpcHRpb25NYW5hZ2VyIGZyb20gJ2V0aC1qc29uLXJwYy1maWx0ZXJzL3N1YnNjcmlwdGlvbk1hbmFnZXInO1xuaW1wb3J0IHsgcHJvdmlkZXJBc01pZGRsZXdhcmUgfSBmcm9tICdldGgtanNvbi1ycGMtbWlkZGxld2FyZSc7XG5pbXBvcnQgS2V5cmluZ0NvbnRyb2xsZXIgZnJvbSAnZXRoLWtleXJpbmctY29udHJvbGxlcic7XG5pbXBvcnQge1xuICBlcnJvckNvZGVzIGFzIHJwY0Vycm9yQ29kZXMsXG4gIEV0aGVyZXVtUnBjRXJyb3IsXG4gIGV0aEVycm9ycyxcbn0gZnJvbSAnZXRoLXJwYy1lcnJvcnMnO1xuaW1wb3J0IHsgTXV0ZXggfSBmcm9tICdhd2FpdC1zZW1hcGhvcmUnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgVHJlem9yS2V5cmluZyBmcm9tICdldGgtdHJlem9yLWtleXJpbmcnO1xuaW1wb3J0IExlZGdlckJyaWRnZUtleXJpbmcgZnJvbSAnQG1ldGFtYXNrL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcnO1xuaW1wb3J0IExhdHRpY2VLZXlyaW5nIGZyb20gJ2V0aC1sYXR0aWNlLWtleXJpbmcnO1xuaW1wb3J0IHsgTWV0YU1hc2tLZXlyaW5nIGFzIFFSSGFyZHdhcmVLZXlyaW5nIH0gZnJvbSAnQGtleXN0b25laHEvbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcnO1xuaW1wb3J0IEV0aFF1ZXJ5IGZyb20gJ2V0aC1xdWVyeSc7XG5pbXBvcnQgbmFub2lkIGZyb20gJ25hbm9pZCc7XG5pbXBvcnQgeyBjYXB0dXJlRXhjZXB0aW9uIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCB7XG4gIEFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgQXBwcm92YWxDb250cm9sbGVyLFxuICBDb250cm9sbGVyTWVzc2VuZ2VyLFxuICBDdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICBQaGlzaGluZ0NvbnRyb2xsZXIsXG4gIEFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gIEdhc0ZlZUNvbnRyb2xsZXIsXG4gIFRva2VuTGlzdENvbnRyb2xsZXIsXG4gIFRva2Vuc0NvbnRyb2xsZXIsXG4gIFRva2VuUmF0ZXNDb250cm9sbGVyLFxuICBDb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICBBc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gIENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcixcbiAgUGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXG4gIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IsXG4gIEFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3IsXG59IGZyb20gJ0BtZXRhbWFzay9jb250cm9sbGVycyc7XG5pbXBvcnQgU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyIGZyb20gJ0BtZXRhbWFzay9zbWFydC10cmFuc2FjdGlvbnMtY29udHJvbGxlcic7XG5cbmltcG9ydCB7XG4gIEFTU0VUX1RZUEVTLFxuICBUUkFOU0FDVElPTl9TVEFUVVNFUyxcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgUEhJU0hJTkdfTkVXX0lTU1VFX1VSTFMgfSBmcm9tICcuLi8uLi9zaGFyZWQvY29uc3RhbnRzL3BoaXNoaW5nJztcbmltcG9ydCB7XG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19DTElFTlRfSUQsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgQ0hBSU5fSURTIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIERFVklDRV9OQU1FUyxcbiAgS0VZUklOR19UWVBFUyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9oYXJkd2FyZS13YWxsZXRzJztcbmltcG9ydCB7XG4gIENhdmVhdFR5cGVzLFxuICBSZXN0cmljdGVkTWV0aG9kcyxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9wZXJtaXNzaW9ucyc7XG5pbXBvcnQgeyBVSV9OT1RJRklDQVRJT05TIH0gZnJvbSAnLi4vLi4vc2hhcmVkL25vdGlmaWNhdGlvbnMnO1xuaW1wb3J0IHtcbiAgdG9DaGVja3N1bUhleEFkZHJlc3MsXG4gIHN0cmlwSGV4UHJlZml4LFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuaW1wb3J0IHsgTUlMTElTRUNPTkQsIFNFQ09ORCB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdGltZSc7XG5pbXBvcnQge1xuICBPUklHSU5fTUVUQU1BU0ssXG4gIFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVMsXG4gIFNVQkpFQ1RfVFlQRVMsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcbmltcG9ydCB7IEVWRU5ULCBFVkVOVF9OQU1FUyB9IGZyb20gJy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MnO1xuXG5pbXBvcnQgeyBnZXRUb2tlbklkUGFyYW0gfSBmcm9tICcuLi8uLi91aS9oZWxwZXJzL3V0aWxzL3Rva2VuLXV0aWwnO1xuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uLy4uL3NoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscyc7XG5pbXBvcnQgeyBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQgeyBTVEFUSUNfTUFJTk5FVF9UT0tFTl9MSVNUIH0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90b2tlbnMnO1xuaW1wb3J0IHtcbiAgZ2V0VG9rZW5WYWx1ZVBhcmFtLFxuICBoZXhUb0RlY2ltYWwsXG59IGZyb20gJy4uLy4uL3NoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQge1xuICBvbk1lc3NhZ2VSZWNlaXZlZCxcbiAgY2hlY2tGb3JNdWx0aXBsZVZlcnNpb25zUnVubmluZyxcbn0gZnJvbSAnLi9kZXRlY3QtbXVsdGlwbGUtaW5zdGFuY2VzJztcbmltcG9ydCBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlIGZyb20gJy4vbGliL0NvbXBvc2FibGVPYnNlcnZhYmxlU3RvcmUnO1xuaW1wb3J0IEFjY291bnRUcmFja2VyIGZyb20gJy4vbGliL2FjY291bnQtdHJhY2tlcic7XG5pbXBvcnQgY3JlYXRlTG9nZ2VyTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVMb2dnZXJNaWRkbGV3YXJlJztcbmltcG9ydCB7XG4gIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUsXG59IGZyb20gJy4vbGliL3JwYy1tZXRob2QtbWlkZGxld2FyZSc7XG5pbXBvcnQgY3JlYXRlT3JpZ2luTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVPcmlnaW5NaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVUYWJJZE1pZGRsZXdhcmUgZnJvbSAnLi9saWIvY3JlYXRlVGFiSWRNaWRkbGV3YXJlJztcbmltcG9ydCBjcmVhdGVPbmJvYXJkaW5nTWlkZGxld2FyZSBmcm9tICcuL2xpYi9jcmVhdGVPbmJvYXJkaW5nTWlkZGxld2FyZSc7XG5pbXBvcnQgeyBzZXR1cE11bHRpcGxleCB9IGZyb20gJy4vbGliL3N0cmVhbS11dGlscyc7XG5pbXBvcnQgRW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2Vucyc7XG5pbXBvcnQgTmV0d29ya0NvbnRyb2xsZXIsIHsgTkVUV09SS19FVkVOVFMgfSBmcm9tICcuL2NvbnRyb2xsZXJzL25ldHdvcmsnO1xuaW1wb3J0IFByZWZlcmVuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3ByZWZlcmVuY2VzJztcbmltcG9ydCBBcHBTdGF0ZUNvbnRyb2xsZXIgZnJvbSAnLi9jb250cm9sbGVycy9hcHAtc3RhdGUnO1xuaW1wb3J0IENhY2hlZEJhbGFuY2VzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2NhY2hlZC1iYWxhbmNlcyc7XG5pbXBvcnQgQWxlcnRDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvYWxlcnQnO1xuaW1wb3J0IE9uYm9hcmRpbmdDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvb25ib2FyZGluZyc7XG5pbXBvcnQgQmFja3VwQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2JhY2t1cCc7XG5pbXBvcnQgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyIGZyb20gJy4vY29udHJvbGxlcnMvaW5jb21pbmctdHJhbnNhY3Rpb25zJztcbmltcG9ydCBNZXNzYWdlTWFuYWdlciwgeyBub3JtYWxpemVNc2dEYXRhIH0gZnJvbSAnLi9saWIvbWVzc2FnZS1tYW5hZ2VyJztcbmltcG9ydCBEZWNyeXB0TWVzc2FnZU1hbmFnZXIgZnJvbSAnLi9saWIvZGVjcnlwdC1tZXNzYWdlLW1hbmFnZXInO1xuaW1wb3J0IEVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyIGZyb20gJy4vbGliL2VuY3J5cHRpb24tcHVibGljLWtleS1tYW5hZ2VyJztcbmltcG9ydCBQZXJzb25hbE1lc3NhZ2VNYW5hZ2VyIGZyb20gJy4vbGliL3BlcnNvbmFsLW1lc3NhZ2UtbWFuYWdlcic7XG5pbXBvcnQgVHlwZWRNZXNzYWdlTWFuYWdlciBmcm9tICcuL2xpYi90eXBlZC1tZXNzYWdlLW1hbmFnZXInO1xuaW1wb3J0IFRyYW5zYWN0aW9uQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3RyYW5zYWN0aW9ucyc7XG5pbXBvcnQgRGV0ZWN0VG9rZW5zQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL2RldGVjdC10b2tlbnMnO1xuaW1wb3J0IFN3YXBzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL3N3YXBzJztcbmltcG9ydCBhY2NvdW50SW1wb3J0ZXIgZnJvbSAnLi9hY2NvdW50LWltcG9ydC1zdHJhdGVnaWVzJztcbmltcG9ydCBzZWVkUGhyYXNlVmVyaWZpZXIgZnJvbSAnLi9saWIvc2VlZC1waHJhc2UtdmVyaWZpZXInO1xuaW1wb3J0IE1ldGFNZXRyaWNzQ29udHJvbGxlciBmcm9tICcuL2NvbnRyb2xsZXJzL21ldGFtZXRyaWNzJztcbmltcG9ydCB7IHNlZ21lbnQgfSBmcm9tICcuL2xpYi9zZWdtZW50JztcbmltcG9ydCBjcmVhdGVNZXRhUlBDSGFuZGxlciBmcm9tICcuL2xpYi9jcmVhdGVNZXRhUlBDSGFuZGxlcic7XG5pbXBvcnQge1xuICBDYXZlYXRNdXRhdG9yRmFjdG9yaWVzLFxuICBnZXRDYXZlYXRTcGVjaWZpY2F0aW9ucyxcbiAgZ2V0Q2hhbmdlZEFjY291bnRzLFxuICBnZXRQZXJtaXNzaW9uQmFja2dyb3VuZEFwaU1ldGhvZHMsXG4gIGdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyxcbiAgZ2V0UGVybWl0dGVkQWNjb3VudHNCeU9yaWdpbixcbiAgTk9USUZJQ0FUSU9OX05BTUVTLFxuICBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcixcbiAgdW5yZXN0cmljdGVkTWV0aG9kcyxcbn0gZnJvbSAnLi9jb250cm9sbGVycy9wZXJtaXNzaW9ucyc7XG5pbXBvcnQgY3JlYXRlUlBDTWV0aG9kVHJhY2tpbmdNaWRkbGV3YXJlIGZyb20gJy4vbGliL2NyZWF0ZVJQQ01ldGhvZFRyYWNraW5nTWlkZGxld2FyZSc7XG5cbmV4cG9ydCBjb25zdCBNRVRBTUFTS19DT05UUk9MTEVSX0VWRU5UUyA9IHtcbiAgLy8gRmlyZWQgYWZ0ZXIgc3RhdGUgY2hhbmdlcyB0aGF0IGltcGFjdCB0aGUgZXh0ZW5zaW9uIGJhZGdlICh1bmFwcHJvdmVkIG1zZyBjb3VudClcbiAgLy8gVGhlIHByb2Nlc3Mgb2YgdXBkYXRpbmcgdGhlIGJhZGdlIGhhcHBlbnMgaW4gYXBwL3NjcmlwdHMvYmFja2dyb3VuZC5qcy5cbiAgVVBEQVRFX0JBREdFOiAndXBkYXRlQmFkZ2UnLFxuICAvLyBUT0RPOiBBZGQgdGhpcyBhbmQgc2ltaWxhciBlbnVtcyB0byBAbWV0YW1hc2svY29udHJvbGxlcnMgYW5kIGV4cG9ydCB0aGVtXG4gIEFQUFJPVkFMX1NUQVRFX0NIQU5HRTogJ0FwcHJvdmFsQ29udHJvbGxlcjpzdGF0ZUNoYW5nZScsXG59O1xuXG4vLyBzdHJlYW0gY2hhbm5lbHNcbmNvbnN0IFBISVNISU5HX1NBRkVMSVNUID0gJ21ldGFtYXNrLXBoaXNoaW5nLXNhZmVsaXN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWV0YW1hc2tDb250cm9sbGVyIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuZGVmYXVsdE1heExpc3RlbmVycyA9IDIwO1xuXG4gICAgdGhpcy5zZW5kVXBkYXRlID0gZGVib3VuY2UoXG4gICAgICB0aGlzLnByaXZhdGVTZW5kVXBkYXRlLmJpbmQodGhpcyksXG4gICAgICBNSUxMSVNFQ09ORCAqIDIwMCxcbiAgICApO1xuICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgdGhpcy5leHRlbnNpb24gPSBvcHRzLmJyb3dzZXI7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IG9wdHMucGxhdGZvcm07XG4gICAgdGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyID0gb3B0cy5ub3RpZmljYXRpb25NYW5hZ2VyO1xuICAgIGNvbnN0IGluaXRTdGF0ZSA9IG9wdHMuaW5pdFN0YXRlIHx8IHt9O1xuICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKTtcbiAgICB0aGlzLnJlY29yZEZpcnN0VGltZUluZm8oaW5pdFN0YXRlKTtcblxuICAgIC8vIHRoaXMga2VlcHMgdHJhY2sgb2YgaG93IG1hbnkgXCJjb250cm9sbGVyU3RyZWFtXCIgY29ubmVjdGlvbnMgYXJlIG9wZW5cbiAgICAvLyB0aGUgb25seSB0aGluZyB0aGF0IHVzZXMgY29udHJvbGxlciBjb25uZWN0aW9ucyBhcmUgb3BlbiBtZXRhbWFzayBVSSBpbnN0YW5jZXNcbiAgICB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyA9IDA7XG5cbiAgICB0aGlzLmdldFJlcXVlc3RBY2NvdW50VGFiSWRzID0gb3B0cy5nZXRSZXF1ZXN0QWNjb3VudFRhYklkcztcbiAgICB0aGlzLmdldE9wZW5NZXRhbWFza1RhYnNJZHMgPSBvcHRzLmdldE9wZW5NZXRhbWFza1RhYnNJZHM7XG5cbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIgPSBuZXcgQ29udHJvbGxlck1lc3NlbmdlcigpO1xuXG4gICAgLy8gaW5zdGFuY2Ugb2YgYSBjbGFzcyB0aGF0IHdyYXBzIHRoZSBleHRlbnNpb24ncyBzdG9yYWdlIGxvY2FsIEFQSS5cbiAgICB0aGlzLmxvY2FsU3RvcmVBcGlXcmFwcGVyID0gb3B0cy5sb2NhbFN0b3JlO1xuXG4gICAgLy8gb2JzZXJ2YWJsZSBzdGF0ZSBzdG9yZVxuICAgIHRoaXMuc3RvcmUgPSBuZXcgQ29tcG9zYWJsZU9ic2VydmFibGVTdG9yZSh7XG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLFxuICAgICAgY29udHJvbGxlck1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLFxuICAgICAgcGVyc2lzdDogdHJ1ZSxcbiAgICB9KTtcblxuICAgIC8vIGV4dGVybmFsIGNvbm5lY3Rpb25zIGJ5IG9yaWdpblxuICAgIC8vIERvIG5vdCBtb2RpZnkgZGlyZWN0bHkuIFVzZSB0aGUgYXNzb2NpYXRlZCBtZXRob2RzLlxuICAgIHRoaXMuY29ubmVjdGlvbnMgPSB7fTtcblxuICAgIC8vIGxvY2sgdG8gZW5zdXJlIG9ubHkgb25lIHZhdWx0IGNyZWF0ZWQgYXQgb25jZVxuICAgIHRoaXMuY3JlYXRlVmF1bHRNdXRleCA9IG5ldyBNdXRleCgpO1xuXG4gICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5vbkluc3RhbGxlZC5hZGRMaXN0ZW5lcigoZGV0YWlscykgPT4ge1xuICAgICAgaWYgKGRldGFpbHMucmVhc29uID09PSAndXBkYXRlJyAmJiB2ZXJzaW9uID09PSAnOC4xLjAnKSB7XG4gICAgICAgIHRoaXMucGxhdGZvcm0ub3BlbkV4dGVuc2lvbkluQnJvd3NlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gbmV4dCwgd2Ugd2lsbCBpbml0aWFsaXplIHRoZSBjb250cm9sbGVyc1xuICAgIC8vIGNvbnRyb2xsZXIgaW5pdGlhbGl6YXRpb24gb3JkZXIgbWF0dGVyc1xuXG4gICAgdGhpcy5hcHByb3ZhbENvbnRyb2xsZXIgPSBuZXcgQXBwcm92YWxDb250cm9sbGVyKHtcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgICBuYW1lOiAnQXBwcm92YWxDb250cm9sbGVyJyxcbiAgICAgIH0pLFxuICAgICAgc2hvd0FwcHJvdmFsUmVxdWVzdDogb3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbixcbiAgICB9KTtcblxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIgPSBuZXcgTmV0d29ya0NvbnRyb2xsZXIoaW5pdFN0YXRlLk5ldHdvcmtDb250cm9sbGVyKTtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldEluZnVyYVByb2plY3RJZChvcHRzLmluZnVyYVByb2plY3RJZCk7XG5cbiAgICAvLyBub3cgd2UgY2FuIGluaXRpYWxpemUgdGhlIFJQQyBwcm92aWRlciwgd2hpY2ggb3RoZXIgY29udHJvbGxlcnMgcmVxdWlyZVxuICAgIHRoaXMuaW5pdGlhbGl6ZVByb3ZpZGVyKCk7XG4gICAgdGhpcy5wcm92aWRlciA9XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQW5kQmxvY2tUcmFja2VyKCkucHJvdmlkZXI7XG4gICAgdGhpcy5ibG9ja1RyYWNrZXIgPVxuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLmJsb2NrVHJhY2tlcjtcblxuICAgIGNvbnN0IHRva2VuTGlzdE1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgIG5hbWU6ICdUb2tlbkxpc3RDb250cm9sbGVyJyxcbiAgICB9KTtcblxuICAgIHRoaXMudG9rZW5MaXN0Q29udHJvbGxlciA9IG5ldyBUb2tlbkxpc3RDb250cm9sbGVyKHtcbiAgICAgIGNoYWluSWQ6IGhleFRvRGVjaW1hbCh0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCkpLFxuICAgICAgcHJldmVudFBvbGxpbmdPbk5ldHdvcmtSZXN0YXJ0OiBpbml0U3RhdGUuVG9rZW5MaXN0Q29udHJvbGxlclxuICAgICAgICA/IGluaXRTdGF0ZS5Ub2tlbkxpc3RDb250cm9sbGVyLnByZXZlbnRQb2xsaW5nT25OZXR3b3JrUmVzdGFydFxuICAgICAgICA6IHRydWUsXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogKGNiKSA9PiB7XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKChuZXR3b3JrU3RhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB7XG4gICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlcixcbiAgICAgICAgICAgICAgY2hhaW5JZDogaGV4VG9EZWNpbWFsKG5ldHdvcmtTdGF0ZS5wcm92aWRlci5jaGFpbklkKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gY2IobW9kaWZpZWROZXR3b3JrU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBtZXNzZW5nZXI6IHRva2VuTGlzdE1lc3NlbmdlcixcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuVG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyID0gbmV3IFByZWZlcmVuY2VzQ29udHJvbGxlcih7XG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICBpbml0TGFuZ0NvZGU6IG9wdHMuaW5pdExhbmdDb2RlLFxuICAgICAgb3BlblBvcHVwOiBvcHRzLm9wZW5Qb3B1cCxcbiAgICAgIG5ldHdvcms6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICB0b2tlbkxpc3RDb250cm9sbGVyOiB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG1pZ3JhdGVBZGRyZXNzQm9va1N0YXRlOiB0aGlzLm1pZ3JhdGVBZGRyZXNzQm9va1N0YXRlLmJpbmQodGhpcyksXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIgPSBuZXcgVG9rZW5zQ29udHJvbGxlcih7XG4gICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2U6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICksXG4gICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICksXG4gICAgICBjb25maWc6IHsgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIgfSxcbiAgICAgIHN0YXRlOiBpbml0U3RhdGUuVG9rZW5zQ29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyID0gbmV3IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcihcbiAgICAgIHtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlOiAobGlzdGVuZXIpID0+XG4gICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlKGxpc3RlbmVyKSxcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT5cbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZSgobmV0d29ya1N0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZE5ldHdvcmtTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgICBwcm92aWRlcjoge1xuICAgICAgICAgICAgICAgIC4uLm5ldHdvcmtTdGF0ZS5wcm92aWRlcixcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwobmV0d29ya1N0YXRlLnByb3ZpZGVyLmNoYWluSWQpLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XG4gICAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIH0sXG4gICAgICBpbml0U3RhdGUuQXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIgPSBuZXcgQ29sbGVjdGlibGVzQ29udHJvbGxlcihcbiAgICAgIHtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlOlxuICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICAgKSxcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0RVJDNzIxQXNzZXROYW1lOlxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzcyMUFzc2V0TmFtZS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgZ2V0RVJDNzIxQXNzZXRTeW1ib2w6XG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDNzIxQXNzZXRTeW1ib2wuYmluZChcbiAgICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgIGdldEVSQzcyMVRva2VuVVJJOiB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkM3MjFUb2tlblVSSS5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRFUkM3MjFPd25lck9mOiB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRFUkM3MjFPd25lck9mLmJpbmQoXG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGdldEVSQzExNTVCYWxhbmNlT2Y6XG4gICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0RVJDMTE1NUJhbGFuY2VPZi5iaW5kKFxuICAgICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgZ2V0RVJDMTE1NVRva2VuVVJJOlxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLmdldEVSQzExNTVUb2tlblVSSS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgb25Db2xsZWN0aWJsZUFkZGVkOiAoeyBhZGRyZXNzLCBzeW1ib2wsIHRva2VuSWQsIHN0YW5kYXJkLCBzb3VyY2UgfSkgPT5cbiAgICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KHtcbiAgICAgICAgICAgIGV2ZW50OiBFVkVOVF9OQU1FUy5ORlRfQURERUQsXG4gICAgICAgICAgICBjYXRlZ29yeTogRVZFTlQuQ0FURUdPUklFUy5XQUxMRVQsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHRva2VuX2NvbnRyYWN0X2FkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgIHRva2VuX3N5bWJvbDogc3ltYm9sLFxuICAgICAgICAgICAgICBhc3NldF90eXBlOiBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRSxcbiAgICAgICAgICAgICAgdG9rZW5fc3RhbmRhcmQ6IHN0YW5kYXJkLFxuICAgICAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2Vuc2l0aXZlUHJvcGVydGllczoge1xuICAgICAgICAgICAgICB0b2tlbklkLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgICB7fSxcbiAgICAgIGluaXRTdGF0ZS5Db2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuc2V0QXBpS2V5KHByb2Nlc3MuZW52Lk9QRU5TRUFfS0VZKTtcblxuICAgIHByb2Nlc3MuZW52LkNPTExFQ1RJQkxFU19WMSAmJlxuICAgICAgKHRoaXMuY29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyID0gbmV3IENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcihcbiAgICAgICAge1xuICAgICAgICAgIG9uQ29sbGVjdGlibGVzU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT5cbiAgICAgICAgICAgIHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5zdWJzY3JpYmUobGlzdGVuZXIpLFxuICAgICAgICAgIG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZTpcbiAgICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZS5iaW5kKFxuICAgICAgICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICAgICksXG4gICAgICAgICAgZ2V0T3BlblNlYUFwaUtleTogKCkgPT4gdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLm9wZW5TZWFBcGlLZXksXG4gICAgICAgICAgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGw6XG4gICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRCYWxhbmNlc0luU2luZ2xlQ2FsbC5iaW5kKFxuICAgICAgICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcixcbiAgICAgICAgICAgICksXG4gICAgICAgICAgYWRkQ29sbGVjdGlibGU6IHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5hZGRDb2xsZWN0aWJsZS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgICAgZ2V0Q29sbGVjdGlibGVzU3RhdGU6ICgpID0+IHRoaXMuY29sbGVjdGlibGVzQ29udHJvbGxlci5zdGF0ZSxcbiAgICAgICAgfSxcbiAgICAgICkpO1xuXG4gICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIgPSBuZXcgTWV0YU1ldHJpY3NDb250cm9sbGVyKHtcbiAgICAgIHNlZ21lbnQsXG4gICAgICBwcmVmZXJlbmNlc1N0b3JlOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIG9uTmV0d29ya0RpZENoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbi5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICBORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsXG4gICAgICApLFxuICAgICAgZ2V0TmV0d29ya0lkZW50aWZpZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0TmV0d29ya0lkZW50aWZpZXIuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHZlcnNpb246IHRoaXMucGxhdGZvcm0uZ2V0VmVyc2lvbigpLFxuICAgICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk1FVEFNQVNLX0VOVklST05NRU5ULFxuICAgICAgZXh0ZW5zaW9uOiB0aGlzLmV4dGVuc2lvbixcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgIGNhcHR1cmVFeGNlcHRpb24sXG4gICAgfSk7XG5cbiAgICB0aGlzLm9uKCd1cGRhdGUnLCAodXBkYXRlKSA9PiB7XG4gICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5oYW5kbGVNZXRhTWFza1N0YXRlVXBkYXRlKHVwZGF0ZSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBnYXNGZWVNZXNzZW5nZXIgPSB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuZ2V0UmVzdHJpY3RlZCh7XG4gICAgICBuYW1lOiAnR2FzRmVlQ29udHJvbGxlcicsXG4gICAgfSk7XG5cbiAgICBjb25zdCBnYXNBcGlCYXNlVXJsID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTXG4gICAgICA/IEdBU19ERVZfQVBJX0JBU0VfVVJMXG4gICAgICA6IEdBU19BUElfQkFTRV9VUkw7XG5cbiAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIgPSBuZXcgR2FzRmVlQ29udHJvbGxlcih7XG4gICAgICBpbnRlcnZhbDogMTAwMDAsXG4gICAgICBtZXNzZW5nZXI6IGdhc0ZlZU1lc3NlbmdlcixcbiAgICAgIGNsaWVudElkOiBTV0FQU19DTElFTlRfSUQsXG4gICAgICBnZXRQcm92aWRlcjogKCkgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRQcm92aWRlckFuZEJsb2NrVHJhY2tlcigpLnByb3ZpZGVyLFxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24uYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLFxuICAgICAgKSxcbiAgICAgIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk6XG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZChcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eTpcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5LmJpbmQodGhpcyksXG4gICAgICBsZWdhY3lBUElFbmRwb2ludDogYCR7Z2FzQXBpQmFzZVVybH0vbmV0d29ya3MvPGNoYWluX2lkPi9nYXNQcmljZXNgLFxuICAgICAgRUlQMTU1OUFQSUVuZHBvaW50OiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy88Y2hhaW5faWQ+L3N1Z2dlc3RlZEdhc0ZlZXNgLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYWluSWQgPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5JTl9URVNUIHx8IGNoYWluSWQgPT09IENIQUlOX0lEUy5NQUlOTkVUO1xuICAgICAgfSxcbiAgICAgIGdldENoYWluSWQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52LklOX1RFU1RcbiAgICAgICAgICA/IENIQUlOX0lEUy5NQUlOTkVUXG4gICAgICAgICAgOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkKCk7XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgdGhpcy5xckhhcmR3YXJlS2V5cmluZyA9IG5ldyBRUkhhcmR3YXJlS2V5cmluZygpO1xuXG4gICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIgPSBuZXcgQXBwU3RhdGVDb250cm9sbGVyKHtcbiAgICAgIGFkZFVubG9ja0xpc3RlbmVyOiB0aGlzLm9uLmJpbmQodGhpcywgJ3VubG9jaycpLFxuICAgICAgaXNVbmxvY2tlZDogdGhpcy5pc1VubG9ja2VkLmJpbmQodGhpcyksXG4gICAgICBpbml0U3RhdGU6IGluaXRTdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICBvbkluYWN0aXZlVGltZW91dDogKCkgPT4gdGhpcy5zZXRMb2NrZWQoKSxcbiAgICAgIHNob3dVbmxvY2tSZXF1ZXN0OiBvcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uLFxuICAgICAgcHJlZmVyZW5jZXNTdG9yZTogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBxckhhcmR3YXJlU3RvcmU6IHRoaXMucXJIYXJkd2FyZUtleXJpbmcuZ2V0TWVtU3RvcmUoKSxcbiAgICB9KTtcblxuICAgIGNvbnN0IGN1cnJlbmN5UmF0ZU1lc3NlbmdlciA9IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgIG5hbWU6ICdDdXJyZW5jeVJhdGVDb250cm9sbGVyJyxcbiAgICB9KTtcbiAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgPSBuZXcgQ3VycmVuY3lSYXRlQ29udHJvbGxlcih7XG4gICAgICBpbmNsdWRlVXNkUmF0ZTogdHJ1ZSxcbiAgICAgIG1lc3NlbmdlcjogY3VycmVuY3lSYXRlTWVzc2VuZ2VyLFxuICAgICAgc3RhdGU6IHtcbiAgICAgICAgLi4uaW5pdFN0YXRlLkN1cnJlbmN5Q29udHJvbGxlcixcbiAgICAgICAgbmF0aXZlQ3VycmVuY3k6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXJTdG9yZS5nZXRTdGF0ZSgpLnRpY2tlcixcbiAgICAgIH0sXG4gICAgfSk7XG5cbiAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlciA9IG5ldyBQaGlzaGluZ0NvbnRyb2xsZXIoKTtcbiAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci51cGRhdGVQaGlzaGluZ0xpc3RzKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52LklOX1RFU1QpIHtcbiAgICAgIHRoaXMucGhpc2hpbmdDb250cm9sbGVyLnNldFJlZnJlc2hJbnRlcnZhbCg1ICogU0VDT05EKTtcbiAgICB9XG5cbiAgICB0aGlzLmFubm91bmNlbWVudENvbnRyb2xsZXIgPSBuZXcgQW5ub3VuY2VtZW50Q29udHJvbGxlcihcbiAgICAgIHsgYWxsQW5ub3VuY2VtZW50czogVUlfTk9USUZJQ0FUSU9OUyB9LFxuICAgICAgaW5pdFN0YXRlLkFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gICAgKTtcblxuICAgIC8vIHRva2VuIGV4Y2hhbmdlIHJhdGUgdHJhY2tlclxuICAgIHRoaXMudG9rZW5SYXRlc0NvbnRyb2xsZXIgPSBuZXcgVG9rZW5SYXRlc0NvbnRyb2xsZXIoe1xuICAgICAgb25Ub2tlbnNTdGF0ZUNoYW5nZTogKGxpc3RlbmVyKSA9PlxuICAgICAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIuc3Vic2NyaWJlKGxpc3RlbmVyKSxcbiAgICAgIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2U6IChsaXN0ZW5lcikgPT5cbiAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShcbiAgICAgICAgICBgJHt0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIubmFtZX06c3RhdGVDaGFuZ2VgLFxuICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICApLFxuICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IChjYikgPT5cbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZS5zdWJzY3JpYmUoKG5ldHdvcmtTdGF0ZSkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTmV0d29ya1N0YXRlID0ge1xuICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgICAgICAgLi4ubmV0d29ya1N0YXRlLnByb3ZpZGVyLFxuICAgICAgICAgICAgICBjaGFpbklkOiBoZXhUb0RlY2ltYWwobmV0d29ya1N0YXRlLnByb3ZpZGVyLmNoYWluSWQpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiBjYihtb2RpZmllZE5ldHdvcmtTdGF0ZSk7XG4gICAgICAgIH0pLFxuICAgIH0pO1xuXG4gICAgdGhpcy5lbnNDb250cm9sbGVyID0gbmV3IEVuc0NvbnRyb2xsZXIoe1xuICAgICAgcHJvdmlkZXI6IHRoaXMucHJvdmlkZXIsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIG9uTmV0d29ya0RpZENoYW5nZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbi5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICBORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIgPSBuZXcgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyKHtcbiAgICAgIGJsb2NrVHJhY2tlcjogdGhpcy5ibG9ja1RyYWNrZXIsXG4gICAgICBvbk5ldHdvcmtEaWRDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24uYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLFxuICAgICAgKSxcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIC8vIGFjY291bnQgdHJhY2tlciB3YXRjaGVzIGJhbGFuY2VzLCBub25jZXMsIGFuZCBhbnkgY29kZSBhdCB0aGVpciBhZGRyZXNzXG4gICAgdGhpcy5hY2NvdW50VHJhY2tlciA9IG5ldyBBY2NvdW50VHJhY2tlcih7XG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIGJsb2NrVHJhY2tlcjogdGhpcy5ibG9ja1RyYWNrZXIsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGdldE5ldHdvcmtJZGVudGlmaWVyOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldE5ldHdvcmtJZGVudGlmaWVyLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgLy8gc3RhcnQgYW5kIHN0b3AgcG9sbGluZyBmb3IgYmFsYW5jZXMgYmFzZWQgb24gYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zXG4gICAgdGhpcy5vbignY29udHJvbGxlckNvbm5lY3Rpb25DaGFuZ2VkJywgKGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucykgPT4ge1xuICAgICAgaWYgKGFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyA+IDApIHtcbiAgICAgICAgdGhpcy5hY2NvdW50VHJhY2tlci5zdGFydCgpO1xuICAgICAgICB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdGFydCgpO1xuICAgICAgICB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc3RhcnQoKTtcbiAgICAgICAgaWYgKHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkudXNlVG9rZW5EZXRlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hY2NvdW50VHJhY2tlci5zdG9wKCk7XG4gICAgICAgIHRoaXMuaW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkudXNlVG9rZW5EZXRlY3Rpb24pIHtcbiAgICAgICAgICB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmNhY2hlZEJhbGFuY2VzQ29udHJvbGxlciA9IG5ldyBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIoe1xuICAgICAgYWNjb3VudFRyYWNrZXI6IHRoaXMuYWNjb3VudFRyYWNrZXIsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkNhY2hlZEJhbGFuY2VzQ29udHJvbGxlcixcbiAgICB9KTtcblxuICAgIHRoaXMub25ib2FyZGluZ0NvbnRyb2xsZXIgPSBuZXcgT25ib2FyZGluZ0NvbnRyb2xsZXIoe1xuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnRva2Vuc0NvbnRyb2xsZXIuaHViLm9uKCdwZW5kaW5nU3VnZ2VzdGVkQXNzZXQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCBvcHRzLm9wZW5Qb3B1cCgpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgYWRkaXRpb25hbEtleXJpbmdzID0gW1xuICAgICAgVHJlem9yS2V5cmluZyxcbiAgICAgIExlZGdlckJyaWRnZUtleXJpbmcsXG4gICAgICBMYXR0aWNlS2V5cmluZyxcbiAgICAgIFFSSGFyZHdhcmVLZXlyaW5nLFxuICAgIF07XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlciA9IG5ldyBLZXlyaW5nQ29udHJvbGxlcih7XG4gICAgICBrZXlyaW5nVHlwZXM6IGFkZGl0aW9uYWxLZXlyaW5ncyxcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLktleXJpbmdDb250cm9sbGVyLFxuICAgICAgZW5jcnlwdG9yOiBvcHRzLmVuY3J5cHRvciB8fCB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZS5zdWJzY3JpYmUoKHN0YXRlKSA9PlxuICAgICAgdGhpcy5fb25LZXlyaW5nQ29udHJvbGxlclVwZGF0ZShzdGF0ZSksXG4gICAgKTtcbiAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLm9uKCd1bmxvY2snLCAoKSA9PiB0aGlzLl9vblVubG9jaygpKTtcbiAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLm9uKCdsb2NrJywgKCkgPT4gdGhpcy5fb25Mb2NrKCkpO1xuXG4gICAgY29uc3QgZ2V0SWRlbnRpdGllcyA9ICgpID0+XG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLmlkZW50aXRpZXM7XG5cbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyID0gbmV3IFBlcm1pc3Npb25Db250cm9sbGVyKHtcbiAgICAgIG1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmdldFJlc3RyaWN0ZWQoe1xuICAgICAgICBuYW1lOiAnUGVybWlzc2lvbkNvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW1xuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFkZFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9Omhhc1JlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OmFjY2VwdFJlcXVlc3RgLFxuICAgICAgICAgIGAke3RoaXMuYXBwcm92YWxDb250cm9sbGVyLm5hbWV9OnJlamVjdFJlcXVlc3RgLFxuICAgICAgICBdLFxuICAgICAgfSksXG4gICAgICBzdGF0ZTogaW5pdFN0YXRlLlBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgY2F2ZWF0U3BlY2lmaWNhdGlvbnM6IGdldENhdmVhdFNwZWNpZmljYXRpb25zKHsgZ2V0SWRlbnRpdGllcyB9KSxcbiAgICAgIHBlcm1pc3Npb25TcGVjaWZpY2F0aW9uczoge1xuICAgICAgICAuLi5nZXRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMoe1xuICAgICAgICAgIGdldElkZW50aXRpZXMsXG4gICAgICAgICAgZ2V0QWxsQWNjb3VudHM6IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMuYmluZChcbiAgICAgICAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICAgICAgKSxcbiAgICAgICAgICBjYXB0dXJlS2V5cmluZ1R5cGVzV2l0aE1pc3NpbmdJZGVudGl0aWVzOiAoXG4gICAgICAgICAgICBpZGVudGl0aWVzID0ge30sXG4gICAgICAgICAgICBhY2NvdW50cyA9IFtdLFxuICAgICAgICAgICkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudHNNaXNzaW5nSWRlbnRpdGllcyA9IGFjY291bnRzLmZpbHRlcihcbiAgICAgICAgICAgICAgKGFkZHJlc3MpID0+ICFpZGVudGl0aWVzW2FkZHJlc3NdLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllcyA9XG4gICAgICAgICAgICAgIGFjY291bnRzTWlzc2luZ0lkZW50aXRpZXMubWFwKFxuICAgICAgICAgICAgICAgIChhZGRyZXNzKSA9PlxuICAgICAgICAgICAgICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKT8udHlwZSxcbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY29uc3QgaWRlbnRpdGllc0NvdW50ID0gT2JqZWN0LmtleXMoaWRlbnRpdGllcyB8fCB7fSkubGVuZ3RoO1xuXG4gICAgICAgICAgICBjb25zdCBhY2NvdW50VHJhY2tlckNvdW50ID0gT2JqZWN0LmtleXMoXG4gICAgICAgICAgICAgIHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUuZ2V0U3RhdGUoKS5hY2NvdW50cyB8fCB7fSxcbiAgICAgICAgICAgICkubGVuZ3RoO1xuXG4gICAgICAgICAgICBjYXB0dXJlRXhjZXB0aW9uKFxuICAgICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgYEF0dGVtcHQgdG8gZ2V0IHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbnMgZmFpbGVkIGJlY2F1c2UgdGhlaXIgd2VyZSAke2FjY291bnRzLmxlbmd0aH0gYWNjb3VudHMsIGJ1dCAke2lkZW50aXRpZXNDb3VudH0gaWRlbnRpdGllcywgYW5kIHRoZSAke2tleXJpbmdUeXBlc1dpdGhNaXNzaW5nSWRlbnRpdGllc30ga2V5cmluZ3MgaW5jbHVkZWQgYWNjb3VudHMgd2l0aCBtaXNzaW5nIGlkZW50aXRpZXMuIE1lYW53aGlsZSwgdGhlcmUgYXJlICR7YWNjb3VudFRyYWNrZXJDb3VudH0gYWNjb3VudHMgaW4gdGhlIGFjY291bnQgdHJhY2tlci5gLFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgIH0sXG4gICAgICB1bnJlc3RyaWN0ZWRNZXRob2RzLFxuICAgIH0pO1xuXG4gICAgdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlciA9IG5ldyBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcih7XG4gICAgICByZXN0cmljdGVkTWV0aG9kczogbmV3IFNldChPYmplY3Qua2V5cyhSZXN0cmljdGVkTWV0aG9kcykpLFxuICAgICAgaW5pdFN0YXRlOiBpbml0U3RhdGUuUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIsXG4gICAgfSk7XG5cbiAgICB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIgPSBuZXcgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcih7XG4gICAgICBtZXNzZW5nZXI6IHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5nZXRSZXN0cmljdGVkKHtcbiAgICAgICAgbmFtZTogJ1N1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXInLFxuICAgICAgICBhbGxvd2VkQWN0aW9uczogW2Ake3RoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIubmFtZX06aGFzUGVybWlzc2lvbnNgXSxcbiAgICAgIH0pLFxuICAgICAgc3RhdGU6IGluaXRTdGF0ZS5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgc3ViamVjdENhY2hlTGltaXQ6IDEwMCxcbiAgICB9KTtcblxuICAgIHRoaXMuZGV0ZWN0VG9rZW5zQ29udHJvbGxlciA9IG5ldyBEZXRlY3RUb2tlbnNDb250cm9sbGVyKHtcbiAgICAgIHByZWZlcmVuY2VzOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIHRva2Vuc0NvbnRyb2xsZXI6IHRoaXMudG9rZW5zQ29udHJvbGxlcixcbiAgICAgIGFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjogdGhpcy5hc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAga2V5cmluZ01lbVN0b3JlOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLm1lbVN0b3JlLFxuICAgICAgdG9rZW5MaXN0OiB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIgPSBuZXcgQWRkcmVzc0Jvb2tDb250cm9sbGVyKFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgaW5pdFN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICApO1xuXG4gICAgdGhpcy5hbGVydENvbnRyb2xsZXIgPSBuZXcgQWxlcnRDb250cm9sbGVyKHtcbiAgICAgIGluaXRTdGF0ZTogaW5pdFN0YXRlLkFsZXJ0Q29udHJvbGxlcixcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgIH0pO1xuXG4gICAgdGhpcy5iYWNrdXBDb250cm9sbGVyID0gbmV3IEJhY2t1cENvbnRyb2xsZXIoe1xuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgIGFkZHJlc3NCb29rQ29udHJvbGxlcjogdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuXG4gICAgdGhpcy50eENvbnRyb2xsZXIgPSBuZXcgVHJhbnNhY3Rpb25Db250cm9sbGVyKHtcbiAgICAgIGluaXRTdGF0ZTpcbiAgICAgICAgaW5pdFN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlciB8fCBpbml0U3RhdGUuVHJhbnNhY3Rpb25NYW5hZ2VyLFxuICAgICAgZ2V0UGVybWl0dGVkQWNjb3VudHM6IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMuYmluZCh0aGlzKSxcbiAgICAgIGdldFByb3ZpZGVyQ29uZmlnOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQ29uZmlnLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eTpcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5OlxuICAgICAgICB0aGlzLmdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHkuYmluZCh0aGlzKSxcbiAgICAgIG5ldHdvcmtTdG9yZTogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrU3RvcmUsXG4gICAgICBnZXRDdXJyZW50Q2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZC5iaW5kKFxuICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHByZWZlcmVuY2VzU3RvcmU6IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgdHhIaXN0b3J5TGltaXQ6IDYwLFxuICAgICAgc2lnblRyYW5zYWN0aW9uOiB0aGlzLmtleXJpbmdDb250cm9sbGVyLnNpZ25UcmFuc2FjdGlvbi5iaW5kKFxuICAgICAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHByb3ZpZGVyOiB0aGlzLnByb3ZpZGVyLFxuICAgICAgYmxvY2tUcmFja2VyOiB0aGlzLmJsb2NrVHJhY2tlcixcbiAgICAgIGNyZWF0ZUV2ZW50RnJhZ21lbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLmNyZWF0ZUV2ZW50RnJhZ21lbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgdXBkYXRlRXZlbnRGcmFnbWVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudXBkYXRlRXZlbnRGcmFnbWVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBmaW5hbGl6ZUV2ZW50RnJhZ21lbnQ6XG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLmZpbmFsaXplRXZlbnRGcmFnbWVudC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgZ2V0RXZlbnRGcmFnbWVudEJ5SWQ6XG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLmdldEV2ZW50RnJhZ21lbnRCeUlkLmJpbmQoXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0UGFydGljaXBhdGVJbk1ldHJpY3M6ICgpID0+XG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0YXRlLnBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcyxcbiAgICAgIGdldEVJUDE1NTlHYXNGZWVFc3RpbWF0ZXM6XG4gICAgICAgIHRoaXMuZ2FzRmVlQ29udHJvbGxlci5mZXRjaEdhc0ZlZUVzdGltYXRlcy5iaW5kKHRoaXMuZ2FzRmVlQ29udHJvbGxlciksXG4gICAgICBnZXRFeHRlcm5hbFBlbmRpbmdUcmFuc2FjdGlvbnM6XG4gICAgICAgIHRoaXMuZ2V0RXh0ZXJuYWxQZW5kaW5nVHJhbnNhY3Rpb25zLmJpbmQodGhpcyksXG4gICAgICBnZXRBY2NvdW50VHlwZTogdGhpcy5nZXRBY2NvdW50VHlwZS5iaW5kKHRoaXMpLFxuICAgICAgZ2V0RGV2aWNlTW9kZWw6IHRoaXMuZ2V0RGV2aWNlTW9kZWwuYmluZCh0aGlzKSxcbiAgICAgIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzOlxuICAgICAgICB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscy5iaW5kKFxuICAgICAgICAgIHRoaXMuYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMudHhDb250cm9sbGVyLm9uKCduZXdVbmFwcHJvdmVkVHgnLCAoKSA9PiBvcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCkpO1xuXG4gICAgdGhpcy50eENvbnRyb2xsZXIub24oYHR4OnN0YXR1cy11cGRhdGVgLCBhc3luYyAodHhJZCwgc3RhdHVzKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQ09ORklSTUVEIHx8XG4gICAgICAgIHN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgdHhNZXRhID0gdGhpcy50eENvbnRyb2xsZXIudHhTdGF0ZU1hbmFnZXIuZ2V0VHJhbnNhY3Rpb24odHhJZCk7XG4gICAgICAgIGNvbnN0IGZyZXF1ZW50UnBjTGlzdERldGFpbCA9XG4gICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0RnJlcXVlbnRScGNMaXN0RGV0YWlsKCk7XG4gICAgICAgIGxldCBycGNQcmVmcyA9IHt9O1xuICAgICAgICBpZiAodHhNZXRhLmNoYWluSWQpIHtcbiAgICAgICAgICBjb25zdCBycGNTZXR0aW5ncyA9IGZyZXF1ZW50UnBjTGlzdERldGFpbC5maW5kKFxuICAgICAgICAgICAgKHJwYykgPT4gdHhNZXRhLmNoYWluSWQgPT09IHJwYy5jaGFpbklkLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcnBjUHJlZnMgPSBycGNTZXR0aW5ncz8ucnBjUHJlZnMgPz8ge307XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wbGF0Zm9ybS5zaG93VHJhbnNhY3Rpb25Ob3RpZmljYXRpb24odHhNZXRhLCBycGNQcmVmcyk7XG5cbiAgICAgICAgY29uc3QgeyB0eFJlY2VpcHQgfSA9IHR4TWV0YTtcblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGEgdHJhbnNmZXJGcm9tIG1ldGhvZCBnZW5lcmF0ZWQgZnJvbSB3aXRoaW4gdGhlIGFwcCBpdCBtYXkgYmUgYSBjb2xsZWN0aWJsZSB0cmFuc2ZlciB0cmFuc2FjdGlvblxuICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIHdpbGwgd2FudCB0byBjaGVjayBhbmQgdXBkYXRlIG93bmVyc2hpcCBzdGF0dXMgb2YgdGhlIHRyYW5zZmVycmVkIGNvbGxlY3RpYmxlLlxuICAgICAgICBpZiAoXG4gICAgICAgICAgdHhNZXRhLnR5cGUgPT09IFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NICYmXG4gICAgICAgICAgdHhNZXRhLnR4UGFyYW1zICE9PSB1bmRlZmluZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHRvOiBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICBmcm9tOiB1c2VyQWRkcmVzcyxcbiAgICAgICAgICB9ID0gdHhNZXRhLnR4UGFyYW1zO1xuICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdHhNZXRhO1xuICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uRGF0YSA9IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YShkYXRhKTtcbiAgICAgICAgICAvLyBTb21ldGltZXMgdGhlIHRva2VuSWQgdmFsdWUgaXMgcGFyc2VkIGFzIFwiX3ZhbHVlXCIgcGFyYW0uIE5vdCBzZWVpbmcgdGhpcyBvZnRlbiBhbnkgbW9yZSwgYnV0IHN0aWxsIG9jY2FzaW9uYWxseTpcbiAgICAgICAgICAvLyBpLmUuIGNhbGwgYXBwcm92ZSgpIG9uIEJBWUMgY29udHJhY3QgLSBodHRwczovL2V0aGVyc2Nhbi5pby90b2tlbi8weGJjNGNhMGVkYTc2NDdhOGFiN2MyMDYxYzJlMTE4YTE4YTkzNmYxM2Qjd3JpdGVDb250cmFjdCwgYW5kIHRva2VuSWQgc2hvd3MgdXAgYXMgX3ZhbHVlLFxuICAgICAgICAgIC8vIG5vdCBzdXJlIHdoeSBzaW5jZSBpdCBkb2Vzbid0IG1hdGNoIHRoZSBFUkM3MjEgQUJJIHNwZWMgd2UgdXNlIHRvIHBhcnNlIHRoZXNlIHRyYW5zYWN0aW9ucyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1ldGgtYWJpcy9ibG9iL2QwNDc0MzA4YTI4OGY5MjUyNTk3YjdjOTNhM2E4ZGVhYWQxOWUxYjIvc3JjL2FiaXMvYWJpRVJDNzIxLnRzI0w2Mi5cbiAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkRhdGFUb2tlbklkID1cbiAgICAgICAgICAgIGdldFRva2VuSWRQYXJhbSh0cmFuc2FjdGlvbkRhdGEpID8/XG4gICAgICAgICAgICBnZXRUb2tlblZhbHVlUGFyYW0odHJhbnNhY3Rpb25EYXRhKTtcbiAgICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLnN0YXRlO1xuXG4gICAgICAgICAgLy8gY2hlY2sgaWYgaXRzIGEga25vd24gY29sbGVjdGlibGVcbiAgICAgICAgICBjb25zdCBrbm93bkNvbGxlY3RpYmxlID0gYWxsQ29sbGVjdGlibGVzPy5bdXNlckFkZHJlc3NdPy5bXG4gICAgICAgICAgICBjaGFpbklkXG4gICAgICAgICAgXS5maW5kKFxuICAgICAgICAgICAgKHsgYWRkcmVzcywgdG9rZW5JZCB9KSA9PlxuICAgICAgICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFkZHJlc3MsIGNvbnRyYWN0QWRkcmVzcykgJiZcbiAgICAgICAgICAgICAgdG9rZW5JZCA9PT0gdHJhbnNhY3Rpb25EYXRhVG9rZW5JZCxcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gaWYgaXQgaXMgd2UgY2hlY2sgYW5kIHVwZGF0ZSBvd25lcnNoaXAgc3RhdHVzLlxuICAgICAgICAgIGlmIChrbm93bkNvbGxlY3RpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIuY2hlY2tBbmRVcGRhdGVTaW5nbGVDb2xsZWN0aWJsZU93bmVyc2hpcFN0YXR1cyhcbiAgICAgICAgICAgICAga25vd25Db2xsZWN0aWJsZSxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIHsgdXNlckFkZHJlc3MsIGNoYWluSWQgfSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWV0YW1hc2tTdGF0ZSA9IGF3YWl0IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgICAgICBpZiAodHhSZWNlaXB0ICYmIHR4UmVjZWlwdC5zdGF0dXMgPT09ICcweDAnKSB7XG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXZlbnQ6ICdUeCBTdGF0dXMgVXBkYXRlOiBPbi1DaGFpbiBGYWlsdXJlJyxcbiAgICAgICAgICAgICAgY2F0ZWdvcnk6IEVWRU5ULkNBVEVHT1JJRVMuQkFDS0dST1VORCxcbiAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ1RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB0eE1ldGEuc2ltdWxhdGlvbkZhaWxzPy5yZWFzb24sXG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZUb2tlbnM6IG1ldGFtYXNrU3RhdGUudG9rZW5zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkFjY291bnRzOiBPYmplY3Qua2V5cyhtZXRhbWFza1N0YXRlLmFjY291bnRzKS5sZW5ndGgsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRvbW9FdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5vbihORVRXT1JLX0VWRU5UUy5ORVRXT1JLX0RJRF9DSEFOR0UsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHsgdGlja2VyIH0gPSB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQ29uZmlnKCk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc2V0TmF0aXZlQ3VycmVuY3kodGlja2VyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBmYWlsdXJlIHRvIGdldCBjb252ZXJzaW9uIHJhdGUgbW9yZSBncmFjZWZ1bGx5XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5sb29rdXBOZXR3b3JrKCk7XG4gICAgdGhpcy5tZXNzYWdlTWFuYWdlciA9IG5ldyBNZXNzYWdlTWFuYWdlcih7XG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlciA9IG5ldyBQZXJzb25hbE1lc3NhZ2VNYW5hZ2VyKHtcbiAgICAgIG1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG4gICAgdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIgPSBuZXcgRGVjcnlwdE1lc3NhZ2VNYW5hZ2VyKHtcbiAgICAgIG1ldHJpY3NFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgfSk7XG4gICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlciA9IG5ldyBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlcih7XG4gICAgICBtZXRyaWNzRXZlbnQ6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrRXZlbnQuYmluZChcbiAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgIH0pO1xuICAgIHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlciA9IG5ldyBUeXBlZE1lc3NhZ2VNYW5hZ2VyKHtcbiAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgbWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICB9KTtcblxuICAgIHRoaXMuc3dhcHNDb250cm9sbGVyID0gbmV3IFN3YXBzQ29udHJvbGxlcih7XG4gICAgICBnZXRCdWZmZXJlZEdhc0xpbWl0OiB0aGlzLnR4Q29udHJvbGxlci50eEdhc1V0aWwuZ2V0QnVmZmVyZWRHYXNMaW1pdC5iaW5kKFxuICAgICAgICB0aGlzLnR4Q29udHJvbGxlci50eEdhc1V0aWwsXG4gICAgICApLFxuICAgICAgbmV0d29ya0NvbnRyb2xsZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIGdldFByb3ZpZGVyQ29uZmlnOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldFByb3ZpZGVyQ29uZmlnLmJpbmQoXG4gICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgZ2V0VG9rZW5SYXRlc1N0YXRlOiAoKSA9PiB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyLnN0YXRlLFxuICAgICAgZ2V0Q3VycmVudENoYWluSWQ6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0Q3VycmVudENoYWluSWQuYmluZChcbiAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBnZXRFSVAxNTU5R2FzRmVlRXN0aW1hdGVzOlxuICAgICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuZmV0Y2hHYXNGZWVFc3RpbWF0ZXMuYmluZCh0aGlzLmdhc0ZlZUNvbnRyb2xsZXIpLFxuICAgIH0pO1xuICAgIHRoaXMuc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyID0gbmV3IFNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlcihcbiAgICAgIHtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2U6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUuc3Vic2NyaWJlLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0TmV0d29yazogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXROZXR3b3JrU3RhdGUuYmluZChcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXROb25jZUxvY2s6IHRoaXMudHhDb250cm9sbGVyLm5vbmNlVHJhY2tlci5nZXROb25jZUxvY2suYmluZChcbiAgICAgICAgICB0aGlzLnR4Q29udHJvbGxlci5ub25jZVRyYWNrZXIsXG4gICAgICAgICksXG4gICAgICAgIGNvbmZpcm1FeHRlcm5hbFRyYW5zYWN0aW9uOlxuICAgICAgICAgIHRoaXMudHhDb250cm9sbGVyLmNvbmZpcm1FeHRlcm5hbFRyYW5zYWN0aW9uLmJpbmQodGhpcy50eENvbnRyb2xsZXIpLFxuICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgICAgdHJhY2tNZXRhTWV0cmljc0V2ZW50OiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBzdXBwb3J0ZWRDaGFpbklkczogW0NIQUlOX0lEUy5NQUlOTkVULCBDSEFJTl9JRFMuR09FUkxJXSxcbiAgICAgIH0sXG4gICAgICBpbml0U3RhdGUuU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICk7XG5cbiAgICAvLyBlbnN1cmUgYWNjb3VudFRyYWNrZXIgdXBkYXRlcyBiYWxhbmNlcyBhZnRlciBuZXR3b3JrIGNoYW5nZVxuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIub24oTkVUV09SS19FVkVOVFMuTkVUV09SS19ESURfQ0hBTkdFLCAoKSA9PiB7XG4gICAgICB0aGlzLmFjY291bnRUcmFja2VyLl91cGRhdGVBY2NvdW50cygpO1xuICAgIH0pO1xuXG4gICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgYW5kIG1lc3NhZ2VzIHdoZW4gdGhlIG5ldHdvcmsgd2lsbCBjaGFuZ2VcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLm9uKE5FVFdPUktfRVZFTlRTLk5FVFdPUktfV0lMTF9DSEFOR0UsICgpID0+IHtcbiAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZFR4cygpO1xuICAgICAgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZCgpO1xuICAgICAgdGhpcy5tZXNzYWdlTWFuYWdlci5jbGVhclVuYXBwcm92ZWQoKTtcbiAgICB9KTtcblxuICAgIC8vIGVuc3VyZSBpc0NsaWVudE9wZW5BbmRVbmxvY2tlZCBpcyB1cGRhdGVkIHdoZW4gbWVtU3RhdGUgdXBkYXRlc1xuICAgIHRoaXMub24oJ3VwZGF0ZScsIChtZW1TdGF0ZSkgPT4gdGhpcy5fb25TdGF0ZVVwZGF0ZShtZW1TdGF0ZSkpO1xuXG4gICAgdGhpcy5zdG9yZS51cGRhdGVTdHJ1Y3R1cmUoe1xuICAgICAgQXBwU3RhdGVDb250cm9sbGVyOiB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIFRyYW5zYWN0aW9uQ29udHJvbGxlcjogdGhpcy50eENvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBLZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjogdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBNZXRhTWV0cmljc0NvbnRyb2xsZXI6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0b3JlLFxuICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgIEN1cnJlbmN5Q29udHJvbGxlcjogdGhpcy5jdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICAgICAgTmV0d29ya0NvbnRyb2xsZXI6IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXI6IHRoaXMuY2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLnN0b3JlLFxuICAgICAgQWxlcnRDb250cm9sbGVyOiB0aGlzLmFsZXJ0Q29udHJvbGxlci5zdG9yZSxcbiAgICAgIE9uYm9hcmRpbmdDb250cm9sbGVyOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLFxuICAgICAgSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyOiB0aGlzLmluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5zdG9yZSxcbiAgICAgIFBlcm1pc3Npb25Db250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXI6IHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyOiB0aGlzLnN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIsXG4gICAgICBCYWNrdXBDb250cm9sbGVyOiB0aGlzLmJhY2t1cENvbnRyb2xsZXIsXG4gICAgICBBbm5vdW5jZW1lbnRDb250cm9sbGVyOiB0aGlzLmFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gICAgICBHYXNGZWVDb250cm9sbGVyOiB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICBUb2tlbkxpc3RDb250cm9sbGVyOiB0aGlzLnRva2VuTGlzdENvbnRyb2xsZXIsXG4gICAgICBUb2tlbnNDb250cm9sbGVyOiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIsXG4gICAgICBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXI6IHRoaXMuc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgQ29sbGVjdGlibGVzQ29udHJvbGxlcjogdGhpcy5jb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1TdG9yZSA9IG5ldyBDb21wb3NhYmxlT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBBcHBTdGF0ZUNvbnRyb2xsZXI6IHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBOZXR3b3JrQ29udHJvbGxlcjogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgQWNjb3VudFRyYWNrZXI6IHRoaXMuYWNjb3VudFRyYWNrZXIuc3RvcmUsXG4gICAgICAgIFR4Q29udHJvbGxlcjogdGhpcy50eENvbnRyb2xsZXIubWVtU3RvcmUsXG4gICAgICAgIENhY2hlZEJhbGFuY2VzQ29udHJvbGxlcjogdGhpcy5jYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIFRva2VuUmF0ZXNDb250cm9sbGVyOiB0aGlzLnRva2VuUmF0ZXNDb250cm9sbGVyLFxuICAgICAgICBNZXNzYWdlTWFuYWdlcjogdGhpcy5tZXNzYWdlTWFuYWdlci5tZW1TdG9yZSxcbiAgICAgICAgUGVyc29uYWxNZXNzYWdlTWFuYWdlcjogdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBEZWNyeXB0TWVzc2FnZU1hbmFnZXI6IHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBFbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlcjogdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5tZW1TdG9yZSxcbiAgICAgICAgVHlwZXNNZXNzYWdlTWFuYWdlcjogdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyLm1lbVN0b3JlLFxuICAgICAgICBLZXlyaW5nQ29udHJvbGxlcjogdGhpcy5rZXlyaW5nQ29udHJvbGxlci5tZW1TdG9yZSxcbiAgICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgTWV0YU1ldHJpY3NDb250cm9sbGVyOiB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgQWRkcmVzc0Jvb2tDb250cm9sbGVyOiB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgICAgQ3VycmVuY3lDb250cm9sbGVyOiB0aGlzLmN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICAgIEFsZXJ0Q29udHJvbGxlcjogdGhpcy5hbGVydENvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIE9uYm9hcmRpbmdDb250cm9sbGVyOiB0aGlzLm9uYm9hcmRpbmdDb250cm9sbGVyLnN0b3JlLFxuICAgICAgICBJbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXI6XG4gICAgICAgICAgdGhpcy5pbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIFBlcm1pc3Npb25Db250cm9sbGVyOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgICBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcjogdGhpcy5wZXJtaXNzaW9uTG9nQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgICBCYWNrdXBDb250cm9sbGVyOiB0aGlzLmJhY2t1cENvbnRyb2xsZXIsXG4gICAgICAgIFN3YXBzQ29udHJvbGxlcjogdGhpcy5zd2Fwc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgIEVuc0NvbnRyb2xsZXI6IHRoaXMuZW5zQ29udHJvbGxlci5zdG9yZSxcbiAgICAgICAgQXBwcm92YWxDb250cm9sbGVyOiB0aGlzLmFwcHJvdmFsQ29udHJvbGxlcixcbiAgICAgICAgQW5ub3VuY2VtZW50Q29udHJvbGxlcjogdGhpcy5hbm5vdW5jZW1lbnRDb250cm9sbGVyLFxuICAgICAgICBHYXNGZWVDb250cm9sbGVyOiB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIsXG4gICAgICAgIFRva2VuTGlzdENvbnRyb2xsZXI6IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlcixcbiAgICAgICAgVG9rZW5zQ29udHJvbGxlcjogdGhpcy50b2tlbnNDb250cm9sbGVyLFxuICAgICAgICBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXI6IHRoaXMuc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICBDb2xsZWN0aWJsZXNDb250cm9sbGVyOiB0aGlzLmNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICB9LFxuICAgICAgY29udHJvbGxlck1lc3NlbmdlcjogdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLFxuICAgIH0pO1xuICAgIHRoaXMubWVtU3RvcmUuc3Vic2NyaWJlKHRoaXMuc2VuZFVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIGNvbnN0IHBhc3N3b3JkID0gcHJvY2Vzcy5lbnYuQ09ORj8uUEFTU1dPUkQ7XG4gICAgaWYgKFxuICAgICAgcGFzc3dvcmQgJiZcbiAgICAgICF0aGlzLmlzVW5sb2NrZWQoKSAmJlxuICAgICAgdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpLmNvbXBsZXRlZE9uYm9hcmRpbmdcbiAgICApIHtcbiAgICAgIHRoaXMuc3VibWl0UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIH1cblxuICAgIC8vIExhemlseSB1cGRhdGUgdGhlIHN0b3JlIHdpdGggdGhlIGN1cnJlbnQgZXh0ZW5zaW9uIGVudmlyb25tZW50XG4gICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5nZXRQbGF0Zm9ybUluZm8oKS50aGVuKCh7IG9zIH0pID0+IHtcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLnNldEJyb3dzZXJFbnZpcm9ubWVudChcbiAgICAgICAgb3MsXG4gICAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHByZXNlbnRseSBvbmx5IHN1cHBvcnRlZCBieSBGaXJlZm94XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUuZ2V0QnJvd3NlckluZm8gPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gJ2Nocm9tZSdcbiAgICAgICAgICA6ICdmaXJlZm94JyxcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNldHVwQ29udHJvbGxlckV2ZW50U3Vic2NyaXB0aW9ucygpO1xuXG4gICAgLy8gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgdGhlc2UgbGVnYWN5IHN0cmVhbXMsIHNlZSBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1leHRlbnNpb24vaXNzdWVzLzE1NDkxXG4gICAgLy8gVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAgdGhpcy5wdWJsaWNDb25maWdTdG9yZSA9IHRoaXMuY3JlYXRlUHVibGljQ29uZmlnU3RvcmUoKTtcblxuICAgIC8vIE11bHRpcGxlIE1ldGFNYXNrIGluc3RhbmNlcyBsYXVuY2hlZCB3YXJuaW5nXG4gICAgdGhpcy5leHRlbnNpb24ucnVudGltZS5vbk1lc3NhZ2VFeHRlcm5hbC5hZGRMaXN0ZW5lcihvbk1lc3NhZ2VSZWNlaXZlZCk7XG4gICAgLy8gRmlyZSBhIHBpbmcgbWVzc2FnZSB0byBjaGVjayBpZiBvdGhlciBleHRlbnNpb25zIGFyZSBydW5uaW5nXG4gICAgY2hlY2tGb3JNdWx0aXBsZVZlcnNpb25zUnVubmluZygpO1xuICB9XG5cblxuICAvKipcbiAgICogU2V0cyB1cCBCYXNlQ29udHJvbGxlciBWMiBldmVudCBzdWJzY3JpcHRpb25zLiBDdXJyZW50bHksIHRoaXMgaW5jbHVkZXNcbiAgICogdGhlIHN1YnNjcmlwdGlvbnMgbmVjZXNzYXJ5IHRvIG5vdGlmeSBwZXJtaXNzaW9uIHN1YmplY3RzIG9mIGFjY291bnRcbiAgICogY2hhbmdlcy5cbiAgICpcbiAgICogU29tZSBvZiB0aGUgc3Vic2NyaXB0aW9ucyBpbiB0aGlzIG1ldGhvZCBhcmUgQ29udHJvbGxlck1lc3NlbmdlciBzZWxlY3RvclxuICAgKiBldmVudCBzdWJzY3JpcHRpb25zLiBTZWUgdGhlIHJlbGV2YW50IEBtZXRhbWFzay9jb250cm9sbGVycyBkb2N1bWVudGF0aW9uXG4gICAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgYWNjb3VudC1yZWxhdGVkIG5vdGlmaWNhdGlvbnMgZW1pdHRlZCB3aGVuIHRoZSBleHRlbnNpb25cbiAgICogYmVjb21lcyB1bmxvY2tlZCBhcmUgaGFuZGxlZCBpbiBNZXRhTWFza0NvbnRyb2xsZXIuX29uVW5sb2NrLlxuICAgKi9cbiAgc2V0dXBDb250cm9sbGVyRXZlbnRTdWJzY3JpcHRpb25zKCkge1xuICAgIGNvbnN0IGhhbmRsZUFjY291bnRzQ2hhbmdlID0gYXN5bmMgKG9yaWdpbiwgbmV3QWNjb3VudHMpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSkge1xuICAgICAgICB0aGlzLm5vdGlmeUNvbm5lY3Rpb25zKG9yaWdpbiwge1xuICAgICAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLmFjY291bnRzQ2hhbmdlZCxcbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGBldGhfYWNjb3VudHNgLFxuICAgICAgICAgIC8vIG5hbWVseSBhbiBhcnJheSBvZiB0aGUgY3VycmVudCAvIG1vc3QgcmVjZW50bHkgc2VsZWN0ZWQgRXRoZXJldW1cbiAgICAgICAgICAvLyBhY2NvdW50LlxuICAgICAgICAgIHBhcmFtczpcbiAgICAgICAgICAgIG5ld0FjY291bnRzLmxlbmd0aCA8IDJcbiAgICAgICAgICAgICAgPyAvLyBJZiB0aGUgbGVuZ3RoIGlzIDEgb3IgMCwgdGhlIGFjY291bnRzIGFyZSBzb3J0ZWQgYnkgZGVmaW5pdGlvbi5cbiAgICAgICAgICAgICAgICBuZXdBY2NvdW50c1xuICAgICAgICAgICAgICA6IC8vIElmIHRoZSBsZW5ndGggaXMgMiBvciBncmVhdGVyLCB3ZSBoYXZlIHRvIGV4ZWN1dGVcbiAgICAgICAgICAgICAgICAvLyBgZXRoX2FjY291bnRzYCB2aSB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKG9yaWdpbiksXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlcm1pc3Npb25Mb2dDb250cm9sbGVyLnVwZGF0ZUFjY291bnRzSGlzdG9yeShvcmlnaW4sIG5ld0FjY291bnRzKTtcbiAgICB9O1xuXG4gICAgLy8gVGhpcyBoYW5kbGVzIGFjY291bnQgY2hhbmdlcyB3aGVuZXZlciB0aGUgc2VsZWN0ZWQgYWRkcmVzcyBjaGFuZ2VzLlxuICAgIGxldCBsYXN0U2VsZWN0ZWRBZGRyZXNzO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLnN1YnNjcmliZShhc3luYyAoeyBzZWxlY3RlZEFkZHJlc3MgfSkgPT4ge1xuICAgICAgaWYgKHNlbGVjdGVkQWRkcmVzcyAmJiBzZWxlY3RlZEFkZHJlc3MgIT09IGxhc3RTZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgbGFzdFNlbGVjdGVkQWRkcmVzcyA9IHNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgY29uc3QgcGVybWl0dGVkQWNjb3VudHNNYXAgPSBnZXRQZXJtaXR0ZWRBY2NvdW50c0J5T3JpZ2luKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuc3RhdGUsXG4gICAgICAgICk7XG5cbiAgICAgICAgZm9yIChjb25zdCBbb3JpZ2luLCBhY2NvdW50c10gb2YgcGVybWl0dGVkQWNjb3VudHNNYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgaWYgKGFjY291bnRzLmluY2x1ZGVzKHNlbGVjdGVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgIGhhbmRsZUFjY291bnRzQ2hhbmdlKG9yaWdpbiwgYWNjb3VudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBoYW5kbGVzIGFjY291bnQgY2hhbmdlcyBldmVyeSB0aW1lIHJlbGV2YW50IHBlcm1pc3Npb24gc3RhdGVcbiAgICAvLyBjaGFuZ2VzLCBmb3IgYW55IHJlYXNvbi5cbiAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIuc3Vic2NyaWJlKFxuICAgICAgYCR7dGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5uYW1lfTpzdGF0ZUNoYW5nZWAsXG4gICAgICBhc3luYyAoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRBY2NvdW50cyA9IGdldENoYW5nZWRBY2NvdW50cyhjdXJyZW50VmFsdWUsIHByZXZpb3VzVmFsdWUpO1xuXG4gICAgICAgIGZvciAoY29uc3QgW29yaWdpbiwgYWNjb3VudHNdIG9mIGNoYW5nZWRBY2NvdW50cy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICBoYW5kbGVBY2NvdW50c0NoYW5nZShvcmlnaW4sIGFjY291bnRzKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGdldFBlcm1pdHRlZEFjY291bnRzQnlPcmlnaW4sXG4gICAgKTtcblxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGhlbHBlcjogaW5pdGlhbGl6ZSBhIHByb3ZpZGVyLlxuICAgKi9cbiAgaW5pdGlhbGl6ZVByb3ZpZGVyKCkge1xuICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKTtcbiAgICBjb25zdCBwcm92aWRlck9wdHMgPSB7XG4gICAgICBzdGF0aWM6IHtcbiAgICAgICAgZXRoX3N5bmNpbmc6IGZhbHNlLFxuICAgICAgICB3ZWIzX2NsaWVudFZlcnNpb246IGBNZXRhTWFzay92JHt2ZXJzaW9ufWAsXG4gICAgICB9LFxuICAgICAgdmVyc2lvbixcbiAgICAgIC8vIGFjY291bnQgbWdtdFxuICAgICAgZ2V0QWNjb3VudHM6IGFzeW5jIChcbiAgICAgICAgeyBvcmlnaW4gfSxcbiAgICAgICAgeyBzdXBwcmVzc1VuYXV0aG9yaXplZEVycm9yID0gdHJ1ZSB9ID0ge30sXG4gICAgICApID0+IHtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gT1JJR0lOX01FVEFNQVNLKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID1cbiAgICAgICAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldFNlbGVjdGVkQWRkcmVzcygpO1xuICAgICAgICAgIHJldHVybiBzZWxlY3RlZEFkZHJlc3MgPyBbc2VsZWN0ZWRBZGRyZXNzXSA6IFtdO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNVbmxvY2tlZCgpKSB7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0UGVybWl0dGVkQWNjb3VudHMob3JpZ2luLCB7XG4gICAgICAgICAgICBzdXBwcmVzc1VuYXV0aG9yaXplZEVycm9yLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTsgLy8gY2hhbmdpbmcgdGhpcyBpcyBhIGJyZWFraW5nIGNoYW5nZVxuICAgICAgfSxcbiAgICAgIC8vIHR4IHNpZ25pbmdcbiAgICAgIHByb2Nlc3NUcmFuc2FjdGlvbjogdGhpcy5uZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIC8vIG1zZyBzaWduaW5nXG4gICAgICBwcm9jZXNzRXRoU2lnbk1lc3NhZ2U6IHRoaXMubmV3VW5zaWduZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlOiB0aGlzLm5ld1Vuc2lnbmVkVHlwZWRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBwcm9jZXNzVHlwZWRNZXNzYWdlVjM6IHRoaXMubmV3VW5zaWduZWRUeXBlZE1lc3NhZ2UuYmluZCh0aGlzKSxcbiAgICAgIHByb2Nlc3NUeXBlZE1lc3NhZ2VWNDogdGhpcy5uZXdVbnNpZ25lZFR5cGVkTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZTogdGhpcy5uZXdVbnNpZ25lZFBlcnNvbmFsTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlOiB0aGlzLm5ld1JlcXVlc3REZWNyeXB0TWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXk6IHRoaXMubmV3UmVxdWVzdEVuY3J5cHRpb25QdWJsaWNLZXkuYmluZCh0aGlzKSxcbiAgICAgIGdldFBlbmRpbmdOb25jZTogdGhpcy5nZXRQZW5kaW5nTm9uY2UuYmluZCh0aGlzKSxcbiAgICAgIGdldFBlbmRpbmdUcmFuc2FjdGlvbkJ5SGFzaDogKGhhc2gpID0+XG4gICAgICAgIHRoaXMudHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgc2VhcmNoQ3JpdGVyaWE6IHtcbiAgICAgICAgICAgIGhhc2gsXG4gICAgICAgICAgICBzdGF0dXM6IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVswXSxcbiAgICB9O1xuICAgIGNvbnN0IHByb3ZpZGVyUHJveHkgPVxuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5pbml0aWFsaXplUHJvdmlkZXIocHJvdmlkZXJPcHRzKTtcbiAgICByZXR1cm4gcHJvdmlkZXJQcm94eTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOkxlZ2FjeVByb3ZpZGVyOiBEZWxldGVcbiAgICogQ29uc3RydWN0b3IgaGVscGVyOiBpbml0aWFsaXplIGEgcHVibGljIGNvbmZpZyBzdG9yZS5cbiAgICogVGhpcyBzdG9yZSBpcyB1c2VkIHRvIG1ha2Ugc29tZSBjb25maWcgaW5mbyBhdmFpbGFibGUgdG8gRGFwcHMgc3luY2hyb25vdXNseS5cbiAgICovXG4gIGNyZWF0ZVB1YmxpY0NvbmZpZ1N0b3JlKCkge1xuICAgIC8vIHN1YnNldCBvZiBzdGF0ZSBmb3IgbWV0YW1hc2sgaW5wYWdlIHByb3ZpZGVyXG4gICAgY29uc3QgcHVibGljQ29uZmlnU3RvcmUgPSBuZXcgT2JzZXJ2YWJsZVN0b3JlKCk7XG4gICAgY29uc3QgeyBuZXR3b3JrQ29udHJvbGxlciB9ID0gdGhpcztcblxuICAgIC8vIHNldHVwIG1lbVN0b3JlIHN1YnNjcmlwdGlvbiBob29rc1xuICAgIHRoaXMub24oJ3VwZGF0ZScsIHVwZGF0ZVB1YmxpY0NvbmZpZ1N0b3JlKTtcbiAgICB1cGRhdGVQdWJsaWNDb25maWdTdG9yZSh0aGlzLmdldFN0YXRlKCkpO1xuXG4gICAgZnVuY3Rpb24gdXBkYXRlUHVibGljQ29uZmlnU3RvcmUobWVtU3RhdGUpIHtcbiAgICAgIGNvbnN0IGNoYWluSWQgPSBuZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZCgpO1xuICAgICAgaWYgKG1lbVN0YXRlLm5ldHdvcmsgIT09ICdsb2FkaW5nJykge1xuICAgICAgICBwdWJsaWNDb25maWdTdG9yZS5wdXRTdGF0ZShzZWxlY3RQdWJsaWNTdGF0ZShjaGFpbklkLCBtZW1TdGF0ZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdFB1YmxpY1N0YXRlKGNoYWluSWQsIHsgaXNVbmxvY2tlZCwgbmV0d29yayB9KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpc1VubG9ja2VkLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICBuZXR3b3JrVmVyc2lvbjogbmV0d29yayxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB1YmxpY0NvbmZpZ1N0b3JlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgcmVsZXZhbnQgc3RhdGUgZm9yIHRoZSBwcm92aWRlciBvZiBhbiBleHRlcm5hbCBvcmlnaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgb3JpZ2luIHRvIGdldCB0aGUgcHJvdmlkZXIgc3RhdGUgZm9yLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7XG4gICAqICBpc1VubG9ja2VkOiBib29sZWFuLFxuICAgKiAgbmV0d29ya1ZlcnNpb246IHN0cmluZyxcbiAgICogIGNoYWluSWQ6IHN0cmluZyxcbiAgICogIGFjY291bnRzOiBzdHJpbmdbXSxcbiAgICogfT59IEFuIG9iamVjdCB3aXRoIHJlbGV2YW50IHN0YXRlIHByb3BlcnRpZXMuXG4gICAqL1xuICBhc3luYyBnZXRQcm92aWRlclN0YXRlKG9yaWdpbikge1xuICAgIHJldHVybiB7XG4gICAgICBpc1VubG9ja2VkOiB0aGlzLmlzVW5sb2NrZWQoKSxcbiAgICAgIC4uLnRoaXMuZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUoKSxcbiAgICAgIGFjY291bnRzOiBhd2FpdCB0aGlzLmdldFBlcm1pdHRlZEFjY291bnRzKG9yaWdpbiksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIG5ldHdvcmsgc3RhdGUgcmVsZXZhbnQgZm9yIGV4dGVybmFsIHByb3ZpZGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IFttZW1TdGF0ZV0gLSBUaGUgTWV0YU1hc2sgbWVtU3RhdGUuIElmIG5vdCBwcm92aWRlZCxcbiAgICogdGhpcyBmdW5jdGlvbiB3aWxsIHJldHJpZXZlIHRoZSBtb3N0IHJlY2VudCBzdGF0ZS5cbiAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggcmVsZXZhbnQgbmV0d29yayBzdGF0ZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgZ2V0UHJvdmlkZXJOZXR3b3JrU3RhdGUobWVtU3RhdGUpIHtcbiAgICBjb25zdCB7IG5ldHdvcmsgfSA9IG1lbVN0YXRlIHx8IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2hhaW5JZDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50Q2hhaW5JZCgpLFxuICAgICAgbmV0d29ya1ZlcnNpb246IG5ldHdvcmssXG4gICAgfTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gRVhQT1NFRCBUTyBUSEUgVUkgU1VCU1lTVEVNXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogVGhlIG1ldGFtYXNrLXN0YXRlIG9mIHRoZSB2YXJpb3VzIGNvbnRyb2xsZXJzLCBtYWRlIGF2YWlsYWJsZSB0byB0aGUgVUlcbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gc3RhdHVzXG4gICAqL1xuICBnZXRTdGF0ZSgpIHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB0aGlzLmtleXJpbmdDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IEJvb2xlYW4odmF1bHQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzSW5pdGlhbGl6ZWQsXG4gICAgICAuLi50aGlzLm1lbVN0b3JlLmdldEZsYXRTdGF0ZSgpLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBPYmplY3QgY29udGFpbmluZyBBUEkgQ2FsbGJhY2sgRnVuY3Rpb25zLlxuICAgKiBUaGVzZSBmdW5jdGlvbnMgYXJlIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBVSS5cbiAgICogVGhlIEFQSSBvYmplY3QgY2FuIGJlIHRyYW5zbWl0dGVkIG92ZXIgYSBzdHJlYW0gdmlhIEpTT04tUlBDLlxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBBUEkgZnVuY3Rpb25zLlxuICAgKi9cbiAgZ2V0QXBpKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFkZHJlc3NCb29rQ29udHJvbGxlcixcbiAgICAgIGFsZXJ0Q29udHJvbGxlcixcbiAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICBjb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIsXG4gICAgICBjdXJyZW5jeVJhdGVDb250cm9sbGVyLFxuICAgICAgZGV0ZWN0VG9rZW5zQ29udHJvbGxlcixcbiAgICAgIGVuc0NvbnRyb2xsZXIsXG4gICAgICBnYXNGZWVDb250cm9sbGVyLFxuICAgICAga2V5cmluZ0NvbnRyb2xsZXIsXG4gICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICBuZXR3b3JrQ29udHJvbGxlcixcbiAgICAgIGFubm91bmNlbWVudENvbnRyb2xsZXIsXG4gICAgICBvbmJvYXJkaW5nQ29udHJvbGxlcixcbiAgICAgIHBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgcXJIYXJkd2FyZUtleXJpbmcsXG4gICAgICBzd2Fwc0NvbnRyb2xsZXIsXG4gICAgICB0b2tlbnNDb250cm9sbGVyLFxuICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgdHhDb250cm9sbGVyLFxuICAgICAgYXNzZXRzQ29udHJhY3RDb250cm9sbGVyLFxuICAgICAgYmFja3VwQ29udHJvbGxlcixcbiAgICB9ID0gdGhpcztcblxuICAgIHJldHVybiB7XG4gICAgICAvLyBldGNcbiAgICAgIGdldFN0YXRlOiB0aGlzLmdldFN0YXRlLmJpbmQodGhpcyksXG4gICAgICBzZXRDdXJyZW50Q3VycmVuY3k6IGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIuc2V0Q3VycmVudEN1cnJlbmN5LmJpbmQoXG4gICAgICAgIGN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0VXNlQmxvY2tpZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZUJsb2NraWUuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldFVzZU5vbmNlRmllbGQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRVc2VOb25jZUZpZWxkLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VQaGlzaERldGVjdDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZVBoaXNoRGV0ZWN0LmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VUb2tlbkRldGVjdGlvbjogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZVRva2VuRGV0ZWN0aW9uLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRVc2VDb2xsZWN0aWJsZURldGVjdGlvbjpcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uLmJpbmQoXG4gICAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0T3BlblNlYUVuYWJsZWQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRPcGVuU2VhRW5hYmxlZC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0SXBmc0dhdGV3YXk6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRJcGZzR2F0ZXdheS5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOlxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIuc2V0UGFydGljaXBhdGVJbk1ldGFNZXRyaWNzLmJpbmQoXG4gICAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0Q3VycmVudExvY2FsZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEN1cnJlbnRMb2NhbGUuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIG1hcmtQYXNzd29yZEZvcmdvdHRlbjogdGhpcy5tYXJrUGFzc3dvcmRGb3Jnb3R0ZW4uYmluZCh0aGlzKSxcbiAgICAgIHVuTWFya1Bhc3N3b3JkRm9yZ290dGVuOiB0aGlzLnVuTWFya1Bhc3N3b3JkRm9yZ290dGVuLmJpbmQodGhpcyksXG4gICAgICBnZXRSZXF1ZXN0QWNjb3VudFRhYklkczogdGhpcy5nZXRSZXF1ZXN0QWNjb3VudFRhYklkcyxcbiAgICAgIGdldE9wZW5NZXRhbWFza1RhYnNJZHM6IHRoaXMuZ2V0T3Blbk1ldGFtYXNrVGFic0lkcyxcbiAgICAgIG1hcmtOb3RpZmljYXRpb25Qb3B1cEFzQXV0b21hdGljYWxseUNsb3NlZDogKCkgPT5cbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25NYW5hZ2VyLm1hcmtBc0F1dG9tYXRpY2FsbHlDbG9zZWQoKSxcblxuICAgICAgLy8gcHJpbWFyeSBIRCBrZXlyaW5nIG1hbmFnZW1lbnRcbiAgICAgIGFkZE5ld0FjY291bnQ6IHRoaXMuYWRkTmV3QWNjb3VudC5iaW5kKHRoaXMpLFxuICAgICAgdmVyaWZ5U2VlZFBocmFzZTogdGhpcy52ZXJpZnlTZWVkUGhyYXNlLmJpbmQodGhpcyksXG4gICAgICByZXNldEFjY291bnQ6IHRoaXMucmVzZXRBY2NvdW50LmJpbmQodGhpcyksXG4gICAgICByZW1vdmVBY2NvdW50OiB0aGlzLnJlbW92ZUFjY291bnQuYmluZCh0aGlzKSxcbiAgICAgIGltcG9ydEFjY291bnRXaXRoU3RyYXRlZ3k6IHRoaXMuaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBoYXJkd2FyZSB3YWxsZXRzXG4gICAgICBjb25uZWN0SGFyZHdhcmU6IHRoaXMuY29ubmVjdEhhcmR3YXJlLmJpbmQodGhpcyksXG4gICAgICBmb3JnZXREZXZpY2U6IHRoaXMuZm9yZ2V0RGV2aWNlLmJpbmQodGhpcyksXG4gICAgICBjaGVja0hhcmR3YXJlU3RhdHVzOiB0aGlzLmNoZWNrSGFyZHdhcmVTdGF0dXMuYmluZCh0aGlzKSxcbiAgICAgIHVubG9ja0hhcmR3YXJlV2FsbGV0QWNjb3VudDogdGhpcy51bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQuYmluZCh0aGlzKSxcbiAgICAgIHNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2U6XG4gICAgICAgIHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZS5iaW5kKHRoaXMpLFxuICAgICAgYXR0ZW1wdExlZGdlclRyYW5zcG9ydENyZWF0aW9uOlxuICAgICAgICB0aGlzLmF0dGVtcHRMZWRnZXJUcmFuc3BvcnRDcmVhdGlvbi5iaW5kKHRoaXMpLFxuICAgICAgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZTpcbiAgICAgICAgdGhpcy5lc3RhYmxpc2hMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIHFyIGhhcmR3YXJlIGRldmljZXNcbiAgICAgIHN1Ym1pdFFSSGFyZHdhcmVDcnlwdG9IREtleTpcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0Q3J5cHRvSERLZXkuYmluZChxckhhcmR3YXJlS2V5cmluZyksXG4gICAgICBzdWJtaXRRUkhhcmR3YXJlQ3J5cHRvQWNjb3VudDpcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0Q3J5cHRvQWNjb3VudC5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcbiAgICAgIGNhbmNlbFN5bmNRUkhhcmR3YXJlOlxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTeW5jLmJpbmQocXJIYXJkd2FyZUtleXJpbmcpLFxuICAgICAgc3VibWl0UVJIYXJkd2FyZVNpZ25hdHVyZTpcbiAgICAgICAgcXJIYXJkd2FyZUtleXJpbmcuc3VibWl0U2lnbmF0dXJlLmJpbmQocXJIYXJkd2FyZUtleXJpbmcpLFxuICAgICAgY2FuY2VsUVJIYXJkd2FyZVNpZ25SZXF1ZXN0OlxuICAgICAgICBxckhhcmR3YXJlS2V5cmluZy5jYW5jZWxTaWduUmVxdWVzdC5iaW5kKHFySGFyZHdhcmVLZXlyaW5nKSxcblxuICAgICAgLy8gbW9iaWxlXG4gICAgICBmZXRjaEluZm9Ub1N5bmM6IHRoaXMuZmV0Y2hJbmZvVG9TeW5jLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIHZhdWx0IG1hbmFnZW1lbnRcbiAgICAgIHN1Ym1pdFBhc3N3b3JkOiB0aGlzLnN1Ym1pdFBhc3N3b3JkLmJpbmQodGhpcyksXG4gICAgICB2ZXJpZnlQYXNzd29yZDogdGhpcy52ZXJpZnlQYXNzd29yZC5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBuZXR3b3JrIG1hbmFnZW1lbnRcbiAgICAgIHNldFByb3ZpZGVyVHlwZTpcbiAgICAgICAgbmV0d29ya0NvbnRyb2xsZXIuc2V0UHJvdmlkZXJUeXBlLmJpbmQobmV0d29ya0NvbnRyb2xsZXIpLFxuICAgICAgcm9sbGJhY2tUb1ByZXZpb3VzUHJvdmlkZXI6XG4gICAgICAgIG5ldHdvcmtDb250cm9sbGVyLnJvbGxiYWNrVG9QcmV2aW91c1Byb3ZpZGVyLmJpbmQobmV0d29ya0NvbnRyb2xsZXIpLFxuICAgICAgc2V0Q3VzdG9tUnBjOiB0aGlzLnNldEN1c3RvbVJwYy5iaW5kKHRoaXMpLFxuICAgICAgdXBkYXRlQW5kU2V0Q3VzdG9tUnBjOiB0aGlzLnVwZGF0ZUFuZFNldEN1c3RvbVJwYy5iaW5kKHRoaXMpLFxuICAgICAgZGVsQ3VzdG9tUnBjOiB0aGlzLmRlbEN1c3RvbVJwYy5iaW5kKHRoaXMpLFxuICAgICAgYWRkQ3VzdG9tTmV0d29yazogdGhpcy5hZGRDdXN0b21OZXR3b3JrLmJpbmQodGhpcyksXG4gICAgICByZXF1ZXN0QWRkTmV0d29ya0FwcHJvdmFsOiB0aGlzLnJlcXVlc3RBZGROZXR3b3JrQXBwcm92YWwuYmluZCh0aGlzKSxcbiAgICAgIC8vIFByZWZlcmVuY2VzQ29udHJvbGxlclxuICAgICAgc2V0U2VsZWN0ZWRBZGRyZXNzOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBhZGRUb2tlbjogdG9rZW5zQ29udHJvbGxlci5hZGRUb2tlbi5iaW5kKHRva2Vuc0NvbnRyb2xsZXIpLFxuICAgICAgcmVqZWN0V2F0Y2hBc3NldDpcbiAgICAgICAgdG9rZW5zQ29udHJvbGxlci5yZWplY3RXYXRjaEFzc2V0LmJpbmQodG9rZW5zQ29udHJvbGxlciksXG4gICAgICBhY2NlcHRXYXRjaEFzc2V0OlxuICAgICAgICB0b2tlbnNDb250cm9sbGVyLmFjY2VwdFdhdGNoQXNzZXQuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRva2VuVHlwZTogdG9rZW5zQ29udHJvbGxlci51cGRhdGVUb2tlblR5cGUuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIHNldEFjY291bnRMYWJlbDogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFjY291bnRMYWJlbC5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0RmVhdHVyZUZsYWc6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRGZWF0dXJlRmxhZy5iaW5kKFxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc2V0UHJlZmVyZW5jZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFByZWZlcmVuY2UuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgYWRkS25vd25NZXRob2REYXRhOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkS25vd25NZXRob2REYXRhLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXREaXNtaXNzU2VlZEJhY2tVcFJlbWluZGVyOlxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0RGlzbWlzc1NlZWRCYWNrVXBSZW1pbmRlci5iaW5kKFxuICAgICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHNldEFkdmFuY2VkR2FzRmVlOiBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWR2YW5jZWRHYXNGZWUuYmluZChcbiAgICAgICAgcHJlZmVyZW5jZXNDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHNldEVJUDE1NTlWMkVuYWJsZWQ6IHByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRFSVAxNTU5VjJFbmFibGVkLmJpbmQoXG4gICAgICAgIHByZWZlcmVuY2VzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBzZXRUaGVtZTogcHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFRoZW1lLmJpbmQocHJlZmVyZW5jZXNDb250cm9sbGVyKSxcbiAgICAgIHNldEltcHJvdmVkVG9rZW5BbGxvd2FuY2VFbmFibGVkOlxuICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0SW1wcm92ZWRUb2tlbkFsbG93YW5jZUVuYWJsZWQuYmluZChcbiAgICAgICAgICBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAvLyBBc3NldHNDb250cmFjdENvbnRyb2xsZXJcbiAgICAgIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzOiB0aGlzLmdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIENvbGxlY3RpYmxlc0NvbnRyb2xsZXJcbiAgICAgIGFkZENvbGxlY3RpYmxlOiBjb2xsZWN0aWJsZXNDb250cm9sbGVyLmFkZENvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICBhZGRDb2xsZWN0aWJsZVZlcmlmeU93bmVyc2hpcDpcbiAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlci5hZGRDb2xsZWN0aWJsZVZlcmlmeU93bmVyc2hpcC5iaW5kKFxuICAgICAgICAgIGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG5cbiAgICAgIHJlbW92ZUFuZElnbm9yZUNvbGxlY3RpYmxlOlxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLnJlbW92ZUFuZElnbm9yZUNvbGxlY3RpYmxlLmJpbmQoXG4gICAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICAgKSxcblxuICAgICAgcmVtb3ZlQ29sbGVjdGlibGU6IGNvbGxlY3RpYmxlc0NvbnRyb2xsZXIucmVtb3ZlQ29sbGVjdGlibGUuYmluZChcbiAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIGNoZWNrQW5kVXBkYXRlQWxsQ29sbGVjdGlibGVzT3duZXJzaGlwU3RhdHVzOlxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLmNoZWNrQW5kVXBkYXRlQWxsQ29sbGVjdGlibGVzT3duZXJzaGlwU3RhdHVzLmJpbmQoXG4gICAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICAgKSxcblxuICAgICAgY2hlY2tBbmRVcGRhdGVTaW5nbGVDb2xsZWN0aWJsZU93bmVyc2hpcFN0YXR1czpcbiAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlci5jaGVja0FuZFVwZGF0ZVNpbmdsZUNvbGxlY3RpYmxlT3duZXJzaGlwU3RhdHVzLmJpbmQoXG4gICAgICAgICAgY29sbGVjdGlibGVzQ29udHJvbGxlcixcbiAgICAgICAgKSxcblxuICAgICAgaXNDb2xsZWN0aWJsZU93bmVyOiBjb2xsZWN0aWJsZXNDb250cm9sbGVyLmlzQ29sbGVjdGlibGVPd25lci5iaW5kKFxuICAgICAgICBjb2xsZWN0aWJsZXNDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gQWRkcmVzc0NvbnRyb2xsZXJcbiAgICAgIHNldEFkZHJlc3NCb29rOiBhZGRyZXNzQm9va0NvbnRyb2xsZXIuc2V0LmJpbmQoYWRkcmVzc0Jvb2tDb250cm9sbGVyKSxcbiAgICAgIHJlbW92ZUZyb21BZGRyZXNzQm9vazogYWRkcmVzc0Jvb2tDb250cm9sbGVyLmRlbGV0ZS5iaW5kKFxuICAgICAgICBhZGRyZXNzQm9va0NvbnRyb2xsZXIsXG4gICAgICApLFxuXG4gICAgICAvLyBBcHBTdGF0ZUNvbnRyb2xsZXJcbiAgICAgIHNldExhc3RBY3RpdmVUaW1lOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0TGFzdEFjdGl2ZVRpbWUuYmluZChhcHBTdGF0ZUNvbnRyb2xsZXIpLFxuICAgICAgc2V0RGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0RGVmYXVsdEhvbWVBY3RpdmVUYWJOYW1lLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcbiAgICAgIHNldENvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd246XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRDb25uZWN0ZWRTdGF0dXNQb3BvdmVySGFzQmVlblNob3duLmJpbmQoXG4gICAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93bjpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldFJlY292ZXJ5UGhyYXNlUmVtaW5kZXJIYXNCZWVuU2hvd24uYmluZChcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXRSZWNvdmVyeVBocmFzZVJlbWluZGVyTGFzdFNob3duOlxuICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIuc2V0UmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bi5iaW5kKFxuICAgICAgICAgIGFwcFN0YXRlQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgIHNldFNob3dUZXN0bmV0TWVzc2FnZUluRHJvcGRvd246XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRTaG93VGVzdG5ldE1lc3NhZ2VJbkRyb3Bkb3duLmJpbmQoXG4gICAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgc2V0U2hvd1BvcnRmb2xpb1Rvb2x0aXA6XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRTaG93UG9ydGZvbGlvVG9vbHRpcC5iaW5kKGFwcFN0YXRlQ29udHJvbGxlciksXG4gICAgICBzZXRDb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQ6XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRDb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQuYmluZChcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXRFbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQ6XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5zZXRFbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQuYmluZChcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICB1cGRhdGVDb2xsZWN0aWJsZURyb3BEb3duU3RhdGU6XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci51cGRhdGVDb2xsZWN0aWJsZURyb3BEb3duU3RhdGUuYmluZChcbiAgICAgICAgICBhcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXRGaXJzdFRpbWVVc2VkTmV0d29yazpcbiAgICAgICAgYXBwU3RhdGVDb250cm9sbGVyLnNldEZpcnN0VGltZVVzZWROZXR3b3JrLmJpbmQoYXBwU3RhdGVDb250cm9sbGVyKSxcbiAgICAgIC8vIEVuc0NvbnRyb2xsZXJcbiAgICAgIHRyeVJldmVyc2VSZXNvbHZlQWRkcmVzczpcbiAgICAgICAgZW5zQ29udHJvbGxlci5yZXZlcnNlUmVzb2x2ZUFkZHJlc3MuYmluZChlbnNDb250cm9sbGVyKSxcblxuICAgICAgLy8gS2V5cmluZ0NvbnRyb2xsZXJcbiAgICAgIHNldExvY2tlZDogdGhpcy5zZXRMb2NrZWQuYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZU5ld1ZhdWx0QW5kS2V5Y2hhaW46IHRoaXMuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbi5iaW5kKHRoaXMpLFxuICAgICAgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlOiB0aGlzLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZS5iaW5kKHRoaXMpLFxuICAgICAgZXhwb3J0QWNjb3VudDoga2V5cmluZ0NvbnRyb2xsZXIuZXhwb3J0QWNjb3VudC5iaW5kKGtleXJpbmdDb250cm9sbGVyKSxcblxuICAgICAgLy8gdHhDb250cm9sbGVyXG4gICAgICBjYW5jZWxUcmFuc2FjdGlvbjogdHhDb250cm9sbGVyLmNhbmNlbFRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uOiB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgdXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlQW5kQXBwcm92ZVRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIGFwcHJvdmVUcmFuc2FjdGlvbnNXaXRoU2FtZU5vbmNlOlxuICAgICAgICB0eENvbnRyb2xsZXIuYXBwcm92ZVRyYW5zYWN0aW9uc1dpdGhTYW1lTm9uY2UuYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb246IHRoaXMuY3JlYXRlQ2FuY2VsVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIGNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbjogdGhpcy5jcmVhdGVTcGVlZFVwVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgIGVzdGltYXRlR2FzOiB0aGlzLmVzdGltYXRlR2FzLmJpbmQodGhpcyksXG4gICAgICBnZXROZXh0Tm9uY2U6IHRoaXMuZ2V0TmV4dE5vbmNlLmJpbmQodGhpcyksXG4gICAgICBhZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb246XG4gICAgICAgIHR4Q29udHJvbGxlci5hZGRVbmFwcHJvdmVkVHJhbnNhY3Rpb24uYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50OlxuICAgICAgICB0eENvbnRyb2xsZXIuY3JlYXRlVHJhbnNhY3Rpb25FdmVudEZyYWdtZW50LmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIGdldFRyYW5zYWN0aW9uczogdHhDb250cm9sbGVyLmdldFRyYW5zYWN0aW9ucy5iaW5kKHR4Q29udHJvbGxlciksXG5cbiAgICAgIHVwZGF0ZUVkaXRhYmxlUGFyYW1zOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlRWRpdGFibGVQYXJhbXMuYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgdXBkYXRlVHJhbnNhY3Rpb25HYXNGZWVzOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb25HYXNGZWVzLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uU2VuZEZsb3dIaXN0b3J5OlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlVHJhbnNhY3Rpb25TZW5kRmxvd0hpc3RvcnkuYmluZCh0eENvbnRyb2xsZXIpLFxuXG4gICAgICB1cGRhdGVTd2FwQXBwcm92YWxUcmFuc2FjdGlvbjpcbiAgICAgICAgdHhDb250cm9sbGVyLnVwZGF0ZVN3YXBBcHByb3ZhbFRyYW5zYWN0aW9uLmJpbmQodHhDb250cm9sbGVyKSxcbiAgICAgIHVwZGF0ZVN3YXBUcmFuc2FjdGlvbjpcbiAgICAgICAgdHhDb250cm9sbGVyLnVwZGF0ZVN3YXBUcmFuc2FjdGlvbi5iaW5kKHR4Q29udHJvbGxlciksXG5cbiAgICAgIHVwZGF0ZVByZXZpb3VzR2FzUGFyYW1zOlxuICAgICAgICB0eENvbnRyb2xsZXIudXBkYXRlUHJldmlvdXNHYXNQYXJhbXMuYmluZCh0eENvbnRyb2xsZXIpLFxuICAgICAgLy8gbWVzc2FnZU1hbmFnZXJcbiAgICAgIHNpZ25NZXNzYWdlOiB0aGlzLnNpZ25NZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxNZXNzYWdlOiB0aGlzLmNhbmNlbE1lc3NhZ2UuYmluZCh0aGlzKSxcblxuICAgICAgLy8gcGVyc29uYWxNZXNzYWdlTWFuYWdlclxuICAgICAgc2lnblBlcnNvbmFsTWVzc2FnZTogdGhpcy5zaWduUGVyc29uYWxNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBjYW5jZWxQZXJzb25hbE1lc3NhZ2U6IHRoaXMuY2FuY2VsUGVyc29uYWxNZXNzYWdlLmJpbmQodGhpcyksXG5cbiAgICAgIC8vIHR5cGVkTWVzc2FnZU1hbmFnZXJcbiAgICAgIHNpZ25UeXBlZE1lc3NhZ2U6IHRoaXMuc2lnblR5cGVkTWVzc2FnZS5iaW5kKHRoaXMpLFxuICAgICAgY2FuY2VsVHlwZWRNZXNzYWdlOiB0aGlzLmNhbmNlbFR5cGVkTWVzc2FnZS5iaW5kKHRoaXMpLFxuXG4gICAgICAvLyBkZWNyeXB0TWVzc2FnZU1hbmFnZXJcbiAgICAgIGRlY3J5cHRNZXNzYWdlOiB0aGlzLmRlY3J5cHRNZXNzYWdlLmJpbmQodGhpcyksXG4gICAgICBkZWNyeXB0TWVzc2FnZUlubGluZTogdGhpcy5kZWNyeXB0TWVzc2FnZUlubGluZS5iaW5kKHRoaXMpLFxuICAgICAgY2FuY2VsRGVjcnlwdE1lc3NhZ2U6IHRoaXMuY2FuY2VsRGVjcnlwdE1lc3NhZ2UuYmluZCh0aGlzKSxcblxuICAgICAgLy8gRW5jcnlwdGlvblB1YmxpY0tleU1hbmFnZXJcbiAgICAgIGVuY3J5cHRpb25QdWJsaWNLZXk6IHRoaXMuZW5jcnlwdGlvblB1YmxpY0tleS5iaW5kKHRoaXMpLFxuICAgICAgY2FuY2VsRW5jcnlwdGlvblB1YmxpY0tleTogdGhpcy5jYW5jZWxFbmNyeXB0aW9uUHVibGljS2V5LmJpbmQodGhpcyksXG5cbiAgICAgIC8vIG9uYm9hcmRpbmcgY29udHJvbGxlclxuICAgICAgc2V0U2VlZFBocmFzZUJhY2tlZFVwOlxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlci5zZXRTZWVkUGhyYXNlQmFja2VkVXAuYmluZChvbmJvYXJkaW5nQ29udHJvbGxlciksXG4gICAgICBjb21wbGV0ZU9uYm9hcmRpbmc6XG4gICAgICAgIG9uYm9hcmRpbmdDb250cm9sbGVyLmNvbXBsZXRlT25ib2FyZGluZy5iaW5kKG9uYm9hcmRpbmdDb250cm9sbGVyKSxcbiAgICAgIHNldEZpcnN0VGltZUZsb3dUeXBlOlxuICAgICAgICBvbmJvYXJkaW5nQ29udHJvbGxlci5zZXRGaXJzdFRpbWVGbG93VHlwZS5iaW5kKG9uYm9hcmRpbmdDb250cm9sbGVyKSxcblxuICAgICAgLy8gYWxlcnQgY29udHJvbGxlclxuICAgICAgc2V0QWxlcnRFbmFibGVkbmVzczpcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLnNldEFsZXJ0RW5hYmxlZG5lc3MuYmluZChhbGVydENvbnRyb2xsZXIpLFxuICAgICAgc2V0VW5jb25uZWN0ZWRBY2NvdW50QWxlcnRTaG93bjpcbiAgICAgICAgYWxlcnRDb250cm9sbGVyLnNldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24uYmluZChhbGVydENvbnRyb2xsZXIpLFxuICAgICAgc2V0V2ViM1NoaW1Vc2FnZUFsZXJ0RGlzbWlzc2VkOlxuICAgICAgICBhbGVydENvbnRyb2xsZXIuc2V0V2ViM1NoaW1Vc2FnZUFsZXJ0RGlzbWlzc2VkLmJpbmQoYWxlcnRDb250cm9sbGVyKSxcblxuICAgICAgLy8gcGVybWlzc2lvbnNcbiAgICAgIHJlbW92ZVBlcm1pc3Npb25zRm9yOiB0aGlzLnJlbW92ZVBlcm1pc3Npb25zRm9yLFxuICAgICAgYXBwcm92ZVBlcm1pc3Npb25zUmVxdWVzdDogdGhpcy5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3QsXG4gICAgICByZWplY3RQZXJtaXNzaW9uc1JlcXVlc3Q6IHRoaXMucmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0LFxuICAgICAgLi4uZ2V0UGVybWlzc2lvbkJhY2tncm91bmRBcGlNZXRob2RzKHBlcm1pc3Npb25Db250cm9sbGVyKSxcblxuXG4gICAgICAvLyBzd2Fwc1xuICAgICAgZmV0Y2hBbmRTZXRRdW90ZXM6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5mZXRjaEFuZFNldFF1b3Rlcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTZWxlY3RlZFF1b3RlQWdnSWQ6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTZWxlY3RlZFF1b3RlQWdnSWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgcmVzZXRTd2Fwc1N0YXRlOiBzd2Fwc0NvbnRyb2xsZXIucmVzZXRTd2Fwc1N0YXRlLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzVG9rZW5zOiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUb2tlbnMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgY2xlYXJTd2Fwc1F1b3Rlczogc3dhcHNDb250cm9sbGVyLmNsZWFyU3dhcHNRdW90ZXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0QXBwcm92ZVR4SWQ6IHN3YXBzQ29udHJvbGxlci5zZXRBcHByb3ZlVHhJZC5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRUcmFkZVR4SWQ6IHN3YXBzQ29udHJvbGxlci5zZXRUcmFkZVR4SWQuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNUeEdhc1ByaWNlOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeEdhc1ByaWNlLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzVHhHYXNMaW1pdDpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVHhHYXNMaW1pdC5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1R4TWF4RmVlUGVyR2FzOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNUeE1heEZlZVBlckdhcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1R4TWF4RmVlUHJpb3JpdHlQZXJHYXM6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc1R4TWF4RmVlUHJpb3JpdHlQZXJHYXMuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2FmZVJlZmV0Y2hRdW90ZXM6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zYWZlUmVmZXRjaFF1b3Rlcy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzdG9wUG9sbGluZ0ZvclF1b3RlczpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnN0b3BQb2xsaW5nRm9yUXVvdGVzLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldEJhY2tncm91bmRTd2FwUm91dGVTdGF0ZTpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldEJhY2tncm91bmRTd2FwUm91dGVTdGF0ZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICByZXNldFBvc3RGZXRjaFN0YXRlOlxuICAgICAgICBzd2Fwc0NvbnRyb2xsZXIucmVzZXRQb3N0RmV0Y2hTdGF0ZS5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc0Vycm9yS2V5OiBzd2Fwc0NvbnRyb2xsZXIuc2V0U3dhcHNFcnJvcktleS5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRJbml0aWFsR2FzRXN0aW1hdGU6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRJbml0aWFsR2FzRXN0aW1hdGUuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0Q3VzdG9tQXBwcm92ZVR4RGF0YTpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldEN1c3RvbUFwcHJvdmVUeERhdGEuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNMaXZlbmVzczogc3dhcHNDb250cm9sbGVyLnNldFN3YXBzTGl2ZW5lc3MuYmluZChzd2Fwc0NvbnRyb2xsZXIpLFxuICAgICAgc2V0U3dhcHNGZWF0dXJlRmxhZ3M6XG4gICAgICAgIHN3YXBzQ29udHJvbGxlci5zZXRTd2Fwc0ZlYXR1cmVGbGFncy5iaW5kKHN3YXBzQ29udHJvbGxlciksXG4gICAgICBzZXRTd2Fwc1VzZXJGZWVMZXZlbDpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFN3YXBzVXNlckZlZUxldmVsLmJpbmQoc3dhcHNDb250cm9sbGVyKSxcbiAgICAgIHNldFN3YXBzUXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZDpcbiAgICAgICAgc3dhcHNDb250cm9sbGVyLnNldFN3YXBzUXVvdGVzUG9sbGluZ0xpbWl0RW5hYmxlZC5iaW5kKHN3YXBzQ29udHJvbGxlciksXG5cbiAgICAgIC8vIFNtYXJ0IFRyYW5zYWN0aW9uc1xuICAgICAgc2V0U21hcnRUcmFuc2FjdGlvbnNPcHRJblN0YXR1czpcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnNldE9wdEluU3RhdGUuYmluZChcbiAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBmZXRjaFNtYXJ0VHJhbnNhY3Rpb25GZWVzOiBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuZ2V0RmVlcy5iaW5kKFxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgY2xlYXJTbWFydFRyYW5zYWN0aW9uRmVlczogc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmNsZWFyRmVlcy5iaW5kKFxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgc3VibWl0U2lnbmVkVHJhbnNhY3Rpb25zOlxuICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuc3VibWl0U2lnbmVkVHJhbnNhY3Rpb25zLmJpbmQoXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgY2FuY2VsU21hcnRUcmFuc2FjdGlvbjpcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLmNhbmNlbFNtYXJ0VHJhbnNhY3Rpb24uYmluZChcbiAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBmZXRjaFNtYXJ0VHJhbnNhY3Rpb25zTGl2ZW5lc3M6XG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5mZXRjaExpdmVuZXNzLmJpbmQoXG4gICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgdXBkYXRlU21hcnRUcmFuc2FjdGlvbjpcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyLnVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb24uYmluZChcbiAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICBzZXRTdGF0dXNSZWZyZXNoSW50ZXJ2YWw6XG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5zZXRTdGF0dXNSZWZyZXNoSW50ZXJ2YWwuYmluZChcbiAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIsXG4gICAgICAgICksXG5cbiAgICAgIC8vIE1ldGFNZXRyaWNzXG4gICAgICB0cmFja01ldGFNZXRyaWNzRXZlbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50LmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICB0cmFja01ldGFNZXRyaWNzUGFnZTogbWV0YU1ldHJpY3NDb250cm9sbGVyLnRyYWNrUGFnZS5iaW5kKFxuICAgICAgICBtZXRhTWV0cmljc0NvbnRyb2xsZXIsXG4gICAgICApLFxuICAgICAgY3JlYXRlRXZlbnRGcmFnbWVudDogbWV0YU1ldHJpY3NDb250cm9sbGVyLmNyZWF0ZUV2ZW50RnJhZ21lbnQuYmluZChcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcbiAgICAgIHVwZGF0ZUV2ZW50RnJhZ21lbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci51cGRhdGVFdmVudEZyYWdtZW50LmJpbmQoXG4gICAgICAgIG1ldGFNZXRyaWNzQ29udHJvbGxlcixcbiAgICAgICksXG4gICAgICBmaW5hbGl6ZUV2ZW50RnJhZ21lbnQ6IG1ldGFNZXRyaWNzQ29udHJvbGxlci5maW5hbGl6ZUV2ZW50RnJhZ21lbnQuYmluZChcbiAgICAgICAgbWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgKSxcblxuICAgICAgLy8gYXBwcm92YWwgY29udHJvbGxlclxuICAgICAgcmVzb2x2ZVBlbmRpbmdBcHByb3ZhbDogdGhpcy5yZXNvbHZlUGVuZGluZ0FwcHJvdmFsLFxuICAgICAgcmVqZWN0UGVuZGluZ0FwcHJvdmFsOiB0aGlzLnJlamVjdFBlbmRpbmdBcHByb3ZhbCxcblxuICAgICAgLy8gTm90aWZpY2F0aW9uc1xuICAgICAgdXBkYXRlVmlld2VkTm90aWZpY2F0aW9uczogYW5ub3VuY2VtZW50Q29udHJvbGxlci51cGRhdGVWaWV3ZWQuYmluZChcbiAgICAgICAgYW5ub3VuY2VtZW50Q29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIEdhc0ZlZUNvbnRyb2xsZXJcbiAgICAgIGdldEdhc0ZlZUVzdGltYXRlc0FuZFN0YXJ0UG9sbGluZzpcbiAgICAgICAgZ2FzRmVlQ29udHJvbGxlci5nZXRHYXNGZWVFc3RpbWF0ZXNBbmRTdGFydFBvbGxpbmcuYmluZChcbiAgICAgICAgICBnYXNGZWVDb250cm9sbGVyLFxuICAgICAgICApLFxuXG4gICAgICBkaXNjb25uZWN0R2FzRmVlRXN0aW1hdGVQb2xsZXI6XG4gICAgICAgIGdhc0ZlZUNvbnRyb2xsZXIuZGlzY29ubmVjdFBvbGxlci5iaW5kKGdhc0ZlZUNvbnRyb2xsZXIpLFxuXG4gICAgICBnZXRHYXNGZWVUaW1lRXN0aW1hdGU6XG4gICAgICAgIGdhc0ZlZUNvbnRyb2xsZXIuZ2V0VGltZUVzdGltYXRlLmJpbmQoZ2FzRmVlQ29udHJvbGxlciksXG5cbiAgICAgIGFkZFBvbGxpbmdUb2tlblRvQXBwU3RhdGU6XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5hZGRQb2xsaW5nVG9rZW4uYmluZChhcHBTdGF0ZUNvbnRyb2xsZXIpLFxuXG4gICAgICByZW1vdmVQb2xsaW5nVG9rZW5Gcm9tQXBwU3RhdGU6XG4gICAgICAgIGFwcFN0YXRlQ29udHJvbGxlci5yZW1vdmVQb2xsaW5nVG9rZW4uYmluZChhcHBTdGF0ZUNvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBCYWNrdXBDb250cm9sbGVyXG4gICAgICBiYWNrdXBVc2VyRGF0YTogYmFja3VwQ29udHJvbGxlci5iYWNrdXBVc2VyRGF0YS5iaW5kKGJhY2t1cENvbnRyb2xsZXIpLFxuICAgICAgcmVzdG9yZVVzZXJEYXRhOiBiYWNrdXBDb250cm9sbGVyLnJlc3RvcmVVc2VyRGF0YS5iaW5kKGJhY2t1cENvbnRyb2xsZXIpLFxuXG4gICAgICAvLyBEZXRlY3RUb2tlbkNvbnRyb2xsZXJcbiAgICAgIGRldGVjdE5ld1Rva2VuczogZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5kZXRlY3ROZXdUb2tlbnMuYmluZChcbiAgICAgICAgZGV0ZWN0VG9rZW5zQ29udHJvbGxlcixcbiAgICAgICksXG5cbiAgICAgIC8vIERldGVjdENvbGxlY3RpYmxlQ29udHJvbGxlclxuICAgICAgZGV0ZWN0Q29sbGVjdGlibGVzOiBwcm9jZXNzLmVudi5DT0xMRUNUSUJMRVNfVjFcbiAgICAgICAgPyBjb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIuZGV0ZWN0Q29sbGVjdGlibGVzLmJpbmQoXG4gICAgICAgICAgICBjb2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgKVxuICAgICAgICA6IG51bGwsXG5cbiAgICAgIC8qKiBUb2tlbiBEZXRlY3Rpb24gVjIgKi9cbiAgICAgIGFkZERldGVjdGVkVG9rZW5zOlxuICAgICAgICB0b2tlbnNDb250cm9sbGVyLmFkZERldGVjdGVkVG9rZW5zLmJpbmQodG9rZW5zQ29udHJvbGxlciksXG4gICAgICBhZGRJbXBvcnRlZFRva2VuczogdG9rZW5zQ29udHJvbGxlci5hZGRUb2tlbnMuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIGlnbm9yZVRva2VuczogdG9rZW5zQ29udHJvbGxlci5pZ25vcmVUb2tlbnMuYmluZCh0b2tlbnNDb250cm9sbGVyKSxcbiAgICAgIGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsOlxuICAgICAgICBhc3NldHNDb250cmFjdENvbnRyb2xsZXIuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwuYmluZChcbiAgICAgICAgICBhc3NldHNDb250cmFjdENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgfTtcbiAgfVxuXG4gIGFzeW5jIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKGFkZHJlc3MsIHVzZXJBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgY29uc3QgZGV0YWlscyA9XG4gICAgICBhd2FpdCB0aGlzLmFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5nZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyhcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgdXNlckFkZHJlc3MsXG4gICAgICAgIHRva2VuSWQsXG4gICAgICApO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kZXRhaWxzLFxuICAgICAgZGVjaW1hbHM6IGRldGFpbHM/LmRlY2ltYWxzPy50b1N0cmluZygxMCksXG4gICAgICBiYWxhbmNlOiBkZXRhaWxzPy5iYWxhbmNlPy50b1N0cmluZygxMCksXG4gICAgfTtcbiAgfVxuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gVkFVTFQgLyBLRVlSSU5HIFJFTEFURUQgTUVUSE9EU1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVmF1bHQgYW5kIGNyZWF0ZSBhIG5ldyBrZXljaGFpbi5cbiAgICpcbiAgICogQSB2YXVsdCwgb3IgS2V5cmluZ0NvbnRyb2xsZXIsIGlzIGEgY29udHJvbGxlciB0aGF0IGNvbnRhaW5zXG4gICAqIG1hbnkgZGlmZmVyZW50IGFjY291bnQgc3RyYXRlZ2llcywgY3VycmVudGx5IGNhbGxlZCBLZXlyaW5ncy5cbiAgICogQ3JlYXRpbmcgaXQgbmV3IG1lYW5zIHdpcGluZyBhbGwgcHJldmlvdXMga2V5cmluZ3MuXG4gICAqXG4gICAqIEEga2V5Y2hhaW4sIG9yIGtleXJpbmcsIGNvbnRyb2xzIG1hbnkgYWNjb3VudHMgd2l0aCBhIHNpbmdsZSBiYWNrdXAgYW5kIHNpZ25pbmcgc3RyYXRlZ3kuXG4gICAqIEZvciBleGFtcGxlLCBhIG1uZW1vbmljIHBocmFzZSBjYW4gZ2VuZXJhdGUgbWFueSBhY2NvdW50cywgYW5kIGlzIGEga2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkXG4gICAqIEByZXR1cm5zIHtvYmplY3R9IHZhdWx0XG4gICAqL1xuICBhc3luYyBjcmVhdGVOZXdWYXVsdEFuZEtleWNoYWluKHBhc3N3b3JkKSB7XG4gICAgY29uc3QgcmVsZWFzZUxvY2sgPSBhd2FpdCB0aGlzLmNyZWF0ZVZhdWx0TXV0ZXguYWNxdWlyZSgpO1xuICAgIHRyeSB7XG4gICAgICBsZXQgdmF1bHQ7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhdWx0ID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5mdWxsVXBkYXRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXVsdCA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihcbiAgICAgICAgICBwYXNzd29yZCxcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgYWRkcmVzc2VzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMoYWRkcmVzc2VzKTtcbiAgICAgICAgdGhpcy5zZWxlY3RGaXJzdElkZW50aXR5KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2YXVsdDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZXF1ZXN0QWRkTmV0d29ya0FwcHJvdmFsKGN1c3RvbVJwYywgb3JpZ2luSXNNZXRhTWFzaykge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KHtcbiAgICAgICAgb3JpZ2luOiAnbWV0YW1hc2snLFxuICAgICAgICB0eXBlOiAnd2FsbGV0X2FkZEV0aGVyZXVtQ2hhaW4nLFxuICAgICAgICByZXF1ZXN0RGF0YToge1xuICAgICAgICAgIGNoYWluSWQ6IGN1c3RvbVJwYy5jaGFpbklkLFxuICAgICAgICAgIGJsb2NrRXhwbG9yZXJVcmw6IGN1c3RvbVJwYy5ycGNQcmVmcy5ibG9ja0V4cGxvcmVyVXJsLFxuICAgICAgICAgIGNoYWluTmFtZTogY3VzdG9tUnBjLm5pY2tuYW1lLFxuICAgICAgICAgIHJwY1VybDogY3VzdG9tUnBjLnJwY1VybCxcbiAgICAgICAgICB0aWNrZXI6IGN1c3RvbVJwYy50aWNrZXIsXG4gICAgICAgICAgaW1hZ2VVcmw6IGN1c3RvbVJwYy5ycGNQcmVmcy5pbWFnZVVybCxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoXG4gICAgICAgICEob3JpZ2luSXNNZXRhTWFzayAmJiBlcnJvci5tZXNzYWdlID09PSAnVXNlciByZWplY3RlZCB0aGUgcmVxdWVzdC4nKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGFkZEN1c3RvbU5ldHdvcmsoY3VzdG9tUnBjLCBhY3Rpb25JZCkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgY2hhaW5OYW1lLCBycGNVcmwsIHRpY2tlciwgYmxvY2tFeHBsb3JlclVybCB9ID0gY3VzdG9tUnBjO1xuXG4gICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkVG9GcmVxdWVudFJwY0xpc3QoXG4gICAgICBycGNVcmwsXG4gICAgICBjaGFpbklkLFxuICAgICAgdGlja2VyLFxuICAgICAgY2hhaW5OYW1lLFxuICAgICAge1xuICAgICAgICBibG9ja0V4cGxvcmVyVXJsLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgbGV0IHJwY1VybE9yaWdpbjtcbiAgICB0cnkge1xuICAgICAgcnBjVXJsT3JpZ2luID0gbmV3IFVSTChycGNVcmwpLm9yaWdpbjtcbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIGlnbm9yZVxuICAgIH1cbiAgICB0aGlzLm1ldGFNZXRyaWNzQ29udHJvbGxlci50cmFja0V2ZW50KHtcbiAgICAgIGV2ZW50OiAnQ3VzdG9tIE5ldHdvcmsgQWRkZWQnLFxuICAgICAgY2F0ZWdvcnk6IEVWRU5ULkNBVEVHT1JJRVMuTkVUV09SSyxcbiAgICAgIHJlZmVycmVyOiB7XG4gICAgICAgIHVybDogcnBjVXJsT3JpZ2luLFxuICAgICAgfSxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgY2hhaW5faWQ6IGNoYWluSWQsXG4gICAgICAgIG5ldHdvcmtfbmFtZTogY2hhaW5OYW1lLFxuICAgICAgICBuZXR3b3JrOiBycGNVcmxPcmlnaW4sXG4gICAgICAgIHN5bWJvbDogdGlja2VyLFxuICAgICAgICBibG9ja19leHBsb3Jlcl91cmw6IGJsb2NrRXhwbG9yZXJVcmwsXG4gICAgICAgIHNvdXJjZTogRVZFTlQuU09VUkNFLk5FVFdPUksuUE9QVUxBUl9ORVRXT1JLX0xJU1QsXG4gICAgICB9LFxuICAgICAgc2Vuc2l0aXZlUHJvcGVydGllczoge1xuICAgICAgICBycGNfdXJsOiBycGNVcmxPcmlnaW4sXG4gICAgICB9LFxuICAgICAgYWN0aW9uSWQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFZhdWx0IGFuZCByZXN0b3JlIGFuIGV4aXN0ZW50IGtleXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZFxuICAgKiBAcGFyYW0ge251bWJlcltdfSBlbmNvZGVkU2VlZFBocmFzZSAtIFRoZSBzZWVkIHBocmFzZSwgZW5jb2RlZCBhcyBhbiBhcnJheVxuICAgKiBvZiBVVEYtOCBieXRlcy5cbiAgICovXG4gIGFzeW5jIGNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShwYXNzd29yZCwgZW5jb2RlZFNlZWRQaHJhc2UpIHtcbiAgICBjb25zdCByZWxlYXNlTG9jayA9IGF3YWl0IHRoaXMuY3JlYXRlVmF1bHRNdXRleC5hY3F1aXJlKCk7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBhY2NvdW50cywgbGFzdEJhbGFuY2U7XG5cbiAgICAgIGNvbnN0IHNlZWRQaHJhc2VBc0J1ZmZlciA9IEJ1ZmZlci5mcm9tKGVuY29kZWRTZWVkUGhyYXNlKTtcblxuICAgICAgY29uc3QgeyBrZXlyaW5nQ29udHJvbGxlciB9ID0gdGhpcztcblxuICAgICAgLy8gY2xlYXIga25vd24gaWRlbnRpdGllc1xuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKFtdKTtcblxuICAgICAgLy8gY2xlYXIgcGVybWlzc2lvbnNcbiAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuY2xlYXJTdGF0ZSgpO1xuXG5cbiAgICAgIC8vIGNsZWFyIGFjY291bnRzIGluIGFjY291bnRUcmFja2VyXG4gICAgICB0aGlzLmFjY291bnRUcmFja2VyLmNsZWFyQWNjb3VudHMoKTtcblxuICAgICAgLy8gY2xlYXIgY2FjaGVkQmFsYW5jZXNcbiAgICAgIHRoaXMuY2FjaGVkQmFsYW5jZXNDb250cm9sbGVyLmNsZWFyQ2FjaGVkQmFsYW5jZXMoKTtcblxuICAgICAgLy8gY2xlYXIgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnNcbiAgICAgIHRoaXMudHhDb250cm9sbGVyLnR4U3RhdGVNYW5hZ2VyLmNsZWFyVW5hcHByb3ZlZFR4cygpO1xuXG4gICAgICAvLyBjcmVhdGUgbmV3IHZhdWx0XG4gICAgICBjb25zdCB2YXVsdCA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmNyZWF0ZU5ld1ZhdWx0QW5kUmVzdG9yZShcbiAgICAgICAgcGFzc3dvcmQsXG4gICAgICAgIHNlZWRQaHJhc2VBc0J1ZmZlcixcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGV0aFF1ZXJ5ID0gbmV3IEV0aFF1ZXJ5KHRoaXMucHJvdmlkZXIpO1xuICAgICAgYWNjb3VudHMgPSBhd2FpdCBrZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgICAgbGFzdEJhbGFuY2UgPSBhd2FpdCB0aGlzLmdldEJhbGFuY2UoXG4gICAgICAgIGFjY291bnRzW2FjY291bnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICBldGhRdWVyeSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IFtwcmltYXJ5S2V5cmluZ10gPVxuICAgICAgICBrZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZSgnSEQgS2V5IFRyZWUnKTtcbiAgICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBIRCBLZXkgVHJlZSBmb3VuZCcpO1xuICAgICAgfVxuXG4gICAgICAvLyBzZWVrIG91dCB0aGUgZmlyc3QgemVybyBiYWxhbmNlXG4gICAgICB3aGlsZSAobGFzdEJhbGFuY2UgIT09ICcweDAnKSB7XG4gICAgICAgIGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmFkZE5ld0FjY291bnQocHJpbWFyeUtleXJpbmcpO1xuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICAgIGxhc3RCYWxhbmNlID0gYXdhaXQgdGhpcy5nZXRCYWxhbmNlKFxuICAgICAgICAgIGFjY291bnRzW2FjY291bnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgIGV0aFF1ZXJ5LFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyByZW1vdmUgZXh0cmEgemVybyBiYWxhbmNlIGFjY291bnQgcG90ZW50aWFsbHkgY3JlYXRlZCBmcm9tIHNlZWtpbmcgYWhlYWRcbiAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPiAxICYmIGxhc3RCYWxhbmNlID09PSAnMHgwJykge1xuICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUFjY291bnQoYWNjb3VudHNbYWNjb3VudHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICBhY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgbXVzdCBiZSBzZXQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBjb21tdW5pY2F0ZSB0byB0aGVcbiAgICAgIC8vIGtleXJpbmcncyBpZnJhbWUgYW5kIGhhdmUgdGhlIHNldHRpbmcgaW5pdGlhbGl6ZWQgcHJvcGVybHlcbiAgICAgIC8vIE9wdGltaXN0aWNhbGx5IGNhbGxlZCB0byBub3QgYmxvY2sgTWV0YU1hc2sgbG9naW4gZHVlIHRvXG4gICAgICAvLyBMZWRnZXIgS2V5cmluZyBHaXRIdWIgZG93bnRpbWVcbiAgICAgIGNvbnN0IHRyYW5zcG9ydFByZWZlcmVuY2UgPVxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5nZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICB0aGlzLnNldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0UHJlZmVyZW5jZSk7XG5cbiAgICAgIC8vIHNldCBuZXcgaWRlbnRpdGllc1xuICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0QWRkcmVzc2VzKGFjY291bnRzKTtcbiAgICAgIHRoaXMuc2VsZWN0Rmlyc3RJZGVudGl0eSgpO1xuICAgICAgcmV0dXJuIHZhdWx0O1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZWxlYXNlTG9jaygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gYWNjb3VudCBiYWxhbmNlIGZyb20gdGhlIEFjY291bnRUcmFja2VyIG9yIHJlcXVlc3QgaXQgZGlyZWN0bHkgZnJvbSB0aGUgbmV0d29yay5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWNjb3VudCBhZGRyZXNzXG4gICAqIEBwYXJhbSB7RXRoUXVlcnl9IGV0aFF1ZXJ5IC0gVGhlIEV0aFF1ZXJ5IGluc3RhbmNlIHRvIHVzZSB3aGVuIGFza2luZyB0aGUgbmV0d29ya1xuICAgKi9cbiAgZ2V0QmFsYW5jZShhZGRyZXNzLCBldGhRdWVyeSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLmFjY291bnRUcmFja2VyLnN0b3JlLmdldFN0YXRlKCkuYWNjb3VudHNbYWRkcmVzc107XG5cbiAgICAgIGlmIChjYWNoZWQgJiYgY2FjaGVkLmJhbGFuY2UpIHtcbiAgICAgICAgcmVzb2x2ZShjYWNoZWQuYmFsYW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhRdWVyeS5nZXRCYWxhbmNlKGFkZHJlc3MsIChlcnJvciwgYmFsYW5jZSkgPT4ge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoYmFsYW5jZSB8fCAnMHgwJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0cyBhbGwgdGhlIGluZm9ybWF0aW9uIHRoYXQgd2Ugd2FudCB0byBzaGFyZVxuICAgKiB3aXRoIHRoZSBtb2JpbGUgY2xpZW50IGZvciBzeW5jaW5nIHB1cnBvc2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IFBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0IHdlIHdhbnQgdG8gc3luY3hcbiAgICovXG4gIGFzeW5jIGZldGNoSW5mb1RvU3luYygpIHtcbiAgICAvLyBQcmVmZXJlbmNlc1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRMb2NhbGUsXG4gICAgICBmcmVxdWVudFJwY0xpc3QsXG4gICAgICBpZGVudGl0aWVzLFxuICAgICAgc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgdXNlVG9rZW5EZXRlY3Rpb24sXG4gICAgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBjb25zdCBpc1Rva2VuRGV0ZWN0aW9uSW5hY3RpdmVJbk1haW5uZXQgPVxuICAgICAgIXVzZVRva2VuRGV0ZWN0aW9uICYmXG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCkucHJvdmlkZXIuY2hhaW5JZCA9PT1cbiAgICAgICAgQ0hBSU5fSURTLk1BSU5ORVQ7XG4gICAgY29uc3QgeyB0b2tlbkxpc3QgfSA9IHRoaXMudG9rZW5MaXN0Q29udHJvbGxlci5zdGF0ZTtcbiAgICBjb25zdCBjYXNlSW5TZW5zaXRpdmVUb2tlbkxpc3QgPSBpc1Rva2VuRGV0ZWN0aW9uSW5hY3RpdmVJbk1haW5uZXRcbiAgICAgID8gU1RBVElDX01BSU5ORVRfVE9LRU5fTElTVFxuICAgICAgOiB0b2tlbkxpc3Q7XG5cbiAgICBjb25zdCBwcmVmZXJlbmNlcyA9IHtcbiAgICAgIGN1cnJlbnRMb2NhbGUsXG4gICAgICBmcmVxdWVudFJwY0xpc3QsXG4gICAgICBpZGVudGl0aWVzLFxuICAgICAgc2VsZWN0ZWRBZGRyZXNzLFxuICAgIH07XG5cbiAgICAvLyBUb2tlbnNcbiAgICBjb25zdCB7IGFsbFRva2VucywgYWxsSWdub3JlZFRva2VucyB9ID0gdGhpcy50b2tlbnNDb250cm9sbGVyLnN0YXRlO1xuXG4gICAgLy8gRmlsdGVyIEVSQzIwIHRva2Vuc1xuICAgIGNvbnN0IGFsbEVSQzIwVG9rZW5zID0ge307XG5cbiAgICBPYmplY3Qua2V5cyhhbGxUb2tlbnMpLmZvckVhY2goKGNoYWluSWQpID0+IHtcbiAgICAgIGFsbEVSQzIwVG9rZW5zW2NoYWluSWRdID0ge307XG4gICAgICBPYmplY3Qua2V5cyhhbGxUb2tlbnNbY2hhaW5JZF0pLmZvckVhY2goKGFjY291bnRBZGRyZXNzKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrc3VtbWVkQWNjb3VudEFkZHJlc3MgPSB0b0NoZWNrc3VtSGV4QWRkcmVzcyhhY2NvdW50QWRkcmVzcyk7XG4gICAgICAgIGFsbEVSQzIwVG9rZW5zW2NoYWluSWRdW2NoZWNrc3VtbWVkQWNjb3VudEFkZHJlc3NdID0gYWxsVG9rZW5zW2NoYWluSWRdW1xuICAgICAgICAgIGNoZWNrc3VtbWVkQWNjb3VudEFkZHJlc3NcbiAgICAgICAgXS5maWx0ZXIoKGFzc2V0KSA9PiB7XG4gICAgICAgICAgaWYgKGFzc2V0LmlzRVJDNzIxID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHRoZSB0b2tlbkxpc3Qgd2lsbCBiZSBob2xkaW5nIG9ubHkgZXJjMjAgdG9rZW5zXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIGNhc2VJblNlbnNpdGl2ZVRva2VuTGlzdFthc3NldC5hZGRyZXNzPy50b0xvd2VyQ2FzZSgpXSAhPT1cbiAgICAgICAgICAgICAgdW5kZWZpbmVkXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChhc3NldC5pc0VSQzcyMSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBBY2NvdW50c1xuICAgIGNvbnN0IFtoZEtleXJpbmddID0gdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZSgnSEQgS2V5IFRyZWUnKTtcbiAgICBjb25zdCBzaW1wbGVLZXlQYWlyS2V5cmluZ3MgPVxuICAgICAgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nc0J5VHlwZSgnU2ltcGxlIEtleSBQYWlyJyk7XG4gICAgY29uc3QgaGRBY2NvdW50cyA9IGF3YWl0IGhkS2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgIGNvbnN0IHNpbXBsZUtleVBhaXJLZXlyaW5nQWNjb3VudHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHNpbXBsZUtleVBhaXJLZXlyaW5ncy5tYXAoKGtleXJpbmcpID0+IGtleXJpbmcuZ2V0QWNjb3VudHMoKSksXG4gICAgKTtcbiAgICBjb25zdCBzaW1wbGVLZXlQYWlyQWNjb3VudHMgPSBzaW1wbGVLZXlQYWlyS2V5cmluZ0FjY291bnRzLnJlZHVjZShcbiAgICAgIChhY2MsIGFjY291bnRzKSA9PiBbLi4uYWNjLCAuLi5hY2NvdW50c10sXG4gICAgICBbXSxcbiAgICApO1xuICAgIGNvbnN0IGFjY291bnRzID0ge1xuICAgICAgaGQ6IGhkQWNjb3VudHNcbiAgICAgICAgLmZpbHRlcigoaXRlbSwgcG9zKSA9PiBoZEFjY291bnRzLmluZGV4T2YoaXRlbSkgPT09IHBvcylcbiAgICAgICAgLm1hcCgoYWRkcmVzcykgPT4gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgc2ltcGxlS2V5UGFpcjogc2ltcGxlS2V5UGFpckFjY291bnRzXG4gICAgICAgIC5maWx0ZXIoKGl0ZW0sIHBvcykgPT4gc2ltcGxlS2V5UGFpckFjY291bnRzLmluZGV4T2YoaXRlbSkgPT09IHBvcylcbiAgICAgICAgLm1hcCgoYWRkcmVzcykgPT4gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykpLFxuICAgICAgbGVkZ2VyOiBbXSxcbiAgICAgIHRyZXpvcjogW10sXG4gICAgICBsYXR0aWNlOiBbXSxcbiAgICB9O1xuXG4gICAgLy8gdHJhbnNhY3Rpb25zXG5cbiAgICBsZXQgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMudHhDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG4gICAgLy8gZGVsZXRlIHR4IGZvciBvdGhlciBhY2NvdW50cyB0aGF0IHdlJ3JlIG5vdCBpbXBvcnRpbmdcbiAgICB0cmFuc2FjdGlvbnMgPSBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucykuZmlsdGVyKCh0eCkgPT4ge1xuICAgICAgY29uc3QgY2hlY2tzdW1tZWRUeEZyb20gPSB0b0NoZWNrc3VtSGV4QWRkcmVzcyh0eC50eFBhcmFtcy5mcm9tKTtcbiAgICAgIHJldHVybiBhY2NvdW50cy5oZC5pbmNsdWRlcyhjaGVja3N1bW1lZFR4RnJvbSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudHMsXG4gICAgICBwcmVmZXJlbmNlcyxcbiAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgIHRva2VuczogeyBhbGxUb2tlbnM6IGFsbEVSQzIwVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zIH0sXG4gICAgICBuZXR3b3JrOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCksXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIHRoZSB1c2VyJ3MgcGFzc3dvcmQgYW5kIGF0dGVtcHRzIHRvIHVubG9jayB0aGUgdmF1bHQuXG4gICAqIEFsc28gc3luY2hyb25pemVzIHRoZSBwcmVmZXJlbmNlc0NvbnRyb2xsZXIsIHRvIGVuc3VyZSBpdHMgc2NoZW1hXG4gICAqIGlzIHVwIHRvIGRhdGUgd2l0aCBrbm93biBhY2NvdW50cyBvbmNlIHRoZSB2YXVsdCBpcyBkZWNyeXB0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCAtIFRoZSB1c2VyJ3MgcGFzc3dvcmRcbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gVGhlIGtleXJpbmdDb250cm9sbGVyIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zdWJtaXRQYXNzd29yZChwYXNzd29yZCk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgdGhpcy5ibG9ja1RyYWNrZXIuY2hlY2tGb3JMYXRlc3RCbG9jaygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoJ0Vycm9yIHdoaWxlIHVubG9ja2luZyBleHRlbnNpb24uJywgZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgbXVzdCBiZSBzZXQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBjb21tdW5pY2F0ZSB0byB0aGVcbiAgICAvLyBrZXlyaW5nJ3MgaWZyYW1lIGFuZCBoYXZlIHRoZSBzZXR0aW5nIGluaXRpYWxpemVkIHByb3Blcmx5XG4gICAgLy8gT3B0aW1pc3RpY2FsbHkgY2FsbGVkIHRvIG5vdCBibG9jayBNZXRhTWFzayBsb2dpbiBkdWUgdG9cbiAgICAvLyBMZWRnZXIgS2V5cmluZyBHaXRIdWIgZG93bnRpbWVcbiAgICBjb25zdCB0cmFuc3BvcnRQcmVmZXJlbmNlID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcblxuICAgIHRoaXMuc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRQcmVmZXJlbmNlKTtcblxuICAgIHJldHVybiB0aGlzLmtleXJpbmdDb250cm9sbGVyLmZ1bGxVcGRhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdWJtaXRzIGEgdXNlcidzIHBhc3N3b3JkIHRvIGNoZWNrIGl0cyB2YWxpZGl0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHVzZXIncyBwYXNzd29yZFxuICAgKi9cbiAgYXN5bmMgdmVyaWZ5UGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnZlcmlmeVBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSBJZGVudGl0eVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBhY2NvdW50IG5pY2tuYW1lLlxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBhY2NvdW50J3MgZXRoZXJldW0gYWRkcmVzcywgaW4gbG93ZXIgY2FzZS5cbiAgICogcmVjZWl2aW5nIGZ1bmRzIGZyb20gb3VyIGF1dG9tYXRpYyBSb3BzdGVuIGZhdWNldC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGZpcnN0IGFkZHJlc3MgaW4gdGhlIHN0YXRlIHRvIHRoZSBzZWxlY3RlZCBhZGRyZXNzXG4gICAqL1xuICBzZWxlY3RGaXJzdElkZW50aXR5KCkge1xuICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBbYWRkcmVzc10gPSBPYmplY3Qua2V5cyhpZGVudGl0aWVzKTtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRTZWxlY3RlZEFkZHJlc3MoYWRkcmVzcyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgbW5lbW9uaWMgb2YgdGhlIHVzZXIncyBwcmltYXJ5IGtleXJpbmcuXG4gICAqL1xuICBnZXRQcmltYXJ5S2V5cmluZ01uZW1vbmljKCkge1xuICAgIGNvbnN0IFtrZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoJ0hEIEtleSBUcmVlJyk7XG4gICAgaWYgKCFrZXlyaW5nLm1uZW1vbmljKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1hcnkga2V5cmluZyBtbmVtb25pYyB1bmF2YWlsYWJsZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXJpbmcubW5lbW9uaWM7XG4gIH1cblxuICAvL1xuICAvLyBIYXJkd2FyZVxuICAvL1xuXG4gIGFzeW5jIGdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoID0gbnVsbCkge1xuICAgIGxldCBrZXlyaW5nTmFtZSA9IG51bGw7XG4gICAgc3dpdGNoIChkZXZpY2VOYW1lKSB7XG4gICAgICBjYXNlIERFVklDRV9OQU1FUy5UUkVaT1I6XG4gICAgICAgIGtleXJpbmdOYW1lID0gVHJlem9yS2V5cmluZy50eXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgREVWSUNFX05BTUVTLkxFREdFUjpcbiAgICAgICAga2V5cmluZ05hbWUgPSBMZWRnZXJCcmlkZ2VLZXlyaW5nLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBERVZJQ0VfTkFNRVMuUVI6XG4gICAgICAgIGtleXJpbmdOYW1lID0gUVJIYXJkd2FyZUtleXJpbmcudHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERFVklDRV9OQU1FUy5MQVRUSUNFOlxuICAgICAgICBrZXlyaW5nTmFtZSA9IExhdHRpY2VLZXlyaW5nLnR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdNZXRhbWFza0NvbnRyb2xsZXI6Z2V0S2V5cmluZ0ZvckRldmljZSAtIFVua25vd24gZGV2aWNlJyxcbiAgICAgICAgKTtcbiAgICB9XG4gICAgbGV0IFtrZXlyaW5nXSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoa2V5cmluZ05hbWUpO1xuICAgIGlmICgha2V5cmluZykge1xuICAgICAga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3S2V5cmluZyhrZXlyaW5nTmFtZSk7XG4gICAgfVxuICAgIGlmIChoZFBhdGggJiYga2V5cmluZy5zZXRIZFBhdGgpIHtcbiAgICAgIGtleXJpbmcuc2V0SGRQYXRoKGhkUGF0aCk7XG4gICAgfVxuICAgIGlmIChkZXZpY2VOYW1lID09PSBERVZJQ0VfTkFNRVMuTEFUVElDRSkge1xuICAgICAga2V5cmluZy5hcHBOYW1lID0gJ01ldGFNYXNrJztcbiAgICB9XG4gICAgaWYgKGRldmljZU5hbWUgPT09IERFVklDRV9OQU1FUy5UUkVaT1IpIHtcbiAgICAgIGNvbnN0IG1vZGVsID0ga2V5cmluZy5nZXRNb2RlbCgpO1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc2V0VHJlem9yTW9kZWwobW9kZWwpO1xuICAgIH1cblxuICAgIGtleXJpbmcubmV0d29yayA9IHRoaXMubmV0d29ya0NvbnRyb2xsZXIuZ2V0UHJvdmlkZXJDb25maWcoKS50eXBlO1xuXG4gICAgcmV0dXJuIGtleXJpbmc7XG4gIH1cblxuICBhc3luYyBhdHRlbXB0TGVkZ2VyVHJhbnNwb3J0Q3JlYXRpb24oKSB7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShERVZJQ0VfTkFNRVMuTEVER0VSKTtcbiAgICByZXR1cm4gYXdhaXQga2V5cmluZy5hdHRlbXB0TWFrZUFwcCgpO1xuICB9XG5cbiAgYXN5bmMgZXN0YWJsaXNoTGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSgpIHtcbiAgICBjb25zdCB0cmFuc3BvcnRQcmVmZXJlbmNlID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydFByZWZlcmVuY2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFjY291bnQgbGlzdCBmcm9tIGEgdHJlem9yIGRldmljZS5cbiAgICpcbiAgICogQHBhcmFtIGRldmljZU5hbWVcbiAgICogQHBhcmFtIHBhZ2VcbiAgICogQHBhcmFtIGhkUGF0aFxuICAgKiBAcmV0dXJucyBbXSBhY2NvdW50c1xuICAgKi9cbiAgYXN5bmMgY29ubmVjdEhhcmR3YXJlKGRldmljZU5hbWUsIHBhZ2UsIGhkUGF0aCkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcbiAgICBsZXQgYWNjb3VudHMgPSBbXTtcbiAgICBzd2l0Y2ggKHBhZ2UpIHtcbiAgICAgIGNhc2UgLTE6XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRQcmV2aW91c1BhZ2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXROZXh0UGFnZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFjY291bnRzID0gYXdhaXQga2V5cmluZy5nZXRGaXJzdFBhZ2UoKTtcbiAgICB9XG5cbiAgICAvLyBNZXJnZSB3aXRoIGV4aXN0aW5nIGFjY291bnRzXG4gICAgLy8gYW5kIG1ha2Ugc3VyZSBhZGRyZXNzZXMgYXJlIG5vdCByZXBlYXRlZFxuICAgIGNvbnN0IG9sZEFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIGNvbnN0IGFjY291bnRzVG9UcmFjayA9IFtcbiAgICAgIC4uLm5ldyBTZXQoXG4gICAgICAgIG9sZEFjY291bnRzLmNvbmNhdChhY2NvdW50cy5tYXAoKGEpID0+IGEuYWRkcmVzcy50b0xvd2VyQ2FzZSgpKSksXG4gICAgICApLFxuICAgIF07XG4gICAgdGhpcy5hY2NvdW50VHJhY2tlci5zeW5jV2l0aEFkZHJlc3NlcyhhY2NvdW50c1RvVHJhY2spO1xuICAgIHJldHVybiBhY2NvdW50cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgZGV2aWNlIGlzIHVubG9ja2VkXG4gICAqXG4gICAqIEBwYXJhbSBkZXZpY2VOYW1lXG4gICAqIEBwYXJhbSBoZFBhdGhcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBjaGVja0hhcmR3YXJlU3RhdHVzKGRldmljZU5hbWUsIGhkUGF0aCkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcbiAgICByZXR1cm4ga2V5cmluZy5pc1VubG9ja2VkKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJcbiAgICpcbiAgICogQHBhcmFtIGRldmljZU5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59XG4gICAqL1xuICBhc3luYyBmb3JnZXREZXZpY2UoZGV2aWNlTmFtZSkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSk7XG4gICAga2V5cmluZy5mb3JnZXREZXZpY2UoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGtleXJpbmcgZm9yIHRoZSBzZWxlY3RlZCBhZGRyZXNzIGFuZCB1c2luZyB0aGUgLnR5cGUgcmV0dXJuc1xuICAgKiBhIHN1YnR5cGUgZm9yIHRoZSBhY2NvdW50LiBFaXRoZXIgJ2hhcmR3YXJlJywgJ2ltcG9ydGVkJyBvciAnTWV0YU1hc2snLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIEFkZHJlc3MgdG8gcmV0cmlldmUga2V5cmluZyBmb3JcbiAgICogQHJldHVybnMgeydoYXJkd2FyZScgfCAnaW1wb3J0ZWQnIHwgJ01ldGFNYXNrJ31cbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRUeXBlKGFkZHJlc3MpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICBzd2l0Y2ggKGtleXJpbmcudHlwZSkge1xuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLlRSRVpPUjpcbiAgICAgIGNhc2UgS0VZUklOR19UWVBFUy5MQVRUSUNFOlxuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLlFSOlxuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLkxFREdFUjpcbiAgICAgICAgcmV0dXJuICdoYXJkd2FyZSc7XG4gICAgICBjYXNlIEtFWVJJTkdfVFlQRVMuSU1QT1JURUQ6XG4gICAgICAgIHJldHVybiAnaW1wb3J0ZWQnO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdNZXRhTWFzayc7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUga2V5cmluZyBmb3IgdGhlIHNlbGVjdGVkIGFkZHJlc3MgYW5kIHVzaW5nIHRoZSAudHlwZVxuICAgKiBkZXRlcm1pbmVzIGlmIGEgbW9yZSBzcGVjaWZpYyBuYW1lIGZvciB0aGUgZGV2aWNlIGlzIGF2YWlsYWJsZS4gUmV0dXJuc1xuICAgKiAnTi9BJyBmb3Igbm9uIGhhcmR3YXJlIHdhbGxldHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gQWRkcmVzcyB0byByZXRyaWV2ZSBrZXlyaW5nIGZvclxuICAgKiBAcmV0dXJucyB7J2xlZGdlcicgfCAnbGF0dGljZScgfCAnTi9BJyB8IHN0cmluZ31cbiAgICovXG4gIGFzeW5jIGdldERldmljZU1vZGVsKGFkZHJlc3MpIHtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRLZXlyaW5nRm9yQWNjb3VudChhZGRyZXNzKTtcbiAgICBzd2l0Y2ggKGtleXJpbmcudHlwZSkge1xuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLlRSRVpPUjpcbiAgICAgICAgcmV0dXJuIGtleXJpbmcuZ2V0TW9kZWwoKTtcbiAgICAgIGNhc2UgS0VZUklOR19UWVBFUy5RUjpcbiAgICAgICAgcmV0dXJuIGtleXJpbmcuZ2V0TmFtZSgpO1xuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLkxFREdFUjpcbiAgICAgICAgLy8gVE9ETzogZ2V0IG1vZGVsIGFmdGVyIGxlZGdlciBrZXlyaW5nIGV4cG9zZXMgbWV0aG9kXG4gICAgICAgIHJldHVybiBERVZJQ0VfTkFNRVMuTEVER0VSO1xuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLkxBVFRJQ0U6XG4gICAgICAgIC8vIFRPRE86IGdldCBtb2RlbCBhZnRlciBsYXR0aWNlIGtleXJpbmcgZXhwb3NlcyBtZXRob2RcbiAgICAgICAgcmV0dXJuIERFVklDRV9OQU1FUy5MQVRUSUNFO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdOL0EnO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgaGFyZHdhcmUgYWNjb3VudCBsYWJlbFxuICAgKlxuICAgKiBAcmV0dXJucyBzdHJpbmcgbGFiZWxcbiAgICovXG5cbiAgZ2V0QWNjb3VudExhYmVsKG5hbWUsIGluZGV4LCBoZFBhdGhEZXNjcmlwdGlvbikge1xuICAgIHJldHVybiBgJHtuYW1lWzBdLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnNsaWNlKDEpfSAke1xuICAgICAgcGFyc2VJbnQoaW5kZXgsIDEwKSArIDFcbiAgICB9ICR7aGRQYXRoRGVzY3JpcHRpb24gfHwgJyd9YC50cmltKCk7XG4gIH1cblxuICAvKipcbiAgICogSW1wb3J0cyBhbiBhY2NvdW50IGZyb20gYSBUcmV6b3Igb3IgTGVkZ2VyIGRldmljZS5cbiAgICpcbiAgICogQHBhcmFtIGluZGV4XG4gICAqIEBwYXJhbSBkZXZpY2VOYW1lXG4gICAqIEBwYXJhbSBoZFBhdGhcbiAgICogQHBhcmFtIGhkUGF0aERlc2NyaXB0aW9uXG4gICAqIEByZXR1cm5zIHt9IGtleVN0YXRlXG4gICAqL1xuICBhc3luYyB1bmxvY2tIYXJkd2FyZVdhbGxldEFjY291bnQoXG4gICAgaW5kZXgsXG4gICAgZGV2aWNlTmFtZSxcbiAgICBoZFBhdGgsXG4gICAgaGRQYXRoRGVzY3JpcHRpb24sXG4gICkge1xuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmdldEtleXJpbmdGb3JEZXZpY2UoZGV2aWNlTmFtZSwgaGRQYXRoKTtcblxuICAgIGtleXJpbmcuc2V0QWNjb3VudFRvVW5sb2NrKGluZGV4KTtcbiAgICBjb25zdCBvbGRBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICBjb25zdCBrZXlTdGF0ZSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChrZXlyaW5nKTtcbiAgICBjb25zdCBuZXdBY2NvdW50cyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMobmV3QWNjb3VudHMpO1xuICAgIG5ld0FjY291bnRzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgIGlmICghb2xkQWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldEFjY291bnRMYWJlbChcbiAgICAgICAgICBkZXZpY2VOYW1lID09PSBERVZJQ0VfTkFNRVMuUVIgPyBrZXlyaW5nLmdldE5hbWUoKSA6IGRldmljZU5hbWUsXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgaGRQYXRoRGVzY3JpcHRpb24sXG4gICAgICAgICk7XG4gICAgICAgIC8vIFNldCB0aGUgYWNjb3VudCBsYWJlbCB0byBUcmV6b3IgMSAvICBMZWRnZXIgMSAvIFFSIEhhcmR3YXJlIDEsIGV0Y1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgbGFiZWwpO1xuICAgICAgICAvLyBTZWxlY3QgdGhlIGFjY291bnRcbiAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiB7IC4uLmtleVN0YXRlLCBpZGVudGl0aWVzIH07XG4gIH1cblxuICAvL1xuICAvLyBBY2NvdW50IE1hbmFnZW1lbnRcbiAgLy9cblxuICAvKipcbiAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2UgS2V5cmluZy5cbiAgICpcbiAgICogQHBhcmFtIGFjY291bnRDb3VudFxuICAgKiBAcmV0dXJucyB7fSBrZXlTdGF0ZVxuICAgKi9cbiAgYXN5bmMgYWRkTmV3QWNjb3VudChhY2NvdW50Q291bnQpIHtcbiAgICBjb25zdCBbcHJpbWFyeUtleXJpbmddID1cbiAgICAgIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoJ0hEIEtleSBUcmVlJyk7XG4gICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRhbWFza0NvbnRyb2xsZXIgLSBObyBIRCBLZXkgVHJlZSBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCB7IGtleXJpbmdDb250cm9sbGVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaWRlbnRpdGllczogb2xkSWRlbnRpdGllcyB9ID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBpZiAoT2JqZWN0LmtleXMob2xkSWRlbnRpdGllcykubGVuZ3RoID09PSBhY2NvdW50Q291bnQpIHtcbiAgICAgIGNvbnN0IG9sZEFjY291bnRzID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuZ2V0QWNjb3VudHMoKTtcbiAgICAgIGNvbnN0IGtleVN0YXRlID0gYXdhaXQga2V5cmluZ0NvbnRyb2xsZXIuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICBjb25zdCBuZXdBY2NvdW50cyA9IGF3YWl0IGtleXJpbmdDb250cm9sbGVyLmdldEFjY291bnRzKCk7XG5cbiAgICAgIGF3YWl0IHRoaXMudmVyaWZ5U2VlZFBocmFzZSgpO1xuXG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRBZGRyZXNzZXMobmV3QWNjb3VudHMpO1xuICAgICAgbmV3QWNjb3VudHMuZm9yRWFjaCgoYWRkcmVzcykgPT4ge1xuICAgICAgICBpZiAoIW9sZEFjY291bnRzLmluY2x1ZGVzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgcmV0dXJuIHsgLi4ua2V5U3RhdGUsIGlkZW50aXRpZXMgfTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUuZ2V0U3RhdGUoKSxcbiAgICAgIGlkZW50aXRpZXM6IG9sZElkZW50aXRpZXMsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZmllcyB0aGUgdmFsaWRpdHkgb2YgdGhlIGN1cnJlbnQgdmF1bHQncyBzZWVkIHBocmFzZS5cbiAgICpcbiAgICogVmFsaWRpdHk6IHNlZWQgcGhyYXNlIHJlc3RvcmVzIHRoZSBhY2NvdW50cyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgdmF1bHQuXG4gICAqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBmaXJzdCBhY2NvdW50IGlzIGNyZWF0ZWQgYW5kIG9uIHVubG9ja2luZyB0aGUgdmF1bHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlcltdPn0gVGhlIHNlZWQgcGhyYXNlIHRvIGJlIGNvbmZpcm1lZCBieSB0aGUgdXNlcixcbiAgICogZW5jb2RlZCBhcyBhbiBhcnJheSBvZiBVVEYtOCBieXRlcy5cbiAgICovXG4gIGFzeW5jIHZlcmlmeVNlZWRQaHJhc2UoKSB7XG4gICAgY29uc3QgW3ByaW1hcnlLZXlyaW5nXSA9XG4gICAgICB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKCdIRCBLZXkgVHJlZScpO1xuICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gSEQgS2V5IFRyZWUgZm91bmQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZXJpYWxpemVkID0gYXdhaXQgcHJpbWFyeUtleXJpbmcuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2VlZFBocmFzZUFzQnVmZmVyID0gQnVmZmVyLmZyb20oc2VyaWFsaXplZC5tbmVtb25pYyk7XG5cbiAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IHByaW1hcnlLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgaWYgKGFjY291bnRzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWV0YW1hc2tDb250cm9sbGVyIC0gTm8gYWNjb3VudHMgZm91bmQnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgc2VlZFBocmFzZVZlcmlmaWVyLnZlcmlmeUFjY291bnRzKGFjY291bnRzLCBzZWVkUGhyYXNlQXNCdWZmZXIpO1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20oc2VlZFBocmFzZUFzQnVmZmVyLnZhbHVlcygpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGxvZy5lcnJvcihlcnIubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFycyB0aGUgdHJhbnNhY3Rpb24gaGlzdG9yeSwgdG8gYWxsb3cgdXNlcnMgdG8gZm9yY2UtcmVzZXQgdGhlaXIgbm9uY2VzLlxuICAgKiBNb3N0bHkgdXNlZCBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMsIHdoZW4gbmV0d29ya3MgYXJlIHJlc3RhcnRlZCB3aXRoXG4gICAqIHRoZSBzYW1lIG5ldHdvcmsgSUQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IFRoZSBjdXJyZW50IHNlbGVjdGVkIGFkZHJlc3MuXG4gICAqL1xuICBhc3luYyByZXNldEFjY291bnQoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRBZGRyZXNzKCk7XG4gICAgdGhpcy50eENvbnRyb2xsZXIud2lwZVRyYW5zYWN0aW9ucyhzZWxlY3RlZEFkZHJlc3MpO1xuICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIucmVzZXRDb25uZWN0aW9uKCk7XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRBZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBlcm1pdHRlZCBhY2NvdW50cyBmb3IgdGhlIHNwZWNpZmllZCBvcmlnaW4uIFJldHVybnMgYW4gZW1wdHlcbiAgICogYXJyYXkgaWYgbm8gYWNjb3VudHMgYXJlIHBlcm1pdHRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gd2hvc2UgZXhwb3NlZCBhY2NvdW50cyB0byByZXRyaWV2ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc3VwcHJlc3NVbmF1dGhvcml6ZWRFcnJvcl0gLSBTdXBwcmVzc2VzIHRoZSB1bmF1dGhvcml6ZWQgZXJyb3IuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZ1tdPn0gVGhlIG9yaWdpbidzIHBlcm1pdHRlZCBhY2NvdW50cywgb3IgYW4gZW1wdHlcbiAgICogYXJyYXkuXG4gICAqL1xuICBhc3luYyBnZXRQZXJtaXR0ZWRBY2NvdW50cyhcbiAgICBvcmlnaW4sXG4gICAgeyBzdXBwcmVzc1VuYXV0aG9yaXplZEVycm9yID0gdHJ1ZSB9ID0ge30sXG4gICkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZChcbiAgICAgICAgb3JpZ2luLFxuICAgICAgICBSZXN0cmljdGVkTWV0aG9kcy5ldGhfYWNjb3VudHMsXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHN1cHByZXNzVW5hdXRob3JpemVkRXJyb3IgJiZcbiAgICAgICAgZXJyb3IuY29kZSA9PT0gcnBjRXJyb3JDb2Rlcy5wcm92aWRlci51bmF1dGhvcml6ZWRcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcHMgZXhwb3NpbmcgdGhlIGFjY291bnQgd2l0aCB0aGUgc3BlY2lmaWVkIGFkZHJlc3MgdG8gYWxsIHRoaXJkIHBhcnRpZXMuXG4gICAqIEV4cG9zZWQgYWNjb3VudHMgYXJlIHN0b3JlZCBpbiBjYXZlYXRzIG9mIHRoZSBldGhfYWNjb3VudHMgcGVybWlzc2lvbi4gVGhpc1xuICAgKiBtZXRob2QgdXNlcyBgUGVybWlzc2lvbkNvbnRyb2xsZXIudXBkYXRlUGVybWlzc2lvbnNCeUNhdmVhdGAgdG9cbiAgICogcmVtb3ZlIHRoZSBzcGVjaWZpZWQgYWRkcmVzcyBmcm9tIGV2ZXJ5IGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLiBJZiBhXG4gICAqIHBlcm1pc3Npb24gb25seSBpbmNsdWRlZCB0aGlzIGFkZHJlc3MsIHRoZSBwZXJtaXNzaW9uIGlzIHJldm9rZWQgZW50aXJlbHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRBY2NvdW50IC0gVGhlIGFkZHJlc3Mgb2YgdGhlIGFjY291bnQgdG8gc3RvcCBleHBvc2luZ1xuICAgKiB0byB0aGlyZCBwYXJ0aWVzLlxuICAgKi9cbiAgcmVtb3ZlQWxsQWNjb3VudFBlcm1pc3Npb25zKHRhcmdldEFjY291bnQpIHtcbiAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQoXG4gICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHMsXG4gICAgICAoZXhpc3RpbmdBY2NvdW50cykgPT5cbiAgICAgICAgQ2F2ZWF0TXV0YXRvckZhY3Rvcmllc1tcbiAgICAgICAgICBDYXZlYXRUeXBlcy5yZXN0cmljdFJldHVybmVkQWNjb3VudHNcbiAgICAgICAgXS5yZW1vdmVBY2NvdW50KHRhcmdldEFjY291bnQsIGV4aXN0aW5nQWNjb3VudHMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhY2NvdW50IGZyb20gc3RhdGUgLyBzdG9yYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZGRyZXNzIC0gQSBoZXggYWRkcmVzc1xuICAgKi9cbiAgYXN5bmMgcmVtb3ZlQWNjb3VudChhZGRyZXNzKSB7XG4gICAgLy8gUmVtb3ZlIGFsbCBhc3NvY2lhdGVkIHBlcm1pc3Npb25zXG4gICAgdGhpcy5yZW1vdmVBbGxBY2NvdW50UGVybWlzc2lvbnMoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnJlbW92ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgLy8gUmVtb3ZlIGFjY291bnQgZnJvbSB0aGUgYWNjb3VudCB0cmFja2VyIGNvbnRyb2xsZXJcbiAgICB0aGlzLmFjY291bnRUcmFja2VyLnJlbW92ZUFjY291bnQoW2FkZHJlc3NdKTtcblxuICAgIGNvbnN0IGtleXJpbmcgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdGb3JBY2NvdW50KGFkZHJlc3MpO1xuICAgIC8vIFJlbW92ZSBhY2NvdW50IGZyb20gdGhlIGtleXJpbmdcbiAgICBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLnJlbW92ZUFjY291bnQoYWRkcmVzcyk7XG4gICAgY29uc3QgdXBkYXRlZEtleXJpbmdBY2NvdW50cyA9IGtleXJpbmcgPyBhd2FpdCBrZXlyaW5nLmdldEFjY291bnRzKCkgOiB7fTtcbiAgICBpZiAodXBkYXRlZEtleXJpbmdBY2NvdW50cz8ubGVuZ3RoID09PSAwKSB7XG4gICAgICBrZXlyaW5nLmRlc3Ryb3k/LigpO1xuICAgIH1cblxuICAgIHJldHVybiBhZGRyZXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIEltcG9ydHMgYW4gYWNjb3VudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW1wb3J0IHN0cmF0ZWd5LlxuICAgKiBUaGVzZSBhcmUgZGVmaW5lZCBpbiBhcHAvc2NyaXB0cy9hY2NvdW50LWltcG9ydC1zdHJhdGVnaWVzXG4gICAqIEVhY2ggc3RyYXRlZ3kgcmVwcmVzZW50cyBhIGRpZmZlcmVudCB3YXkgb2Ygc2VyaWFsaXppbmcgYW4gRXRoZXJldW0ga2V5IHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJhdGVneSAtIEEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGFuIGFjY291bnQgaW1wb3J0IHN0cmF0ZWd5LlxuICAgKiBAcGFyYW0ge2FueX0gYXJncyAtIFRoZSBkYXRhIHJlcXVpcmVkIGJ5IHRoYXQgc3RyYXRlZ3kgdG8gaW1wb3J0IGFuIGFjY291bnQuXG4gICAqL1xuICBhc3luYyBpbXBvcnRBY2NvdW50V2l0aFN0cmF0ZWd5KHN0cmF0ZWd5LCBhcmdzKSB7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGF3YWl0IGFjY291bnRJbXBvcnRlci5pbXBvcnRBY2NvdW50KHN0cmF0ZWd5LCBhcmdzKTtcbiAgICBjb25zdCBrZXlyaW5nID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5hZGROZXdLZXlyaW5nKFxuICAgICAgJ1NpbXBsZSBLZXkgUGFpcicsXG4gICAgICBbcHJpdmF0ZUtleV0sXG4gICAgKTtcbiAgICBjb25zdCBbZmlyc3RBY2NvdW50XSA9IGF3YWl0IGtleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAvLyB1cGRhdGUgYWNjb3VudHMgaW4gcHJlZmVyZW5jZXMgY29udHJvbGxlclxuICAgIGNvbnN0IGFsbEFjY291bnRzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5nZXRBY2NvdW50cygpO1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldEFkZHJlc3NlcyhhbGxBY2NvdW50cyk7XG4gICAgLy8gc2V0IG5ldyBhY2NvdW50IGFzIHNlbGVjdGVkXG4gICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0U2VsZWN0ZWRBZGRyZXNzKGZpcnN0QWNjb3VudCk7XG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWRlbnRpdHkgTWFuYWdlbWVudCAoc2lnbmF0dXJlIG9wZXJhdGlvbnMpXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgRGFwcCBzdWdnZXN0cyBhIG5ldyB0eCB0byBiZSBzaWduZWQuXG4gICAqIHRoaXMgd3JhcHBlciBuZWVkcyB0byBleGlzdCBzbyB3ZSBjYW4gcHJvdmlkZSBhIHJlZmVyZW5jZSB0b1xuICAgKiAgXCJuZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb25cIiBiZWZvcmUgXCJ0eENvbnRyb2xsZXJcIiBpcyBpbnN0YW50aWF0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHR4UGFyYW1zIC0gVGhlIHRyYW5zYWN0aW9uIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcmVxXSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBvcmlnaW4uXG4gICAqL1xuICBhc3luYyBuZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5uZXdVbmFwcHJvdmVkVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gIH1cblxuICAvLyBldGhfc2lnbiBtZXRob2RzOlxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIERhcHAgdXNlcyB0aGUgZXRoX3NpZ24gbWV0aG9kLCB0byByZXF1ZXN0IHVzZXIgYXBwcm92YWwuXG4gICAqIGV0aF9zaWduIGlzIGEgcHVyZSBzaWduYXR1cmUgb2YgYXJiaXRyYXJ5IGRhdGEuIEl0IGlzIG9uIGEgZGVwcmVjYXRpb25cbiAgICogcGF0aCwgc2luY2UgdGhpcyBkYXRhIGNhbiBiZSBhIHRyYW5zYWN0aW9uLCBvciBjYW4gbGVhayBwcml2YXRlIGtleVxuICAgKiBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgcGFzc2VkIHRvIGV0aF9zaWduLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgKi9cbiAgYXN5bmMgbmV3VW5zaWduZWRNZXNzYWdlKG1zZ1BhcmFtcywgcmVxKSB7XG4gICAgY29uc3QgZGF0YSA9IG5vcm1hbGl6ZU1zZ0RhdGEobXNnUGFyYW1zLmRhdGEpO1xuICAgIGxldCBwcm9taXNlO1xuICAgIC8vIDY0IGhleCArIFwiMHhcIiBhdCB0aGUgYmVnaW5uaW5nXG4gICAgLy8gVGhpcyBpcyBuZWVkZWQgYmVjYXVzZSBFdGhlcmV1bSdzIEVjU2lnbiB3b3JrcyBvbmx5IG9uIDMyIGJ5dGUgbnVtYmVyc1xuICAgIC8vIEZvciA2NyBsZW5ndGggc2VlOiBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2stZXh0ZW5zaW9uL3B1bGwvMTI2NzkvZmlsZXMjcjc0OTQ3OTYwN1xuICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gNjYgfHwgZGF0YS5sZW5ndGggPT09IDY3KSB7XG4gICAgICBwcm9taXNlID0gdGhpcy5tZXNzYWdlTWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKG1zZ1BhcmFtcywgcmVxKTtcbiAgICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICAgICAgdGhpcy5vcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhcbiAgICAgICAgJ2V0aF9zaWduIHJlcXVpcmVzIDMyIGJ5dGUgbWVzc2FnZSBoYXNoJyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBwcm9taXNlO1xuICB9XG5cblxuICAvKipcbiAgICogU2lnbmlmaWVzIHVzZXIgaW50ZW50IHRvIGNvbXBsZXRlIGFuIGV0aF9zaWduIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgcGFzc2VkIHRvIGV0aF9jYWxsLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBGdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHNpZ25NZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBzaWduTWVzc2FnZScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgdHJ5IHtcbiAgICAgIC8vIHNldHMgdGhlIHN0YXR1cyBvcCB0aGUgbWVzc2FnZSB0byAnYXBwcm92ZWQnXG4gICAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3Igc2lnbmluZ1xuICAgICAgY29uc3QgY2xlYW5Nc2dQYXJhbXMgPSBhd2FpdCB0aGlzLm1lc3NhZ2VNYW5hZ2VyLmFwcHJvdmVNZXNzYWdlKFxuICAgICAgICBtc2dQYXJhbXMsXG4gICAgICApO1xuICAgICAgY29uc3QgcmF3U2lnID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5zaWduTWVzc2FnZShjbGVhbk1zZ1BhcmFtcyk7XG4gICAgICB0aGlzLm1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c1NpZ25lZChtc2dJZCwgcmF3U2lnKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfc2lnbiBmYWlsZWQnLCBlcnJvcik7XG4gICAgICB0aGlzLm1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgbWVzc2FnZSBzdWJtaXR0ZWQgdmlhIGV0aF9zaWduLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgaWQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsTWVzc2FnZShtc2dJZCkge1xuICAgIGNvbnN0IHsgbWVzc2FnZU1hbmFnZXIgfSA9IHRoaXM7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLy8gcGVyc29uYWxfc2lnbiBtZXRob2RzOlxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGRhcHAgdXNlcyB0aGUgcGVyc29uYWxfc2lnbiBtZXRob2QuXG4gICAqIFRoaXMgaXMgaWRlbnRpY2FsIHRvIHRoZSBHZXRoIGV0aF9zaWduIG1ldGhvZCwgYW5kIG1heSBldmVudHVhbGx5IHJlcGxhY2VcbiAgICogZXRoX3NpZ24uXG4gICAqXG4gICAqIFdlIGN1cnJlbnRseSBkZWZpbmUgb3VyIGV0aF9zaWduIGFuZCBwZXJzb25hbF9zaWduIG1vc3RseSBmb3IgbGVnYWN5IERhcHBzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW3JlcV0gLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgKi9cbiAgYXN5bmMgbmV3VW5zaWduZWRQZXJzb25hbE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpIHtcbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMoXG4gICAgICBtc2dQYXJhbXMsXG4gICAgICByZXEsXG4gICAgKTtcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgICB0aGlzLm9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24oKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaWduaWZpZXMgYSB1c2VyJ3MgYXBwcm92YWwgdG8gc2lnbiBhIHBlcnNvbmFsX3NpZ24gbWVzc2FnZSBpbiBxdWV1ZS5cbiAgICogVHJpZ2dlcnMgc2lnbmluZywgYW5kIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmcm9tIG5ld1Vuc2lnbmVkUGVyc29uYWxNZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxvYmplY3Q+fSBBIGZ1bGwgc3RhdGUgdXBkYXRlLlxuICAgKi9cbiAgYXN5bmMgc2lnblBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gc2lnblBlcnNvbmFsTWVzc2FnZScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgLy8gc2V0cyB0aGUgc3RhdHVzIG9wIHRoZSBtZXNzYWdlIHRvICdhcHByb3ZlZCdcbiAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3Igc2lnbmluZ1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGVhbk1zZ1BhcmFtcyA9IGF3YWl0IHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJhd1NpZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2lnblBlcnNvbmFsTWVzc2FnZShcbiAgICAgICAgY2xlYW5Nc2dQYXJhbXMsXG4gICAgICApO1xuICAgICAgLy8gdGVsbHMgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2lnbmVkXG4gICAgICAvLyBhbmQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBkYXBwXG4gICAgICB0aGlzLnBlcnNvbmFsTWVzc2FnZU1hbmFnZXIuc2V0TXNnU3RhdHVzU2lnbmVkKG1zZ0lkLCByYXdTaWcpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgbG9nLmluZm8oJ01ldGFNYXNrQ29udHJvbGxlciAtIGV0aF9wZXJzb25hbFNpZ24gZmFpbGVkJywgZXJyb3IpO1xuICAgICAgdGhpcy5wZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgcGVyc29uYWxfc2lnbiB0eXBlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dJZCAtIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byBjYW5jZWwuXG4gICAqL1xuICBjYW5jZWxQZXJzb25hbE1lc3NhZ2UobXNnSWQpIHtcbiAgICBjb25zdCBtZXNzYWdlTWFuYWdlciA9IHRoaXMucGVyc29uYWxNZXNzYWdlTWFuYWdlcjtcbiAgICBtZXNzYWdlTWFuYWdlci5yZWplY3RNc2cobXNnSWQpO1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvLyBldGhfZGVjcnlwdCBtZXRob2RzXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgZGFwcCB1c2VzIHRoZSBldGhfZGVjcnlwdCBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIG9mIHRoZSBtZXNzYWdlIHRvIHNpZ24gJiByZXR1cm4gdG8gdGhlIERhcHAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXEgLSAob3B0aW9uYWwpIHRoZSBvcmlnaW5hbCByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBvcmlnaW5cbiAgICogUGFzc2VkIGJhY2sgdG8gdGhlIHJlcXVlc3RpbmcgRGFwcC5cbiAgICovXG4gIGFzeW5jIG5ld1JlcXVlc3REZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmRlY3J5cHRNZXNzYWdlTWFuYWdlci5hZGRVbmFwcHJvdmVkTWVzc2FnZUFzeW5jKFxuICAgICAgbXNnUGFyYW1zLFxuICAgICAgcmVxLFxuICAgICk7XG4gICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgdGhpcy5vcHRzLnNob3dVc2VyQ29uZmlybWF0aW9uKCk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICAvKipcbiAgICogT25seSBkZWNyeXB0IG1lc3NhZ2UgYW5kIGRvbid0IHRvdWNoIHRyYW5zYWN0aW9uIHN0YXRlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtc2dQYXJhbXMgLSBUaGUgcGFyYW1zIG9mIHRoZSBtZXNzYWdlIHRvIGRlY3J5cHQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG9iamVjdD59IEEgZnVsbCBzdGF0ZSB1cGRhdGUuXG4gICAqL1xuICBhc3luYyBkZWNyeXB0TWVzc2FnZUlubGluZShtc2dQYXJhbXMpIHtcbiAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZGVjcnlwdE1lc3NhZ2VJbmxpbmUnKTtcbiAgICAvLyBkZWNyeXB0IHRoZSBtZXNzYWdlIGlubGluZVxuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgY29uc3QgbXNnID0gdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIuZ2V0TXNnKG1zZ0lkKTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RyaXBwZWQgPSBzdHJpcEhleFByZWZpeChtc2dQYXJhbXMuZGF0YSk7XG4gICAgICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oc3RyaXBwZWQsICdoZXgnKTtcbiAgICAgIG1zZ1BhcmFtcy5kYXRhID0gSlNPTi5wYXJzZShidWZmLnRvU3RyaW5nKCd1dGY4JykpO1xuXG4gICAgICBtc2cucmF3RGF0YSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBtc2cuZXJyb3IgPSBlLm1lc3NhZ2U7XG4gICAgfVxuICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLl91cGRhdGVNc2cobXNnKTtcblxuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogU2lnbmlmaWVzIGEgdXNlcidzIGFwcHJvdmFsIHRvIGRlY3J5cHQgYSBtZXNzYWdlIGluIHF1ZXVlLlxuICAgKiBUcmlnZ2VycyBkZWNyeXB0LCBhbmQgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGZyb20gbmV3VW5zaWduZWREZWNyeXB0TWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gZGVjcnlwdCAmIHJldHVybiB0byB0aGUgRGFwcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBmdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIGRlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcykge1xuICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBkZWNyeXB0TWVzc2FnZScpO1xuICAgIGNvbnN0IG1zZ0lkID0gbXNnUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgLy8gc2V0cyB0aGUgc3RhdHVzIG9wIHRoZSBtZXNzYWdlIHRvICdhcHByb3ZlZCdcbiAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBmb3IgZGVjcnlwdGlvblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBjbGVhbk1zZ1BhcmFtcyA9IGF3YWl0IHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLmFwcHJvdmVNZXNzYWdlKFxuICAgICAgICBtc2dQYXJhbXMsXG4gICAgICApO1xuXG4gICAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGNsZWFuTXNnUGFyYW1zLmRhdGEpO1xuICAgICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKHN0cmlwcGVkLCAnaGV4Jyk7XG4gICAgICBjbGVhbk1zZ1BhcmFtcy5kYXRhID0gSlNPTi5wYXJzZShidWZmLnRvU3RyaW5nKCd1dGY4JykpO1xuXG4gICAgICAvLyBkZWNyeXB0IHRoZSBtZXNzYWdlXG4gICAgICBjb25zdCByYXdNZXNzID0gYXdhaXQgdGhpcy5rZXlyaW5nQ29udHJvbGxlci5kZWNyeXB0TWVzc2FnZShcbiAgICAgICAgY2xlYW5Nc2dQYXJhbXMsXG4gICAgICApO1xuICAgICAgLy8gdGVsbHMgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gZGVjcnlwdGVkIGFuZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIGRhcHBcbiAgICAgIHRoaXMuZGVjcnlwdE1lc3NhZ2VNYW5hZ2VyLnNldE1zZ1N0YXR1c0RlY3J5cHRlZChtc2dJZCwgcmF3TWVzcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGxvZy5pbmZvKCdNZXRhTWFza0NvbnRyb2xsZXIgLSBldGhfZGVjcnlwdCBmYWlsZWQuJywgZXJyb3IpO1xuICAgICAgdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXIuZXJyb3JNZXNzYWdlKG1zZ0lkLCBlcnJvcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjYW5jZWwgYSBldGhfZGVjcnlwdCB0eXBlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtc2dJZCAtIFRoZSBJRCBvZiB0aGUgbWVzc2FnZSB0byBjYW5jZWwuXG4gICAqL1xuICBjYW5jZWxEZWNyeXB0TWVzc2FnZShtc2dJZCkge1xuICAgIGNvbnN0IG1lc3NhZ2VNYW5hZ2VyID0gdGhpcy5kZWNyeXB0TWVzc2FnZU1hbmFnZXI7XG4gICAgbWVzc2FnZU1hbmFnZXIucmVqZWN0TXNnKG1zZ0lkKTtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLy8gZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgbWV0aG9kc1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBhIGRhcHAgdXNlcyB0aGUgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduICYgcmV0dXJuIHRvIHRoZSBEYXBwLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcmVxIC0gKG9wdGlvbmFsKSB0aGUgb3JpZ2luYWwgcmVxdWVzdCwgY29udGFpbmluZyB0aGUgb3JpZ2luXG4gICAqIFBhc3NlZCBiYWNrIHRvIHRoZSByZXF1ZXN0aW5nIERhcHAuXG4gICAqL1xuICBhc3luYyBuZXdSZXF1ZXN0RW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMsIHJlcSkge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBtc2dQYXJhbXM7XG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ0ZvckFjY291bnQoYWRkcmVzcyk7XG5cbiAgICBzd2l0Y2ggKGtleXJpbmcudHlwZSkge1xuICAgICAgY2FzZSBLRVlSSU5HX1RZUEVTLkxFREdFUjoge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcignTGVkZ2VyIGRvZXMgbm90IHN1cHBvcnQgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkuJyksXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNhc2UgS0VZUklOR19UWVBFUy5UUkVaT1I6IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICBuZXcgRXJyb3IoJ1RyZXpvciBkb2VzIG5vdCBzdXBwb3J0IGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5LicpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEtFWVJJTkdfVFlQRVMuTEFUVElDRToge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBFcnJvcignTGF0dGljZSBkb2VzIG5vdCBzdXBwb3J0IGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5LicpLFxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYXNlIEtFWVJJTkdfVFlQRVMuUVI6IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcignUVIgaGFyZHdhcmUgZG9lcyBub3Qgc3VwcG9ydCBldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleS4nKSxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBwcm9taXNlID1cbiAgICAgICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLmFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMoXG4gICAgICAgICAgICBtc2dQYXJhbXMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgKTtcbiAgICAgICAgdGhpcy5zZW5kVXBkYXRlKCk7XG4gICAgICAgIHRoaXMub3B0cy5zaG93VXNlckNvbmZpcm1hdGlvbigpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2lnbmlmaWVzIGEgdXNlcidzIGFwcHJvdmFsIHRvIHJlY2VpdmluZyBlbmNyeXB0aW9uIHB1YmxpYyBrZXkgaW4gcXVldWUuXG4gICAqIFRyaWdnZXJzIHJlY2VpdmluZywgYW5kIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBmcm9tIG5ld1Vuc2lnbmVkRW5jcnlwdGlvblB1YmxpY0tleS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gcmVjZWl2ZSAmIHJldHVybiB0byB0aGUgRGFwcC5cbiAgICogQHJldHVybnMge1Byb21pc2U8b2JqZWN0Pn0gQSBmdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIGVuY3J5cHRpb25QdWJsaWNLZXkobXNnUGFyYW1zKSB7XG4gICAgbG9nLmluZm8oJ01ldGFNYXNrQ29udHJvbGxlciAtIGVuY3J5cHRpb25QdWJsaWNLZXknKTtcbiAgICBjb25zdCBtc2dJZCA9IG1zZ1BhcmFtcy5tZXRhbWFza0lkO1xuICAgIC8vIHNldHMgdGhlIHN0YXR1cyBvcCB0aGUgbWVzc2FnZSB0byAnYXBwcm92ZWQnXG4gICAgLy8gYW5kIHJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgZm9yIGRlY3J5cHRpb25cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gYXdhaXQgdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlci5hcHByb3ZlTWVzc2FnZShcbiAgICAgICAgbXNnUGFyYW1zLFxuICAgICAgKTtcblxuICAgICAgLy8gRW5jcnlwdGlvblB1YmxpY0tleSBtZXNzYWdlXG4gICAgICBjb25zdCBwdWJsaWNLZXkgPSBhd2FpdCB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEVuY3J5cHRpb25QdWJsaWNLZXkoXG4gICAgICAgIHBhcmFtcy5kYXRhLFxuICAgICAgKTtcblxuICAgICAgLy8gdGVsbHMgdGhlIGxpc3RlbmVyIHRoYXQgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgICAvLyBhbmQgY2FuIGJlIHJldHVybmVkIHRvIHRoZSBkYXBwXG4gICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLnNldE1zZ1N0YXR1c1JlY2VpdmVkKG1zZ0lkLCBwdWJsaWNLZXkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuaW5mbyhcbiAgICAgICAgJ01ldGFNYXNrQ29udHJvbGxlciAtIGV0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5IGZhaWxlZC4nLFxuICAgICAgICBlcnJvcixcbiAgICAgICk7XG4gICAgICB0aGlzLmVuY3J5cHRpb25QdWJsaWNLZXlNYW5hZ2VyLmVycm9yTWVzc2FnZShtc2dJZCwgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY2FuY2VsIGEgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXkgdHlwZSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbXNnSWQgLSBUaGUgSUQgb2YgdGhlIG1lc3NhZ2UgdG8gY2FuY2VsLlxuICAgKi9cbiAgY2FuY2VsRW5jcnlwdGlvblB1YmxpY0tleShtc2dJZCkge1xuICAgIGNvbnN0IG1lc3NhZ2VNYW5hZ2VyID0gdGhpcy5lbmNyeXB0aW9uUHVibGljS2V5TWFuYWdlcjtcbiAgICBtZXNzYWdlTWFuYWdlci5yZWplY3RNc2cobXNnSWQpO1xuICAgIHJldHVybiB0aGlzLmdldFN0YXRlKCk7XG4gIH1cblxuICAvLyBldGhfc2lnblR5cGVkRGF0YSBtZXRob2RzXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgZGFwcCB1c2VzIHRoZSBldGhfc2lnblR5cGVkRGF0YSBtZXRob2QsIHBlciBFSVAgNzEyLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBwYXNzZWQgdG8gZXRoX3NpZ25UeXBlZERhdGEuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBbcmVxXSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0LCBjb250YWluaW5nIHRoZSBvcmlnaW4uXG4gICAqIEBwYXJhbSB2ZXJzaW9uXG4gICAqL1xuICBuZXdVbnNpZ25lZFR5cGVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbikge1xuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXIuYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhcbiAgICAgIG1zZ1BhcmFtcyxcbiAgICAgIHJlcSxcbiAgICAgIHZlcnNpb24sXG4gICAgKTtcbiAgICB0aGlzLnNlbmRVcGRhdGUoKTtcbiAgICB0aGlzLm9wdHMuc2hvd1VzZXJDb25maXJtYXRpb24oKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbWV0aG9kIGZvciBhIHVzZXIgYXBwcm92aW5nIGEgY2FsbCB0byBldGhfc2lnblR5cGVkRGF0YSwgcGVyIEVJUCA3MTIuXG4gICAqIFRyaWdnZXJzIHRoZSBjYWxsYmFjayBpbiBuZXdVbnNpZ25lZFR5cGVkTWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgcGFzc2VkIHRvIGV0aF9zaWduVHlwZWREYXRhLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBGdWxsIHN0YXRlIHVwZGF0ZS5cbiAgICovXG4gIGFzeW5jIHNpZ25UeXBlZE1lc3NhZ2UobXNnUGFyYW1zKSB7XG4gICAgbG9nLmluZm8oJ01ldGFNYXNrQ29udHJvbGxlciAtIGV0aF9zaWduVHlwZWREYXRhJyk7XG4gICAgY29uc3QgbXNnSWQgPSBtc2dQYXJhbXMubWV0YW1hc2tJZDtcbiAgICBjb25zdCB7IHZlcnNpb24gfSA9IG1zZ1BhcmFtcztcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2xlYW5Nc2dQYXJhbXMgPSBhd2FpdCB0aGlzLnR5cGVkTWVzc2FnZU1hbmFnZXIuYXBwcm92ZU1lc3NhZ2UoXG4gICAgICAgIG1zZ1BhcmFtcyxcbiAgICAgICk7XG5cbiAgICAgIC8vIEZvciBzb21lIHJlYXNvbiBldmVyeSB2ZXJzaW9uIGFmdGVyIFYxIHVzZWQgc3RyaW5naWZpZWQgcGFyYW1zLlxuICAgICAgaWYgKHZlcnNpb24gIT09ICdWMScpIHtcbiAgICAgICAgLy8gQnV0IHdlIGRvbid0IGhhdmUgdG8gcmVxdWlyZSB0aGF0LiBXZSBjYW4gc3RvcCBzdWdnZXN0aW5nIGl0IG5vdzpcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhbk1zZ1BhcmFtcy5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNsZWFuTXNnUGFyYW1zLmRhdGEgPSBKU09OLnBhcnNlKGNsZWFuTXNnUGFyYW1zLmRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuc2lnblR5cGVkTWVzc2FnZShcbiAgICAgICAgY2xlYW5Nc2dQYXJhbXMsXG4gICAgICAgIHsgdmVyc2lvbiB9LFxuICAgICAgKTtcbiAgICAgIHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5zZXRNc2dTdGF0dXNTaWduZWQobXNnSWQsIHNpZ25hdHVyZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBsb2cuaW5mbygnTWV0YU1hc2tDb250cm9sbGVyIC0gZXRoX3NpZ25UeXBlZERhdGEgZmFpbGVkLicsIGVycm9yKTtcbiAgICAgIHRoaXMudHlwZWRNZXNzYWdlTWFuYWdlci5lcnJvck1lc3NhZ2UobXNnSWQsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNhbmNlbCBhIGV0aF9zaWduVHlwZWREYXRhIHR5cGUgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZ0lkIC0gVGhlIElEIG9mIHRoZSBtZXNzYWdlIHRvIGNhbmNlbC5cbiAgICovXG4gIGNhbmNlbFR5cGVkTWVzc2FnZShtc2dJZCkge1xuICAgIGNvbnN0IG1lc3NhZ2VNYW5hZ2VyID0gdGhpcy50eXBlZE1lc3NhZ2VNYW5hZ2VyO1xuICAgIG1lc3NhZ2VNYW5hZ2VyLnJlamVjdE1zZyhtc2dJZCk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUga2V5cmluZyB0eXBlIHN1cHBvcnRzIEVJUC0xNTU5XG4gICAqL1xuICBhc3luYyBnZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBFTkQgKFZBVUxUIC8gS0VZUklORyBSRUxBVEVEIE1FVEhPRFMpXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogQWxsb3dzIGEgdXNlciB0byBhdHRlbXB0IHRvIGNhbmNlbCBhIHByZXZpb3VzbHkgc3VibWl0dGVkIHRyYW5zYWN0aW9uXG4gICAqIGJ5IGNyZWF0aW5nIGEgbmV3IHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luYWxUeElkIC0gdGhlIGlkIG9mIHRoZSB0eE1ldGEgdGhhdCB5b3Ugd2FudCB0b1xuICAgKiAgYXR0ZW1wdCB0byBjYW5jZWxcbiAgICogQHBhcmFtIHtpbXBvcnQoXG4gICAqICAnLi9jb250cm9sbGVycy90cmFuc2FjdGlvbnMnXG4gICAqICkuQ3VzdG9tR2FzU2V0dGluZ3N9IFtjdXN0b21HYXNTZXR0aW5nc10gLSBvdmVycmlkZXMgdG8gdXNlIGZvciBnYXMgcGFyYW1zXG4gICAqICBpbnN0ZWFkIG9mIGFsbG93aW5nIHRoaXMgbWV0aG9kIHRvIGdlbmVyYXRlIHRoZW1cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHJldHVybnMge29iamVjdH0gTWV0YU1hc2sgc3RhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZUNhbmNlbFRyYW5zYWN0aW9uKG9yaWdpbmFsVHhJZCwgY3VzdG9tR2FzU2V0dGluZ3MsIG9wdGlvbnMpIHtcbiAgICBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5jcmVhdGVDYW5jZWxUcmFuc2FjdGlvbihcbiAgICAgIG9yaWdpbmFsVHhJZCxcbiAgICAgIGN1c3RvbUdhc1NldHRpbmdzLFxuICAgICAgb3B0aW9ucyxcbiAgICApO1xuICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgdGhpcy5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiBzdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIGF0dGVtcHQgdG8gc3BlZWQgdXAgYSBwcmV2aW91c2x5IHN1Ym1pdHRlZCB0cmFuc2FjdGlvblxuICAgKiBieSBjcmVhdGluZyBhIG5ldyB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9yaWdpbmFsVHhJZCAtIHRoZSBpZCBvZiB0aGUgdHhNZXRhIHRoYXQgeW91IHdhbnQgdG9cbiAgICogIGF0dGVtcHQgdG8gc3BlZWQgdXBcbiAgICogQHBhcmFtIHtpbXBvcnQoXG4gICAqICAnLi9jb250cm9sbGVycy90cmFuc2FjdGlvbnMnXG4gICAqICkuQ3VzdG9tR2FzU2V0dGluZ3N9IFtjdXN0b21HYXNTZXR0aW5nc10gLSBvdmVycmlkZXMgdG8gdXNlIGZvciBnYXMgcGFyYW1zXG4gICAqICBpbnN0ZWFkIG9mIGFsbG93aW5nIHRoaXMgbWV0aG9kIHRvIGdlbmVyYXRlIHRoZW1cbiAgICogQHBhcmFtIG9wdGlvbnNcbiAgICogQHJldHVybnMge29iamVjdH0gTWV0YU1hc2sgc3RhdGVcbiAgICovXG4gIGFzeW5jIGNyZWF0ZVNwZWVkVXBUcmFuc2FjdGlvbihvcmlnaW5hbFR4SWQsIGN1c3RvbUdhc1NldHRpbmdzLCBvcHRpb25zKSB7XG4gICAgYXdhaXQgdGhpcy50eENvbnRyb2xsZXIuY3JlYXRlU3BlZWRVcFRyYW5zYWN0aW9uKFxuICAgICAgb3JpZ2luYWxUeElkLFxuICAgICAgY3VzdG9tR2FzU2V0dGluZ3MsXG4gICAgICBvcHRpb25zLFxuICAgICk7XG4gICAgY29uc3Qgc3RhdGUgPSBhd2FpdCB0aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9XG5cbiAgZXN0aW1hdGVHYXMoZXN0aW1hdGVHYXNQYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMudHhDb250cm9sbGVyLnR4R2FzVXRpbC5xdWVyeS5lc3RpbWF0ZUdhcyhcbiAgICAgICAgZXN0aW1hdGVHYXNQYXJhbXMsXG4gICAgICAgIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXMudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFBBU1NXT1JEIE1BTkFHRU1FTlRcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBBbGxvd3MgYSB1c2VyIHRvIGJlZ2luIHRoZSBzZWVkIHBocmFzZSByZWNvdmVyeSBwcm9jZXNzLlxuICAgKi9cbiAgbWFya1Bhc3N3b3JkRm9yZ290dGVuKCkge1xuICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnNldFBhc3N3b3JkRm9yZ290dGVuKHRydWUpO1xuICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93cyBhIHVzZXIgdG8gZW5kIHRoZSBzZWVkIHBocmFzZSByZWNvdmVyeSBwcm9jZXNzLlxuICAgKi9cbiAgdW5NYXJrUGFzc3dvcmRGb3Jnb3R0ZW4oKSB7XG4gICAgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2V0UGFzc3dvcmRGb3Jnb3R0ZW4oZmFsc2UpO1xuICAgIHRoaXMuc2VuZFVwZGF0ZSgpO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBTRVRVUFxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEEgcnVudGltZS5NZXNzYWdlU2VuZGVyIG9iamVjdCwgYXMgcHJvdmlkZWQgYnkgdGhlIGJyb3dzZXI6XG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL0FkZC1vbnMvV2ViRXh0ZW5zaW9ucy9BUEkvcnVudGltZS9NZXNzYWdlU2VuZGVyXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IE1lc3NhZ2VTZW5kZXJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IC0gVGhlIFVSTCBvZiB0aGUgcGFnZSBvciBmcmFtZSBob3N0aW5nIHRoZSBzY3JpcHQgdGhhdCBzZW50IHRoZSBtZXNzYWdlLlxuICAgKi9cblxuICAvKipcbiAgICogQSBTbmFwIHNlbmRlciBvYmplY3QuXG4gICAqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IFNuYXBTZW5kZXJcbiAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNuYXBJZCAtIFRoZSBJRCBvZiB0aGUgc25hcC5cbiAgICovXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gY3JlYXRlIGEgbXVsdGlwbGV4ZWQgc3RyZWFtIGZvciBjb25uZWN0aW5nIHRvIGFuIHVudHJ1c3RlZCBjb250ZXh0XG4gICAqIGxpa2UgYSBEYXBwIG9yIG90aGVyIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gb3B0aW9ucy5jb25uZWN0aW9uU3RyZWFtIC0gVGhlIER1cGxleCBzdHJlYW0gdG8gY29ubmVjdCB0by5cbiAgICogQHBhcmFtIHtNZXNzYWdlU2VuZGVyIHwgU25hcFNlbmRlcn0gb3B0aW9ucy5zZW5kZXIgLSBUaGUgc2VuZGVyIG9mIHRoZSBtZXNzYWdlcyBvbiB0aGlzIHN0cmVhbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnN1YmplY3RUeXBlXSAtIFRoZSB0eXBlIG9mIHRoZSBzZW5kZXIsIGkuZS4gc3ViamVjdC5cbiAgICovXG4gIHNldHVwVW50cnVzdGVkQ29tbXVuaWNhdGlvbih7IGNvbm5lY3Rpb25TdHJlYW0sIHNlbmRlciwgc3ViamVjdFR5cGUgfSkge1xuICAgIGNvbnN0IHsgdXNlUGhpc2hEZXRlY3QgfSA9IHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICBsZXQgX3N1YmplY3RUeXBlO1xuICAgIGlmIChzdWJqZWN0VHlwZSkge1xuICAgICAgX3N1YmplY3RUeXBlID0gc3ViamVjdFR5cGU7XG4gICAgfSBlbHNlIGlmIChzZW5kZXIuaWQgJiYgc2VuZGVyLmlkICE9PSB0aGlzLmV4dGVuc2lvbi5ydW50aW1lLmlkKSB7XG4gICAgICBfc3ViamVjdFR5cGUgPSBTVUJKRUNUX1RZUEVTLkVYVEVOU0lPTjtcbiAgICB9IGVsc2Uge1xuICAgICAgX3N1YmplY3RUeXBlID0gU1VCSkVDVF9UWVBFUy5XRUJTSVRFO1xuICAgIH1cblxuICAgIGlmIChzZW5kZXIudXJsKSB7XG4gICAgICBjb25zdCB7IGhvc3RuYW1lIH0gPSBuZXcgVVJMKHNlbmRlci51cmwpO1xuICAgICAgY29uc3QgcGhpc2hpbmdMaXN0c0FyZU91dE9mRGF0ZSA9IHRoaXMucGhpc2hpbmdDb250cm9sbGVyLmlzT3V0T2ZEYXRlKCk7XG4gICAgICBpZiAocGhpc2hpbmdMaXN0c0FyZU91dE9mRGF0ZSkge1xuICAgICAgICB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci51cGRhdGVQaGlzaGluZ0xpc3RzKCk7XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiBuZXcgY29ubmVjdGlvbiBpcyBibG9ja2VkIGlmIHBoaXNoaW5nIGRldGVjdGlvbiBpcyBvblxuICAgICAgY29uc3QgcGhpc2hpbmdUZXN0UmVzcG9uc2UgPSB0aGlzLnBoaXNoaW5nQ29udHJvbGxlci50ZXN0KGhvc3RuYW1lKTtcbiAgICAgIGlmICh1c2VQaGlzaERldGVjdCAmJiBwaGlzaGluZ1Rlc3RSZXNwb25zZT8ucmVzdWx0KSB7XG4gICAgICAgIHRoaXMuc2VuZFBoaXNoaW5nV2FybmluZyhcbiAgICAgICAgICBjb25uZWN0aW9uU3RyZWFtLFxuICAgICAgICAgIGhvc3RuYW1lLFxuICAgICAgICAgIHBoaXNoaW5nVGVzdFJlc3BvbnNlLFxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgbXVsdGlwbGV4aW5nXG4gICAgY29uc3QgbXV4ID0gc2V0dXBNdWx0aXBsZXgoY29ubmVjdGlvblN0cmVhbSk7XG5cbiAgICAvLyBtZXNzYWdlcyBiZXR3ZWVuIGlucGFnZSBhbmQgYmFja2dyb3VuZFxuICAgIHRoaXMuc2V0dXBQcm92aWRlckNvbm5lY3Rpb24oXG4gICAgICBtdXguY3JlYXRlU3RyZWFtKCdtZXRhbWFzay1wcm92aWRlcicpLFxuICAgICAgc2VuZGVyLFxuICAgICAgX3N1YmplY3RUeXBlLFxuICAgICk7XG5cbiAgICAvLyBUT0RPOkxlZ2FjeVByb3ZpZGVyOiBEZWxldGVcbiAgICBpZiAoc2VuZGVyLnVybCkge1xuICAgICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICAgIHRoaXMuc2V0dXBQdWJsaWNDb25maWcobXV4LmNyZWF0ZVN0cmVhbSgncHVibGljQ29uZmlnJykpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byBhIHRydXN0ZWQgY29udGV4dCxcbiAgICogbGlrZSBvdXIgb3duIHVzZXIgaW50ZXJmYWNlcywgd2hpY2ggaGF2ZSB0aGUgcHJvdmlkZXIgQVBJcywgYnV0IGFsc29cbiAgICogcmVjZWl2ZSB0aGUgZXhwb3J0ZWQgQVBJIGZyb20gdGhpcyBjb250cm9sbGVyLCB3aGljaCBpbmNsdWRlcyB0cnVzdGVkXG4gICAqIGZ1bmN0aW9ucywgbGlrZSB0aGUgYWJpbGl0eSB0byBhcHByb3ZlIHRyYW5zYWN0aW9ucyBvciBzaWduIG1lc3NhZ2VzLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGNvbm5lY3Rpb25TdHJlYW0gLSBUaGUgZHVwbGV4IHN0cmVhbSB0byBjb25uZWN0IHRvLlxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXJ9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2VzIG9uIHRoaXMgc3RyZWFtXG4gICAqL1xuICBzZXR1cFRydXN0ZWRDb21tdW5pY2F0aW9uKGNvbm5lY3Rpb25TdHJlYW0sIHNlbmRlcikge1xuICAgIC8vIHNldHVwIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xuICAgIC8vIGNvbm5lY3QgZmVhdHVyZXNcbiAgICB0aGlzLnNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24obXV4LmNyZWF0ZVN0cmVhbSgnY29udHJvbGxlcicpKTtcbiAgICB0aGlzLnNldHVwUHJvdmlkZXJDb25uZWN0aW9uKFxuICAgICAgbXV4LmNyZWF0ZVN0cmVhbSgncHJvdmlkZXInKSxcbiAgICAgIHNlbmRlcixcbiAgICAgIFNVQkpFQ1RfVFlQRVMuSU5URVJOQUwsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGNyZWF0ZSBhIG11bHRpcGxleGVkIHN0cmVhbSBmb3IgY29ubmVjdGluZyB0byB0aGUgcGhpc2hpbmcgd2FybmluZyBwYWdlLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgKiBAcGFyYW0ge1JlYWRhYmxlU3RyZWFtfSBvcHRpb25zLmNvbm5lY3Rpb25TdHJlYW0gLSBUaGUgRHVwbGV4IHN0cmVhbSB0byBjb25uZWN0IHRvLlxuICAgKi9cbiAgc2V0dXBQaGlzaGluZ0NvbW11bmljYXRpb24oeyBjb25uZWN0aW9uU3RyZWFtIH0pIHtcbiAgICBjb25zdCB7IHVzZVBoaXNoRGV0ZWN0IH0gPSB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zdG9yZS5nZXRTdGF0ZSgpO1xuXG4gICAgaWYgKCF1c2VQaGlzaERldGVjdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHNldHVwIG11bHRpcGxleGluZ1xuICAgIGNvbnN0IG11eCA9IHNldHVwTXVsdGlwbGV4KGNvbm5lY3Rpb25TdHJlYW0pO1xuICAgIGNvbnN0IHBoaXNoaW5nU3RyZWFtID0gbXV4LmNyZWF0ZVN0cmVhbShQSElTSElOR19TQUZFTElTVCk7XG5cbiAgICAvLyBzZXQgdXAgcG9zdFN0cmVhbSB0cmFuc3BvcnRcbiAgICBwaGlzaGluZ1N0cmVhbS5vbihcbiAgICAgICdkYXRhJyxcbiAgICAgIGNyZWF0ZU1ldGFSUENIYW5kbGVyKFxuICAgICAgICB7IHNhZmVsaXN0UGhpc2hpbmdEb21haW46IHRoaXMuc2FmZWxpc3RQaGlzaGluZ0RvbWFpbi5iaW5kKHRoaXMpIH0sXG4gICAgICAgIHBoaXNoaW5nU3RyZWFtLFxuICAgICAgKSxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHdlIGRldGVjdCBhIHN1c3BpY2lvdXMgZG9tYWluLiBSZXF1ZXN0cyB0aGUgYnJvd3NlciByZWRpcmVjdHNcbiAgICogdG8gb3VyIGFudGktcGhpc2hpbmcgcGFnZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHsqfSBjb25uZWN0aW9uU3RyZWFtIC0gVGhlIGR1cGxleCBzdHJlYW0gdG8gdGhlIHBlci1wYWdlIHNjcmlwdCxcbiAgICogZm9yIHNlbmRpbmcgdGhlIHJlbG9hZCBhdHRlbXB0IHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdG5hbWUgLSBUaGUgaG9zdG5hbWUgdGhhdCB0cmlnZ2VyZWQgdGhlIHN1c3BpY2lvbi5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBoaXNoaW5nVGVzdFJlc3BvbnNlIC0gUmVzdWx0IG9mIGNhbGxpbmcgYHBoaXNoaW5nQ29udHJvbGxlci50ZXN0YCxcbiAgICogd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIGV0aC1waGlzaGluZy1kZXRlY3RzIGRldGVjdG9yLmNoZWNrIG1ldGhvZCBodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svZXRoLXBoaXNoaW5nLWRldGVjdC9ibG9iL21hc3Rlci9zcmMvZGV0ZWN0b3IuanMjTDU1LUwxMTJcbiAgICovXG4gIHNlbmRQaGlzaGluZ1dhcm5pbmcoY29ubmVjdGlvblN0cmVhbSwgaG9zdG5hbWUsIHBoaXNoaW5nVGVzdFJlc3BvbnNlKSB7XG4gICAgY29uc3QgbmV3SXNzdWVVcmwgPSBQSElTSElOR19ORVdfSVNTVUVfVVJMU1twaGlzaGluZ1Rlc3RSZXNwb25zZT8ubmFtZV07XG5cbiAgICBjb25zdCBtdXggPSBzZXR1cE11bHRpcGxleChjb25uZWN0aW9uU3RyZWFtKTtcbiAgICBjb25zdCBwaGlzaGluZ1N0cmVhbSA9IG11eC5jcmVhdGVTdHJlYW0oJ3BoaXNoaW5nJyk7XG4gICAgcGhpc2hpbmdTdHJlYW0ud3JpdGUoeyBob3N0bmFtZSwgbmV3SXNzdWVVcmwgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHByb3ZpZGluZyBvdXIgQVBJIG92ZXIgYSBzdHJlYW0gdXNpbmcgSlNPTi1SUEMuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb3V0U3RyZWFtIC0gVGhlIHN0cmVhbSB0byBwcm92aWRlIG91ciBBUEkgb3Zlci5cbiAgICovXG4gIHNldHVwQ29udHJvbGxlckNvbm5lY3Rpb24ob3V0U3RyZWFtKSB7XG4gICAgY29uc3QgYXBpID0gdGhpcy5nZXRBcGkoKTtcblxuICAgIC8vIHJlcG9ydCBuZXcgYWN0aXZlIGNvbnRyb2xsZXIgY29ubmVjdGlvblxuICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zICs9IDE7XG4gICAgdGhpcy5lbWl0KCdjb250cm9sbGVyQ29ubmVjdGlvbkNoYW5nZWQnLCB0aGlzLmFjdGl2ZUNvbnRyb2xsZXJDb25uZWN0aW9ucyk7XG5cbiAgICAvLyBzZXQgdXAgcG9zdFN0cmVhbSB0cmFuc3BvcnRcbiAgICBvdXRTdHJlYW0ub24oXG4gICAgICAnZGF0YScsXG4gICAgICBjcmVhdGVNZXRhUlBDSGFuZGxlcihcbiAgICAgICAgYXBpLFxuICAgICAgICBvdXRTdHJlYW0sXG4gICAgICAgIHRoaXMuc3RvcmUsXG4gICAgICAgIHRoaXMubG9jYWxTdG9yZUFwaVdyYXBwZXIsXG4gICAgICApLFxuICAgICk7XG4gICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKHVwZGF0ZSkgPT4ge1xuICAgICAgaWYgKG91dFN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBzZW5kIG5vdGlmaWNhdGlvbiB0byBjbGllbnQtc2lkZVxuICAgICAgb3V0U3RyZWFtLndyaXRlKHtcbiAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgIG1ldGhvZDogJ3NlbmRVcGRhdGUnLFxuICAgICAgICBwYXJhbXM6IFt1cGRhdGVdLFxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uKCd1cGRhdGUnLCBoYW5kbGVVcGRhdGUpO1xuICAgIG91dFN0cmVhbS5vbignZW5kJywgKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmVDb250cm9sbGVyQ29ubmVjdGlvbnMgLT0gMTtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgJ2NvbnRyb2xsZXJDb25uZWN0aW9uQ2hhbmdlZCcsXG4gICAgICAgIHRoaXMuYWN0aXZlQ29udHJvbGxlckNvbm5lY3Rpb25zLFxuICAgICAgKTtcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHNlcnZpbmcgb3VyIGV0aGVyZXVtIHByb3ZpZGVyIG92ZXIgYSBnaXZlbiBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gb3V0U3RyZWFtIC0gVGhlIHN0cmVhbSB0byBwcm92aWRlIG92ZXIuXG4gICAqIEBwYXJhbSB7TWVzc2FnZVNlbmRlciB8IFNuYXBTZW5kZXJ9IHNlbmRlciAtIFRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2VzIG9uIHRoaXMgc3RyZWFtXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqZWN0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzZW5kZXIsIGkuZS4gc3ViamVjdC5cbiAgICovXG4gIHNldHVwUHJvdmlkZXJDb25uZWN0aW9uKG91dFN0cmVhbSwgc2VuZGVyLCBzdWJqZWN0VHlwZSkge1xuICAgIGxldCBvcmlnaW47XG4gICAgaWYgKHN1YmplY3RUeXBlID09PSBTVUJKRUNUX1RZUEVTLklOVEVSTkFMKSB7XG4gICAgICBvcmlnaW4gPSBPUklHSU5fTUVUQU1BU0s7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgb3JpZ2luID0gbmV3IFVSTChzZW5kZXIudXJsKS5vcmlnaW47XG4gICAgfVxuXG4gICAgaWYgKHNlbmRlci5pZCAmJiBzZW5kZXIuaWQgIT09IHRoaXMuZXh0ZW5zaW9uLnJ1bnRpbWUuaWQpIHtcbiAgICAgIHRoaXMuc3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5hZGRTdWJqZWN0TWV0YWRhdGEoe1xuICAgICAgICBvcmlnaW4sXG4gICAgICAgIGV4dGVuc2lvbklkOiBzZW5kZXIuaWQsXG4gICAgICAgIHN1YmplY3RUeXBlOiBTVUJKRUNUX1RZUEVTLkVYVEVOU0lPTixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGxldCB0YWJJZDtcbiAgICBpZiAoc2VuZGVyLnRhYiAmJiBzZW5kZXIudGFiLmlkKSB7XG4gICAgICB0YWJJZCA9IHNlbmRlci50YWIuaWQ7XG4gICAgfVxuXG4gICAgY29uc3QgZW5naW5lID0gdGhpcy5zZXR1cFByb3ZpZGVyRW5naW5lKHtcbiAgICAgIG9yaWdpbixcbiAgICAgIHNlbmRlcixcbiAgICAgIHN1YmplY3RUeXBlLFxuICAgICAgdGFiSWQsXG4gICAgfSk7XG5cbiAgICAvLyBzZXR1cCBjb25uZWN0aW9uXG4gICAgY29uc3QgcHJvdmlkZXJTdHJlYW0gPSBjcmVhdGVFbmdpbmVTdHJlYW0oeyBlbmdpbmUgfSk7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uSWQgPSB0aGlzLmFkZENvbm5lY3Rpb24ob3JpZ2luLCB7IGVuZ2luZSB9KTtcblxuICAgIHB1bXAob3V0U3RyZWFtLCBwcm92aWRlclN0cmVhbSwgb3V0U3RyZWFtLCAoZXJyKSA9PiB7XG4gICAgICAvLyBoYW5kbGUgYW55IG1pZGRsZXdhcmUgY2xlYW51cFxuICAgICAgZW5naW5lLl9taWRkbGV3YXJlLmZvckVhY2goKG1pZCkgPT4ge1xuICAgICAgICBpZiAobWlkLmRlc3Ryb3kgJiYgdHlwZW9mIG1pZC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbWlkLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25uZWN0aW9uSWQgJiYgdGhpcy5yZW1vdmVDb25uZWN0aW9uKG9yaWdpbiwgY29ubmVjdGlvbklkKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBwcm92aWRlciB0aGF0IGlzIHNhZmVseSByZXN0cmljdGVkIGZvciB0aGUgcmVxdWVzdGluZyBzdWJqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIFByb3ZpZGVyIGVuZ2luZSBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLm9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHNlbmRlclxuICAgKiBAcGFyYW0ge01lc3NhZ2VTZW5kZXIgfCBTbmFwU2VuZGVyfSBvcHRpb25zLnNlbmRlciAtIFRoZSBzZW5kZXIgb2JqZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5zdWJqZWN0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzZW5kZXIgc3ViamVjdC5cbiAgICogQHBhcmFtIHt0YWJJZH0gW29wdGlvbnMudGFiSWRdIC0gVGhlIHRhYiBJRCBvZiB0aGUgc2VuZGVyIC0gaWYgdGhlIHNlbmRlciBpcyB3aXRoaW4gYSB0YWJcbiAgICovXG4gIHNldHVwUHJvdmlkZXJFbmdpbmUoeyBvcmlnaW4sIHN1YmplY3RUeXBlLCBzZW5kZXIsIHRhYklkIH0pIHtcbiAgICAvLyBzZXR1cCBqc29uIHJwYyBlbmdpbmUgc3RhY2tcbiAgICBjb25zdCBlbmdpbmUgPSBuZXcgSnNvblJwY0VuZ2luZSgpO1xuICAgIGNvbnN0IHsgYmxvY2tUcmFja2VyLCBwcm92aWRlciB9ID0gdGhpcztcblxuICAgIC8vIGNyZWF0ZSBmaWx0ZXIgcG9seWZpbGwgbWlkZGxld2FyZVxuICAgIGNvbnN0IGZpbHRlck1pZGRsZXdhcmUgPSBjcmVhdGVGaWx0ZXJNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciB9KTtcblxuICAgIC8vIGNyZWF0ZSBzdWJzY3JpcHRpb24gcG9seWZpbGwgbWlkZGxld2FyZVxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbk1hbmFnZXIgPSBjcmVhdGVTdWJzY3JpcHRpb25NYW5hZ2VyKHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgYmxvY2tUcmFja2VyLFxuICAgIH0pO1xuICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIuZXZlbnRzLm9uKCdub3RpZmljYXRpb24nLCAobWVzc2FnZSkgPT5cbiAgICAgIGVuZ2luZS5lbWl0KCdub3RpZmljYXRpb24nLCBtZXNzYWdlKSxcbiAgICApO1xuXG4gICAgLy8gYXBwZW5kIG9yaWdpbiB0byBlYWNoIHJlcXVlc3RcbiAgICBlbmdpbmUucHVzaChjcmVhdGVPcmlnaW5NaWRkbGV3YXJlKHsgb3JpZ2luIH0pKTtcblxuICAgIC8vIGFwcGVuZCB0YWJJZCB0byBlYWNoIHJlcXVlc3QgaWYgaXQgZXhpc3RzXG4gICAgaWYgKHRhYklkKSB7XG4gICAgICBlbmdpbmUucHVzaChjcmVhdGVUYWJJZE1pZGRsZXdhcmUoeyB0YWJJZCB9KSk7XG4gICAgfVxuXG4gICAgLy8gbG9nZ2luZ1xuICAgIGVuZ2luZS5wdXNoKGNyZWF0ZUxvZ2dlck1pZGRsZXdhcmUoeyBvcmlnaW4gfSkpO1xuICAgIGVuZ2luZS5wdXNoKHRoaXMucGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIuY3JlYXRlTWlkZGxld2FyZSgpKTtcblxuICAgIGVuZ2luZS5wdXNoKFxuICAgICAgY3JlYXRlUlBDTWV0aG9kVHJhY2tpbmdNaWRkbGV3YXJlKHtcbiAgICAgICAgdHJhY2tFdmVudDogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuICAgICAgICBnZXRNZXRyaWNzU3RhdGU6IHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLnN0b3JlLmdldFN0YXRlLmJpbmQoXG4gICAgICAgICAgdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIuc3RvcmUsXG4gICAgICAgICksXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gb25ib2FyZGluZ1xuICAgIGlmIChzdWJqZWN0VHlwZSA9PT0gU1VCSkVDVF9UWVBFUy5XRUJTSVRFKSB7XG4gICAgICBlbmdpbmUucHVzaChcbiAgICAgICAgY3JlYXRlT25ib2FyZGluZ01pZGRsZXdhcmUoe1xuICAgICAgICAgIGxvY2F0aW9uOiBzZW5kZXIudXJsLFxuICAgICAgICAgIHJlZ2lzdGVyT25ib2FyZGluZzogdGhpcy5vbmJvYXJkaW5nQ29udHJvbGxlci5yZWdpc3Rlck9uYm9hcmRpbmcsXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBVbnJlc3RyaWN0ZWQvcGVybWlzc2lvbmxlc3MgUlBDIG1ldGhvZCBpbXBsZW1lbnRhdGlvbnNcbiAgICBlbmdpbmUucHVzaChcbiAgICAgIGNyZWF0ZU1ldGhvZE1pZGRsZXdhcmUoe1xuICAgICAgICBvcmlnaW4sXG5cbiAgICAgICAgc3ViamVjdFR5cGUsXG5cbiAgICAgICAgLy8gTWlzY2VsbGFuZW91c1xuICAgICAgICBhZGRTdWJqZWN0TWV0YWRhdGE6XG4gICAgICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmFkZFN1YmplY3RNZXRhZGF0YS5iaW5kKFxuICAgICAgICAgICAgdGhpcy5zdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICAgIGdldFByb3ZpZGVyU3RhdGU6IHRoaXMuZ2V0UHJvdmlkZXJTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICBnZXRVbmxvY2tQcm9taXNlOiB0aGlzLmFwcFN0YXRlQ29udHJvbGxlci5nZXRVbmxvY2tQcm9taXNlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIGhhbmRsZVdhdGNoQXNzZXRSZXF1ZXN0OiB0aGlzLnRva2Vuc0NvbnRyb2xsZXIud2F0Y2hBc3NldC5iaW5kKFxuICAgICAgICAgIHRoaXMudG9rZW5zQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgcmVxdWVzdFVzZXJBcHByb3ZhbDpcbiAgICAgICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlci5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0LmJpbmQoXG4gICAgICAgICAgICB0aGlzLmFwcHJvdmFsQ29udHJvbGxlcixcbiAgICAgICAgICApLFxuICAgICAgICBzZW5kTWV0cmljczogdGhpcy5tZXRhTWV0cmljc0NvbnRyb2xsZXIudHJhY2tFdmVudC5iaW5kKFxuICAgICAgICAgIHRoaXMubWV0YU1ldHJpY3NDb250cm9sbGVyLFxuICAgICAgICApLFxuXG4gICAgICAgIC8vIFBlcm1pc3Npb24tcmVsYXRlZFxuICAgICAgICBnZXRBY2NvdW50czogdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cy5iaW5kKHRoaXMsIG9yaWdpbiksXG4gICAgICAgIGdldFBlcm1pc3Npb25zRm9yT3JpZ2luOiB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmdldFBlcm1pc3Npb25zLmJpbmQoXG4gICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICksXG4gICAgICAgIGhhc1Blcm1pc3Npb246IHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIuaGFzUGVybWlzc2lvbi5iaW5kKFxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIsXG4gICAgICAgICAgb3JpZ2luLFxuICAgICAgICApLFxuICAgICAgICByZXF1ZXN0QWNjb3VudHNQZXJtaXNzaW9uOlxuICAgICAgICAgIHRoaXMucGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zLmJpbmQoXG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLFxuICAgICAgICAgICAgeyBvcmlnaW4gfSxcbiAgICAgICAgICAgIHsgZXRoX2FjY291bnRzOiB7fSB9LFxuICAgICAgICAgICksXG4gICAgICAgIHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbjpcbiAgICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9ucy5iaW5kKFxuICAgICAgICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlcixcbiAgICAgICAgICAgIHsgb3JpZ2luIH0sXG4gICAgICAgICAgKSxcblxuICAgICAgICAvLyBDdXN0b20gUlBDLXJlbGF0ZWRcbiAgICAgICAgYWRkQ3VzdG9tUnBjOiBhc3luYyAoe1xuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgYmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgY2hhaW5OYW1lLFxuICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgfSA9IHt9KSA9PiB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWRkVG9GcmVxdWVudFJwY0xpc3QoXG4gICAgICAgICAgICBycGNVcmwsXG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgdGlja2VyLFxuICAgICAgICAgICAgY2hhaW5OYW1lLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBibG9ja0V4cGxvcmVyVXJsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kQ3VzdG9tUnBjQnk6IHRoaXMuZmluZEN1c3RvbVJwY0J5LmJpbmQodGhpcyksXG4gICAgICAgIGdldEN1cnJlbnRDaGFpbklkOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLmdldEN1cnJlbnRDaGFpbklkLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgZ2V0Q3VycmVudFJwY1VybDogdGhpcy5uZXR3b3JrQ29udHJvbGxlci5nZXRDdXJyZW50UnBjVXJsLmJpbmQoXG4gICAgICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlcixcbiAgICAgICAgKSxcbiAgICAgICAgc2V0UHJvdmlkZXJUeXBlOiB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFByb3ZpZGVyVHlwZS5iaW5kKFxuICAgICAgICAgIHRoaXMubmV0d29ya0NvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIHVwZGF0ZVJwY1RhcmdldDogKHsgcnBjVXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lIH0pID0+IHtcbiAgICAgICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFJwY1RhcmdldChcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgICBuaWNrbmFtZSxcbiAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFdlYjMgc2hpbS1yZWxhdGVkXG4gICAgICAgIGdldFdlYjNTaGltVXNhZ2VTdGF0ZTogdGhpcy5hbGVydENvbnRyb2xsZXIuZ2V0V2ViM1NoaW1Vc2FnZVN0YXRlLmJpbmQoXG4gICAgICAgICAgdGhpcy5hbGVydENvbnRyb2xsZXIsXG4gICAgICAgICksXG4gICAgICAgIHNldFdlYjNTaGltVXNhZ2VSZWNvcmRlZDpcbiAgICAgICAgICB0aGlzLmFsZXJ0Q29udHJvbGxlci5zZXRXZWIzU2hpbVVzYWdlUmVjb3JkZWQuYmluZChcbiAgICAgICAgICAgIHRoaXMuYWxlcnRDb250cm9sbGVyLFxuICAgICAgICAgICksXG4gICAgICB9KSxcbiAgICApO1xuXG5cbiAgICAvLyBmaWx0ZXIgYW5kIHN1YnNjcmlwdGlvbiBwb2x5ZmlsbHNcbiAgICBlbmdpbmUucHVzaChmaWx0ZXJNaWRkbGV3YXJlKTtcbiAgICBlbmdpbmUucHVzaChzdWJzY3JpcHRpb25NYW5hZ2VyLm1pZGRsZXdhcmUpO1xuICAgIGlmIChzdWJqZWN0VHlwZSAhPT0gU1VCSkVDVF9UWVBFUy5JTlRFUk5BTCkge1xuICAgICAgLy8gcGVybWlzc2lvbnNcbiAgICAgIGVuZ2luZS5wdXNoKFxuICAgICAgICB0aGlzLnBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlKHtcbiAgICAgICAgICBvcmlnaW4sXG4gICAgICAgIH0pLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBmb3J3YXJkIHRvIG1ldGFtYXNrIHByaW1hcnkgcHJvdmlkZXJcbiAgICBlbmdpbmUucHVzaChwcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikpO1xuICAgIHJldHVybiBlbmdpbmU7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzpMZWdhY3lQcm92aWRlcjogRGVsZXRlXG4gICAqIEEgbWV0aG9kIGZvciBwcm92aWRpbmcgb3VyIHB1YmxpYyBjb25maWcgaW5mbyBvdmVyIGEgc3RyZWFtLlxuICAgKiBUaGlzIGluY2x1ZGVzIGluZm8gd2UgbGlrZSB0byBiZSBzeW5jaHJvbm91cyBpZiBwb3NzaWJsZSwgbGlrZVxuICAgKiB0aGUgY3VycmVudCBzZWxlY3RlZCBhY2NvdW50LCBhbmQgbmV0d29yayBJRC5cbiAgICpcbiAgICogU2luY2Ugc3luY2hyb25vdXMgbWV0aG9kcyBoYXZlIGJlZW4gZGVwcmVjYXRlZCBpbiB3ZWIzLFxuICAgKiB0aGlzIGlzIGEgZ29vZCBjYW5kaWRhdGUgZm9yIGRlcHJlY2F0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IG91dFN0cmVhbSAtIFRoZSBzdHJlYW0gdG8gcHJvdmlkZSBwdWJsaWMgY29uZmlnIG92ZXIuXG4gICAqL1xuICBzZXR1cFB1YmxpY0NvbmZpZyhvdXRTdHJlYW0pIHtcbiAgICBjb25zdCBjb25maWdTdHJlYW0gPSBzdG9yZUFzU3RyZWFtKHRoaXMucHVibGljQ29uZmlnU3RvcmUpO1xuXG4gICAgcHVtcChjb25maWdTdHJlYW0sIG91dFN0cmVhbSwgKGVycikgPT4ge1xuICAgICAgY29uZmlnU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgbG9nLmVycm9yKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHJlZmVyZW5jZSB0byBhIGNvbm5lY3Rpb24gYnkgb3JpZ2luLiBJZ25vcmVzIHRoZSAnbWV0YW1hc2snIG9yaWdpbi5cbiAgICogQ2FsbGVyIG11c3QgZW5zdXJlIHRoYXQgdGhlIHJldHVybmVkIGlkIGlzIHN0b3JlZCBzdWNoIHRoYXQgdGhlIHJlZmVyZW5jZVxuICAgKiBjYW4gYmUgZGVsZXRlZCBsYXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBjb25uZWN0aW9uJ3Mgb3JpZ2luIHN0cmluZy5cbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29ubmVjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucy5lbmdpbmUgLSBUaGUgY29ubmVjdGlvbidzIEpTT04gUnBjIEVuZ2luZVxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29ubmVjdGlvbidzIGlkIChzbyB0aGF0IGl0IGNhbiBiZSBkZWxldGVkIGxhdGVyKVxuICAgKi9cbiAgYWRkQ29ubmVjdGlvbihvcmlnaW4sIHsgZW5naW5lIH0pIHtcbiAgICBpZiAob3JpZ2luID09PSBPUklHSU5fTUVUQU1BU0spIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dKSB7XG4gICAgICB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0gPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBpZCA9IG5hbm9pZCgpO1xuICAgIHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXVtpZF0gPSB7XG4gICAgICBlbmdpbmUsXG4gICAgfTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgcmVmZXJlbmNlIHRvIGEgY29ubmVjdGlvbiwgYnkgb3JpZ2luIGFuZCBpZC5cbiAgICogSWdub3JlcyB1bmtub3duIG9yaWdpbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcmlnaW4gLSBUaGUgY29ubmVjdGlvbidzIG9yaWdpbiBzdHJpbmcuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBjb25uZWN0aW9uJ3MgaWQsIGFzIHJldHVybmVkIGZyb20gYWRkQ29ubmVjdGlvbi5cbiAgICovXG4gIHJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dO1xuICAgIGlmICghY29ubmVjdGlvbnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgY29ubmVjdGlvbnNbaWRdO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKGNvbm5lY3Rpb25zKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgY29ubmVjdGlvbnMgZm9yIHRoZSBnaXZlbiBvcmlnaW4sIGFuZCByZW1vdmVzIHRoZSByZWZlcmVuY2VzXG4gICAqIHRvIHRoZW0uXG4gICAqIElnbm9yZXMgdW5rbm93biBvcmlnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIG9yaWdpbiBzdHJpbmcuXG4gICAqL1xuICByZW1vdmVBbGxDb25uZWN0aW9ucyhvcmlnaW4pIHtcbiAgICBjb25zdCBjb25uZWN0aW9ucyA9IHRoaXMuY29ubmVjdGlvbnNbb3JpZ2luXTtcbiAgICBpZiAoIWNvbm5lY3Rpb25zKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LmtleXMoY29ubmVjdGlvbnMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZUNvbm5lY3Rpb24ob3JpZ2luLCBpZCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2F1c2VzIHRoZSBSUEMgZW5naW5lcyBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbm5lY3Rpb25zIHRvIHRoZSBnaXZlbiBvcmlnaW5cbiAgICogdG8gZW1pdCBhIG5vdGlmaWNhdGlvbiBldmVudCB3aXRoIHRoZSBnaXZlbiBwYXlsb2FkLlxuICAgKlxuICAgKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IG9ubHkgcGVybWl0dGVkIG5vdGlmaWNhdGlvbnNcbiAgICogYXJlIHNlbnQuXG4gICAqXG4gICAqIElnbm9yZXMgdW5rbm93biBvcmlnaW5zLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luIC0gVGhlIGNvbm5lY3Rpb24ncyBvcmlnaW4gc3RyaW5nLlxuICAgKiBAcGFyYW0ge3Vua25vd259IHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZC5cbiAgICovXG4gIG5vdGlmeUNvbm5lY3Rpb25zKG9yaWdpbiwgcGF5bG9hZCkge1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdGhpcy5jb25uZWN0aW9uc1tvcmlnaW5dO1xuXG4gICAgaWYgKGNvbm5lY3Rpb25zKSB7XG4gICAgICBPYmplY3QudmFsdWVzKGNvbm5lY3Rpb25zKS5mb3JFYWNoKChjb25uKSA9PiB7XG4gICAgICAgIGlmIChjb25uLmVuZ2luZSkge1xuICAgICAgICAgIGNvbm4uZW5naW5lLmVtaXQoJ25vdGlmaWNhdGlvbicsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2F1c2VzIHRoZSBSUEMgZW5naW5lcyBhc3NvY2lhdGVkIHdpdGggYWxsIGNvbm5lY3Rpb25zIHRvIGVtaXQgYVxuICAgKiBub3RpZmljYXRpb24gZXZlbnQgd2l0aCB0aGUgZ2l2ZW4gcGF5bG9hZC5cbiAgICpcbiAgICogSWYgdGhlIFwicGF5bG9hZFwiIHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uLCB0aGUgcGF5bG9hZCBmb3IgZWFjaCBjb25uZWN0aW9uXG4gICAqIHdpbGwgYmUgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGF0IGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHRoZSBjb25uZWN0aW9uJ3NcbiAgICogb3JpZ2luLlxuICAgKlxuICAgKiBUaGUgY2FsbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBlbnN1cmluZyB0aGF0IG9ubHkgcGVybWl0dGVkIG5vdGlmaWNhdGlvbnNcbiAgICogYXJlIHNlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGF5bG9hZCAtIFRoZSBldmVudCBwYXlsb2FkLCBvciBwYXlsb2FkIGdldHRlciBmdW5jdGlvbi5cbiAgICovXG4gIG5vdGlmeUFsbENvbm5lY3Rpb25zKHBheWxvYWQpIHtcbiAgICBjb25zdCBnZXRQYXlsb2FkID1cbiAgICAgIHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gKG9yaWdpbikgPT4gcGF5bG9hZChvcmlnaW4pXG4gICAgICAgIDogKCkgPT4gcGF5bG9hZDtcblxuICAgIE9iamVjdC5rZXlzKHRoaXMuY29ubmVjdGlvbnMpLmZvckVhY2goKG9yaWdpbikgPT4ge1xuICAgICAgT2JqZWN0LnZhbHVlcyh0aGlzLmNvbm5lY3Rpb25zW29yaWdpbl0pLmZvckVhY2goYXN5bmMgKGNvbm4pID0+IHtcbiAgICAgICAgaWYgKGNvbm4uZW5naW5lKSB7XG4gICAgICAgICAgY29ubi5lbmdpbmUuZW1pdCgnbm90aWZpY2F0aW9uJywgYXdhaXQgZ2V0UGF5bG9hZChvcmlnaW4pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBoYW5kbGVyc1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBLZXlyaW5nQ29udHJvbGxlciB1cGRhdGVcbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gdGhlIEtDIHN0YXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX29uS2V5cmluZ0NvbnRyb2xsZXJVcGRhdGUoc3RhdGUpIHtcbiAgICBjb25zdCB7IGtleXJpbmdzIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBrZXlyaW5ncy5yZWR1Y2UoXG4gICAgICAoYWNjLCB7IGFjY291bnRzIH0pID0+IGFjYy5jb25jYXQoYWNjb3VudHMpLFxuICAgICAgW10sXG4gICAgKTtcblxuICAgIGlmICghYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSBwcmVmZXJlbmNlcyArIGlkZW50aXRpZXMgY29udHJvbGxlciBrbm93IGFib3V0IGFsbCBhZGRyZXNzZXNcbiAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zeW5jQWRkcmVzc2VzKGFkZHJlc3Nlcyk7XG4gICAgdGhpcy5hY2NvdW50VHJhY2tlci5zeW5jV2l0aEFkZHJlc3NlcyhhZGRyZXNzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBnbG9iYWwgYXBwbGljYXRpb24gdW5sb2NrLlxuICAgKiBOb3RpZmllcyBhbGwgY29ubmVjdGlvbnMgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIHVubG9ja2VkLCBhbmQgd2hpY2hcbiAgICogYWNjb3VudChzKSBhcmUgY3VycmVudGx5IGFjY2Vzc2libGUsIGlmIGFueS5cbiAgICovXG4gIF9vblVubG9jaygpIHtcbiAgICB0aGlzLm5vdGlmeUFsbENvbm5lY3Rpb25zKGFzeW5jIChvcmlnaW4pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLnVubG9ja1N0YXRlQ2hhbmdlZCxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaXNVbmxvY2tlZDogdHJ1ZSxcbiAgICAgICAgICBhY2NvdW50czogYXdhaXQgdGhpcy5nZXRQZXJtaXR0ZWRBY2NvdW50cyhvcmlnaW4pLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIEluIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uLCB0aGlzIGhhbmRsZXIgaXMgdHJpZ2dlcmVkIGJ5IGFcbiAgICAvLyBLZXlyaW5nQ29udHJvbGxlciBldmVudC4gT3RoZXIgY29udHJvbGxlcnMgc3Vic2NyaWJlIHRvIHRoZSAndW5sb2NrJ1xuICAgIC8vIGV2ZW50IG9mIHRoZSBNZXRhTWFza0NvbnRyb2xsZXIgaXRzZWxmLlxuICAgIHRoaXMuZW1pdCgndW5sb2NrJyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGdsb2JhbCBhcHBsaWNhdGlvbiBsb2NrLlxuICAgKiBOb3RpZmllcyBhbGwgY29ubmVjdGlvbnMgdGhhdCB0aGUgZXh0ZW5zaW9uIGlzIGxvY2tlZC5cbiAgICovXG4gIF9vbkxvY2soKSB7XG4gICAgdGhpcy5ub3RpZnlBbGxDb25uZWN0aW9ucyh7XG4gICAgICBtZXRob2Q6IE5PVElGSUNBVElPTl9OQU1FUy51bmxvY2tTdGF0ZUNoYW5nZWQsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgaXNVbmxvY2tlZDogZmFsc2UsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gSW4gdGhlIGN1cnJlbnQgaW1wbGVtZW50YXRpb24sIHRoaXMgaGFuZGxlciBpcyB0cmlnZ2VyZWQgYnkgYVxuICAgIC8vIEtleXJpbmdDb250cm9sbGVyIGV2ZW50LiBPdGhlciBjb250cm9sbGVycyBzdWJzY3JpYmUgdG8gdGhlICdsb2NrJ1xuICAgIC8vIGV2ZW50IG9mIHRoZSBNZXRhTWFza0NvbnRyb2xsZXIgaXRzZWxmLlxuICAgIHRoaXMuZW1pdCgnbG9jaycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtZW1vcnkgc3RhdGUgdXBkYXRlcy5cbiAgICogLSBFbnN1cmUgaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgaXMgdXBkYXRlZFxuICAgKiAtIE5vdGlmaWVzIGFsbCBjb25uZWN0aW9ucyB3aXRoIHRoZSBuZXcgcHJvdmlkZXIgbmV0d29yayBzdGF0ZVxuICAgKiAgIC0gVGhlIGV4dGVybmFsIHByb3ZpZGVycyBoYW5kbGUgZGlmZmluZyB0aGUgc3RhdGVcbiAgICpcbiAgICogQHBhcmFtIG5ld1N0YXRlXG4gICAqL1xuICBfb25TdGF0ZVVwZGF0ZShuZXdTdGF0ZSkge1xuICAgIHRoaXMuaXNDbGllbnRPcGVuQW5kVW5sb2NrZWQgPSBuZXdTdGF0ZS5pc1VubG9ja2VkICYmIHRoaXMuX2lzQ2xpZW50T3BlbjtcbiAgICB0aGlzLm5vdGlmeUFsbENvbm5lY3Rpb25zKHtcbiAgICAgIG1ldGhvZDogTk9USUZJQ0FUSU9OX05BTUVTLmNoYWluQ2hhbmdlZCxcbiAgICAgIHBhcmFtczogdGhpcy5nZXRQcm92aWRlck5ldHdvcmtTdGF0ZShuZXdTdGF0ZSksXG4gICAgfSk7XG4gIH1cblxuICAvLyBtaXNjXG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBlbWl0dGluZyB0aGUgZnVsbCBNZXRhTWFzayBzdGF0ZSB0byBhbGwgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlU2VuZFVwZGF0ZSgpIHtcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGV4dGVuc2lvbiBpcyB1bmxvY2tlZC5cbiAgICovXG4gIGlzVW5sb2NrZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5cmluZ0NvbnRyb2xsZXIubWVtU3RvcmUuZ2V0U3RhdGUoKS5pc1VubG9ja2VkO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBNSVNDRUxMQU5FT1VTXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBnZXRFeHRlcm5hbFBlbmRpbmdUcmFuc2FjdGlvbnMoYWRkcmVzcykge1xuICAgIHJldHVybiB0aGlzLnNtYXJ0VHJhbnNhY3Rpb25zQ29udHJvbGxlci5nZXRUcmFuc2FjdGlvbnMoe1xuICAgICAgYWRkcmVzc0Zyb206IGFkZHJlc3MsXG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBub25jZSB0aGF0IHdpbGwgYmUgYXNzb2NpYXRlZCB3aXRoIGEgdHJhbnNhY3Rpb24gb25jZSBhcHByb3ZlZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBoZXggc3RyaW5nIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGVuZGluZ05vbmNlKGFkZHJlc3MpIHtcbiAgICBjb25zdCB7IG5vbmNlRGV0YWlscywgcmVsZWFzZUxvY2sgfSA9XG4gICAgICBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5ub25jZVRyYWNrZXIuZ2V0Tm9uY2VMb2NrKGFkZHJlc3MpO1xuICAgIGNvbnN0IHBlbmRpbmdOb25jZSA9IG5vbmNlRGV0YWlscy5wYXJhbXMuaGlnaGVzdFN1Z2dlc3RlZDtcblxuICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgcmV0dXJuIHBlbmRpbmdOb25jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vbmNlIGFjY29yZGluZyB0byB0aGUgbm9uY2UtdHJhY2tlclxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBoZXggc3RyaW5nIGFkZHJlc3MgZm9yIHRoZSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxudW1iZXI+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TmV4dE5vbmNlKGFkZHJlc3MpIHtcbiAgICBjb25zdCBub25jZUxvY2sgPSBhd2FpdCB0aGlzLnR4Q29udHJvbGxlci5ub25jZVRyYWNrZXIuZ2V0Tm9uY2VMb2NrKFxuICAgICAgYWRkcmVzcyxcbiAgICApO1xuICAgIG5vbmNlTG9jay5yZWxlYXNlTG9jaygpO1xuICAgIHJldHVybiBub25jZUxvY2submV4dE5vbmNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1pZ3JhdGUgYWRkcmVzcyBib29rIHN0YXRlIGZyb20gb2xkIHRvIG5ldyBjaGFpbklkLlxuICAgKlxuICAgKiBBZGRyZXNzIGJvb2sgc3RhdGUgaXMga2V5ZWQgYnkgdGhlIGBuZXR3b3JrU3RvcmVgIHN0YXRlIGZyb20gdGhlIG5ldHdvcmsgY29udHJvbGxlci4gVGhpcyB2YWx1ZSBpcyBzZXQgdG8gdGhlXG4gICAqIGBuZXR3b3JrSWRgIGZvciBvdXIgYnVpbHQtaW4gSW5mdXJhIG5ldHdvcmtzLCBidXQgaXQncyBzZXQgdG8gdGhlIGBjaGFpbklkYCBmb3IgY3VzdG9tIG5ldHdvcmtzLlxuICAgKiBXaGVuIHRoaXMgYGNoYWluSWRgIHZhbHVlIGlzIGNoYW5nZWQgZm9yIGN1c3RvbSBSUEMgZW5kcG9pbnRzLCB3ZSBuZWVkIHRvIG1pZ3JhdGUgYW55IGNvbnRhY3RzIHN0b3JlZCB1bmRlciB0aGVcbiAgICogb2xkIGtleSB0byB0aGUgbmV3IGtleS5cbiAgICpcbiAgICogVGhlIGBkdXBsaWNhdGVgIHBhcmFtZXRlciBpcyB1c2VkIHRvIHNwZWNpZnkgdGhhdCB0aGUgY29udGFjdHMgdW5kZXIgdGhlIG9sZCBrZXkgc2hvdWxkIG5vdCBiZSByZW1vdmVkLiBUaGlzIGlzXG4gICAqIHVzZWZ1bCBpbiB0aGUgY2FzZSB3aGVyZSB0d28gUlBDIGVuZHBvaW50cyBzaGFyZWQgdGhlIHNhbWUgc2V0IG9mIGNvbnRhY3RzLCBhbmQgd2UncmUgbm90IHN1cmUgd2hpY2ggb25lIGVhY2hcbiAgICogY29udGFjdCBiZWxvbmdzIHVuZGVyLiBEdXBsaWNhdGluZyB0aGUgY29udGFjdHMgdW5kZXIgYm90aCBrZXlzIGlzIHRoZSBvbmx5IHdheSB0byBlbnN1cmUgdGhleSBhcmUgbm90IGxvc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRDaGFpbklkIC0gVGhlIG9sZCBjaGFpbklkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdDaGFpbklkIC0gVGhlIG5ldyBjaGFpbklkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2R1cGxpY2F0ZV0gLSBXaGV0aGVyIHRvIGR1cGxpY2F0ZSB0aGUgYWRkcmVzc2VzIG9uIGJvdGggY2hhaW5JZHMgKGRlZmF1bHQ6IGZhbHNlKVxuICAgKi9cbiAgYXN5bmMgbWlncmF0ZUFkZHJlc3NCb29rU3RhdGUob2xkQ2hhaW5JZCwgbmV3Q2hhaW5JZCwgZHVwbGljYXRlID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IGFkZHJlc3NCb29rIH0gPSB0aGlzLmFkZHJlc3NCb29rQ29udHJvbGxlci5zdGF0ZTtcblxuICAgIGlmICghYWRkcmVzc0Jvb2tbb2xkQ2hhaW5JZF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2tbb2xkQ2hhaW5JZF0pKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGFkZHJlc3NCb29rW29sZENoYWluSWRdW2FkZHJlc3NdO1xuICAgICAgdGhpcy5hZGRyZXNzQm9va0NvbnRyb2xsZXIuc2V0KFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBlbnRyeS5uYW1lLFxuICAgICAgICBuZXdDaGFpbklkLFxuICAgICAgICBlbnRyeS5tZW1vLFxuICAgICAgKTtcbiAgICAgIGlmICghZHVwbGljYXRlKSB7XG4gICAgICAgIHRoaXMuYWRkcmVzc0Jvb2tDb250cm9sbGVyLmRlbGV0ZShvbGRDaGFpbklkLCBhZGRyZXNzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIENPTkZJR1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgLy8gTG9nIGJsb2Nrc1xuXG4gIC8qKlxuICAgKiBBIG1ldGhvZCBmb3Igc2VsZWN0aW5nIGEgY3VzdG9tIFVSTCBmb3IgYW4gZXRoZXJldW0gUlBDIHByb3ZpZGVyIGFuZCB1cGRhdGluZyBpdFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcnBjVXJsIC0gQSBVUkwgZm9yIGEgdmFsaWQgRXRoZXJldW0gUlBDIEFQSS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgY2hhaW5JZCBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRpY2tlciAtIFRoZSB0aWNrZXIgc3ltYm9sIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25pY2tuYW1lXSAtIE5pY2tuYW1lIG9mIHRoZSBzZWxlY3RlZCBuZXR3b3JrLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW3JwY1ByZWZzXSAtIFJQQyBwcmVmZXJlbmNlcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtycGNQcmVmcy5ibG9ja0V4cGxvcmVyVXJsXSAtIFVSTCBvZiBibG9jayBleHBsb3JlciBmb3IgdGhlIGNoYWluLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgUlBDIFRhcmdldCBVUkwgY29uZmlybWVkLlxuICAgKi9cbiAgYXN5bmMgdXBkYXRlQW5kU2V0Q3VzdG9tUnBjKFxuICAgIHJwY1VybCxcbiAgICBjaGFpbklkLFxuICAgIHRpY2tlciA9ICdFVEgnLFxuICAgIG5pY2tuYW1lLFxuICAgIHJwY1ByZWZzLFxuICApIHtcbiAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFJwY1RhcmdldChcbiAgICAgIHJwY1VybCxcbiAgICAgIGNoYWluSWQsXG4gICAgICB0aWNrZXIsXG4gICAgICBuaWNrbmFtZSxcbiAgICAgIHJwY1ByZWZzLFxuICAgICk7XG4gICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIudXBkYXRlUnBjKHtcbiAgICAgIHJwY1VybCxcbiAgICAgIGNoYWluSWQsXG4gICAgICB0aWNrZXIsXG4gICAgICBuaWNrbmFtZSxcbiAgICAgIHJwY1ByZWZzLFxuICAgIH0pO1xuICAgIHJldHVybiBycGNVcmw7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHNlbGVjdGluZyBhIGN1c3RvbSBVUkwgZm9yIGFuIGV0aGVyZXVtIFJQQyBwcm92aWRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJwY1VybCAtIEEgVVJMIGZvciBhIHZhbGlkIEV0aGVyZXVtIFJQQyBBUEkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFpbklkIC0gVGhlIGNoYWluSWQgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0aWNrZXIgLSBUaGUgdGlja2VyIHN5bWJvbCBvZiB0aGUgc2VsZWN0ZWQgbmV0d29yay5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5pY2tuYW1lIC0gT3B0aW9uYWwgbmlja25hbWUgb2YgdGhlIHNlbGVjdGVkIG5ldHdvcmsuXG4gICAqIEBwYXJhbSBycGNQcmVmc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBUaGUgUlBDIFRhcmdldCBVUkwgY29uZmlybWVkLlxuICAgKi9cbiAgYXN5bmMgc2V0Q3VzdG9tUnBjKFxuICAgIHJwY1VybCxcbiAgICBjaGFpbklkLFxuICAgIHRpY2tlciA9ICdFVEgnLFxuICAgIG5pY2tuYW1lID0gJycsXG4gICAgcnBjUHJlZnMgPSB7fSxcbiAgKSB7XG4gICAgY29uc3QgZnJlcXVlbnRScGNMaXN0RGV0YWlsID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuICAgIGNvbnN0IHJwY1NldHRpbmdzID0gZnJlcXVlbnRScGNMaXN0RGV0YWlsLmZpbmQoXG4gICAgICAocnBjKSA9PiBycGNVcmwgPT09IHJwYy5ycGNVcmwsXG4gICAgKTtcblxuICAgIGlmIChycGNTZXR0aW5ncykge1xuICAgICAgdGhpcy5uZXR3b3JrQ29udHJvbGxlci5zZXRScGNUYXJnZXQoXG4gICAgICAgIHJwY1NldHRpbmdzLnJwY1VybCxcbiAgICAgICAgcnBjU2V0dGluZ3MuY2hhaW5JZCxcbiAgICAgICAgcnBjU2V0dGluZ3MudGlja2VyLFxuICAgICAgICBycGNTZXR0aW5ncy5uaWNrbmFtZSxcbiAgICAgICAgcnBjUHJlZnMsXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5ldHdvcmtDb250cm9sbGVyLnNldFJwY1RhcmdldChcbiAgICAgICAgcnBjVXJsLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB0aWNrZXIsXG4gICAgICAgIG5pY2tuYW1lLFxuICAgICAgICBycGNQcmVmcyxcbiAgICAgICk7XG4gICAgICBhd2FpdCB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5hZGRUb0ZyZXF1ZW50UnBjTGlzdChcbiAgICAgICAgcnBjVXJsLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB0aWNrZXIsXG4gICAgICAgIG5pY2tuYW1lLFxuICAgICAgICBycGNQcmVmcyxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBycGNVcmw7XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgZm9yIGRlbGV0aW5nIGEgc2VsZWN0ZWQgY3VzdG9tIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJwY1VybCAtIEEgUlBDIFVSTCB0byBkZWxldGUuXG4gICAqL1xuICBhc3luYyBkZWxDdXN0b21ScGMocnBjVXJsKSB7XG4gICAgYXdhaXQgdGhpcy5wcmVmZXJlbmNlc0NvbnRyb2xsZXIucmVtb3ZlRnJvbUZyZXF1ZW50UnBjTGlzdChycGNVcmwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IFJQQyBpbmZvIG9iamVjdCB0aGF0IG1hdGNoZXMgYXQgbGVhc3Qgb25lIGZpZWxkIG9mIHRoZVxuICAgKiBwcm92aWRlZCBzZWFyY2ggY3JpdGVyaWEuIFJldHVybnMgbnVsbCBpZiBubyBtYXRjaCBpcyBmb3VuZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcnBjSW5mbyAtIFRoZSBSUEMgZW5kcG9pbnQgcHJvcGVydGllcyBhbmQgdmFsdWVzIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fSBycGNJbmZvIGZvdW5kIGluIHRoZSBmcmVxdWVudFJwY0xpc3RcbiAgICovXG4gIGZpbmRDdXN0b21ScGNCeShycGNJbmZvKSB7XG4gICAgY29uc3QgZnJlcXVlbnRScGNMaXN0RGV0YWlsID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldEZyZXF1ZW50UnBjTGlzdERldGFpbCgpO1xuICAgIGZvciAoY29uc3QgZXhpc3RpbmdScGNJbmZvIG9mIGZyZXF1ZW50UnBjTGlzdERldGFpbCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocnBjSW5mbykpIHtcbiAgICAgICAgaWYgKGV4aXN0aW5nUnBjSW5mb1trZXldID09PSBycGNJbmZvW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gZXhpc3RpbmdScGNJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIExlZGdlciBMaXZlIHByZWZlcmVuY2UgdG8gdXNlIGZvciBMZWRnZXIgaGFyZHdhcmUgd2FsbGV0IHN1cHBvcnRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zcG9ydFR5cGUgLSBUaGUgTGVkZ2VyIHRyYW5zcG9ydCB0eXBlLlxuICAgKi9cbiAgYXN5bmMgc2V0TGVkZ2VyVHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnRUeXBlKSB7XG4gICAgY29uc3QgY3VycmVudFZhbHVlID1cbiAgICAgIHRoaXMucHJlZmVyZW5jZXNDb250cm9sbGVyLmdldExlZGdlclRyYW5zcG9ydFByZWZlcmVuY2UoKTtcbiAgICBjb25zdCBuZXdWYWx1ZSA9XG4gICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKHRyYW5zcG9ydFR5cGUpO1xuXG4gICAgY29uc3Qga2V5cmluZyA9IGF3YWl0IHRoaXMuZ2V0S2V5cmluZ0ZvckRldmljZShERVZJQ0VfTkFNRVMuTEVER0VSKTtcbiAgICBpZiAoa2V5cmluZz8udXBkYXRlVHJhbnNwb3J0TWV0aG9kKSB7XG4gICAgICByZXR1cm4ga2V5cmluZy51cGRhdGVUcmFuc3BvcnRNZXRob2QobmV3VmFsdWUpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBlcnJvciB1cGRhdGluZyB0aGUgdHJhbnNwb3J0LCB3ZSBzaG91bGRcbiAgICAgICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZVxuICAgICAgICB0aGlzLnByZWZlcmVuY2VzQ29udHJvbGxlci5zZXRMZWRnZXJUcmFuc3BvcnRQcmVmZXJlbmNlKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbWV0aG9kIGZvciBpbml0aWFsaXppbmcgc3RvcmFnZSB0aGUgZmlyc3QgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGluaXRTdGF0ZSAtIFRoZSBkZWZhdWx0IHN0YXRlIHRvIGluaXRpYWxpemUgd2l0aC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlY29yZEZpcnN0VGltZUluZm8oaW5pdFN0YXRlKSB7XG4gICAgaWYgKCEoJ2ZpcnN0VGltZUluZm8nIGluIGluaXRTdGF0ZSkpIHtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSB0aGlzLnBsYXRmb3JtLmdldFZlcnNpb24oKTtcbiAgICAgIGluaXRTdGF0ZS5maXJzdFRpbWVJbmZvID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBkYXRlOiBEYXRlLm5vdygpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBSZXBsYWNlIGlzQ2xpZW50T3BlbiBtZXRob2RzIHdpdGggYGNvbnRyb2xsZXJDb25uZWN0aW9uQ2hhbmdlZGAgZXZlbnRzLlxuICAvKiBlc2xpbnQtZGlzYWJsZSBhY2Nlc3Nvci1wYWlycyAqL1xuICAvKipcbiAgICogQSBtZXRob2QgZm9yIHJlY29yZGluZyB3aGV0aGVyIHRoZSBNZXRhTWFzayB1c2VyIGludGVyZmFjZSBpcyBvcGVuIG9yIG5vdC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuXG4gICAqL1xuICBzZXQgaXNDbGllbnRPcGVuKG9wZW4pIHtcbiAgICB0aGlzLl9pc0NsaWVudE9wZW4gPSBvcGVuO1xuICAgIHRoaXMuZGV0ZWN0VG9rZW5zQ29udHJvbGxlci5pc09wZW4gPSBvcGVuO1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgYWNjZXNzb3ItcGFpcnMgKi9cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhbGwgaW5zdGFuY2VzIG9mIG1ldGFtYXNrIGFyZSBjbG9zZWQuXG4gICAqIEN1cnJlbnRseSB1c2VkIHRvIHN0b3AgcG9sbGluZyBpbiB0aGUgZ2FzRmVlQ29udHJvbGxlci5cbiAgICovXG4gIG9uQ2xpZW50Q2xvc2VkKCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuc3RvcFBvbGxpbmcoKTtcbiAgICAgIHRoaXMuYXBwU3RhdGVDb250cm9sbGVyLmNsZWFyUG9sbGluZ1Rva2VucygpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgYnkgdGhlIGJhY2tncm91bmQgd2hlbiBhIHBhcnRpY3VsYXIgZW52aXJvbm1lbnQgdHlwZSBpcyBjbG9zZWQgKGZ1bGxzY3JlZW4sIHBvcHVwLCBub3RpZmljYXRpb24pLlxuICAgKiBDdXJyZW50bHkgdXNlZCB0byBzdG9wIHBvbGxpbmcgaW4gdGhlIGdhc0ZlZUNvbnRyb2xsZXIgZm9yIG9ubHkgdGhhdCBlbnZpcm9uZW1lbnQgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0gZW52aXJvbm1lbnRUeXBlXG4gICAqL1xuICBvbkVudmlyb25tZW50VHlwZUNsb3NlZChlbnZpcm9ubWVudFR5cGUpIHtcbiAgICBjb25zdCBhcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGUgPVxuICAgICAgUE9MTElOR19UT0tFTl9FTlZJUk9OTUVOVF9UWVBFU1tlbnZpcm9ubWVudFR5cGVdO1xuICAgIGNvbnN0IHBvbGxpbmdUb2tlbnNUb0Rpc2Nvbm5lY3QgPVxuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIuc3RvcmUuZ2V0U3RhdGUoKVthcHBTdGF0ZVBvbGxpbmdUb2tlblR5cGVdO1xuICAgIHBvbGxpbmdUb2tlbnNUb0Rpc2Nvbm5lY3QuZm9yRWFjaCgocG9sbGluZ1Rva2VuKSA9PiB7XG4gICAgICB0aGlzLmdhc0ZlZUNvbnRyb2xsZXIuZGlzY29ubmVjdFBvbGxlcihwb2xsaW5nVG9rZW4pO1xuICAgICAgdGhpcy5hcHBTdGF0ZUNvbnRyb2xsZXIucmVtb3ZlUG9sbGluZ1Rva2VuKFxuICAgICAgICBwb2xsaW5nVG9rZW4sXG4gICAgICAgIGFwcFN0YXRlUG9sbGluZ1Rva2VuVHlwZSxcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGRvbWFpbiB0byB0aGUgUGhpc2hpbmdDb250cm9sbGVyIHNhZmVsaXN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob3N0bmFtZSAtIHRoZSBkb21haW4gdG8gc2FmZWxpc3RcbiAgICovXG4gIHNhZmVsaXN0UGhpc2hpbmdEb21haW4oaG9zdG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5waGlzaGluZ0NvbnRyb2xsZXIuYnlwYXNzKGhvc3RuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2NrcyBNZXRhTWFza1xuICAgKi9cbiAgc2V0TG9ja2VkKCkge1xuICAgIGNvbnN0IFt0cmV6b3JLZXlyaW5nXSA9IHRoaXMua2V5cmluZ0NvbnRyb2xsZXIuZ2V0S2V5cmluZ3NCeVR5cGUoXG4gICAgICBLRVlSSU5HX1RZUEVTLlRSRVpPUixcbiAgICApO1xuICAgIGlmICh0cmV6b3JLZXlyaW5nKSB7XG4gICAgICB0cmV6b3JLZXlyaW5nLmRpc3Bvc2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBbbGVkZ2VyS2V5cmluZ10gPSB0aGlzLmtleXJpbmdDb250cm9sbGVyLmdldEtleXJpbmdzQnlUeXBlKFxuICAgICAgS0VZUklOR19UWVBFUy5MRURHRVIsXG4gICAgKTtcbiAgICBsZWRnZXJLZXlyaW5nPy5kZXN0cm95Py4oKTtcblxuICAgIHJldHVybiB0aGlzLmtleXJpbmdDb250cm9sbGVyLnNldExvY2tlZCgpO1xuICB9XG5cbiAgcmVtb3ZlUGVybWlzc2lvbnNGb3IgPSAoc3ViamVjdHMpID0+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5yZXZva2VQZXJtaXNzaW9ucyhzdWJqZWN0cyk7XG4gICAgfSBjYXRjaCAoZXhwKSB7XG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBQZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xuICAgICAgICB0aHJvdyBleHA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlamVjdFBlcm1pc3Npb25zUmVxdWVzdCA9IChyZXF1ZXN0SWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3QocmVxdWVzdElkKTtcbiAgICB9IGNhdGNoIChleHApIHtcbiAgICAgIGlmICghKGV4cCBpbnN0YW5jZW9mIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGV4cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0ID0gKHJlcXVlc3QpID0+IHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5wZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3QocmVxdWVzdCk7XG4gICAgfSBjYXRjaCAoZXhwKSB7XG4gICAgICBpZiAoIShleHAgaW5zdGFuY2VvZiBQZXJtaXNzaW9uc1JlcXVlc3ROb3RGb3VuZEVycm9yKSkge1xuICAgICAgICB0aHJvdyBleHA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJlc29sdmVQZW5kaW5nQXBwcm92YWwgPSAoaWQsIHZhbHVlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyLmFjY2VwdChpZCwgdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGV4cCkge1xuICAgICAgaWYgKCEoZXhwIGluc3RhbmNlb2YgQXBwcm92YWxSZXF1ZXN0Tm90Rm91bmRFcnJvcikpIHtcbiAgICAgICAgdGhyb3cgZXhwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZWplY3RQZW5kaW5nQXBwcm92YWwgPSAoaWQsIGVycm9yKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYXBwcm92YWxDb250cm9sbGVyLnJlamVjdChcbiAgICAgICAgaWQsXG4gICAgICAgIG5ldyBFdGhlcmV1bVJwY0Vycm9yKGVycm9yLmNvZGUsIGVycm9yLm1lc3NhZ2UsIGVycm9yLmRhdGEpLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChleHApIHtcbiAgICAgIGlmICghKGV4cCBpbnN0YW5jZW9mIEFwcHJvdmFsUmVxdWVzdE5vdEZvdW5kRXJyb3IpKSB7XG4gICAgICAgIHRocm93IGV4cDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGlmICh2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgPT09ICdldGhlcnNjYW4nKSB7XHJcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci50eXBlID0gJ3JwYyc7XHJcbiAgICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPVxyXG4gICAgICAgICAgJ2h0dHBzOi8vcnBjLm1ldGFtYXNrLmlvLyc7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgLy8gZW1wdHlcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzO1xyXG5jb25zdCBvbGRUZXN0UnBjID0gJ2h0dHBzOi8vcmF3dGVzdHJwYy5tZXRhbWFzay5pby8nO1xyXG5jb25zdCBuZXdUZXN0UnBjID0gJ2h0dHBzOi8vdGVzdHJwYy5tZXRhbWFzay5pby8nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBpZiAodmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQgPT09IG9sZFRlc3RScGMpIHtcclxuICAgICAgICB2ZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnJwY1RhcmdldCA9IG5ld1Rlc3RScGM7XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKF8pIHtcclxuICAgICAgLy8gZW1wdHlcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUodmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3Qgc2FmZVZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAodmVyc2lvbmVkRGF0YSk7XHJcbiAgICBzYWZlVmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyLnR5cGUgIT09ICdycGMnKSB7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzYWZlVmVyc2lvbmVkRGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoIChzYWZlVmVyc2lvbmVkRGF0YS5kYXRhLmNvbmZpZy5wcm92aWRlci5ycGNUYXJnZXQpIHtcclxuICAgICAgICBjYXNlICdodHRwczovL3Rlc3RycGMubWV0YW1hc2suaW8vJzpcclxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAndGVzdG5ldCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnaHR0cHM6Ly9ycGMubWV0YW1hc2suaW8vJzpcclxuICAgICAgICAgIHNhZmVWZXJzaW9uZWREYXRhLmRhdGEuY29uZmlnLnByb3ZpZGVyID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnbWFpbm5ldCcsXHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgLy8gTm8gZGVmYXVsdFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChfKSB7XHJcbiAgICAgIC8vIGVtcHR5XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNhZmVWZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gbW92ZXMgc3RhdGUgZnJvbSB0aGUgZmxhdCBzdGF0ZSB0cmllIGludG8gS2V5cmluZ0NvbnRyb2xsZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDU7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHNlbGVjdFN1YnN0YXRlRm9yS2V5cmluZ0NvbnRyb2xsZXIoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjNSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gc2VsZWN0U3Vic3RhdGVGb3JLZXlyaW5nQ29udHJvbGxlcihzdGF0ZSkge1xyXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBzdGF0ZTtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgS2V5cmluZ0NvbnRyb2xsZXI6IHtcclxuICAgICAgdmF1bHQ6IHN0YXRlLnZhdWx0LFxyXG4gICAgICBzZWxlY3RlZEFjY291bnQ6IGNvbmZpZy5zZWxlY3RlZEFjY291bnQsXHJcbiAgICAgIHdhbGxldE5pY2tuYW1lczogc3RhdGUud2FsbGV0Tmlja25hbWVzLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS52YXVsdDtcclxuICBkZWxldGUgbmV3U3RhdGUud2FsbGV0Tmlja25hbWVzO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcuc2VsZWN0ZWRBY2NvdW50O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vdmVzIEtleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWRkcmVzcyB0byBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuc2VsZWN0ZWRBZGRyZXNzXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSBtaWdyYXRlU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gbWlncmF0ZVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qga2V5cmluZ1N1YnN0YXRlID0gc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXI7XHJcblxyXG4gIC8vIGFkZCBuZXcgc3RhdGVcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIHNlbGVjdGVkQWRkcmVzczoga2V5cmluZ1N1YnN0YXRlLnNlbGVjdGVkQWNjb3VudCxcclxuICAgIH0sXHJcbiAgfTtcclxuXHJcbiAgLy8gcm0gb2xkIHN0YXRlXHJcbiAgZGVsZXRlIG5ld1N0YXRlLktleXJpbmdDb250cm9sbGVyLnNlbGVjdGVkQWNjb3VudDtcclxuXHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBicmVha3Mgb3V0IHRoZSBUcmFuc2FjdGlvbk1hbmFnZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFRyYW5zYWN0aW9uTWFuYWdlcjoge1xyXG4gICAgICB0cmFuc2FjdGlvbnM6IHN0YXRlLnRyYW5zYWN0aW9ucyB8fCBbXSxcclxuICAgICAgZ2FzTXVsdGlwbGllcjogc3RhdGUuZ2FzTXVsdGlwbGllciB8fCAxLFxyXG4gICAgfSxcclxuICB9O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS50cmFuc2FjdGlvbnM7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLmdhc011bHRpcGxpZXI7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgTm90aWNlQ29udHJvbGxlciBzdWJzdGF0ZVxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gODtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgTm90aWNlQ29udHJvbGxlcjoge1xyXG4gICAgICBub3RpY2VzTGlzdDogc3RhdGUubm90aWNlc0xpc3QgfHwgW10sXHJcbiAgICB9LFxyXG4gIH07XHJcbiAgZGVsZXRlIG5ld1N0YXRlLm5vdGljZXNMaXN0O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGJyZWFrcyBvdXQgdGhlIEN1cnJlbmN5Q29udHJvbGxlciBzdWJzdGF0ZVxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCwgbWVyZ2UgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBtZXJnZSh7fSwgc3RhdGUsIHtcclxuICAgIEN1cnJlbmN5Q29udHJvbGxlcjoge1xyXG4gICAgICBjdXJyZW50Q3VycmVuY3k6IHN0YXRlLmN1cnJlbnRGaWF0IHx8IHN0YXRlLmZpYXRDdXJyZW5jeSB8fCAnVVNEJyxcclxuICAgICAgY29udmVyc2lvblJhdGU6IHN0YXRlLmNvbnZlcnNpb25SYXRlLFxyXG4gICAgICBjb252ZXJzaW9uRGF0ZTogc3RhdGUuY29udmVyc2lvbkRhdGUsXHJcbiAgICB9LFxyXG4gIH0pO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jdXJyZW50RmlhdDtcclxuICBkZWxldGUgbmV3U3RhdGUuZmlhdEN1cnJlbmN5O1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb252ZXJzaW9uUmF0ZTtcclxuICBkZWxldGUgbmV3U3RhdGUuY29udmVyc2lvbkRhdGU7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gYnJlYWtzIG91dCB0aGUgU2hhcGVTaGlmdENvbnRyb2xsZXIgc3Vic3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IG1lcmdlKHt9LCBzdGF0ZSwge1xyXG4gICAgU2hhcGVTaGlmdENvbnRyb2xsZXI6IHtcclxuICAgICAgc2hhcGVTaGlmdFR4TGlzdDogc3RhdGUuc2hhcGVTaGlmdFR4TGlzdCB8fCBbXSxcclxuICAgIH0sXHJcbiAgfSk7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLnNoYXBlU2hpZnRUeExpc3Q7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgZGlzY2FpbWVyIHN0YXRlIGZyb20gb3VyIGFwcCwgd2hpY2ggd2FzIGludGVncmF0ZWQgaW50byBvdXIgbm90aWNlcy5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDExO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLlRPU0hhc2g7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLmlzRGlzY2xhaW1lckNvbmZpcm1lZDtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIG91ciBub3RpY2VzIHRvIGRlbGV0ZSB0aGVpciBib2R5IGFmdGVyIGJlaW5nIHJlYWQuXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMjtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIG5ld1N0YXRlLk5vdGljZUNvbnRyb2xsZXIubm90aWNlc0xpc3QuZm9yRWFjaCgobm90aWNlKSA9PiB7XHJcbiAgICBpZiAobm90aWNlLnJlYWQpIHtcclxuICAgICAgbm90aWNlLmJvZHkgPSAnJztcclxuICAgIH1cclxuICB9KTtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vZGlmaWVzIHRoZSBuZXR3b3JrIGNvbmZpZyBmcm9tIGFtYmlndW91cyAndGVzdG5ldCcgdG8gZXhwbGljaXQgJ3JvcHN0ZW4nXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxMztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgY29uZmlnIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5wcm92aWRlcikge1xyXG4gICAgaWYgKGNvbmZpZy5wcm92aWRlci50eXBlID09PSAndGVzdG5ldCcpIHtcclxuICAgICAgbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyLnR5cGUgPSAncm9wc3Rlbic7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyBwcm92aWRlciBmcm9tIGNvbmZpZyBhbmQgbW92ZXMgaXQgdG9vIE5ldHdvcmtDb250cm9sbGVyLlxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlciA9IHt9O1xyXG4gIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0gbmV3U3RhdGUuY29uZmlnLnByb3ZpZGVyO1xyXG4gIGRlbGV0ZSBuZXdTdGF0ZS5jb25maWcucHJvdmlkZXI7XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyB3aXRoIHRoZSAnR2F2ZSB1cCBzdWJtaXR0aW5nIHR4LicgZXJyIG1lc3NhZ2VcclxudG8gYSAnZmFpbGVkJyBzdGF0ZWRcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDE1O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IFRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfSBlbHNlIGlmICh0eE1ldGEuZXJyLm1lc3NhZ2UgPT09ICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJykge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdpdGggdGhlICdHYXZlIHVwIHN1Ym1pdHRpbmcgdHguJyBlcnIgbWVzc2FnZVxyXG50byBhICdmYWlsZWQnIHN0YXRlZFxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTY7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCF0eE1ldGEuZXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHhNZXRhLmVyciA9PT0gJ3RyYW5zYWN0aW9uIHdpdGggdGhlIHNhbWUgaGFzaCB3YXMgYWxyZWFkeSBpbXBvcnRlZC4nXHJcbiAgICAgICkge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQ7XHJcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHNldHMgdHJhbnNhY3Rpb25zIHdobyB3ZXJlIHJldHJpZWQgYW5kIG1hcmtlZCBhcyBmYWlsZWQgdG8gc3VibWl0dGVkXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAxNztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2ZXJzaW9uZWREYXRhKTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBuZXdTdGF0ZSA9IHN0YXRlO1xyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcbiAgICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcCgodHhNZXRhKSA9PiB7XHJcbiAgICAgIGlmICghdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEKSB7XHJcbiAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHhNZXRhLnJldHJ5Q291bnQgPiAwICYmIHR4TWV0YS5yZXRyeUNvdW50IDwgMikge1xyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQ7XHJcbiAgICAgICAgZGVsZXRlIHR4TWV0YS5lcnI7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHVwZGF0ZXMgXCJ0cmFuc2FjdGlvbiBzdGF0ZSBoaXN0b3J5XCIgdG8gZGlmZnMgc3R5bGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQge1xyXG4gIHNuYXBzaG90RnJvbVR4TWV0YSxcclxuICBtaWdyYXRlRnJvbVNuYXBzaG90c1RvRGlmZnMsXHJcbn0gZnJvbSAnLi4vY29udHJvbGxlcnMvdHJhbnNhY3Rpb25zL2xpYi90eC1zdGF0ZS1oaXN0b3J5LWhlbHBlcnMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDE4O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgY29uc3QgeyBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgfSA9IG5ld1N0YXRlO1xyXG4gIGlmIChUcmFuc2FjdGlvbkNvbnRyb2xsZXIgJiYgVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucykge1xyXG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgLy8gbm8gaGlzdG9yeTogaW5pdGlhbGl6ZVxyXG4gICAgICBpZiAoIXR4TWV0YS5oaXN0b3J5IHx8IHR4TWV0YS5oaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0gc25hcHNob3RGcm9tVHhNZXRhKHR4TWV0YSk7XHJcbiAgICAgICAgdHhNZXRhLmhpc3RvcnkgPSBbc25hcHNob3RdO1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuICAgICAgLy8gaGFzIGhpc3Rvcnk6IG1pZ3JhdGVcclxuICAgICAgY29uc3QgbmV3SGlzdG9yeSA9IG1pZ3JhdGVGcm9tU25hcHNob3RzVG9EaWZmcyh0eE1ldGEuaGlzdG9yeSlcclxuICAgICAgICAvLyByZW1vdmUgZW1wdHkgZGlmZnNcclxuICAgICAgICAuZmlsdGVyKChlbnRyeSkgPT4ge1xyXG4gICAgICAgICAgcmV0dXJuICFBcnJheS5pc0FycmF5KGVudHJ5KSB8fCBlbnRyeS5sZW5ndGggPiAwO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB0eE1ldGEuaGlzdG9yeSA9IG5ld0hpc3Rvcnk7XHJcbiAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsIi8qXHJcblxyXG5UaGlzIG1pZ3JhdGlvbiBzZXRzIHRyYW5zYWN0aW9ucyBhcyBmYWlsZWRcclxud2hvcyBub25jZSBpcyB0b28gaGlnaFxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMTk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKFxyXG4gICAgICAodHhNZXRhLCBfLCB0eExpc3QpID0+IHtcclxuICAgICAgICBpZiAodHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEKSB7XHJcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc3QgY29uZmlybWVkVHhzID0gdHhMaXN0XHJcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHguc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQpXHJcbiAgICAgICAgICAuZmlsdGVyKCh0eCkgPT4gdHgudHhQYXJhbXMuZnJvbSA9PT0gdHhNZXRhLnR4UGFyYW1zLmZyb20pXHJcbiAgICAgICAgICAuZmlsdGVyKFxyXG4gICAgICAgICAgICAodHgpID0+IHR4Lm1ldGFtYXNrTmV0d29ya0lkLmZyb20gPT09IHR4TWV0YS5tZXRhbWFza05ldHdvcmtJZC5mcm9tLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBoaWdoZXN0Q29uZmlybWVkTm9uY2UgPSBnZXRIaWdoZXN0Tm9uY2UoY29uZmlybWVkVHhzKTtcclxuXHJcbiAgICAgICAgY29uc3QgcGVuZGluZ1R4cyA9IHR4TGlzdFxyXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEKVxyXG4gICAgICAgICAgLmZpbHRlcigodHgpID0+IHR4LnR4UGFyYW1zLmZyb20gPT09IHR4TWV0YS50eFBhcmFtcy5mcm9tKVxyXG4gICAgICAgICAgLmZpbHRlcihcclxuICAgICAgICAgICAgKHR4KSA9PiB0eC5tZXRhbWFza05ldHdvcmtJZC5mcm9tID09PSB0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQuZnJvbSxcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgaGlnaGVzdENvbnRpbnVvdXNOb25jZSA9IGdldEhpZ2hlc3RDb250aW51b3VzRnJvbShcclxuICAgICAgICAgIHBlbmRpbmdUeHMsXHJcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWF4Tm9uY2UgPSBNYXRoLm1heChcclxuICAgICAgICAgIGhpZ2hlc3RDb250aW51b3VzTm9uY2UsXHJcbiAgICAgICAgICBoaWdoZXN0Q29uZmlybWVkTm9uY2UsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcnNlSW50KHR4TWV0YS50eFBhcmFtcy5ub25jZSwgMTYpID4gbWF4Tm9uY2UgKyAxKSB7XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEO1xyXG4gICAgICAgICAgdHhNZXRhLmVyciA9IHtcclxuICAgICAgICAgICAgbWVzc2FnZTogJ25vbmNlIHRvbyBoaWdoJyxcclxuICAgICAgICAgICAgbm90ZTogJ21pZ3JhdGlvbiAwMTkgY3VzdG9tIGVycm9yJyxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hlc3RDb250aW51b3VzRnJvbSh0eExpc3QsIHN0YXJ0UG9pbnQpIHtcclxuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcclxuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcclxuICAgIHJldHVybiBwYXJzZUludChub25jZSwgMTYpO1xyXG4gIH0pO1xyXG5cclxuICBsZXQgaGlnaGVzdCA9IHN0YXJ0UG9pbnQ7XHJcbiAgd2hpbGUgKG5vbmNlcy5pbmNsdWRlcyhoaWdoZXN0KSkge1xyXG4gICAgaGlnaGVzdCArPSAxO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGhpZ2hlc3Q7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEhpZ2hlc3ROb25jZSh0eExpc3QpIHtcclxuICBjb25zdCBub25jZXMgPSB0eExpc3QubWFwKCh0eE1ldGEpID0+IHtcclxuICAgIGNvbnN0IHsgbm9uY2UgfSA9IHR4TWV0YS50eFBhcmFtcztcclxuICAgIHJldHVybiBwYXJzZUludChub25jZSB8fCAnMHgwJywgMTYpO1xyXG4gIH0pO1xyXG4gIGNvbnN0IGhpZ2hlc3ROb25jZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG5vbmNlcyk7XHJcbiAgcmV0dXJuIGhpZ2hlc3ROb25jZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gZW5zdXJlcyBwcmV2aW91cyBpbnN0YWxsYXRpb25zXHJcbmdldCBhIGBmaXJzdFRpbWVJbmZvYCBrZXkgb24gdGhlIG1ldGFtYXNrIHN0YXRlLFxyXG5zbyB0aGF0IHdlIGNhbiB2ZXJzaW9uIG5vdGljZXMgaW4gdGhlIGZ1dHVyZS5cclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIwO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgaWYgKCdtZXRhbWFzaycgaW4gbmV3U3RhdGUgJiYgISgnZmlyc3RUaW1lSW5mbycgaW4gbmV3U3RhdGUubWV0YW1hc2spKSB7XHJcbiAgICBuZXdTdGF0ZS5tZXRhbWFzay5maXJzdFRpbWVJbmZvID0ge1xyXG4gICAgICB2ZXJzaW9uOiAnMy4xMi4wJyxcclxuICAgICAgZGF0ZTogRGF0ZS5ub3coKSxcclxuICAgIH07XHJcbiAgfVxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCIvKlxyXG5cclxuVGhpcyBtaWdyYXRpb24gcmVtb3ZlcyB0aGUgQmxhY2tMaXN0Q29udHJvbGxlciBmcm9tIGRpc2sgc3RhdGVcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIxO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLkJsYWNrbGlzdENvbnRyb2xsZXI7XHJcbiAgZGVsZXRlIG5ld1N0YXRlLlJlY2VudEJsb2NrcztcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGFkZHMgc3VibWl0dGVkVGltZSB0byB0aGUgdHhNZXRhIGlmIGl0IGlzIG5vdCB0aGVpclxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgIT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRCB8fFxyXG4gICAgICAgIHR4TWV0YS5zdWJtaXR0ZWRUaW1lXHJcbiAgICAgICkge1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuICAgICAgdHhNZXRhLnN1Ym1pdHRlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIHJlbW92ZXMgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIG5vIGxvbmdlciB1c2VmdWxsIGRvd24gdG8gNDAgdG90YWxcclxuXHJcbiovXHJcblxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDIzO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcblxyXG4gIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihgTWV0YU1hc2sgTWlncmF0aW9uICMke3ZlcnNpb259JHtlcnIuc3RhY2t9YCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZlcnNpb25lZERhdGEpO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcblxyXG4gIGNvbnN0IHsgVHJhbnNhY3Rpb25Db250cm9sbGVyIH0gPSBuZXdTdGF0ZTtcclxuICBpZiAoVHJhbnNhY3Rpb25Db250cm9sbGVyICYmIFRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXI7XHJcblxyXG4gICAgaWYgKHRyYW5zYWN0aW9ucy5sZW5ndGggPD0gNDApIHtcclxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJldmVyc2VUeExpc3QgPSB0cmFuc2FjdGlvbnMucmV2ZXJzZSgpO1xyXG4gICAgbGV0IHN0cmlwcGluZyA9IHRydWU7XHJcbiAgICB3aGlsZSAocmV2ZXJzZVR4TGlzdC5sZW5ndGggPiA0MCAmJiBzdHJpcHBpbmcpIHtcclxuICAgICAgY29uc3QgdHhJbmRleCA9IHJldmVyc2VUeExpc3QuZmluZEluZGV4KCh0eE1ldGEpID0+IHtcclxuICAgICAgICByZXR1cm4gKFxyXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuRkFJTEVEIHx8XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5SRUpFQ1RFRCB8fFxyXG4gICAgICAgICAgdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQ09ORklSTUVEIHx8XHJcbiAgICAgICAgICB0eE1ldGEuc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5EUk9QUEVEXHJcbiAgICAgICAgKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh0eEluZGV4IDwgMCkge1xyXG4gICAgICAgIHN0cmlwcGluZyA9IGZhbHNlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJldmVyc2VUeExpc3Quc3BsaWNlKHR4SW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHJldmVyc2VUeExpc3QucmV2ZXJzZSgpO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIGVuc3VyZXMgdGhhdCB0aGUgZnJvbSBhZGRyZXNzIGluIHR4UGFyYW1zIGlzIHRvIGxvd2VyIGNhc2UgZm9yXHJcbmFsbCB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uc1xyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFRSQU5TQUNUSU9OX1NUQVRVU0VTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcbiAgaWYgKCFuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIpIHtcclxuICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICB9XHJcbiAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICBuZXdTdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0gdHJhbnNhY3Rpb25zLm1hcChcclxuICAgICh0eE1ldGEsIF8pID0+IHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHR4TWV0YS5zdGF0dXMgPT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQgJiZcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMgJiZcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbVxyXG4gICAgICApIHtcclxuICAgICAgICB0eE1ldGEudHhQYXJhbXMuZnJvbSA9IHR4TWV0YS50eFBhcmFtcy5mcm9tLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0sXHJcbiAgKTtcclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uL2xpYi91dGlsJztcclxuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5tYXAoXHJcbiAgICAgICAgKHR4TWV0YSkgPT4ge1xyXG4gICAgICAgICAgaWYgKHR4TWV0YS5zdGF0dXMgIT09IFRSQU5TQUNUSU9OX1NUQVRVU0VTLlVOQVBQUk9WRUQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHR4TWV0YS50eFBhcmFtcyA9IG5vcm1hbGl6ZVR4UGFyYW1zKHR4TWV0YS50eFBhcmFtcyk7XHJcbiAgICAgICAgICByZXR1cm4gdHhNZXRhO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZVR4UGFyYW1zKHR4UGFyYW1zKSB7XHJcbiAgLy8gZnVuY3Rpb25zIHRoYXQgaGFuZGxlIG5vcm1hbGl6aW5nIG9mIHRoYXQga2V5IGluIHR4UGFyYW1zXHJcbiAgY29uc3Qgd2hpdGVMaXN0ID0ge1xyXG4gICAgZnJvbTogKGZyb20pID0+IGFkZEhleFByZWZpeChmcm9tKS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgdG86ICgpID0+IGFkZEhleFByZWZpeCh0eFBhcmFtcy50bykudG9Mb3dlckNhc2UoKSxcclxuICAgIG5vbmNlOiAobm9uY2UpID0+IGFkZEhleFByZWZpeChub25jZSksXHJcbiAgICB2YWx1ZTogKHZhbHVlKSA9PiBhZGRIZXhQcmVmaXgodmFsdWUpLFxyXG4gICAgZGF0YTogKGRhdGEpID0+IGFkZEhleFByZWZpeChkYXRhKSxcclxuICAgIGdhczogKGdhcykgPT4gYWRkSGV4UHJlZml4KGdhcyksXHJcbiAgICBnYXNQcmljZTogKGdhc1ByaWNlKSA9PiBhZGRIZXhQcmVmaXgoZ2FzUHJpY2UpLFxyXG4gIH07XHJcblxyXG4gIC8vIGFwcGx5IG9ubHkga2V5cyBpbiB0aGUgd2hpdGVMaXN0XHJcbiAgY29uc3Qgbm9ybWFsaXplZFR4UGFyYW1zID0ge307XHJcbiAgT2JqZWN0LmtleXMod2hpdGVMaXN0KS5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgIGlmICh0eFBhcmFtc1trZXldKSB7XHJcbiAgICAgIG5vcm1hbGl6ZWRUeFBhcmFtc1trZXldID0gd2hpdGVMaXN0W2tleV0odHhQYXJhbXNba2V5XSk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBub3JtYWxpemVkVHhQYXJhbXM7XHJcbn1cclxuIiwiLypcclxuXHJcblRoaXMgbWlncmF0aW9uIG1vdmVzIHRoZSBpZGVudGl0aWVzIHN0b3JlZCBpbiB0aGUgS2V5cmluZ0NvbnRyb2xsZXJcclxuIGludG8gdGhlIFByZWZlcmVuY2VzQ29udHJvbGxlclxyXG5cclxuKi9cclxuXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjY7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICBjb25zb2xlLndhcm4oYE1ldGFNYXNrIE1pZ3JhdGlvbiAjJHt2ZXJzaW9ufSR7ZXJyLnN0YWNrfWApO1xyXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKCFzdGF0ZS5LZXlyaW5nQ29udHJvbGxlciB8fCAhc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICByZXR1cm4gc3RhdGU7XHJcbiAgfVxyXG5cclxuICBpZiAoIXN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcykge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmlkZW50aXRpZXMgPSBPYmplY3Qua2V5cyhcclxuICAgIHN0YXRlLktleXJpbmdDb250cm9sbGVyLndhbGxldE5pY2tuYW1lcyxcclxuICApLnJlZHVjZSgoaWRlbnRpdGllcywgYWRkcmVzcykgPT4ge1xyXG4gICAgaWRlbnRpdGllc1thZGRyZXNzXSA9IHtcclxuICAgICAgbmFtZTogc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzW2FkZHJlc3NdLFxyXG4gICAgICBhZGRyZXNzLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBpZGVudGl0aWVzO1xyXG4gIH0sIHt9KTtcclxuICBkZWxldGUgc3RhdGUuS2V5cmluZ0NvbnRyb2xsZXIud2FsbGV0Tmlja25hbWVzO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXHJcbi8qXHJcblxyXG5ub3JtYWxpemVzIHR4UGFyYW1zIG9uIHVuY29uZmlybWVkIHR4c1xyXG5cclxuKi9cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVFJBTlNBQ1RJT05fU1RBVFVTRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyNztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcikge1xyXG4gICAgaWYgKG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpIHtcclxuICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlcjtcclxuICAgICAgbmV3U3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9ucy5maWx0ZXIoXHJcbiAgICAgICAgKHR4TWV0YSkgPT4gdHhNZXRhLnN0YXR1cyAhPT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuUkVKRUNURUQsXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcbmltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMjg7XHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IG5ld1N0YXRlID0gc3RhdGU7XHJcblxyXG4gIGlmIChuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGlmIChcclxuICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyAmJlxyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuaWRlbnRpdGllc1xyXG4gICAgKSB7XHJcbiAgICAgIGNvbnN0IHsgaWRlbnRpdGllcywgdG9rZW5zIH0gPSBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XHJcbiAgICAgIG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0ge307XHJcbiAgICAgIE9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmZvckVhY2goKGlkZW50aXR5KSA9PiB7XHJcbiAgICAgICAgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnNbaWRlbnRpdHldID0ge1xyXG4gICAgICAgICAgbWFpbm5ldDogdG9rZW5zLFxyXG4gICAgICAgIH07XHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5pbXBvcnQgZmFpbFR4c1RoYXQgZnJvbSAnLi9mYWlsLXR4JztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAyOTtcclxuXHJcbi8vIHRpbWVcclxuY29uc3Qgc2Vjb25kcyA9IDEwMDA7XHJcbmNvbnN0IG1pbnV0ZXMgPSA2MCAqIHNlY29uZHM7XHJcbmNvbnN0IGhvdXJzID0gNjAgKiBtaW51dGVzO1xyXG5jb25zdCB1bmFjY2VwdGFibGVEZWxheSA9IDEyICogaG91cnM7XHJcblxyXG4vKlxyXG5cclxubm9ybWFsaXplcyB0eFBhcmFtcyBvbiB1bmNvbmZpcm1lZCB0eHNcclxuXHJcbiovXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuXHJcbiAgbWlncmF0ZTogZmFpbFR4c1RoYXQoXHJcbiAgICB2ZXJzaW9uLFxyXG4gICAgJ1N0dWNrIGluIGFwcHJvdmVkIHN0YXRlIGZvciB0b28gbG9uZy4nLFxyXG4gICAgKHR4TWV0YSkgPT4ge1xyXG4gICAgICBjb25zdCBpc0FwcHJvdmVkID0gdHhNZXRhLnN0YXR1cyA9PT0gVFJBTlNBQ1RJT05fU1RBVFVTRVMuQVBQUk9WRUQ7XHJcbiAgICAgIGNvbnN0IGNyZWF0ZWRUaW1lID0gdHhNZXRhLnN1Ym1pdHRlZFRpbWU7XHJcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XHJcbiAgICAgIHJldHVybiBpc0FwcHJvdmVkICYmIG5vdyAtIGNyZWF0ZWRUaW1lID4gdW5hY2NlcHRhYmxlRGVsYXk7XHJcbiAgICB9LFxyXG4gICksXHJcbn07XHJcbiIsIi8vIG5leHQgdmVyc2lvbiBudW1iZXJcclxuLypcclxuXHJcbnJlbW92ZXMgaW52YWxpZCBjaGFpZHMgZnJvbSBwcmVmZXJlbmNlcyBhbmQgbmV0d29ya0NvbnRyb2xsZXIgZm9yIGN1c3RvbSBycGNzXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzMDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdERldGFpbCB9ID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xyXG4gICAgaWYgKGZyZXF1ZW50UnBjTGlzdERldGFpbCkge1xyXG4gICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgocnBjLCBpbmRleCkgPT4ge1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICAgIGlmIChCb29sZWFuKHJwYy5jaGFpbklkKSAmJiBOdW1iZXIuaXNOYU4ocGFyc2VJbnQocnBjLmNoYWluSWQpKSkge1xyXG4gICAgICAgICAgZGVsZXRlIGZyZXF1ZW50UnBjTGlzdERldGFpbFtpbmRleF0uY2hhaW5JZDtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID1cclxuICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWw7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcikge1xyXG4gICAgaWYgKFxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5uZXR3b3JrICYmXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIubmV0d29yaykpXHJcbiAgICApIHtcclxuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLm5ldHdvcms7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciAmJlxyXG4gICAgICBuZXdTdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5jaGFpbklkICYmXHJcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByYWRpeFxyXG4gICAgICBOdW1iZXIuaXNOYU4ocGFyc2VJbnQobmV3U3RhdGUuTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIuY2hhaW5JZCkpXHJcbiAgICApIHtcclxuICAgICAgZGVsZXRlIG5ld1N0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG5pbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDMxO1xyXG5cclxuLypcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gcHJvcGVybHkgc2V0IHRoZSBjb21wbGV0ZWRPbmJvYXJkaW5nIGZsYWcgYmFzZWQgb24gdGhlIHN0YXRlXHJcbiAqIG9mIHRoZSBLZXlyaW5nQ29udHJvbGxlci5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBLZXlyaW5nQ29udHJvbGxlciwgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgaWYgKEtleXJpbmdDb250cm9sbGVyICYmIFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgeyB2YXVsdCB9ID0gS2V5cmluZ0NvbnRyb2xsZXI7XHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkT25ib2FyZGluZyA9IEJvb2xlYW4odmF1bHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzI7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gc2V0IHRoZSB7QGNvZGUgY29tcGxldGVkVWlNaWdyYXRpb259IGZsYWcgYmFzZWQgb24gdGhlIHVzZXIncyBVSSBwcmVmZXJlbmNlc1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IGJldGFVSSB9ID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcclxuICAgIC8vIFVzZXJzIHdobyBoYXZlIGJlZW4gdXNpbmcgdGhlIFwiYmV0YVwiIFVJIGFyZSBjb25zaWRlcmVkIHRvIGhhdmUgY29tcGxldGVkIHRoZSBtaWdyYXRpb25cclxuICAgIC8vIGFzIHRoZXknbGwgc2VlIG5vIGRpZmZlcmVuY2UgaW4gdGhpcyB2ZXJzaW9uXHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuY29tcGxldGVkVWlNaWdyYXRpb24gPSBiZXRhVUk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiLy8gbmV4dCB2ZXJzaW9uIG51bWJlclxyXG4vKlxyXG5cclxuQ2xlYW5zIHVwIG5vdGljZXMgYW5kIGFzc29jYXRlZCBub3RpY2UgY29udHJvbGxlciBjb2RlXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzMztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICAvLyB0cmFuc2Zvcm0gc3RhdGUgaGVyZVxyXG4gIGlmIChzdGF0ZS5Ob3RpY2VDb250cm9sbGVyKSB7XHJcbiAgICBkZWxldGUgbmV3U3RhdGUuTm90aWNlQ29udHJvbGxlcjtcclxuICB9XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzQ7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gZW5hYmxlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZyBhbmQgc2V0IHRoZSB1c2VyIGFzIGJlaW5nIG1pZ3JhdGVkXHJcbiAqIGlmIGl0IHdhcyB7QGNvZGUgZmFsc2V9LlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHN0YXRlO1xyXG5cclxuICBpZiAoUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZmVhdHVyZUZsYWdzIHx8IHt9O1xyXG5cclxuICAgIGlmIChcclxuICAgICAgIWZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAmJlxyXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLm1pZ3JhdGVkUHJpdmFjeU1vZGUgPT09ICd1bmRlZmluZWQnXHJcbiAgICApIHtcclxuICAgICAgLy8gTWFyayB0aGUgc3RhdGUgaGFzIGJlaW5nIG1pZ3JhdGVkIGFuZCBlbmFibGUgUHJpdmFjeSBNb2RlXHJcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5taWdyYXRlZFByaXZhY3lNb2RlID0gdHJ1ZTtcclxuICAgICAgZmVhdHVyZUZsYWdzLnByaXZhY3lNb2RlID0gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCIvLyBuZXh0IHZlcnNpb24gbnVtYmVyXHJcbi8qXHJcblxyXG5SZW1vdmVzIHRoZSBkZXByZWNhdGVkICdzZWVkV29yZHMnIHN0YXRlXHJcblxyXG4qL1xyXG5cclxuaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzNTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG5cclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUodmVyc2lvbmVkRGF0YS5kYXRhKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlciAmJlxyXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcyAhPT0gdW5kZWZpbmVkXHJcbiAgKSB7XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnNlZWRXb3JkcztcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzY7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gcmVtb3ZlIHRoZSB7QGNvZGUgcHJpdmFjeU1vZGV9IGZlYXR1cmUgZmxhZy5cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHsgUHJlZmVyZW5jZXNDb250cm9sbGVyIH0gPSBzdGF0ZTtcclxuXHJcbiAgaWYgKFByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgZmVhdHVyZUZsYWdzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmZlYXR1cmVGbGFncyB8fCB7fTtcclxuXHJcbiAgICBpZiAodHlwZW9mIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgZGVsZXRlIGZlYXR1cmVGbGFncy5wcml2YWN5TW9kZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyB1dGlsIH0gZnJvbSAnQG1ldGFtYXNrL2NvbnRyb2xsZXJzJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzNztcclxuXHJcbi8qKlxyXG4gKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1pZ3JhdGlvbiBpcyB0byB1cGRhdGUgdGhlIGFkZHJlc3MgYm9vayBzdGF0ZVxyXG4gKiB0byB0aGUgbmV3IHNjaGVtYSB3aXRoIGNoYWluSWQgYXMgYSBrZXkuXHJcbiAqIGFuZCB0byBhZGQgdGhlIGlzRW5zIGZsYWcgdG8gYWxsIGVudHJpZXNcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChzdGF0ZS5BZGRyZXNzQm9va0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IGFiID0gc3RhdGUuQWRkcmVzc0Jvb2tDb250cm9sbGVyLmFkZHJlc3NCb29rO1xyXG5cclxuICAgIGNvbnN0IGNoYWluSWRzID0gbmV3IFNldCgpO1xyXG4gICAgY29uc3QgbmV3QWRkcmVzc0Jvb2sgPSB7fTtcclxuXHJcbiAgICAvLyBhZGQgYWxsIG9mIHRoZSBjaGFpbklkcyB0byBhIHNldFxyXG4gICAgT2JqZWN0LnZhbHVlcyhhYikuZm9yRWFjaCgodikgPT4ge1xyXG4gICAgICBjaGFpbklkcy5hZGQodi5jaGFpbklkKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIGZpbGwgdGhlIGNoYWluSWQgb2JqZWN0IHdpdGggdGhlIGVudHJpZXMgd2l0aCB0aGUgbWF0Y2hpbmcgY2hhaW5JZFxyXG4gICAgZm9yIChjb25zdCBpZCBvZiBjaGFpbklkcy52YWx1ZXMoKSkge1xyXG4gICAgICAvLyBtYWtlIGFuIGVtcHR5IG9iamVjdCBlbnRyeSBmb3IgZWFjaCBjaGFpbklkXHJcbiAgICAgIG5ld0FkZHJlc3NCb29rW2lkXSA9IHt9O1xyXG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gYWIpIHtcclxuICAgICAgICBpZiAoYWJbYWRkcmVzc10uY2hhaW5JZCA9PT0gaWQpIHtcclxuICAgICAgICAgIGFiW2FkZHJlc3NdLmlzRW5zID0gZmFsc2U7XHJcbiAgICAgICAgICBpZiAodXRpbC5ub3JtYWxpemVFbnNOYW1lKGFiW2FkZHJlc3NdLm5hbWUpKSB7XHJcbiAgICAgICAgICAgIGFiW2FkZHJlc3NdLmlzRW5zID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIG5ld0FkZHJlc3NCb29rW2lkXVthZGRyZXNzXSA9IGFiW2FkZHJlc3NdO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlci5hZGRyZXNzQm9vayA9IG5ld0FkZHJlc3NCb29rO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gMzg7XHJcblxyXG4vKipcclxuICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtaWdyYXRpb24gaXMgdG8gYXNzaWduIGFsbCB1c2VycyB0byBhIHRlc3QgZ3JvdXAgZm9yIHRoZSBmdWxsU2NyZWVuVnNQb3B1cCBhL2IgdGVzdFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgeyBBQlRlc3RDb250cm9sbGVyOiBBQlRlc3RDb250cm9sbGVyU3RhdGUgPSB7fSB9ID0gc3RhdGU7XHJcbiAgY29uc3QgeyBhYlRlc3RzID0ge30gfSA9IEFCVGVzdENvbnRyb2xsZXJTdGF0ZTtcclxuXHJcbiAgaWYgKGFiVGVzdHMuZnVsbFNjcmVlblZzUG9wdXApIHtcclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIEFCVGVzdENvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uQUJUZXN0Q29udHJvbGxlclN0YXRlLFxyXG4gICAgICBhYlRlc3RzOiB7XHJcbiAgICAgICAgLi4uYWJUZXN0cyxcclxuICAgICAgICBmdWxsU2NyZWVuVnNQb3B1cDogJ2NvbnRyb2wnLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IHRvQ2hlY2tzdW1IZXhBZGRyZXNzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSAzOTtcclxuXHJcbmNvbnN0IERBSV9WMV9DT05UUkFDVF9BRERSRVNTID0gJzB4ODlkMjRBNmI0Q2NCMUI2ZkFBMjYyNWZFNTYyYkREOWEyMzI2MDM1OSc7XHJcbmNvbnN0IERBSV9WMV9UT0tFTl9TWU1CT0wgPSAnREFJJztcclxuY29uc3QgU0FJX1RPS0VOX1NZTUJPTCA9ICdTQUknO1xyXG5cclxuZnVuY3Rpb24gaXNPbGREYWkodG9rZW4gPSB7fSkge1xyXG4gIHJldHVybiAoXHJcbiAgICB0b2tlbiAmJlxyXG4gICAgdHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJlxyXG4gICAgdG9rZW4uc3ltYm9sID09PSBEQUlfVjFfVE9LRU5fU1lNQk9MICYmXHJcbiAgICB0b0NoZWNrc3VtSGV4QWRkcmVzcyh0b2tlbi5hZGRyZXNzKSA9PT0gREFJX1YxX0NPTlRSQUNUX0FERFJFU1NcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogVGhpcyBtaWdyYXRpb24gcmVuYW1lcyB0aGUgRGFpIHRva2VuIHRvIFNhaS5cclxuICpcclxuICogQXMgb2YgMjAxOS0xMS0xOCBEYWkgaXMgbm93IGNhbGxlZCBTYWkgKHJlZnMgaHR0cHM6Ly9naXQuaW8vSmVvb1ApIHRvIGZhY2lsaXRhdGVcclxuICogTWFrZXIncyB1cGdyYWRlIHRvIE11bHRpLUNvbGxhdGVyYWwgRGFpIGFuZCB0aGlzIG1pZ3JhdGlvbiByZW5hbWVzIHRoZSB0b2tlblxyXG4gKiBhdCB0aGUgb2xkIGFkZHJlc3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB7IFByZWZlcmVuY2VzQ29udHJvbGxlciB9ID0gc3RhdGU7XHJcblxyXG4gIGlmIChQcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IHRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0b2tlbnMpKSB7XHJcbiAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zKSB7XHJcbiAgICAgICAgaWYgKGlzT2xkRGFpKHRva2VuKSkge1xyXG4gICAgICAgICAgdG9rZW4uc3ltYm9sID0gU0FJX1RPS0VOX1NZTUJPTDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhY2NvdW50VG9rZW5zID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgfHwge307XHJcbiAgICBpZiAoYWNjb3VudFRva2VucyAmJiB0eXBlb2YgYWNjb3VudFRva2VucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XHJcbiAgICAgICAgY29uc3QgbmV0d29ya1Rva2VucyA9IGFjY291bnRUb2tlbnNbYWRkcmVzc107XHJcbiAgICAgICAgaWYgKG5ldHdvcmtUb2tlbnMgJiYgdHlwZW9mIG5ldHdvcmtUb2tlbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcclxuICAgICAgICAgICAgY29uc3QgdG9rZW5zT25OZXR3b3JrID0gbmV0d29ya1Rva2Vuc1tuZXR3b3JrXTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW5zT25OZXR3b3JrKSkge1xyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdG9rZW5zT25OZXR3b3JrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbGREYWkodG9rZW4pKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRva2VuLnN5bWJvbCA9IFNBSV9UT0tFTl9TWU1CT0w7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0MDtcclxuXHJcbi8qKlxyXG4gKiBTaXRlIGNvbm5lY3Rpb25zIGFyZSBub3cgbWFuYWdlZCBieSB0aGUgUGVybWlzc2lvbnNDb250cm9sbGVyLCBhbmQgdGhlXHJcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIGlzIHJlbW92ZWQuIFRoaXMgbWlncmF0aW9uIGRlbGV0ZXMgYWxsXHJcbiAqIFByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyIHN0YXRlLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgZGVsZXRlIHN0YXRlLlByb3ZpZGVyQXBwcm92YWxDb250cm9sbGVyO1xyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQxO1xyXG5cclxuLyoqXHJcbiAqIFByZWZlcmVuY2VzQ29udHJvbGxlci5hdXRvTG9nb3V0VGltZUxpbWl0IC0+IGF1dG9Mb2NrVGltZUxpbWl0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyICYmIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5wcmVmZXJlbmNlcykge1xyXG4gICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2NrVGltZUxpbWl0ID1cclxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XHJcbiAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzLmF1dG9Mb2dvdXRUaW1lTGltaXQ7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQyO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd25gIHRvIGBmYWxzZWAgaWYgaXQgaGFzbid0IHlldCBiZWVuIHNldCxcclxuICogc28gdGhhdCBleGlzdGluZyB1c2VycyBhcmUgaW50cm9kdWNlZCB0byB0aGUgbmV3IGNvbm5lY3RlZCBzdGF0dXMgaW5kaWNhdG9yXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIuY29ubmVjdGVkU3RhdHVzUG9wb3Zlckhhc0JlZW5TaG93biA9IGZhbHNlO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIgPSB7XHJcbiAgICAgIGNvbm5lY3RlZFN0YXR1c1BvcG92ZXJIYXNCZWVuU2hvd246IGZhbHNlLFxyXG4gICAgfTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNDM7XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHVudXNlZCAnY3VycmVudEFjY291bnRUYWInIHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAoc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uY3VycmVudEFjY291bnRUYWIpIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuY3VycmVudEFjY291bnRUYWI7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ0O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB1bnVzZWQgJ21rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wJyBzdGF0ZSBmcm9tIHRoZSBgQXBwU3RhdGVDb250cm9sbGVyYFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKFxyXG4gICAgdHlwZW9mIHN0YXRlPy5BcHBTdGF0ZUNvbnRyb2xsZXI/Lm1rck1pZ3JhdGlvblJlbWluZGVyVGltZXN0YW1wICE9PVxyXG4gICAgJ3VuZGVmaW5lZCdcclxuICApIHtcclxuICAgIGRlbGV0ZSBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIubWtyTWlncmF0aW9uUmVtaW5kZXJUaW1lc3RhbXA7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ1O1xyXG5cclxuLyoqXHJcbiAqIFJlcGxhY2VzIHtAY29kZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuaXBmc0dhdGV3YXl9IHdpdGggJ2R3ZWIubGluaycgaWYgc2V0XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3Qgb3V0ZGF0ZWRHYXRld2F5cyA9IFsnaXBmcy5pbycsICdpcGZzLmR3ZWIubGluayddO1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAob3V0ZGF0ZWRHYXRld2F5cy5pbmNsdWRlcyhzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5pcGZzR2F0ZXdheSkpIHtcclxuICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5pcGZzR2F0ZXdheSA9ICdkd2ViLmxpbmsnO1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0NjtcclxuXHJcbi8qKlxyXG4gKiBEZWxldGUge0Bjb2RlIEFCVGVzdENvbnRyb2xsZXJ9IHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBpZiAodHlwZW9mIHN0YXRlPy5BQlRlc3RDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgZGVsZXRlIHN0YXRlLkFCVGVzdENvbnRyb2xsZXI7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ3O1xyXG5cclxuLyoqXHJcbiAqIFN0cmluZ2lmeSB0aGUgYG1ldGFtYXNrTmV0d29ya0lkYCBwcm9wZXJ0eSBvZiBhbGwgdHJhbnNhY3Rpb25zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQgPVxyXG4gICAgICAgICAgdHJhbnNhY3Rpb24ubWV0YW1hc2tOZXR3b3JrSWQudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDQ4O1xyXG5cclxuLyoqXHJcbiAqIDEuICBEZWxldGUgTmV0d29ya0NvbnRyb2xsZXIuc2V0dGluZ3NcclxuICogMmEuIE1pZ3JhdGUgTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgdG8gUmlua2VieSBpZiBzZXQgdG8gdHlwZSAncnBjJyBvclxyXG4gKiAgICAgJ2xvY2FsaG9zdCcuXHJcbiAqIDJiLiBSZS1rZXkgcHJvdmlkZXIucnBjVGFyZ2V0IHRvIHByb3ZpZGVyLnJwY1VybFxyXG4gKiAzLiAgQWRkIGxvY2FsaG9zdCBuZXR3b3JrIHRvIGZyZXF1ZW50UnBjTGlzdERldGFpbC5cclxuICogNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcclxuICogNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XHJcbiAqIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcclxuICogNy4gIERlbGV0ZSBsb2NhbGhvc3Qga2V5IGluIEluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxyXG4gKiA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuY29uc3QgaGV4UmVnRXggPSAvXjB4WzAtOWEtZl0rJC9pdTtcclxuY29uc3QgY2hhaW5JZFJlZ0V4ID0gL14weFsxLTlhLWZdK1swLTlhLWZdKiQvaXU7XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSA9IHt9KSB7XHJcbiAgLy8gMS4gRGVsZXRlIE5ldHdvcmtDb250cm9sbGVyLnNldHRpbmdzXHJcbiAgZGVsZXRlIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyPy5zZXR0aW5ncztcclxuXHJcbiAgLy8gMi4gTWlncmF0ZSBOZXR3b3JrQ29udHJvbGxlci5wcm92aWRlciB0byBSaW5rZWJ5IG9yIHJlbmFtZSBycGNUYXJnZXQga2V5XHJcbiAgY29uc3QgcHJvdmlkZXIgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XHJcbiAgY29uc3QgaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgPVxyXG4gICAgcHJvdmlkZXIudHlwZSA9PT0gJ3JwYycgJiZcclxuICAgICh0eXBlb2YgcHJvdmlkZXIuY2hhaW5JZCAhPT0gJ3N0cmluZycgfHxcclxuICAgICAgIWNoYWluSWRSZWdFeC50ZXN0KHByb3ZpZGVyLmNoYWluSWQpKTtcclxuICBpZiAoaXNDdXN0b21ScGNXaXRoSW52YWxpZENoYWluSWQgfHwgcHJvdmlkZXIudHlwZSA9PT0gJ2xvY2FsaG9zdCcpIHtcclxuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyID0ge1xyXG4gICAgICB0eXBlOiAncmlua2VieScsXHJcbiAgICAgIHJwY1VybDogJycsXHJcbiAgICAgIGNoYWluSWQ6ICcweDQnLFxyXG4gICAgICBuaWNrbmFtZTogJycsXHJcbiAgICAgIHJwY1ByZWZzOiB7fSxcclxuICAgICAgdGlja2VyOiAnRVRIJyxcclxuICAgIH07XHJcbiAgfSBlbHNlIGlmIChzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIpIHtcclxuICAgIGlmICgncnBjVGFyZ2V0JyBpbiBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcikge1xyXG4gICAgICBjb25zdCBycGNVcmwgPSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlci5ycGNUYXJnZXQ7XHJcbiAgICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLnJwY1VybCA9IHJwY1VybDtcclxuICAgIH1cclxuICAgIGRlbGV0ZSBzdGF0ZS5OZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXI/LnJwY1RhcmdldDtcclxuICB9XHJcblxyXG4gIC8vIDMuICBBZGQgbG9jYWxob3N0IG5ldHdvcmsgdG8gZnJlcXVlbnRScGNMaXN0RGV0YWlsLlxyXG4gIGlmICghc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSB7fTtcclxuICB9XHJcbiAgaWYgKCFzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsKSB7XHJcbiAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gW107XHJcbiAgfVxyXG4gIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5mcmVxdWVudFJwY0xpc3REZXRhaWwudW5zaGlmdCh7XHJcbiAgICBycGNVcmw6ICdodHRwOi8vbG9jYWxob3N0Ojg1NDUnLFxyXG4gICAgY2hhaW5JZDogJzB4NTM5JyxcclxuICAgIHRpY2tlcjogJ0VUSCcsXHJcbiAgICBuaWNrbmFtZTogJ0xvY2FsaG9zdCA4NTQ1JyxcclxuICAgIHJwY1ByZWZzOiB7fSxcclxuICB9KTtcclxuXHJcbiAgLy8gNC4gIERlbGV0ZSBDYWNoZWRCYWxhbmNlc0NvbnRyb2xsZXIuY2FjaGVkQmFsYW5jZXNcclxuICBkZWxldGUgc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcztcclxuXHJcbiAgLy8gNS4gIENvbnZlcnQgdHJhbnNhY3Rpb25zIG1ldGFtYXNrTmV0d29ya0lkIHRvIGRlY2ltYWwgaWYgdGhleSBhcmUgaGV4XHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2goKHRyYW5zYWN0aW9uKSA9PiB7XHJcbiAgICAgIGNvbnN0IG1ldGFtYXNrTmV0d29ya0lkID0gdHJhbnNhY3Rpb24/Lm1ldGFtYXNrTmV0d29ya0lkO1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgdHlwZW9mIG1ldGFtYXNrTmV0d29ya0lkID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgIGhleFJlZ0V4LnRlc3QobWV0YW1hc2tOZXR3b3JrSWQpXHJcbiAgICAgICkge1xyXG4gICAgICAgIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID0gcGFyc2VJbnQoXHJcbiAgICAgICAgICBtZXRhbWFza05ldHdvcmtJZCxcclxuICAgICAgICAgIDE2LFxyXG4gICAgICAgICkudG9TdHJpbmcoMTApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIDYuICBDb252ZXJ0IGFkZHJlc3MgYm9vayBrZXlzIGZyb20gZGVjaW1hbCB0byBoZXhcclxuICBjb25zdCBhZGRyZXNzQm9vayA9IHN0YXRlLkFkZHJlc3NCb29rQ29udHJvbGxlcj8uYWRkcmVzc0Jvb2sgfHwge307XHJcbiAgT2JqZWN0LmtleXMoYWRkcmVzc0Jvb2spLmZvckVhY2goKG5ldHdvcmtLZXkpID0+IHtcclxuICAgIGlmICgvXlxcZCskL2l1LnRlc3QobmV0d29ya0tleSkpIHtcclxuICAgICAgY29uc3QgY2hhaW5JZCA9IGAweCR7cGFyc2VJbnQobmV0d29ya0tleSwgMTApLnRvU3RyaW5nKDE2KX1gO1xyXG4gICAgICB1cGRhdGVDaGFpbklkcyhhZGRyZXNzQm9va1tuZXR3b3JrS2V5XSwgY2hhaW5JZCk7XHJcblxyXG4gICAgICBpZiAoYWRkcmVzc0Jvb2tbY2hhaW5JZF0pIHtcclxuICAgICAgICBtZXJnZUFkZHJlc3NCb29rS2V5cyhhZGRyZXNzQm9vaywgbmV0d29ya0tleSwgY2hhaW5JZCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkcmVzc0Jvb2tbY2hhaW5JZF0gPSBhZGRyZXNzQm9va1tuZXR3b3JrS2V5XTtcclxuICAgICAgfVxyXG4gICAgICBkZWxldGUgYWRkcmVzc0Jvb2tbbmV0d29ya0tleV07XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIC8vIDcuICBEZWxldGUgbG9jYWxob3N0IGtleSBpbiBJbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXJcclxuICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXHJcbiAgICA/LmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yaz8ubG9jYWxob3N0O1xyXG5cclxuICAvLyA4LiAgTWVyZ2UgJ2xvY2FsaG9zdCcgdG9rZW5zIGludG8gJ3JwYycgdG9rZW5zXHJcbiAgY29uc3QgYWNjb3VudFRva2VucyA9IHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudFRva2VucztcclxuICBpZiAoYWNjb3VudFRva2Vucykge1xyXG4gICAgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xyXG4gICAgICBjb25zdCBsb2NhbGhvc3RUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3QgfHwgW107XHJcblxyXG4gICAgICBpZiAobG9jYWxob3N0VG9rZW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICBjb25zdCBycGNUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyB8fCBbXTtcclxuXHJcbiAgICAgICAgaWYgKHJwY1Rva2Vucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBhY2NvdW50VG9rZW5zW2FjY291bnRdLnJwYyA9IG1lcmdlVG9rZW5BcnJheXMoXHJcbiAgICAgICAgICAgIGxvY2FsaG9zdFRva2VucyxcclxuICAgICAgICAgICAgcnBjVG9rZW5zLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYWNjb3VudFRva2Vuc1thY2NvdW50XS5ycGMgPSBsb2NhbGhvc3RUb2tlbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGRlbGV0ZSBhY2NvdW50VG9rZW5zW2FjY291bnRdPy5sb2NhbGhvc3Q7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0aGUgdHdvIGdpdmVuIGtleXMgZm9yIHRoZSBnaXZlbiBhZGRyZXNzIGJvb2sgaW4gcGxhY2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBhZGRyZXNzQm9va1xyXG4gKiBAcGFyYW0gbmV0d29ya0tleVxyXG4gKiBAcGFyYW0gY2hhaW5JZEtleVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VBZGRyZXNzQm9va0tleXMoYWRkcmVzc0Jvb2ssIG5ldHdvcmtLZXksIGNoYWluSWRLZXkpIHtcclxuICBjb25zdCBuZXR3b3JrS2V5RW50cmllcyA9IGFkZHJlc3NCb29rW25ldHdvcmtLZXldIHx8IHt9O1xyXG4gIC8vIEZvciB0aGUgbmV3IGVudHJpZXMsIHN0YXJ0IGJ5IGNvcHlpbmcgdGhlIGV4aXN0aW5nIGVudHJpZXMgZm9yIHRoZSBjaGFpbklkXHJcbiAgY29uc3QgbmV3RW50cmllcyA9IHsgLi4uYWRkcmVzc0Jvb2tbY2hhaW5JZEtleV0gfTtcclxuXHJcbiAgLy8gRm9yIGVhY2ggYWRkcmVzcyBvZiB0aGUgb2xkL25ldHdvcmtJZCBrZXkgZW50cmllc1xyXG4gIE9iamVjdC5rZXlzKG5ldHdvcmtLZXlFbnRyaWVzKS5mb3JFYWNoKChhZGRyZXNzKSA9PiB7XHJcbiAgICBpZiAobmV3RW50cmllc1thZGRyZXNzXSAmJiB0eXBlb2YgbmV3RW50cmllc1thZGRyZXNzXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgY29uc3QgbWVyZ2VkRW50cnkgPSB7fTtcclxuXHJcbiAgICAgIC8vIENvbGxlY3QgYWxsIGtleXMgZnJvbSBib3RoIGVudHJpZXMgYW5kIG1lcmdlIHRoZSBjb3JyZXNwb25kaW5nIGNoYWluSWRcclxuICAgICAgLy8gZW50cnkgd2l0aCB0aGUgbmV0d29ya0lkIGVudHJ5XHJcbiAgICAgIG5ldyBTZXQoW1xyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ld0VudHJpZXNbYWRkcmVzc10pLFxyXG4gICAgICAgIC4uLk9iamVjdC5rZXlzKG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdIHx8IHt9KSxcclxuICAgICAgXSkuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgLy8gVXNlIG5vbi1lbXB0eSB2YWx1ZSBmb3IgdGhlIGN1cnJlbnQga2V5LCBpZiBhbnlcclxuICAgICAgICBtZXJnZWRFbnRyeVtrZXldID1cclxuICAgICAgICAgIG5ld0VudHJpZXNbYWRkcmVzc11ba2V5XSB8fCBuZXR3b3JrS2V5RW50cmllc1thZGRyZXNzXT8uW2tleV0gfHwgJyc7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbmV3RW50cmllc1thZGRyZXNzXSA9IG1lcmdlZEVudHJ5O1xyXG4gICAgfSBlbHNlIGlmIChcclxuICAgICAgbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc10gJiZcclxuICAgICAgdHlwZW9mIG5ldHdvcmtLZXlFbnRyaWVzW2FkZHJlc3NdID09PSAnb2JqZWN0J1xyXG4gICAgKSB7XHJcbiAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGNvcnJlc3BvbmRpbmcgY2hhaW5JZCBlbnRyeSwganVzdCB1c2UgdGhlIG5ldHdvcmtJZCBlbnRyeVxyXG4gICAgICAvLyBkaXJlY3RseVxyXG4gICAgICBuZXdFbnRyaWVzW2FkZHJlc3NdID0gbmV0d29ya0tleUVudHJpZXNbYWRkcmVzc107XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIGFkZHJlc3NCb29rW2NoYWluSWRLZXldID0gbmV3RW50cmllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgdGhlIGNoYWluSWQga2V5IHZhbHVlcyB0byB0aGUgZ2l2ZW4gY2hhaW5JZCBpbiBwbGFjZSBmb3IgYWxsIHZhbHVlc1xyXG4gKiBvZiB0aGUgZ2l2ZW4gbmV0d29ya0VudHJpZXMgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcGFyYW0gbmV0d29ya0VudHJpZXNcclxuICogQHBhcmFtIGNoYWluSWRcclxuICovXHJcbmZ1bmN0aW9uIHVwZGF0ZUNoYWluSWRzKG5ldHdvcmtFbnRyaWVzLCBjaGFpbklkKSB7XHJcbiAgT2JqZWN0LnZhbHVlcyhuZXR3b3JrRW50cmllcykuZm9yRWFjaCgoZW50cnkpID0+IHtcclxuICAgIGlmIChlbnRyeSAmJiB0eXBlb2YgZW50cnkgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgIGVudHJ5LmNoYWluSWQgPSBjaGFpbklkO1xyXG4gICAgfVxyXG4gIH0pO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHRoZSB0d28gZ2l2ZW4sIG5vbi1lbXB0eSBhcnJheXMgb2YgdG9rZW4gb2JqZWN0cyBhbmQgcmV0dXJucyBhIG5ld1xyXG4gKiBhcnJheS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsaG9zdFRva2Vuc1xyXG4gKiBAcGFyYW0gcnBjVG9rZW5zXHJcbiAqIEByZXR1cm5zIHtBcnJheTxvYmplY3Q+fVxyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VUb2tlbkFycmF5cyhsb2NhbGhvc3RUb2tlbnMsIHJwY1Rva2Vucykge1xyXG4gIGNvbnN0IGxvY2FsaG9zdFRva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChsb2NhbGhvc3RUb2tlbnMpO1xyXG4gIGNvbnN0IHJwY1Rva2Vuc01hcCA9IHRva2VuQXJyYXlUb01hcChycGNUb2tlbnMpO1xyXG5cclxuICBjb25zdCBtZXJnZWRUb2tlbnMgPSBbXTtcclxuICBuZXcgU2V0KFtcclxuICAgIC4uLk9iamVjdC5rZXlzKGxvY2FsaG9zdFRva2Vuc01hcCksXHJcbiAgICAuLi5PYmplY3Qua2V5cyhycGNUb2tlbnNNYXApLFxyXG4gIF0pLmZvckVhY2goKHRva2VuQWRkcmVzcykgPT4ge1xyXG4gICAgbWVyZ2VkVG9rZW5zLnB1c2goe1xyXG4gICAgICAuLi5sb2NhbGhvc3RUb2tlbnNNYXBbdG9rZW5BZGRyZXNzXSxcclxuICAgICAgLi4ucnBjVG9rZW5zTWFwW3Rva2VuQWRkcmVzc10sXHJcbiAgICB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIG1lcmdlZFRva2VucztcclxuXHJcbiAgZnVuY3Rpb24gdG9rZW5BcnJheVRvTWFwKGFycmF5KSB7XHJcbiAgICByZXR1cm4gYXJyYXkucmVkdWNlKChtYXAsIHRva2VuKSA9PiB7XHJcbiAgICAgIGlmICh0b2tlbj8uYWRkcmVzcyAmJiB0eXBlb2YgdG9rZW4/LmFkZHJlc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgbWFwW3Rva2VuLmFkZHJlc3NdID0gdG9rZW47XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH0sIHt9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA0OTtcclxuXHJcbi8qKlxyXG4gKiBNaWdyYXRlIG1ldGFNZXRyaWNzIHN0YXRlIHRvIHRoZSBuZXcgTWV0YU1ldHJpY3MgY29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlID0ge30pIHtcclxuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XHJcbiAgICBjb25zdCB7IG1ldGFNZXRyaWNzSWQsIHBhcnRpY2lwYXRlSW5NZXRhTWV0cmljcywgbWV0YU1ldHJpY3NTZW5kQ291bnQgfSA9XHJcbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcjtcclxuICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA9IHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlciA/PyB7fTtcclxuXHJcbiAgICBpZiAobWV0YU1ldHJpY3NJZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkID0gbWV0YU1ldHJpY3NJZDtcclxuICAgICAgZGVsZXRlIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5tZXRhTWV0cmljc0lkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzID1cclxuICAgICAgICBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3M7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIucGFydGljaXBhdGVJbk1ldGFNZXRyaWNzO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtZXRhTWV0cmljc1NlbmRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlci5tZXRhTWV0cmljc1NlbmRDb3VudCA9IG1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLm1ldGFNZXRyaWNzU2VuZENvdW50O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1MDtcclxuXHJcbmNvbnN0IExFR0FDWV9MT0NBTF9TVE9SQUdFX0tFWVMgPSBbXHJcbiAgJ01FVEFTV0FQX0dBU19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdNRVRBU1dBUF9HQVNfUFJJQ0VfRVNUSU1BVEVTJyxcclxuICAnY2FjaGVkRmV0Y2gnLFxyXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdCQVNJQ19QUklDRV9FU1RJTUFURVMnLFxyXG4gICdCQVNJQ19HQVNfQU5EX1RJTUVfQVBJX0VTVElNQVRFUycsXHJcbiAgJ0JBU0lDX0dBU19BTkRfVElNRV9BUElfRVNUSU1BVEVTX0xBU1RfUkVUUklFVkVEJyxcclxuICAnR0FTX0FQSV9FU1RJTUFURVNfTEFTVF9SRVRSSUVWRUQnLFxyXG4gICdHQVNfQVBJX0VTVElNQVRFUycsXHJcbl07XHJcblxyXG4vKipcclxuICogTWlncmF0ZSBtZXRhTWV0cmljcyBzdGF0ZSB0byB0aGUgbmV3IE1ldGFNZXRyaWNzIGNvbnRyb2xsZXJcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcblxyXG4gICAgTEVHQUNZX0xPQ0FMX1NUT1JBR0VfS0VZUy5mb3JFYWNoKChrZXkpID0+XHJcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2U/LnJlbW92ZUl0ZW0oa2V5KSxcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgQlVJTFRfSU5fTkVUV09SS1MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDUxO1xyXG5cclxuLyoqXHJcbiAqIFNldCB0aGUgY2hhaW5JZCBpbiB0aGUgTmV0d29yayBDb250cm9sbGVyIHByb3ZpZGVyIGRhdGEgZm9yIGFsbCBpbmZ1cmEgbmV0d29ya3NcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHsgY2hhaW5JZCwgdHlwZSB9ID0gc3RhdGU/Lk5ldHdvcmtDb250cm9sbGVyPy5wcm92aWRlciB8fCB7fTtcclxuICBjb25zdCBlbnVtQ2hhaW5JZCA9IEJVSUxUX0lOX05FVFdPUktTW3R5cGVdPy5jaGFpbklkO1xyXG5cclxuICBpZiAoZW51bUNoYWluSWQgJiYgY2hhaW5JZCAhPT0gZW51bUNoYWluSWQpIHtcclxuICAgIHN0YXRlLk5ldHdvcmtDb250cm9sbGVyLnByb3ZpZGVyLmNoYWluSWQgPSBlbnVtQ2hhaW5JZDtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBDSEFJTl9JRFMsIE5FVFdPUktfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTI7XG5cbi8qKlxuICogTWlncmF0ZSB0b2tlbnMgaW4gUHJlZmVyZW5jZXMgdG8gYmUga2V5ZWQgYnkgY2hhaW5JZCBpbnN0ZWFkIG9mXG4gKiBwcm92aWRlclR5cGUuIFRvIHByZXZlbnQgYnJlYWtpbmcgdXNlcidzIE1ldGFNYXNrIGFuZCBzZWxlY3RlZFxuICogdG9rZW5zLCB0aGlzIG1pZ3JhdGlvbiBjb3BpZXMgdGhlIFJQQyBlbnRyeSBpbnRvICpldmVyeSogY3VzdG9tIFJQQ1xuICogY2hhaW5JZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUgPSB7fSkge1xuICBpZiAoc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyKSB7XG4gICAgY29uc3QgeyBhY2NvdW50VG9rZW5zLCBhY2NvdW50SGlkZGVuVG9rZW5zLCBmcmVxdWVudFJwY0xpc3REZXRhaWwgfSA9XG4gICAgICBzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI7XG5cbiAgICBjb25zdCBuZXdBY2NvdW50VG9rZW5zID0ge307XG4gICAgY29uc3QgbmV3QWNjb3VudEhpZGRlblRva2VucyA9IHt9O1xuXG4gICAgaWYgKGFjY291bnRUb2tlbnMgJiYgT2JqZWN0LmtleXMoYWNjb3VudFRva2VucykubGVuZ3RoID4gMCkge1xuICAgICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XG4gICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc10gPSB7fTtcbiAgICAgICAgaWYgKGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdKSB7XG4gICAgICAgICAgZnJlcXVlbnRScGNMaXN0RGV0YWlsLmZvckVhY2goKGRldGFpbCkgPT4ge1xuICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtkZXRhaWwuY2hhaW5JZF0gPVxuICAgICAgICAgICAgICBhY2NvdW50VG9rZW5zW2FkZHJlc3NdW05FVFdPUktfVFlQRVMuUlBDXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByb3ZpZGVyVHlwZSBvZiBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zW2FkZHJlc3NdKSkge1xuICAgICAgICAgIHN3aXRjaCAocHJvdmlkZXJUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5FVFdPUktfVFlQRVMuTUFJTk5FVDpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVtDSEFJTl9JRFMuTUFJTk5FVF0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5NQUlOTkVUXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyb3BzdGVuJzpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVsnMHgzJ10gPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdLnJvcHN0ZW47XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bJzB4NCddID0gYWNjb3VudFRva2Vuc1thZGRyZXNzXS5yaW5rZWJ5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTkVUV09SS19UWVBFUy5HT0VSTEk6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRUb2tlbnNbYWRkcmVzc11bQ0hBSU5fSURTLkdPRVJMSV0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRUb2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5HT0VSTEldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tvdmFuJzpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudFRva2Vuc1thZGRyZXNzXVsnMHgyYSddID0gYWNjb3VudFRva2Vuc1thZGRyZXNzXS5rb3ZhbjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zID0gbmV3QWNjb3VudFRva2VucztcbiAgICB9XG5cbiAgICBpZiAoYWNjb3VudEhpZGRlblRva2VucyAmJiBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKS5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKGNvbnN0IGFkZHJlc3Mgb2YgT2JqZWN0LmtleXMoYWNjb3VudEhpZGRlblRva2VucykpIHtcbiAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXSA9IHt9O1xuICAgICAgICBpZiAoYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLlJQQ10pIHtcbiAgICAgICAgICBmcmVxdWVudFJwY0xpc3REZXRhaWwuZm9yRWFjaCgoZGV0YWlsKSA9PiB7XG4gICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW2RldGFpbC5jaGFpbklkXSA9XG4gICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5SUENdO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgcHJvdmlkZXJUeXBlIG9mIE9iamVjdC5rZXlzKGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc10pKSB7XG4gICAgICAgICAgc3dpdGNoIChwcm92aWRlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTkVUV09SS19UWVBFUy5NQUlOTkVUOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdW0NIQUlOX0lEUy5NQUlOTkVUXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVtORVRXT1JLX1RZUEVTLk1BSU5ORVRdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdWycweDMnXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXS5yb3BzdGVuO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3JpbmtlYnknOlxuICAgICAgICAgICAgICBuZXdBY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdWycweDQnXSA9XG4gICAgICAgICAgICAgICAgYWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXS5yaW5rZWJ5O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgTkVUV09SS19UWVBFUy5HT0VSTEk6XG4gICAgICAgICAgICAgIG5ld0FjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bQ0hBSU5fSURTLkdPRVJMSV0gPVxuICAgICAgICAgICAgICAgIGFjY291bnRIaWRkZW5Ub2tlbnNbYWRkcmVzc11bTkVUV09SS19UWVBFUy5HT0VSTEldO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2tvdmFuJzpcbiAgICAgICAgICAgICAgbmV3QWNjb3VudEhpZGRlblRva2Vuc1thZGRyZXNzXVsnMHgyYSddID1cbiAgICAgICAgICAgICAgICBhY2NvdW50SGlkZGVuVG9rZW5zW2FkZHJlc3NdLmtvdmFuO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRIaWRkZW5Ub2tlbnMgPSBuZXdBY2NvdW50SGlkZGVuVG9rZW5zO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDUzO1xyXG5cclxuLyoqXHJcbiAqIERlcHJlY2F0ZSB0cmFuc2FjdGlvbkNhdGVnb3J5IGFuZCBjb25zb2xpZGF0ZSBvbiAndHlwZSdcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcclxuICBjb25zdCBpbmNvbWluZ1RyYW5zYWN0aW9ucyA9XHJcbiAgICBzdGF0ZT8uSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyPy5pbmNvbWluZ1RyYW5zYWN0aW9ucztcclxuICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICB0cmFuc2FjdGlvbnMuZm9yRWFjaCgodHJhbnNhY3Rpb24pID0+IHtcclxuICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgdHJhbnNhY3Rpb24udHlwZSAhPT0gVFJBTlNBQ1RJT05fVFlQRVMuUkVUUlkgJiZcclxuICAgICAgICAgIHRyYW5zYWN0aW9uLnR5cGUgIT09IFRSQU5TQUNUSU9OX1RZUEVTLkNBTkNFTFxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgdHJhbnNhY3Rpb24udHlwZSA9IHRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uQ2F0ZWdvcnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgaWYgKGluY29taW5nVHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCBpbmNvbWluZ1RyYW5zYWN0aW9uc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhpbmNvbWluZ1RyYW5zYWN0aW9ucyk7XHJcbiAgICBpbmNvbWluZ1RyYW5zYWN0aW9uc0VudHJpZXMuZm9yRWFjaCgoW2tleSwgdHJhbnNhY3Rpb25dKSA9PiB7XHJcbiAgICAgIGlmICh0cmFuc2FjdGlvbikge1xyXG4gICAgICAgIGRlbGV0ZSB0cmFuc2FjdGlvbi50cmFuc2FjdGlvbkNhdGVnb3J5O1xyXG4gICAgICAgIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlci5pbmNvbWluZ1RyYW5zYWN0aW9uc1trZXldID0ge1xyXG4gICAgICAgICAgLi4udHJhbnNhY3Rpb24sXHJcbiAgICAgICAgICB0eXBlOiBUUkFOU0FDVElPTl9UWVBFUy5JTkNPTUlORyxcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTQ7XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpIHtcclxuICByZXR1cm4gKFxyXG4gICAgdHlwZW9mIGRlY2ltYWxzID09PSAnbnVtYmVyJyB8fFxyXG4gICAgKHR5cGVvZiBkZWNpbWFscyA9PT0gJ3N0cmluZycgJiYgZGVjaW1hbHMubWF0Y2goL14oMHgpP1xcZCskL3UpKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNaWdyYXRlcyBwcmVmZXJlbmNlIHRva2VucyB3aXRoIGRlY2ltYWxzIHR5cGVkIGFzIHN0cmluZyB0byBudW1iZXIuXHJcbiAqIEl0IGFsc28gcmVtb3ZlcyBhbnkgdG9rZW5zIHdpdGggY29ycnVwdGVkIG9yIGluY29udmVydGlibGUgZGVjaW1hbCB2YWx1ZXMuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuXHJcbiAgaWYgKCFuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIpIHtcclxuICAgIHJldHVybiBuZXdTdGF0ZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHRva2VucyA9IG5ld1N0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMgfHwgW107XHJcbiAgLy8gRmlsdGVyIG91dCBhbnkgdG9rZW5zIHdpdGggY29ycnVwdGVkIGRlY2ltYWwgdmFsdWVzXHJcbiAgY29uc3QgdmFsaWRUb2tlbnMgPSB0b2tlbnMuZmlsdGVyKCh7IGRlY2ltYWxzIH0pID0+XHJcbiAgICBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpLFxyXG4gICk7XHJcbiAgZm9yIChjb25zdCB0b2tlbiBvZiB2YWxpZFRva2Vucykge1xyXG4gICAgLy8gSW4gdGhlIGNhc2Ugb2YgYSBkZWNpbWFsIHZhbHVlIHR5cGUgc3RyaW5nLCBjb252ZXJ0IHRvIGEgbnVtYmVyLlxyXG4gICAgaWYgKHR5cGVvZiB0b2tlbi5kZWNpbWFscyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJhZGl4XHJcbiAgICAgIHRva2VuLmRlY2ltYWxzID0gcGFyc2VJbnQodG9rZW4uZGVjaW1hbHMpO1xyXG4gICAgfVxyXG4gIH1cclxuICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIudG9rZW5zID0gdmFsaWRUb2tlbnM7XHJcblxyXG4gIGNvbnN0IHsgYWNjb3VudFRva2VucyB9ID0gbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xyXG4gIGlmIChhY2NvdW50VG9rZW5zICYmIHR5cGVvZiBhY2NvdW50VG9rZW5zID09PSAnb2JqZWN0Jykge1xyXG4gICAgZm9yIChjb25zdCBhZGRyZXNzIG9mIE9iamVjdC5rZXlzKGFjY291bnRUb2tlbnMpKSB7XHJcbiAgICAgIGNvbnN0IG5ldHdvcmtUb2tlbnMgPSBhY2NvdW50VG9rZW5zW2FkZHJlc3NdO1xyXG4gICAgICBpZiAobmV0d29ya1Rva2VucyAmJiB0eXBlb2YgbmV0d29ya1Rva2VucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG5ldHdvcmsgb2YgT2JqZWN0LmtleXMobmV0d29ya1Rva2VucykpIHtcclxuICAgICAgICAgIGNvbnN0IHRva2Vuc09uTmV0d29yayA9IG5ldHdvcmtUb2tlbnNbbmV0d29ya10gfHwgW107XHJcbiAgICAgICAgICAvLyBGaWx0ZXIgb3V0IGFueSB0b2tlbnMgd2l0aCBjb3JydXB0ZWQgZGVjaW1hbCB2YWx1ZXNcclxuICAgICAgICAgIGNvbnN0IHZhbGlkVG9rZW5zT25OZXR3b3JrID0gdG9rZW5zT25OZXR3b3JrLmZpbHRlcigoeyBkZWNpbWFscyB9KSA9PlxyXG4gICAgICAgICAgICBpc1ZhbGlkRGVjaW1hbHMoZGVjaW1hbHMpLFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgZGVjaW1hbCB2YWx1ZSB0eXBlIHN0cmluZywgY29udmVydCB0byBhIG51bWJlci5cclxuICAgICAgICAgIGZvciAoY29uc3QgdG9rZW4gb2YgdmFsaWRUb2tlbnNPbk5ldHdvcmspIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbi5kZWNpbWFscyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmFkaXhcclxuICAgICAgICAgICAgICB0b2tlbi5kZWNpbWFscyA9IHBhcnNlSW50KHRva2VuLmRlY2ltYWxzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbmV0d29ya1Rva2Vuc1tuZXR3b3JrXSA9IHZhbGlkVG9rZW5zT25OZXR3b3JrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuICBuZXdTdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2VucyA9IGFjY291bnRUb2tlbnM7XHJcblxyXG4gIHJldHVybiBuZXdTdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAsIG1hcEtleXMgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgQlVJTFRfSU5fTkVUV09SS1MgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuXG5jb25zdCB2ZXJzaW9uID0gNTU7XG5cbi8qKlxuICogcmVwbGFjZSAnaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrJyB3aXRoICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja0J5Q2hhaW5JZCdcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xuICB9LFxufTtcblxuY29uc3QgVU5LTk9XTl9DSEFJTl9JRF9LRVkgPSAnVU5LTk9XTic7XG5cbkJVSUxUX0lOX05FVFdPUktTLnJpbmtlYnkgPSB7XG4gIG5ldHdvcmtJZDogJzQnLFxuICBjaGFpbklkOiAnMHg0JyxcbiAgdGlja2VyOiAnRVRIJyxcbn07XG5CVUlMVF9JTl9ORVRXT1JLUy5yb3BzdGVuID0ge1xuICBuZXR3b3JrSWQ6ICczJyxcbiAgY2hhaW5JZDogJzB4MycsXG4gIHRpY2tlcjogJ0VUSCcsXG59O1xuQlVJTFRfSU5fTkVUV09SS1Mua292YW4gPSB7XG4gIG5ldHdvcmtJZDogJzQyJyxcbiAgY2hhaW5JZDogJzB4MmEnLFxuICB0aWNrZXI6ICdFVEgnLFxufTtcblxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcbiAgaWYgKFxuICAgIHN0YXRlPy5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXI/LmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29ya1xuICApIHtcbiAgICBzdGF0ZS5JbmNvbWluZ1RyYW5zYWN0aW9uc0NvbnRyb2xsZXIuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tCeUNoYWluSWQgPVxuICAgICAgbWFwS2V5cyhcbiAgICAgICAgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgICAgICAgLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2Nrc0J5TmV0d29yayxcbiAgICAgICAgLy8gdXNpbmcgb3B0aW9uYWwgY2hhaW5pbmcgaW4gY2FzZSB1c2VyJ3Mgc3RhdGUgaGFzIGZldGNoZWQgYmxvY2tzIGZvclxuICAgICAgICAvLyBSUEMgbmV0d29yayB0eXBlcyAod2hpY2ggZG9uJ3QgbWFwIHRvIGEgc2luZ2xlIGNoYWluSWQpLiBUaGlzIHNob3VsZFxuICAgICAgICAvLyBub3QgYmUgcG9zc2libGUsIGJ1dCBpdCdzIHNhZmVyXG4gICAgICAgIChfLCBrZXkpID0+IEJVSUxUX0lOX05FVFdPUktTW2tleV0/LmNoYWluSWQgPz8gVU5LTk9XTl9DSEFJTl9JRF9LRVksXG4gICAgICApO1xuICAgIC8vIE5vdyB0aGF0IG1haW5uZXQgYW5kIHRlc3QgbmV0IGxhc3QgZmV0Y2hlZCBibG9ja3MgYXJlIGtleWVkIGJ5IHRoZWlyXG4gICAgLy8gcmVzcGVjdGl2ZSBjaGFpbklkcywgd2UgY2FuIHNhZmVseSBkZWxldGUgYW55dGhpbmcgd2UgaGFkIGZvciBjdXN0b21cbiAgICAvLyBuZXR3b3Jrcy4gQW55IGN1c3RvbSBuZXR3b3JrIHRoYXQgc2hhcmVzIGEgY2hhaW5JZCB3aXRoIG9uZSBvZiB0aGVcbiAgICAvLyBhZm9yZW1lbnRpb25lZCBuZXR3b3JrcyB3aWxsIHVzZSB0aGUgdmFsdWUgc3RvcmVkIGJ5IGNoYWluSWQuXG4gICAgZGVsZXRlIHN0YXRlLkluY29taW5nVHJhbnNhY3Rpb25zQ29udHJvbGxlclxuICAgICAgLmluY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkW1VOS05PV05fQ0hBSU5fSURfS0VZXTtcbiAgICBkZWxldGUgc3RhdGUuSW5jb21pbmdUcmFuc2FjdGlvbnNDb250cm9sbGVyXG4gICAgICAuaW5jb21pbmdUeExhc3RGZXRjaGVkQmxvY2tzQnlOZXR3b3JrO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTY7XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRva2VucyB0aGF0IGRvbid0IGhhdmUgYW4gYWRkcmVzcyBkdWUgdG9cclxuICogbGFjayBvZiBwcmV2aW91cyBhZGRUb2tlbiB2YWxpZGF0aW9uLiAgQWxzbyByZW1vdmVzXHJcbiAqIGFuIHVud2FudGVkLCB1bmRlZmluZWQgaW1hZ2UgcHJvcGVydHlcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcblxyXG4gICAgY29uc3QgeyBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgfSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuXHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShQcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnRva2VucykpIHtcclxuICAgICAgUHJlZmVyZW5jZXNDb250cm9sbGVyLnRva2VucyA9IFByZWZlcmVuY2VzQ29udHJvbGxlci50b2tlbnMuZmlsdGVyKFxyXG4gICAgICAgICh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyxcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoXHJcbiAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcj8uYWNjb3VudFRva2VucyAmJlxyXG4gICAgICB0eXBlb2YgUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMgPT09ICdvYmplY3QnXHJcbiAgICApIHtcclxuICAgICAgT2JqZWN0LmtleXMoUHJlZmVyZW5jZXNDb250cm9sbGVyLmFjY291bnRUb2tlbnMpLmZvckVhY2goKGFjY291bnQpID0+IHtcclxuICAgICAgICBjb25zdCBjaGFpbnMgPSBPYmplY3Qua2V5cyhcclxuICAgICAgICAgIFByZWZlcmVuY2VzQ29udHJvbGxlci5hY2NvdW50VG9rZW5zW2FjY291bnRdLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY2hhaW5zLmZvckVhY2goKGNoYWluKSA9PiB7XHJcbiAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XVtjaGFpbl0gPVxyXG4gICAgICAgICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYWNjb3VudFRva2Vuc1thY2NvdW50XVtjaGFpbl0uZmlsdGVyKFxyXG4gICAgICAgICAgICAgICh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKFxyXG4gICAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFzc2V0SW1hZ2VzICYmXHJcbiAgICAgICd1bmRlZmluZWQnIGluIFByZWZlcmVuY2VzQ29udHJvbGxlci5hc3NldEltYWdlc1xyXG4gICAgKSB7XHJcbiAgICAgIGRlbGV0ZSBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuYXNzZXRJbWFnZXMudW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCwga2V5QnkgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgY3JlYXRlSWQgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1NztcclxuXHJcbi8qKlxyXG4gKiByZXBsYWNlICdpbmNvbWluZ1R4TGFzdEZldGNoZWRCbG9ja3NCeU5ldHdvcmsnIHdpdGggJ2luY29taW5nVHhMYXN0RmV0Y2hlZEJsb2NrQnlDaGFpbklkJ1xyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKFxyXG4gICAgc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zICYmXHJcbiAgICBBcnJheS5pc0FycmF5KHN0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMpICYmXHJcbiAgICAhc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucy5zb21lKFxyXG4gICAgICAoaXRlbSkgPT5cclxuICAgICAgICB0eXBlb2YgaXRlbSAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGl0ZW0udHhQYXJhbXMgPT09ICd1bmRlZmluZWQnLFxyXG4gICAgKVxyXG4gICkge1xyXG4gICAgc3RhdGUuVHJhbnNhY3Rpb25Db250cm9sbGVyLnRyYW5zYWN0aW9ucyA9IGtleUJ5KFxyXG4gICAgICBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zLFxyXG4gICAgICAvLyBJbiBjYXNlIGZvciBzb21lIHJlYXNvbiBhbnkgb2YgYSB1c2VyJ3MgdHJhbnNhY3Rpb25zIGRvIG5vdCBoYXZlIGFuIGlkXHJcbiAgICAgIC8vIGdlbmVyYXRlIGEgbmV3IG9uZSBmb3IgdGhlIHRyYW5zYWN0aW9uLlxyXG4gICAgICAodHgpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIHR4LmlkID09PSAndW5kZWZpbmVkJyB8fCB0eC5pZCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgLy8gVGhpcyBtdXRhdGVzIHRoZSBpdGVtIGluIHRoZSBhcnJheSwgc28gd2lsbCByZXN1bHQgaW4gYSBjaGFuZ2UgdG9cclxuICAgICAgICAgIC8vIHRoZSBzdGF0ZS5cclxuICAgICAgICAgIHR4LmlkID0gY3JlYXRlSWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR4LmlkO1xyXG4gICAgICB9LFxyXG4gICAgKTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNTg7XHJcblxyXG4vKipcclxuICogRGVsZXRlcyB0aGUgc3dhcHNXZWxjb21lTWVzc2FnZUhhc0JlZW5TaG93biBwcm9wZXJ0eSBmcm9tIHN0YXRlXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBkZWxldGUgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyPy5zd2Fwc1dlbGNvbWVNZXNzYWdlSGFzQmVlblNob3duO1xyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBjbG9uZURlZXAsXHJcbiAgY29uY2F0LFxyXG4gIGdyb3VwQnksXHJcbiAga2V5QnksXHJcbiAgcGlja0J5LFxyXG4gIGlzUGxhaW5PYmplY3QsXHJcbn0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVFJBTlNBQ1RJT05fVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA1OTtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIG9ycGhhbmVkIGNhbmNlbCBhbmQgcmV0cnkgdHJhbnNhY3Rpb25zIHRoYXQgbm8gbG9uZ2VyIGhhdmUgdGhlXHJcbiAqIG9yaWdpbmFsIHRyYW5zYWN0aW9uIGluIHN0YXRlLCB3aGljaCByZXN1bHRzIGluIGJ1Z3MuXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnM7XHJcbiAgaWYgKGlzUGxhaW5PYmplY3QodHJhbnNhY3Rpb25zKSkge1xyXG4gICAgY29uc3Qgbm9uY2VOZXR3b3JrR3JvdXBlZE9iamVjdCA9IGdyb3VwQnkoXHJcbiAgICAgIE9iamVjdC52YWx1ZXModHJhbnNhY3Rpb25zKSxcclxuICAgICAgKHR4KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGAke3R4LnR4UGFyYW1zPy5ub25jZX0tJHt0eC5jaGFpbklkID8/IHR4Lm1ldGFtYXNrTmV0d29ya0lkfWA7XHJcbiAgICAgIH0sXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHdpdGhvdXRPcnBoYW5zID0gcGlja0J5KG5vbmNlTmV0d29ya0dyb3VwZWRPYmplY3QsIChncm91cCkgPT4ge1xyXG4gICAgICByZXR1cm4gZ3JvdXAuc29tZShcclxuICAgICAgICAodHgpID0+XHJcbiAgICAgICAgICB0eC50eXBlICE9PSBUUkFOU0FDVElPTl9UWVBFUy5DQU5DRUwgJiZcclxuICAgICAgICAgIHR4LnR5cGUgIT09IFRSQU5TQUNUSU9OX1RZUEVTLlJFVFJZLFxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgICBzdGF0ZS5UcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zID0ga2V5QnkoXHJcbiAgICAgIGNvbmNhdCguLi5PYmplY3QudmFsdWVzKHdpdGhvdXRPcnBoYW5zKSksXHJcbiAgICAgICh0eCkgPT4gdHguaWQsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCwgaXNQbGFpbk9iamVjdCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjA7XHJcbmNvbnN0IFNVUFBPUlRfTk9USUZJQ0FUSU9OX0tFWSA9IDI7XHJcbmNvbnN0IFNVUFBPUlRfTk9USUZJQ0FUSU9OX0RBVEUgPSAnMjAyMC0wOC0zMSc7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgc3VwcG9ydCBzdXJ2ZXkgbm90aWZpY2F0aW9uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qgbm90aWZpY2F0aW9ucyA9IHN0YXRlPy5Ob3RpZmljYXRpb25Db250cm9sbGVyPy5ub3RpZmljYXRpb25zO1xyXG4gIGlmIChpc1BsYWluT2JqZWN0KG5vdGlmaWNhdGlvbnMpKSB7XHJcbiAgICBpZiAoXHJcbiAgICAgIG5vdGlmaWNhdGlvbnNbU1VQUE9SVF9OT1RJRklDQVRJT05fS0VZXT8uZGF0ZSA9PT1cclxuICAgICAgU1VQUE9SVF9OT1RJRklDQVRJT05fREFURVxyXG4gICAgKSB7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5Ob3RpZmljYXRpb25Db250cm9sbGVyLm5vdGlmaWNhdGlvbnNbXHJcbiAgICAgICAgU1VQUE9SVF9OT1RJRklDQVRJT05fS0VZXHJcbiAgICAgIF07XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDYxO1xyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYXR0cmlidXRlcyByZWxhdGVkIHRvIHJlY292ZXJ5IHNlZWQgcGhyYXNlIHJlbWluZGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICBpZiAoc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyKSB7XHJcbiAgICBzdGF0ZS5BcHBTdGF0ZUNvbnRyb2xsZXIucmVjb3ZlcnlQaHJhc2VSZW1pbmRlckhhc0JlZW5TaG93biA9IGZhbHNlO1xyXG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyLnJlY292ZXJ5UGhyYXNlUmVtaW5kZXJMYXN0U2hvd24gPSBjdXJyZW50VGltZTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhdGUuQXBwU3RhdGVDb250cm9sbGVyID0ge1xyXG4gICAgICByZWNvdmVyeVBocmFzZVJlbWluZGVySGFzQmVlblNob3duOiBmYWxzZSxcclxuICAgICAgcmVjb3ZlcnlQaHJhc2VSZW1pbmRlckxhc3RTaG93bjogY3VycmVudFRpbWUsXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2MjtcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIG1ldGFNZXRyaWNzU2VuZENvdW50IGZyb20gTWV0YU1ldHJpY3MgY29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIpIHtcclxuICAgIGNvbnN0IHsgbWV0YU1ldHJpY3NTZW5kQ291bnQgfSA9IHN0YXRlLk1ldGFNZXRyaWNzQ29udHJvbGxlcjtcclxuICAgIGlmIChtZXRhTWV0cmljc1NlbmRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGRlbGV0ZSBzdGF0ZS5NZXRhTWV0cmljc0NvbnRyb2xsZXIubWV0YU1ldHJpY3NTZW5kQ291bnQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDYzO1xyXG5cclxuLyoqXHJcbiAqIE1vdmVzIHRva2VuIHN0YXRlIGZyb20gcHJlZmVyZW5jZXMgY29udHJvbGxlciB0byBUb2tlbnNDb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgYWNjb3VudFRva2VucyA9IHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnM7XHJcbiAgY29uc3QgYWNjb3VudEhpZGRlblRva2VucyA9IHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRIaWRkZW5Ub2tlbnM7XHJcblxyXG4gIGNvbnN0IG5ld0FsbFRva2VucyA9IHt9O1xyXG4gIGlmIChhY2NvdW50VG9rZW5zKSB7XHJcbiAgICBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zKS5mb3JFYWNoKChhY2NvdW50QWRkcmVzcykgPT4ge1xyXG4gICAgICBPYmplY3Qua2V5cyhhY2NvdW50VG9rZW5zW2FjY291bnRBZGRyZXNzXSkuZm9yRWFjaCgoY2hhaW5JZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRva2Vuc0FycmF5ID0gYWNjb3VudFRva2Vuc1thY2NvdW50QWRkcmVzc11bY2hhaW5JZF07XHJcbiAgICAgICAgaWYgKG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICBuZXdBbGxUb2tlbnNbY2hhaW5JZF0gPSB7IFthY2NvdW50QWRkcmVzc106IHRva2Vuc0FycmF5IH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld0FsbFRva2Vuc1tjaGFpbklkXSA9IHtcclxuICAgICAgICAgICAgLi4ubmV3QWxsVG9rZW5zW2NoYWluSWRdLFxyXG4gICAgICAgICAgICBbYWNjb3VudEFkZHJlc3NdOiB0b2tlbnNBcnJheSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgbmV3QWxsSWdub3JlZFRva2VucyA9IHt9O1xyXG4gIGlmIChhY2NvdW50SGlkZGVuVG9rZW5zKSB7XHJcbiAgICBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zKS5mb3JFYWNoKChhY2NvdW50QWRkcmVzcykgPT4ge1xyXG4gICAgICBPYmplY3Qua2V5cyhhY2NvdW50SGlkZGVuVG9rZW5zW2FjY291bnRBZGRyZXNzXSkuZm9yRWFjaCgoY2hhaW5JZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlnbm9yZWRUb2tlbnNBcnJheSA9IGFjY291bnRIaWRkZW5Ub2tlbnNbYWNjb3VudEFkZHJlc3NdW2NoYWluSWRdO1xyXG4gICAgICAgIGlmIChuZXdBbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIG5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0gPSB7XHJcbiAgICAgICAgICAgIFthY2NvdW50QWRkcmVzc106IGlnbm9yZWRUb2tlbnNBcnJheSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0gPSB7XHJcbiAgICAgICAgICAgIC4uLm5ld0FsbElnbm9yZWRUb2tlbnNbY2hhaW5JZF0sXHJcbiAgICAgICAgICAgIFthY2NvdW50QWRkcmVzc106IGlnbm9yZWRUb2tlbnNBcnJheSxcclxuICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIpIHtcclxuICAgIHN0YXRlLlRva2Vuc0NvbnRyb2xsZXIuYWxsVG9rZW5zID0gbmV3QWxsVG9rZW5zO1xyXG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlci5hbGxJZ25vcmVkVG9rZW5zID0gbmV3QWxsSWdub3JlZFRva2VucztcclxuICB9IGVsc2Uge1xyXG4gICAgc3RhdGUuVG9rZW5zQ29udHJvbGxlciA9IHtcclxuICAgICAgYWxsVG9rZW5zOiBuZXdBbGxUb2tlbnMsXHJcbiAgICAgIGFsbElnbm9yZWRUb2tlbnM6IG5ld0FsbElnbm9yZWRUb2tlbnMsXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRIaWRkZW5Ub2tlbnM7XHJcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFjY291bnRUb2tlbnM7XHJcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LmFzc2V0SW1hZ2VzO1xyXG4gIGRlbGV0ZSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyPy5oaWRkZW5Ub2tlbnM7XHJcbiAgZGVsZXRlIHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnRva2VucztcclxuICBkZWxldGUgc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcj8uc3VnZ2VzdGVkVG9rZW5zO1xyXG5cclxuICByZXR1cm4gc3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwLCBpc1BsYWluT2JqZWN0IH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgVFJBTlNBQ1RJT05fVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2NDtcclxuXHJcbmNvbnN0IFNFTlRfRVRIRVIgPSAnc2VudEV0aGVyJzsgLy8gdGhlIGxlZ2FjeSB0cmFuc2FjdGlvbiB0eXBlIGJlaW5nIHJlcGxhY2VkIGluIHRoaXMgbWlncmF0aW9uIHdpdGggVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkRcclxuXHJcbi8qKlxyXG4gKiBSZW1vdmVzIG1ldGFNZXRyaWNzU2VuZENvdW50IGZyb20gTWV0YU1ldHJpY3MgY29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IHRyYW5zYWN0aW9ucyA9IHN0YXRlPy5UcmFuc2FjdGlvbkNvbnRyb2xsZXI/LnRyYW5zYWN0aW9ucztcclxuICBpZiAoaXNQbGFpbk9iamVjdCh0cmFuc2FjdGlvbnMpKSB7XHJcbiAgICBmb3IgKGNvbnN0IHR4IG9mIE9iamVjdC52YWx1ZXModHJhbnNhY3Rpb25zKSkge1xyXG4gICAgICBpZiAodHgudHlwZSA9PT0gU0VOVF9FVEhFUikge1xyXG4gICAgICAgIHR4LnR5cGUgPSBUUkFOU0FDVElPTl9UWVBFUy5TSU1QTEVfU0VORDtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHguaGlzdG9yeSkge1xyXG4gICAgICAgIHR4Lmhpc3RvcnkubWFwKCh0eEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICBpZiAodHhFdmVudC50eXBlICYmIHR4RXZlbnQudHlwZSA9PT0gU0VOVF9FVEhFUikge1xyXG4gICAgICAgICAgICB0eEV2ZW50LnR5cGUgPSBUUkFOU0FDVElPTl9UWVBFUy5TSU1QTEVfU0VORDtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHJldHVybiB0eEV2ZW50O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDY1O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZXMgbWV0YU1ldHJpY3NTZW5kQ291bnQgZnJvbSBNZXRhTWV0cmljcyBjb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlLlByZWZlcmVuY2VzQ29udHJvbGxlcikge1xyXG4gICAgY29uc3QgeyBjb21wbGV0ZWRPbmJvYXJkaW5nLCBmaXJzdFRpbWVGbG93VHlwZSB9ID1cclxuICAgICAgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyO1xyXG4gICAgc3RhdGUuT25ib2FyZGluZ0NvbnRyb2xsZXIgPSBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlciA/PyB7fTtcclxuXHJcbiAgICBpZiAoY29tcGxldGVkT25ib2FyZGluZyAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHN0YXRlLk9uYm9hcmRpbmdDb250cm9sbGVyLmNvbXBsZXRlZE9uYm9hcmRpbmcgPSBjb21wbGV0ZWRPbmJvYXJkaW5nO1xyXG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmNvbXBsZXRlZE9uYm9hcmRpbmc7XHJcbiAgICB9XHJcbiAgICBpZiAoZmlyc3RUaW1lRmxvd1R5cGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzdGF0ZS5PbmJvYXJkaW5nQ29udHJvbGxlci5maXJzdFRpbWVGbG93VHlwZSA9IGZpcnN0VGltZUZsb3dUeXBlO1xyXG4gICAgICBkZWxldGUgc3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLmZpcnN0VGltZUZsb3dUeXBlO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IExFREdFUl9UUkFOU1BPUlRfVFlQRVMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDY2O1xyXG5cclxuLyoqXHJcbiAqIENoYW5nZXMgdGhlIHVzZUxlZGdlckxpdmUgYm9vbGVhbiBwcm9wZXJ0eSB0byB0aGUgbGVkZ2VyVHJhbnNwb3J0VHlwZSBlbnVtXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgZGVmYXVsdFRyYW5zcG9ydFR5cGUgPSB3aW5kb3cubmF2aWdhdG9yLmhpZFxyXG4gICAgPyBMRURHRVJfVFJBTlNQT1JUX1RZUEVTLldFQkhJRFxyXG4gICAgOiBMRURHRVJfVFJBTlNQT1JUX1RZUEVTLlUyRjtcclxuICBjb25zdCB1c2VMZWRnZXJMaXZlID0gQm9vbGVhbihzdGF0ZS5QcmVmZXJlbmNlc0NvbnRyb2xsZXI/LnVzZUxlZGdlckxpdmUpO1xyXG4gIGNvbnN0IG5ld1N0YXRlID0ge1xyXG4gICAgLi4uc3RhdGUsXHJcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXI6IHtcclxuICAgICAgLi4uc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgbGVkZ2VyVHJhbnNwb3J0VHlwZTogdXNlTGVkZ2VyTGl2ZVxyXG4gICAgICAgID8gTEVER0VSX1RSQU5TUE9SVF9UWVBFUy5MSVZFXHJcbiAgICAgICAgOiBkZWZhdWx0VHJhbnNwb3J0VHlwZSxcclxuICAgIH0sXHJcbiAgfTtcclxuICBkZWxldGUgbmV3U3RhdGUuUHJlZmVyZW5jZXNDb250cm9sbGVyLnVzZUxlZGdlckxpdmU7XHJcbiAgcmV0dXJuIG5ld1N0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcclxuaW1wb3J0IHsgVEVTVF9DSEFJTlMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuY29uc3QgaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8gPSAoaGV4TnVtYmVyKSA9PlxyXG4gIG5ldyBCaWdOdW1iZXIoaGV4TnVtYmVyIHx8ICcweDAnLCAxNikuZ3QoMCk7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNjc7XHJcblxyXG4vKipcclxuICogU2V0cyB0aGUgc2hvd1Rlc3ROZXR3b3JrcyBwcm9wZXJ0eSB0byB0cnVlIGlmIGl0IHdhcyBmYWxzZSBvciB1bmRlZmluZWQsIGFuZCB0aGVyZSBpcyBldmlkZW5jZVxyXG4gKiB0aGF0IHRoZSB1c2VyIGhhcyB1c2VkIGEgdGVzdCBuZXRcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICB2ZXJzaW9uLFxyXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XHJcbiAgICBjb25zdCB2ZXJzaW9uZWREYXRhID0gY2xvbmVEZWVwKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XHJcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcclxuICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcclxuICB9LFxyXG59O1xyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUpIHtcclxuICBjb25zdCBQcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSBzdGF0ZT8uUHJlZmVyZW5jZXNDb250cm9sbGVyIHx8IHt9O1xyXG4gIGNvbnN0IHByZWZlcmVuY2VzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzIHx8IHt9O1xyXG5cclxuICBpZiAocHJlZmVyZW5jZXMuc2hvd1Rlc3ROZXR3b3Jrcykge1xyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgdHJhbnNhY3Rpb25zID0gc3RhdGU/LlRyYW5zYWN0aW9uQ29udHJvbGxlcj8udHJhbnNhY3Rpb25zIHx8IHt9O1xyXG4gIGNvbnN0IHByb3ZpZGVyID0gc3RhdGUuTmV0d29ya0NvbnRyb2xsZXI/LnByb3ZpZGVyIHx8IHt9O1xyXG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcclxuXHJcbiAgY29uc3QgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCA9IFRFU1RfQ0hBSU5TLmluY2x1ZGVzKHByb3ZpZGVyPy5jaGFpbklkKTtcclxuICBjb25zdCB1c2VySGFzTWFkZUFUZXN0TmV0VHJhbnNhY3Rpb24gPSBPYmplY3QudmFsdWVzKHRyYW5zYWN0aW9ucykuc29tZShcclxuICAgICh7IGNoYWluSWQgfSkgPT4gVEVTVF9DSEFJTlMuaW5jbHVkZXMoY2hhaW5JZCksXHJcbiAgKTtcclxuICBjb25zdCB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0ID0gVEVTVF9DSEFJTlMuc29tZSgoY2hhaW5JZCkgPT4ge1xyXG4gICAgY29uc3QgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbiA9IE9iamVjdC52YWx1ZXMoY2FjaGVkQmFsYW5jZXNbY2hhaW5JZF0gfHwge30pO1xyXG4gICAgY29uc3QgdXNlckhhc0FCYWxhbmNlR3JlYXRlclRoYW5aZXJvT25UaGlzQ2hhaW4gPVxyXG4gICAgICBjYWNoZWRCYWxhbmNlc0ZvckNoYWluLnNvbWUoaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8pO1xyXG4gICAgcmV0dXJuIHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluO1xyXG4gIH0pO1xyXG4gIGNvbnN0IHVzZXJIYXNVc2VkQVRlc3RuZXQgPVxyXG4gICAgdXNlcklzQ3VycmVudGx5T25BVGVzdE5ldCB8fFxyXG4gICAgdXNlckhhc01hZGVBVGVzdE5ldFRyYW5zYWN0aW9uIHx8XHJcbiAgICB1c2VySGFzQUNhY2hlZEJhbGFuY2VPbkFUZXN0bmV0O1xyXG5cclxuICBjb25zdCBuZXdTdGF0ZSA9IHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAgcHJlZmVyZW5jZXM6IHtcclxuICAgICAgICAuLi5wcmVmZXJlbmNlcyxcclxuICAgICAgICBzaG93VGVzdE5ldHdvcmtzOiB1c2VySGFzVXNlZEFUZXN0bmV0LFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9O1xyXG5cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2ODtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2Zvcm1zIHRoZSBQZXJtaXNzaW9uc0NvbnRyb2xsZXIgYW5kIFBlcm1pc3Npb25zTWV0YWRhdGEgc3Vic3RhdGVzXHJcbiAqIHRvIG1hdGNoIHRoZSBuZXcgcGVybWlzc2lvbiBzeXN0ZW0uXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3Qge1xyXG4gICAgUGVybWlzc2lvbnNDb250cm9sbGVyID0ge30sXHJcbiAgICBQZXJtaXNzaW9uc01ldGFkYXRhID0ge30sXHJcbiAgICAuLi5yZW1haW5pbmdTdGF0ZVxyXG4gIH0gPSBzdGF0ZTtcclxuXHJcbiAgY29uc3Qge1xyXG4gICAgZG9tYWluTWV0YWRhdGEgPSB7fSxcclxuICAgIHBlcm1pc3Npb25zSGlzdG9yeSA9IHt9LFxyXG4gICAgcGVybWlzc2lvbnNMb2cgPSBbXSxcclxuICB9ID0gUGVybWlzc2lvbnNNZXRhZGF0YTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnJlbWFpbmluZ1N0YXRlLFxyXG4gICAgUGVybWlzc2lvbkNvbnRyb2xsZXI6IGdldFBlcm1pc3Npb25Db250cm9sbGVyU3RhdGUoUGVybWlzc2lvbnNDb250cm9sbGVyKSxcclxuICAgIFBlcm1pc3Npb25Mb2dDb250cm9sbGVyOiB7XHJcbiAgICAgIHBlcm1pc3Npb25BY3Rpdml0eUxvZzogcGVybWlzc2lvbnNMb2csXHJcbiAgICAgIHBlcm1pc3Npb25IaXN0b3J5OiBwZXJtaXNzaW9uc0hpc3RvcnksXHJcbiAgICB9LFxyXG4gICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjpcclxuICAgICAgZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSxcclxuICB9O1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRQZXJtaXNzaW9uQ29udHJvbGxlclN0YXRlKFBlcm1pc3Npb25zQ29udHJvbGxlcikge1xyXG4gIGNvbnN0IHsgZG9tYWlucyA9IHt9IH0gPSBQZXJtaXNzaW9uc0NvbnRyb2xsZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4YW1wbGUgZXhpc3RpbmcgZG9tYWluIGVudHJ5LiBFdmVyeSBleGlzdGluZyBkb21haW4gd2lsbCBoYXZlIGEgc2luZ2xlXHJcbiAgICogZXRoX2FjY291bnRzIHBlcm1pc3Npb24sIHdoaWNoIHNpbXBsaWZpZXMgdGhlIHRyYW5zZm9ybS5cclxuICAgKlxyXG4gICAqICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbyc6IHtcclxuICAgKiAgIHBlcm1pc3Npb25zOiBbXHJcbiAgICogICAgIHtcclxuICAgKiAgICAgICAnQGNvbnRleHQnOiBbJ2h0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ycGMtY2FwJ10sXHJcbiAgICogICAgICAgJ2NhdmVhdHMnOiBbXHJcbiAgICogICAgICAgICB7XHJcbiAgICogICAgICAgICAgIG5hbWU6ICdwcmltYXJ5QWNjb3VudE9ubHknLFxyXG4gICAqICAgICAgICAgICB0eXBlOiAnbGltaXRSZXNwb25zZUxlbmd0aCcsXHJcbiAgICogICAgICAgICAgIHZhbHVlOiAxLFxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICAgIHtcclxuICAgKiAgICAgICAgICAgbmFtZTogJ2V4cG9zZWRBY2NvdW50cycsXHJcbiAgICogICAgICAgICAgIHR5cGU6ICdmaWx0ZXJSZXNwb25zZScsXHJcbiAgICogICAgICAgICAgIHZhbHVlOiBbJzB4MGM5N2E1YzgxZTUwYTAyZmY4YmU3M2NjM2YwYTA1NjllNjFmNGVkOCddLFxyXG4gICAqICAgICAgICAgfSxcclxuICAgKiAgICAgICBdLFxyXG4gICAqICAgICAgICdkYXRlJzogMTYxNjAwNjM2OTQ5OCxcclxuICAgKiAgICAgICAnaWQnOiAnM2QwYmRjMjctZThlNC00ZmIwLWEyNGItMzQwZDYxZjZhM2ZhJyxcclxuICAgKiAgICAgICAnaW52b2tlcic6ICdodHRwczovL21ldGFtYXNrLmdpdGh1Yi5pbycsXHJcbiAgICogICAgICAgJ3BhcmVudENhcGFiaWxpdHknOiAnZXRoX2FjY291bnRzJyxcclxuICAgKiAgICAgfSxcclxuICAgKiAgIF0sXHJcbiAgICogfSxcclxuICAgKi9cclxuXHJcbiAgY29uc3QgRVRIX0FDQ09VTlRTID0gJ2V0aF9hY2NvdW50cyc7XHJcbiAgY29uc3QgTkVXX0NBVkVBVF9UWVBFID0gJ3Jlc3RyaWN0UmV0dXJuZWRBY2NvdW50cyc7XHJcbiAgY29uc3QgT0xEX0NBVkVBVF9OQU1FID0gJ2V4cG9zZWRBY2NvdW50cyc7XHJcblxyXG4gIGNvbnN0IHN1YmplY3RzID0gT2JqZWN0LmVudHJpZXMoZG9tYWlucykucmVkdWNlKFxyXG4gICAgKHRyYW5zZm9ybWVkLCBbb3JpZ2luLCBkb21haW5FbnRyeV0pID0+IHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHBlcm1pc3Npb25zOiBbZXRoQWNjb3VudHNQZXJtaXNzaW9uXSxcclxuICAgICAgfSA9IGRvbWFpbkVudHJ5O1xyXG5cclxuICAgICAgLy8gVGhlcmUgYXJlIHR3byBjYXZlYXRzIGZvciBlYWNoIGV0aF9hY2NvdW50cyBwZXJtaXNzaW9uLCBidXQgd2Ugb25seVxyXG4gICAgICAvLyBuZWVkIHRoZSB2YWx1ZSBvZiBvbmUgb2YgdGhlbSBpbiB0aGUgbmV3IHBlcm1pc3Npb24gc3lzdGVtLlxyXG4gICAgICBjb25zdCBvbGRDYXZlYXQgPSBldGhBY2NvdW50c1Blcm1pc3Npb24uY2F2ZWF0cy5maW5kKFxyXG4gICAgICAgIChjYXZlYXQpID0+IGNhdmVhdC5uYW1lID09PSBPTERfQ0FWRUFUX05BTUUsXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBuZXdQZXJtaXNzaW9uID0ge1xyXG4gICAgICAgIC4uLmV0aEFjY291bnRzUGVybWlzc2lvbixcclxuICAgICAgICBjYXZlYXRzOiBbeyB0eXBlOiBORVdfQ0FWRUFUX1RZUEUsIHZhbHVlOiBvbGRDYXZlYXQudmFsdWUgfV0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBXZSBuZXZlciB1c2VkIHRoaXMsIGFuZCBqdXN0IG9taXQgaXQgaW4gdGhlIG5ldyBzeXN0ZW0uXHJcbiAgICAgIGRlbGV0ZSBuZXdQZXJtaXNzaW9uWydAY29udGV4dCddO1xyXG5cclxuICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcclxuICAgICAgICBvcmlnaW4sXHJcbiAgICAgICAgcGVybWlzc2lvbnM6IHtcclxuICAgICAgICAgIFtFVEhfQUNDT1VOVFNdOiBuZXdQZXJtaXNzaW9uLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH0sXHJcbiAgICB7fSxcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3ViamVjdHMsXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0U3ViamVjdE1ldGFkYXRhQ29udHJvbGxlclN0YXRlKGRvbWFpbk1ldGFkYXRhKSB7XHJcbiAgLyoqXHJcbiAgICogRXhhbXBsZSBleGlzdGluZyBkb21haW5NZXRhZGF0YSBlbnRyeS5cclxuICAgKlxyXG4gICAqIFwiaHR0cHM6Ly93d3cueW91dHViZS5jb21cIjoge1xyXG4gICAqICAgXCJob3N0XCI6IFwid3d3LnlvdXR1YmUuY29tXCIsXHJcbiAgICogICBcImljb25cIjogbnVsbCxcclxuICAgKiAgIFwibGFzdFVwZGF0ZWRcIjogMTYzNzY5NzkxNDkwOCxcclxuICAgKiAgIFwibmFtZVwiOiBcIllvdVR1YmVcIlxyXG4gICAqIH1cclxuICAgKi9cclxuXHJcbiAgY29uc3Qgc3ViamVjdE1ldGFkYXRhID0gT2JqZWN0LmVudHJpZXMoZG9tYWluTWV0YWRhdGEpLnJlZHVjZShcclxuICAgICh0cmFuc2Zvcm1lZCwgW29yaWdpbiwgbWV0YWRhdGFdKSA9PiB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBuYW1lID0gbnVsbCxcclxuICAgICAgICBpY29uID0gbnVsbCxcclxuICAgICAgICBleHRlbnNpb25JZCA9IG51bGwsXHJcbiAgICAgICAgLi4ub3RoZXJcclxuICAgICAgfSA9IG1ldGFkYXRhO1xyXG5cclxuICAgICAgLy8gV2UncmUgZ2V0dGluZyByaWQgb2YgdGhlc2UuXHJcbiAgICAgIGRlbGV0ZSBvdGhlci5sYXN0VXBkYXRlZDtcclxuICAgICAgZGVsZXRlIG90aGVyLmhvc3Q7XHJcblxyXG4gICAgICBpZiAob3JpZ2luKSB7XHJcbiAgICAgICAgdHJhbnNmb3JtZWRbb3JpZ2luXSA9IHtcclxuICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICBpY29uVXJsOiBpY29uLFxyXG4gICAgICAgICAgZXh0ZW5zaW9uSWQsXHJcbiAgICAgICAgICAuLi5vdGhlcixcclxuICAgICAgICAgIG9yaWdpbixcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1lZDtcclxuICAgIH0sXHJcbiAgICB7fSxcclxuICApO1xyXG5cclxuICByZXR1cm4ge1xyXG4gICAgc3ViamVjdE1ldGFkYXRhLFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgU1VCSkVDVF9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYXBwJztcclxuXHJcbmNvbnN0IHZlcnNpb24gPSA2OTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBgc3ViamVjdFR5cGVgIHByb3BlcnR5IHRvIGFsbCBzdWJqZWN0IG1ldGFkYXRhLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmICh0eXBlb2Ygc3RhdGU/LlN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXI/LnN1YmplY3RNZXRhZGF0YSA9PT0gJ29iamVjdCcpIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjogeyBzdWJqZWN0TWV0YWRhdGEgfSxcclxuICAgIH0gPSBzdGF0ZTtcclxuXHJcbiAgICAvLyBtdXRhdGUgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0TWV0YWRhdGEgaW4gcGxhY2VcclxuICAgIE9iamVjdC52YWx1ZXMoc3ViamVjdE1ldGFkYXRhKS5mb3JFYWNoKChtZXRhZGF0YSkgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgbWV0YWRhdGEgJiZcclxuICAgICAgICB0eXBlb2YgbWV0YWRhdGEgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgIUFycmF5LmlzQXJyYXkobWV0YWRhdGEpXHJcbiAgICAgICkge1xyXG4gICAgICAgIG1ldGFkYXRhLnN1YmplY3RUeXBlID0gbWV0YWRhdGEuZXh0ZW5zaW9uSWRcclxuICAgICAgICAgID8gU1VCSkVDVF9UWVBFUy5FWFRFTlNJT05cclxuICAgICAgICAgIDogU1VCSkVDVF9UWVBFUy5XRUJTSVRFO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzA7XHJcblxyXG4vKipcclxuICogUmVtb3ZlcyB0aGUgYHJlcXVlc3RgIGFuZCBgcmVzcG9uc2VgIHByb3BlcnRpZXMgZnJvbVxyXG4gKiBgUGVybWlzc2lvbkxvZ0NvbnRyb2xsZXIucGVybWlzc2lvbkFjdGl2aXR5TG9nYCBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGlmIChBcnJheS5pc0FycmF5KHN0YXRlPy5QZXJtaXNzaW9uTG9nQ29udHJvbGxlcj8ucGVybWlzc2lvbkFjdGl2aXR5TG9nKSkge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICBQZXJtaXNzaW9uTG9nQ29udHJvbGxlcjogeyBwZXJtaXNzaW9uQWN0aXZpdHlMb2cgfSxcclxuICAgIH0gPSBzdGF0ZTtcclxuXHJcbiAgICAvLyBtdXRhdGUgYWN0aXZpdHkgbG9nIGVudHJpZXMgaW4gcGxhY2VcclxuICAgIHBlcm1pc3Npb25BY3Rpdml0eUxvZy5mb3JFYWNoKChsb2dFbnRyeSkgPT4ge1xyXG4gICAgICBpZiAoXHJcbiAgICAgICAgbG9nRW50cnkgJiZcclxuICAgICAgICB0eXBlb2YgbG9nRW50cnkgPT09ICdvYmplY3QnICYmXHJcbiAgICAgICAgIUFycmF5LmlzQXJyYXkobG9nRW50cnkpXHJcbiAgICAgICkge1xyXG4gICAgICAgIGRlbGV0ZSBsb2dFbnRyeS5yZXF1ZXN0O1xyXG4gICAgICAgIGRlbGV0ZSBsb2dFbnRyeS5yZXNwb25zZTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBzdGF0ZTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDcxO1xyXG5cclxuLyoqXHJcbiAqIFJlbmFtZXMgTm90aWZpY2F0aW9uQ29udHJvbGxlciB0byBBbm5vdW5jZW1lbnRDb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgaWYgKHN0YXRlLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIpIHtcclxuICAgIHN0YXRlLkFubm91bmNlbWVudENvbnRyb2xsZXIgPSB7XHJcbiAgICAgIGFubm91bmNlbWVudHM6IHN0YXRlLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIubm90aWZpY2F0aW9ucyxcclxuICAgIH07XHJcbiAgICBkZWxldGUgc3RhdGUuTm90aWZpY2F0aW9uQ29udHJvbGxlcjtcclxuICB9XHJcbiAgcmV0dXJuIHN0YXRlO1xyXG59XHJcbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XHJcblxyXG5jb25zdCB2ZXJzaW9uID0gNzI7XHJcblxyXG4vKipcclxuICogU2hvdWxkIGVtcHR5IHRoZSBga25vd25NZXRob2REYXRhYCBvYmplY3QgaW4gUHJlZmVyZW5jZXNDb250cm9sbGVyXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgdmVyc2lvbixcclxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcclxuICAgIHZlcnNpb25lZERhdGEuZGF0YSA9IG5ld1N0YXRlO1xyXG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XHJcbiAgY29uc3QgUHJlZmVyZW5jZXNDb250cm9sbGVyID0gc3RhdGU/LlByZWZlcmVuY2VzQ29udHJvbGxlciB8fCB7fTtcclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIC4uLnN0YXRlLFxyXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XHJcbiAgICAgIC4uLlByZWZlcmVuY2VzQ29udHJvbGxlcixcclxuICAgICAga25vd25NZXRob2REYXRhOiB7fSxcclxuICAgIH0sXHJcbiAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5cclxuY29uc3QgdmVyc2lvbiA9IDczO1xyXG5cclxuLyoqXHJcbiAqIFNob3VsZCBlbXB0eSB0aGUgYGtub3duTWV0aG9kRGF0YWAgb2JqZWN0IGluIFByZWZlcmVuY2VzQ29udHJvbGxlclxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIHZlcnNpb24sXHJcbiAgYXN5bmMgbWlncmF0ZShvcmlnaW5hbFZlcnNpb25lZERhdGEpIHtcclxuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcclxuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcclxuICAgIGNvbnN0IHN0YXRlID0gdmVyc2lvbmVkRGF0YS5kYXRhO1xyXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XHJcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcclxuICAgIHJldHVybiB2ZXJzaW9uZWREYXRhO1xyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xyXG4gIGNvbnN0IFByZWZlcmVuY2VzQ29udHJvbGxlciA9IHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgfHwge307XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAuLi5zdGF0ZSxcclxuICAgIFByZWZlcmVuY2VzQ29udHJvbGxlcjoge1xyXG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXHJcbiAgICAgIGtub3duTWV0aG9kRGF0YToge30sXHJcbiAgICB9LFxyXG4gIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgY2xvbmVEZWVwLCB1bmlxIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGdldFJwY1VybCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5cbmNvbnN0IHZlcnNpb24gPSA3NDtcblxuY29uc3QgaGV4TnVtYmVySXNHcmVhdGVyVGhhblplcm8gPSAoaGV4TnVtYmVyKSA9PlxuICBuZXcgQmlnTnVtYmVyKGhleE51bWJlciB8fCAnMHgwJywgMTYpLmd0KDApO1xuXG5jb25zdCBERVBSRUNBVEVEX1RFU1RfTkVUX0NIQUlOSURTID0gWycweDMnLCAnMHgyYScsICcweDQnXTtcbmNvbnN0IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMUyA9IHtcbiAgJzB4Myc6IHtcbiAgICBycGNVcmw6IGdldFJwY1VybCh7IG5ldHdvcms6ICdyb3BzdGVuJyB9KSxcbiAgICBuaWNrbmFtZTogJ1JvcHN0ZW4nLFxuICAgIHRpY2tlcjogJ1JvcHN0ZW5FVEgnLFxuICB9LFxuICAnMHgyYSc6IHtcbiAgICBycGNVcmw6IGdldFJwY1VybCh7IG5ldHdvcms6ICdrb3ZhbicgfSksXG4gICAgbmlja25hbWU6ICdLb3ZhbicsXG4gICAgdGlja2VyOiAnS292YW5FVEgnLFxuICB9LFxuICAnMHg0Jzoge1xuICAgIHJwY1VybDogZ2V0UnBjVXJsKHsgbmV0d29yazogJ3JpbmtlYnknIH0pLFxuICAgIG5pY2tuYW1lOiAnUmlua2VieScsXG4gICAgdGlja2VyOiAnUmlua2VieUVUSCcsXG4gIH0sXG59O1xuXG4vKipcbiAqIE1pZ3JhdGVzIHRoZSB1c2VyIGRlZmF1bHQgYnV0IGRlcHJlY2F0ZWQgdGVzdG5ldCBuZXR3b3JrcyB0byBjdXN0b20gbmV0d29ya3MsIGFuZFxuICogaWYgdGhlIGN1cnJlbnQgbmV0d29yayBpcyBvbmUgc3VjaCBuZXR3b3JrLCB1cGRhdGVzIHRoZSBuZXR3b3JrIHByb3ZpZGVyIGRldGFpbHMgc28gdGhhdCBpdFxuICogd2lsbCB3b3JrIGFzIGEgY3VzdG9tIHJwY1xuICovXG5leHBvcnQgZGVmYXVsdCB7XG4gIHZlcnNpb24sXG4gIGFzeW5jIG1pZ3JhdGUob3JpZ2luYWxWZXJzaW9uZWREYXRhKSB7XG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xuICAgIHZlcnNpb25lZERhdGEubWV0YS52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBzdGF0ZSA9IHZlcnNpb25lZERhdGEuZGF0YTtcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRyYW5zZm9ybVN0YXRlKHN0YXRlKTtcbiAgICB2ZXJzaW9uZWREYXRhLmRhdGEgPSBuZXdTdGF0ZTtcbiAgICByZXR1cm4gdmVyc2lvbmVkRGF0YTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVN0YXRlKHN0YXRlKSB7XG4gIGNvbnN0IFByZWZlcmVuY2VzQ29udHJvbGxlciA9IHN0YXRlPy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgfHwge307XG4gIGNvbnN0IHByZWZlcmVuY2VzID0gUHJlZmVyZW5jZXNDb250cm9sbGVyLnByZWZlcmVuY2VzIHx8IHt9O1xuICBjb25zdCBOZXR3b3JrQ29udHJvbGxlciA9IHN0YXRlPy5OZXR3b3JrQ29udHJvbGxlciB8fCB7fTtcbiAgY29uc3QgcHJvdmlkZXIgPSBOZXR3b3JrQ29udHJvbGxlcj8ucHJvdmlkZXIgfHwge307XG5cbiAgY29uc3QgY3VycmVudGx5T25EZXByZWNhdGVkTmV0d29yayA9IERFUFJFQ0FURURfVEVTVF9ORVRfQ0hBSU5JRFMuZmlsdGVyKFxuICAgIChjaGFpbklkKSA9PiBjaGFpbklkID09PSBwcm92aWRlcj8uY2hhaW5JZCxcbiAgKTtcblxuICAvLyBJZiB0aGUgdXNlciBkb2VzIG5vdCB3YW50IHRvIHNlZSB0ZXN0IG5ldHdvcmtzLCBhbmQgaWYgdGhlIHRoZSB1c2VyIGlzIG5vdCBvbiBhIGRlcHJlY2F0ZWQgdGVzdCBuZXR3b3JrLCB0aGVuXG4gIC8vIG5vIG5lZWQgdG8gbWlncmF0ZSB0aGUgdGVzdCBuZXR3b3JrIGRhdGEgdG8gYSBjdXN0b20gbmV0d29ya1xuICBpZiAoXG4gICAgIXByZWZlcmVuY2VzLnNob3dUZXN0TmV0d29ya3MgJiZcbiAgICBjdXJyZW50bHlPbkRlcHJlY2F0ZWROZXR3b3JrLmxlbmd0aCA9PT0gMFxuICApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cblxuICBjb25zdCB0cmFuc2FjdGlvbnMgPSBzdGF0ZT8uVHJhbnNhY3Rpb25Db250cm9sbGVyPy50cmFuc2FjdGlvbnMgfHwge307XG4gIGNvbnN0IGNhY2hlZEJhbGFuY2VzID0gc3RhdGUuQ2FjaGVkQmFsYW5jZXNDb250cm9sbGVyPy5jYWNoZWRCYWxhbmNlcyB8fCB7fTtcblxuICBjb25zdCBkZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc01hZGVBVHJhbnNhY3Rpb24gPSBPYmplY3QudmFsdWVzKFxuICAgIHRyYW5zYWN0aW9ucyxcbiAgKVxuICAgIC5maWx0ZXIoKHsgY2hhaW5JZCB9KSA9PiBERVBSRUNBVEVEX1RFU1RfTkVUX0NIQUlOSURTLmluY2x1ZGVzKGNoYWluSWQpKVxuICAgIC5tYXAoKHsgY2hhaW5JZCB9KSA9PiBjaGFpbklkKTtcbiAgY29uc3QgZGVwcmVjYXRlZFRlc3RuZXRzT25XaGljaFRoZVVzZXJIYXNDYWNoZWRCYWxhbmNlID1cbiAgICBERVBSRUNBVEVEX1RFU1RfTkVUX0NIQUlOSURTLmZpbHRlcigoY2hhaW5JZCkgPT4ge1xuICAgICAgY29uc3QgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbiA9IE9iamVjdC52YWx1ZXMoXG4gICAgICAgIGNhY2hlZEJhbGFuY2VzW2NoYWluSWRdIHx8IHt9LFxuICAgICAgKTtcbiAgICAgIGNvbnN0IHVzZXJIYXNBQmFsYW5jZUdyZWF0ZXJUaGFuWmVyb09uVGhpc0NoYWluID1cbiAgICAgICAgY2FjaGVkQmFsYW5jZXNGb3JDaGFpbi5zb21lKGhleE51bWJlcklzR3JlYXRlclRoYW5aZXJvKTtcbiAgICAgIHJldHVybiB1c2VySGFzQUJhbGFuY2VHcmVhdGVyVGhhblplcm9PblRoaXNDaGFpbjtcbiAgICB9KTtcbiAgY29uc3QgZGVwcmVjYXRlZFRlc3RuZXRzVGhhdEhhdmVCZWVuVXNlZCA9IHVuaXEoW1xuICAgIC4uLmRlcHJlY2F0ZWRUZXN0bmV0c09uV2hpY2hUaGVVc2VySGFzQ2FjaGVkQmFsYW5jZSxcbiAgICAuLi5kZXByZWNhdGVkVGVzdG5ldHNPbldoaWNoVGhlVXNlckhhc01hZGVBVHJhbnNhY3Rpb24sXG4gICAgLi4uY3VycmVudGx5T25EZXByZWNhdGVkTmV0d29yayxcbiAgXSk7XG5cbiAgY29uc3QgbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsID1cbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID8/IFtdO1xuXG4gIGRlcHJlY2F0ZWRUZXN0bmV0c1RoYXRIYXZlQmVlblVzZWQuZm9yRWFjaCgoY2hhaW5JZCkgPT4ge1xuICAgIGlmIChcbiAgICAgICFuZXdGcmVxdWVudFJwY0xpc3REZXRhaWwuZmluZChcbiAgICAgICAgKHJwY0RldGFpbHMpID0+IHJwY0RldGFpbHMuY2hhaW5JZCA9PT0gY2hhaW5JZCxcbiAgICAgIClcbiAgICApIHtcbiAgICAgIG5ld0ZyZXF1ZW50UnBjTGlzdERldGFpbC51bnNoaWZ0KHtcbiAgICAgICAgcnBjVXJsOiBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFNbY2hhaW5JZF0ucnBjVXJsLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgICB0aWNrZXI6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tjaGFpbklkXS50aWNrZXIsXG4gICAgICAgIG5pY2tuYW1lOiBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFNbY2hhaW5JZF0ubmlja25hbWUsXG4gICAgICAgIHJwY1ByZWZzOiB7fSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKG5ld0ZyZXF1ZW50UnBjTGlzdERldGFpbC5sZW5ndGgpIHtcbiAgICBQcmVmZXJlbmNlc0NvbnRyb2xsZXIuZnJlcXVlbnRScGNMaXN0RGV0YWlsID0gbmV3RnJlcXVlbnRScGNMaXN0RGV0YWlsO1xuICB9XG5cbiAgaWYgKGN1cnJlbnRseU9uRGVwcmVjYXRlZE5ldHdvcmsubGVuZ3RoKSB7XG4gICAgY29uc3Qgc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZCA9IGN1cnJlbnRseU9uRGVwcmVjYXRlZE5ldHdvcmtbMF07XG4gICAgTmV0d29ya0NvbnRyb2xsZXIucHJvdmlkZXIgPSB7XG4gICAgICAuLi5OZXR3b3JrQ29udHJvbGxlci5wcm92aWRlcixcbiAgICAgIHR5cGU6ICdycGMnLFxuICAgICAgcnBjVXJsOiBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFNbc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZF0ucnBjVXJsLFxuICAgICAgY2hhaW5JZDogc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZCxcbiAgICAgIG5pY2tuYW1lOiBERVBSRUNBVEVEX1RFU1RfTkVUX0RFVEFJTFNbc2VsZWN0ZWROZXR3b3JrQ2hhaW5JZF0ubmlja25hbWUsXG4gICAgICB0aWNrZXI6IERFUFJFQ0FURURfVEVTVF9ORVRfREVUQUlMU1tzZWxlY3RlZE5ldHdvcmtDaGFpbklkXS50aWNrZXIsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uc3RhdGUsXG4gICAgUHJlZmVyZW5jZXNDb250cm9sbGVyOiB7XG4gICAgICAuLi5QcmVmZXJlbmNlc0NvbnRyb2xsZXIsXG4gICAgfSxcbiAgICBOZXR3b3JrQ29udHJvbGxlcjoge1xuICAgICAgLi4uTmV0d29ya0NvbnRyb2xsZXIsXG4gICAgfSxcbiAgfTtcbn1cbiIsImltcG9ydCB7IGNsb25lRGVlcCB9IGZyb20gJ2xvZGFzaCc7XG5cbmNvbnN0IHZlcnNpb24gPSA3NTtcblxuLyoqXG4gKiBEZWxldGUgdGhlIFRocmVlQm94Q29udHJvbGxlci5cbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uLFxuICBhc3luYyBtaWdyYXRlKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xuICAgIGNvbnN0IHZlcnNpb25lZERhdGEgPSBjbG9uZURlZXAob3JpZ2luYWxWZXJzaW9uZWREYXRhKTtcbiAgICB2ZXJzaW9uZWREYXRhLm1ldGEudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XG4gICAgY29uc3QgbmV3U3RhdGUgPSB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSk7XG4gICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XG4gICAgcmV0dXJuIHZlcnNpb25lZERhdGE7XG4gIH0sXG59O1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1TdGF0ZShzdGF0ZSkge1xuICBkZWxldGUgc3RhdGUuVGhyZWVCb3hDb250cm9sbGVyO1xuICByZXR1cm4gc3RhdGU7XG59XG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xyXG5pbXBvcnQgeyBUUkFOU0FDVElPTl9TVEFUVVNFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmFpbFR4c1RoYXQodmVyc2lvbiwgcmVhc29uLCBjb25kaXRpb24pIHtcclxuICByZXR1cm4gZnVuY3Rpb24gKG9yaWdpbmFsVmVyc2lvbmVkRGF0YSkge1xyXG4gICAgY29uc3QgdmVyc2lvbmVkRGF0YSA9IGNsb25lRGVlcChvcmlnaW5hbFZlcnNpb25lZERhdGEpO1xyXG4gICAgdmVyc2lvbmVkRGF0YS5tZXRhLnZlcnNpb24gPSB2ZXJzaW9uO1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB2ZXJzaW9uZWREYXRhLmRhdGE7XHJcbiAgICAgIGNvbnN0IG5ld1N0YXRlID0gdHJhbnNmb3JtU3RhdGUoc3RhdGUsIGNvbmRpdGlvbiwgcmVhc29uKTtcclxuICAgICAgdmVyc2lvbmVkRGF0YS5kYXRhID0gbmV3U3RhdGU7XHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBNZXRhTWFzayBNaWdyYXRpb24gIyR7dmVyc2lvbn0ke2Vyci5zdGFja31gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmVyc2lvbmVkRGF0YSk7XHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gdHJhbnNmb3JtU3RhdGUoc3RhdGUsIGNvbmRpdGlvbiwgcmVhc29uKSB7XHJcbiAgY29uc3QgbmV3U3RhdGUgPSBzdGF0ZTtcclxuICBjb25zdCB7IFRyYW5zYWN0aW9uQ29udHJvbGxlciB9ID0gbmV3U3RhdGU7XHJcbiAgaWYgKFRyYW5zYWN0aW9uQ29udHJvbGxlciAmJiBUcmFuc2FjdGlvbkNvbnRyb2xsZXIudHJhbnNhY3Rpb25zKSB7XHJcbiAgICBjb25zdCB7IHRyYW5zYWN0aW9ucyB9ID0gVHJhbnNhY3Rpb25Db250cm9sbGVyO1xyXG5cclxuICAgIG5ld1N0YXRlLlRyYW5zYWN0aW9uQ29udHJvbGxlci50cmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0eE1ldGEpID0+IHtcclxuICAgICAgaWYgKCFjb25kaXRpb24odHhNZXRhKSkge1xyXG4gICAgICAgIHJldHVybiB0eE1ldGE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHR4TWV0YS5zdGF0dXMgPSBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XHJcbiAgICAgIHR4TWV0YS5lcnIgPSB7XHJcbiAgICAgICAgbWVzc2FnZTogcmVhc29uLFxyXG4gICAgICAgIG5vdGU6IGBUeCBhdXRvbWF0aWNhbGx5IGZhaWxlZCBieSBtaWdyYXRpb24gYmVjYXVzZSAke3JlYXNvbn1gLFxyXG4gICAgICB9O1xyXG5cclxuICAgICAgcmV0dXJuIHR4TWV0YTtcclxuICAgIH0pO1xyXG4gIH1cclxuICByZXR1cm4gbmV3U3RhdGU7XHJcbn1cclxuIiwiLy8gTWlncmF0aW9ucyBtdXN0IHN0YXJ0IGF0IHZlcnNpb24gMSBvciBsYXRlci5cbi8vIFRoZXkgYXJlIG9iamVjdHMgd2l0aCBhIGB2ZXJzaW9uYCBudW1iZXJcbi8vIGFuZCBhIGBtaWdyYXRlYCBmdW5jdGlvbi5cbi8vXG4vLyBUaGUgYG1pZ3JhdGVgIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBwcmV2aW91c1xuLy8gY29uZmlnIGRhdGEgZm9ybWF0LCBhbmQgcmV0dXJucyB0aGUgbmV3IG9uZS5cblxuaW1wb3J0IG0wMDIgZnJvbSAnLi8wMDInO1xuaW1wb3J0IG0wMDMgZnJvbSAnLi8wMDMnO1xuaW1wb3J0IG0wMDQgZnJvbSAnLi8wMDQnO1xuaW1wb3J0IG0wMDUgZnJvbSAnLi8wMDUnO1xuaW1wb3J0IG0wMDYgZnJvbSAnLi8wMDYnO1xuaW1wb3J0IG0wMDcgZnJvbSAnLi8wMDcnO1xuaW1wb3J0IG0wMDggZnJvbSAnLi8wMDgnO1xuaW1wb3J0IG0wMDkgZnJvbSAnLi8wMDknO1xuaW1wb3J0IG0wMTAgZnJvbSAnLi8wMTAnO1xuaW1wb3J0IG0wMTEgZnJvbSAnLi8wMTEnO1xuaW1wb3J0IG0wMTIgZnJvbSAnLi8wMTInO1xuaW1wb3J0IG0wMTMgZnJvbSAnLi8wMTMnO1xuaW1wb3J0IG0wMTQgZnJvbSAnLi8wMTQnO1xuaW1wb3J0IG0wMTUgZnJvbSAnLi8wMTUnO1xuaW1wb3J0IG0wMTYgZnJvbSAnLi8wMTYnO1xuaW1wb3J0IG0wMTcgZnJvbSAnLi8wMTcnO1xuaW1wb3J0IG0wMTggZnJvbSAnLi8wMTgnO1xuaW1wb3J0IG0wMTkgZnJvbSAnLi8wMTknO1xuaW1wb3J0IG0wMjAgZnJvbSAnLi8wMjAnO1xuaW1wb3J0IG0wMjEgZnJvbSAnLi8wMjEnO1xuaW1wb3J0IG0wMjIgZnJvbSAnLi8wMjInO1xuaW1wb3J0IG0wMjMgZnJvbSAnLi8wMjMnO1xuaW1wb3J0IG0wMjQgZnJvbSAnLi8wMjQnO1xuaW1wb3J0IG0wMjUgZnJvbSAnLi8wMjUnO1xuaW1wb3J0IG0wMjYgZnJvbSAnLi8wMjYnO1xuaW1wb3J0IG0wMjcgZnJvbSAnLi8wMjcnO1xuaW1wb3J0IG0wMjggZnJvbSAnLi8wMjgnO1xuaW1wb3J0IG0wMjkgZnJvbSAnLi8wMjknO1xuaW1wb3J0IG0wMzAgZnJvbSAnLi8wMzAnO1xuaW1wb3J0IG0wMzEgZnJvbSAnLi8wMzEnO1xuaW1wb3J0IG0wMzIgZnJvbSAnLi8wMzInO1xuaW1wb3J0IG0wMzMgZnJvbSAnLi8wMzMnO1xuaW1wb3J0IG0wMzQgZnJvbSAnLi8wMzQnO1xuaW1wb3J0IG0wMzUgZnJvbSAnLi8wMzUnO1xuaW1wb3J0IG0wMzYgZnJvbSAnLi8wMzYnO1xuaW1wb3J0IG0wMzcgZnJvbSAnLi8wMzcnO1xuaW1wb3J0IG0wMzggZnJvbSAnLi8wMzgnO1xuaW1wb3J0IG0wMzkgZnJvbSAnLi8wMzknO1xuaW1wb3J0IG0wNDAgZnJvbSAnLi8wNDAnO1xuaW1wb3J0IG0wNDEgZnJvbSAnLi8wNDEnO1xuaW1wb3J0IG0wNDIgZnJvbSAnLi8wNDInO1xuaW1wb3J0IG0wNDMgZnJvbSAnLi8wNDMnO1xuaW1wb3J0IG0wNDQgZnJvbSAnLi8wNDQnO1xuaW1wb3J0IG0wNDUgZnJvbSAnLi8wNDUnO1xuaW1wb3J0IG0wNDYgZnJvbSAnLi8wNDYnO1xuaW1wb3J0IG0wNDcgZnJvbSAnLi8wNDcnO1xuaW1wb3J0IG0wNDggZnJvbSAnLi8wNDgnO1xuaW1wb3J0IG0wNDkgZnJvbSAnLi8wNDknO1xuaW1wb3J0IG0wNTAgZnJvbSAnLi8wNTAnO1xuaW1wb3J0IG0wNTEgZnJvbSAnLi8wNTEnO1xuaW1wb3J0IG0wNTIgZnJvbSAnLi8wNTInO1xuaW1wb3J0IG0wNTMgZnJvbSAnLi8wNTMnO1xuaW1wb3J0IG0wNTQgZnJvbSAnLi8wNTQnO1xuaW1wb3J0IG0wNTUgZnJvbSAnLi8wNTUnO1xuaW1wb3J0IG0wNTYgZnJvbSAnLi8wNTYnO1xuaW1wb3J0IG0wNTcgZnJvbSAnLi8wNTcnO1xuaW1wb3J0IG0wNTggZnJvbSAnLi8wNTgnO1xuaW1wb3J0IG0wNTkgZnJvbSAnLi8wNTknO1xuaW1wb3J0IG0wNjAgZnJvbSAnLi8wNjAnO1xuaW1wb3J0IG0wNjEgZnJvbSAnLi8wNjEnO1xuaW1wb3J0IG0wNjIgZnJvbSAnLi8wNjInO1xuaW1wb3J0IG0wNjMgZnJvbSAnLi8wNjMnO1xuaW1wb3J0IG0wNjQgZnJvbSAnLi8wNjQnO1xuaW1wb3J0IG0wNjUgZnJvbSAnLi8wNjUnO1xuaW1wb3J0IG0wNjYgZnJvbSAnLi8wNjYnO1xuaW1wb3J0IG0wNjcgZnJvbSAnLi8wNjcnO1xuaW1wb3J0IG0wNjggZnJvbSAnLi8wNjgnO1xuaW1wb3J0IG0wNjkgZnJvbSAnLi8wNjknO1xuaW1wb3J0IG0wNzAgZnJvbSAnLi8wNzAnO1xuaW1wb3J0IG0wNzEgZnJvbSAnLi8wNzEnO1xuaW1wb3J0IG0wNzIgZnJvbSAnLi8wNzInO1xuaW1wb3J0IG0wNzMgZnJvbSAnLi8wNzMnO1xuaW1wb3J0IG0wNzQgZnJvbSAnLi8wNzQnO1xuaW1wb3J0IG0wNzUgZnJvbSAnLi8wNzUnO1xuXG5jb25zdCBtaWdyYXRpb25zID0gW1xuICBtMDAyLFxuICBtMDAzLFxuICBtMDA0LFxuICBtMDA1LFxuICBtMDA2LFxuICBtMDA3LFxuICBtMDA4LFxuICBtMDA5LFxuICBtMDEwLFxuICBtMDExLFxuICBtMDEyLFxuICBtMDEzLFxuICBtMDE0LFxuICBtMDE1LFxuICBtMDE2LFxuICBtMDE3LFxuICBtMDE4LFxuICBtMDE5LFxuICBtMDIwLFxuICBtMDIxLFxuICBtMDIyLFxuICBtMDIzLFxuICBtMDI0LFxuICBtMDI1LFxuICBtMDI2LFxuICBtMDI3LFxuICBtMDI4LFxuICBtMDI5LFxuICBtMDMwLFxuICBtMDMxLFxuICBtMDMyLFxuICBtMDMzLFxuICBtMDM0LFxuICBtMDM1LFxuICBtMDM2LFxuICBtMDM3LFxuICBtMDM4LFxuICBtMDM5LFxuICBtMDQwLFxuICBtMDQxLFxuICBtMDQyLFxuICBtMDQzLFxuICBtMDQ0LFxuICBtMDQ1LFxuICBtMDQ2LFxuICBtMDQ3LFxuICBtMDQ4LFxuICBtMDQ5LFxuICBtMDUwLFxuICBtMDUxLFxuICBtMDUyLFxuICBtMDUzLFxuICBtMDU0LFxuICBtMDU1LFxuICBtMDU2LFxuICBtMDU3LFxuICBtMDU4LFxuICBtMDU5LFxuICBtMDYwLFxuICBtMDYxLFxuICBtMDYyLFxuICBtMDYzLFxuICBtMDY0LFxuICBtMDY1LFxuICBtMDY2LFxuICBtMDY3LFxuICBtMDY4LFxuICBtMDY5LFxuICBtMDcwLFxuICBtMDcxLFxuICBtMDcyLFxuICBtMDczLFxuICBtMDc0LFxuICBtMDc1LFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgbWlncmF0aW9ucztcbiIsIi8vIEFsbCBvZiBNZXRhTWFzaydzIHN1cHBvcnRlZCBicm93c2VycyBpbmNsdWRlIGBSZWZsZWN0LmNvbnN0cnVjdGAgc3VwcG9ydCwgc29cclxuLy8gd2UgZG9uJ3QgbmVlZCB0aGlzIHBvbHlmaWxsLlxyXG5cbi8vIFRoaXMgUHJveHkgcHJlc2V2ZXMgdGhlIHR3byBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBhZGRlZCBieSBgQGJhYmVsL3J1bnRpbWVgLlxyXG4vLyBJIGFtIG5vdCBlbnRpcmUgc3VyZSB3aGF0IHRoZXNlIHByb3BlcnRpZXMgYXJlIGZvciAobWF5YmUgRVM1L0VTNlxyXG4vLyBpbnRlcm9wZXJhYmlsaXR5PykgYnV0IHRoZXkgaGF2ZSBiZWVuIHByZXNlcnZlZCBqdXN0IGluIGNhc2UuXHJcbmNvbnN0IHJlZmxlY3RQcm94eSA9ICBuZXcgUHJveHkoXHJcbiAgUmVmbGVjdC5jb25zdHJ1Y3QsXHJcbiAge1xyXG4gICAgZ2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wZXJ0eSkge1xyXG4gICAgICBpZiAocHJvcGVydHkgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgIH0gZWxzZSBpZiAocHJvcGVydHkgPT09ICdfX2VzTW9kdWxlJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBSZWZsZWN0LmdldCguLi5hcmd1bWVudHMpO1xyXG4gICAgfVxyXG4gIH1cbik7XHJcblxubW9kdWxlLmV4cG9ydHMgPSByZWZsZWN0UHJveHk7XHIiLCJmdW5jdGlvbiBfaXNOYXRpdmVGdW5jdGlvbihmbikge1xuICByZXR1cm4gRnVuY3Rpb24udG9TdHJpbmcuY2FsbChmbikuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIikgIT09IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZUZ1bmN0aW9uLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7IiwidmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4vZ2V0UHJvdG90eXBlT2YuanNcIik7XG5cbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuXG52YXIgaXNOYXRpdmVGdW5jdGlvbiA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlRnVuY3Rpb24uanNcIik7XG5cbnZhciBjb25zdHJ1Y3QgPSByZXF1aXJlKFwiLi9jb25zdHJ1Y3QuanNcIik7XG5cbmZ1bmN0aW9uIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpIHtcbiAgdmFyIF9jYWNoZSA9IHR5cGVvZiBNYXAgPT09IFwiZnVuY3Rpb25cIiA/IG5ldyBNYXAoKSA6IHVuZGVmaW5lZDtcblxuICBtb2R1bGUuZXhwb3J0cyA9IF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFpc05hdGl2ZUZ1bmN0aW9uKENsYXNzKSkgcmV0dXJuIENsYXNzO1xuXG4gICAgaWYgKHR5cGVvZiBDbGFzcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuXG4gICAgICBfY2FjaGUuc2V0KENsYXNzLCBXcmFwcGVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBXcmFwcGVyKCkge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdChDbGFzcywgYXJndW1lbnRzLCBnZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3dyYXBOYXRpdmVTdXBlcihDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3dyYXBOYXRpdmVTdXBlciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJyk7XG5cbi8vIExhYmVsJ3MgbWF4IGxlbmd0aCBpbiBETlMgKGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMxMDM0I3BhZ2UtNylcbmNvbnN0IGRuc0xhYmVsTWF4TGVuZ3RoID0gNjM7XG5cbi8qKlxuICogVGFrZSBhbnkgaXBmc0hhc2ggYW5kIGNvbnZlcnQgaXQgdG8gRE5TLWNvbXBhdGlibGUgQ0lEXG4gKiBAcGFyYW0ge3N0cmluZ30gaXBmc0hhc2ggYSByZWd1bGFyIGlwZnMgaGFzaCBlaXRoZXIgYSBjaWQgdjAgb3IgdjFcbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlc3VsdGluZyBpcGZzIGhhc2ggYXMgYSBjaWQgdjFcbiAqL1xuY29uc3QgY2lkRm9yV2ViID0gKGlwZnNIYXNoKSA9PiB7XG5cdGxldCBjaWQgPSBuZXcgQ0lEKGlwZnNIYXNoKTtcblx0aWYgKGNpZC52ZXJzaW9uID09PSAwKSB7XG5cdFx0Y2lkID0gY2lkLnRvVjEoKTtcblx0fVxuICBsZXQgZG5zTGFiZWwgPSBjaWQudG9TdHJpbmcoJ2Jhc2UzMicpO1xuICBpZiAoZG5zTGFiZWwubGVuZ3RoID4gZG5zTGFiZWxNYXhMZW5ndGgpIHtcbiAgICBjb25zdCBiMzYgPSBjaWQudG9TdHJpbmcoJ2Jhc2UzNicpO1xuICAgIGlmIChiMzYubGVuZ3RoIDw9IGRuc0xhYmVsTWF4TGVuZ3RoKSB7XG4gICAgICByZXR1cm4gYjM2O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yICgnQ0lEIGlzIGxvbmdlciB0aGFuIEROUyBsaW1pdCBvZiA2MyBjaGFyYWN0ZXJzIGFuZCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHB1YmxpYyBnYXRld2F5cycpO1xuICB9XG5cdHJldHVybiBkbnNMYWJlbDtcbn1cblxuZXhwb3J0cy5jaWRGb3JXZWIgPSBjaWRGb3JXZWI7XG5cblxuLyoqXG4gKiBUYWtlIGFueSBpcGZzSGFzaCBhbmQgY29udmVydCBpdCB0byBhIENJRCB2MSBlbmNvZGVkIGluIGJhc2UzMi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBhIHJlZ3VsYXIgaXBmcyBoYXNoIGVpdGhlciBhIGNpZCB2MCBvciB2MSAodjEgd2lsbCByZW1haW4gdW5jaGFuZ2VkKVxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGlwZnMgaGFzaCBhcyBhIGNpZCB2MVxuICovXG5jb25zdCBjaWRWMFRvVjFCYXNlMzIgPSAoaXBmc0hhc2gpID0+IHtcblx0bGV0IGNpZCA9IG5ldyBDSUQoaXBmc0hhc2gpO1xuXHRpZiAoY2lkLnZlcnNpb24gPT09IDApIHtcblx0XHRjaWQgPSBjaWQudG9WMSgpO1xuXHR9XG5cdHJldHVybiBjaWQudG9TdHJpbmcoJ2Jhc2UzMicpO1xufVxuXG5leHBvcnRzLmNpZFYwVG9WMUJhc2UzMiA9IGNpZFYwVG9WMUJhc2UzMjtcbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBtdWx0aUMgPSByZXF1aXJlKCdtdWx0aWNvZGVjJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuXG5jb25zdCB7IGhleFN0cmluZ1RvQnVmZmVyLCBwcm9maWxlcyB9ID0gcmVxdWlyZSgnLi9wcm9maWxlcycpO1xuY29uc3QgeyBjaWRGb3JXZWIsIGNpZFYwVG9WMUJhc2UzMiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG5cdC8vZXhwb3J0IHNvbWUgaGVscGVycyBmdW5jdGlvbnNcblx0aGVscGVyczoge1xuXHRcdGNpZEZvcldlYixcblx0XHRjaWRWMFRvVjFCYXNlMzIsXG5cdH0sXG5cblx0LyoqXG5cdCogRGVjb2RlIGEgQ29udGVudCBIYXNoLlxuXHQqIEBwYXJhbSB7c3RyaW5nfSBoYXNoIGFuIGhleCBzdHJpbmcgY29udGFpbmluZyBhIGNvbnRlbnQgaGFzaFxuXHQqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRlY29kZWQgY29udGVudFxuXHQqL1xuXHRkZWNvZGU6IGZ1bmN0aW9uIChjb250ZW50SGFzaCkge1xuXHRcdGNvbnN0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGNvbnRlbnRIYXNoKTtcblx0XHRjb25zdCBjb2RlYyA9IG11bHRpQy5nZXRDb2RlYyhidWZmZXIpO1xuXHRcdGNvbnN0IHZhbHVlID0gbXVsdGlDLnJtUHJlZml4KGJ1ZmZlcik7XG5cdFx0bGV0IHByb2ZpbGUgPSBwcm9maWxlc1tjb2RlY107XG5cdFx0aWYgKCFwcm9maWxlKSBwcm9maWxlID0gcHJvZmlsZXNbJ2RlZmF1bHQnXTtcblx0XHRyZXR1cm4gcHJvZmlsZS5kZWNvZGUodmFsdWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhbiBJUEZTIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBpcGZzSGFzaCBzdHJpbmcgY29udGFpbmluZyBhbiBJUEZTIGFkZHJlc3Ncblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZXN1bHRpbmcgY29udGVudCBoYXNoXG5cdCovXG5cdGZyb21JcGZzOiBmdW5jdGlvbiAoaXBmc0hhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ2lwZnMtbnMnLCBpcGZzSGFzaCk7XG5cdH0sXG5cblx0LyoqXG5cdCogRW5jb2RlIGEgU2t5bGluayBpbnRvIGEgY29udGVudCBoYXNoXG5cdCogQHBhcmFtIHtzdHJpbmd9IHNreWxpbmsgc3RyaW5nIGNvbnRhaW5pbmcgYSBTa3lsaW5rXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU2t5bGluazogZnVuY3Rpb24gKHNreWxpbmspIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3NreW5ldC1ucycsIHNreWxpbmspO1xuXHR9LFxuXG5cdC8qKlxuXHQqIEVuY29kZSBhIFN3YXJtIGFkZHJlc3MgaW50byBhIGNvbnRlbnQgaGFzaFxuXHQqIEBwYXJhbSB7c3RyaW5nfSBzd2FybUhhc2ggc3RyaW5nIGNvbnRhaW5pbmcgYSBTd2FybSBhZGRyZXNzXG5cdCogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVzdWx0aW5nIGNvbnRlbnQgaGFzaFxuXHQqL1xuXHRmcm9tU3dhcm06IGZ1bmN0aW9uIChzd2FybUhhc2gpIHtcblx0XHRyZXR1cm4gdGhpcy5lbmNvZGUoJ3N3YXJtLW5zJywgc3dhcm1IYXNoKTtcblx0fSxcblxuXHQvKipcblx0KiBHZW5lcmFsIHB1cnBvc2UgZW5jb2RpbmcgZnVuY3Rpb25cbiAgKiBAcGFyYW0ge3N0cmluZ30gY29kZWMgXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFxuICAqL1xuXHRlbmNvZGU6IGZ1bmN0aW9uIChjb2RlYywgdmFsdWUpIHtcblx0XHRsZXQgcHJvZmlsZSA9IHByb2ZpbGVzW2NvZGVjXTtcblx0XHRpZiAoIXByb2ZpbGUpIHByb2ZpbGUgPSBwcm9maWxlc1snZGVmYXVsdCddO1xuXHRcdGNvbnN0IGVuY29kZWRWYWx1ZSA9IHByb2ZpbGUuZW5jb2RlKHZhbHVlKTtcblx0XHRyZXR1cm4gbXVsdGlILnRvSGV4U3RyaW5nKG11bHRpQy5hZGRQcmVmaXgoY29kZWMsIGVuY29kZWRWYWx1ZSkpXG5cdH0sXG5cblx0LyoqXG5cdCogRXh0cmFjdCB0aGUgY29kZWMgb2YgYSBjb250ZW50IGhhc2hcblx0KiBAcGFyYW0ge3N0cmluZ30gaGFzaCBoZXggc3RyaW5nIGNvbnRhaW5pbmcgYSBjb250ZW50IGhhc2hcblx0KiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBleHRyYWN0ZWQgY29kZWNcblx0Ki9cblx0Z2V0Q29kZWM6IGZ1bmN0aW9uIChoYXNoKSB7XG5cdFx0bGV0IGJ1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyKGhhc2gpO1xuXHRcdHJldHVybiBtdWx0aUMuZ2V0Q29kZWMoYnVmZmVyKTtcblx0fSxcbn1cbiIsIi8qXG5cdElTQyBMaWNlbnNlXG5cblx0Q29weXJpZ2h0IChjKSAyMDE5LCBQaWVycmUtTG91aXMgRGVzcGFpZ25lXG5cblx0UGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG5cdHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcblx0Y29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cblxuXHRUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFU1xuXHRXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG5cdE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG5cdEFOWSBTUEVDSUFMLCBESVJFQ1QsIElORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVNcblx0V0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG5cdEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG5cdE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SIFBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qL1xuXG5jb25zdCBDSUQgPSByZXF1aXJlKCdjaWRzJyk7XG5jb25zdCBtdWx0aUggPSByZXF1aXJlKCdtdWx0aWhhc2hlcycpO1xuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnanMtYmFzZTY0JylcblxuLyoqXG4gKiBDb252ZXJ0IGFuIGhleGFkZWNpbWFsIHN0cmluZyB0byBhIEJ1ZmZlciwgdGhlIHN0cmluZyBjYW4gc3RhcnQgd2l0aCBvciB3aXRob3V0ICcweCdcbiAqIEBwYXJhbSB7c3RyaW5nfSBoZXggYW4gaGV4YWRlY2ltYWwgdmFsdWVcbiAqIEByZXR1cm4ge0J1ZmZlcn0gdGhlIHJlc3VsdGluZyBCdWZmZXJcbiAqL1xuY29uc3QgaGV4U3RyaW5nVG9CdWZmZXIgPSAoaGV4KSA9PiB7XG5cdGxldCBwcmVmaXggPSBoZXguc2xpY2UoMCwgMik7XG5cdGxldCB2YWx1ZSA9IGhleC5zbGljZSgyKTtcblx0bGV0IHJlcyA9ICcnO1xuXHRpZiAocHJlZml4ID09PSAnMHgnKSByZXMgPSB2YWx1ZTtcblx0ZWxzZSByZXMgPSBoZXg7XG5cdHJldHVybiBtdWx0aUguZnJvbUhleFN0cmluZyhyZXMpO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBJUE5TIGlkZW50aWZpZXIgIHRvIHNhZmVndWFyZCBhZ2FpbnN0IGluc2VjdXJlIG5hbWVzLlxuICogQHBhcmFtIHtDSUR9IG5hbWUgaXNlZCBpbiBpcG5zLW5zXG4gKiBAcmV0dXJuIHtib29sfVxuICovXG5jb25zdCBpc0NyeXB0b2dyYXBoaWNJUE5TID0gIChjaWQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IG11bHRpaGFzaCB9ID0gY2lkXG4gICAgLy8gQWRkaXRpb25hbCBjaGVjayBmb3IgaWRlbnRpZmllcnMgc2hvcnRlclxuICAgIC8vIHRoYW4gd2hhdCBpbmxpbmVkIEVEMjU1MTkgcHVia2V5IHdvdWxkIGJlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2Vuc2RvbWFpbnMvZW5zLWFwcC9pc3N1ZXMvODQ5I2lzc3VlY29tbWVudC03NzcwODg5NTBcbiAgICBpZiAobXVsdGloYXNoLmxlbmd0aCA8IDM4KSB7XG4gICAgICBjb25zdCBtaCA9IG11bHRpSC5kZWNvZGUobXVsdGloYXNoKVxuICAgICAgLy8gRUQyNTUxOSBwdWJrZXlzIGFyZSBpbmxpbmVkIHVzaW5nIGlkZW50aXR5IGhhc2ggZnVuY3Rpb25cbiAgICAgIC8vIGFuZCB3ZSBzaG91bGQgbm90IHNlZSBhbnl0aGluZyBzaG9ydGVyIHRoYW4gdGhhdFxuICAgICAgaWYgKG1oLm5hbWUgPT09ICdpZGVudGl0eScgJiYgbWgubGVuZ3RoIDwgMzYpIHtcbiAgICAgICAgLy8gT25lIGNhbiByZWFkIGlubGluZWQgc3RyaW5nIHZhbHVlIHZpYTpcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lwbnMtbnMgaWQ6JywgU3RyaW5nKG11bHRpSC5kZWNvZGUobmV3IENJRCh2YWx1ZSkubXVsdGloYXNoKS5kaWdlc3QpKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb2ssIENJRCBsb29rcyBmaW5lXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoXykgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4qIGxpc3Qgb2Yga25vd24gZW5jb2RpbmcsXG4qIGVuY29kaW5nIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBgc3RyaW5nYCBpbnB1dCxcbiogYW5kIHJldHVybiBhIGBCdWZmZXJgIHJlc3VsdFxuKi9cbmNvbnN0IGVuY29kZXMgPSB7XG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgc2t5bmV0OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gYmFzZTY0LnRvVWludDhBcnJheSh2YWx1ZSlcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBzd2FybTogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgbXVsdGloYXNoID0gbXVsdGlILmVuY29kZShoZXhTdHJpbmdUb0J1ZmZlcih2YWx1ZSksICdrZWNjYWstMjU2Jyk7XG5cdFx0cmV0dXJuIG5ldyBDSUQoMSwgJ3N3YXJtLW1hbmlmZXN0JywgbXVsdGloYXNoKS5ieXRlcztcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICogQHJldHVybiB7QnVmZmVyfVxuICAqL1xuICBpcGZzOiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gbmV3IENJRCh2YWx1ZSkudG9WMSgpLmJ5dGVzO1xuICB9LFxuICAvKipcbiAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgKiBAcmV0dXJuIHtCdWZmZXJ9XG4gICovXG4gIGlwbnM6ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGNpZCA9IG5ldyBDSUQodmFsdWUpXG4gICAgaWYgKCFpc0NyeXB0b2dyYXBoaWNJUE5TKGNpZCkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2lwbnMtbnMgYWxsb3dzIG9ubHkgdmFsaWQgY3J5cHRvZ3JhcGhpYyBsaWJwMnAta2V5IGlkZW50aWZpZXJzLCB0cnkgdXNpbmcgRUQyNTUxOSBwdWJrZXkgaW5zdGVhZCcpXG4gICAgfVxuICAgIC8vIFJlcHJlc2VudCBJUE5TIG5hbWUgYXMgYSBDSUQgd2l0aCBsaWJwMnAta2V5IGNvZGVjXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2xpYnAycC9zcGVjcy9ibG9iL21hc3Rlci9SRkMvMDAwMS10ZXh0LXBlZXJpZC1jaWQubWRcbiAgICByZXR1cm4gbmV3IENJRCgxLCAnbGlicDJwLWtleScsIGNpZC5tdWx0aWhhc2gpLmJ5dGVzXG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAqIEByZXR1cm4ge0J1ZmZlcn1cbiAgKi9cbiAgdXRmODogKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpO1xuICB9LFxufTtcblxuLyoqIFxuKiBsaXN0IG9mIGtub3duIGRlY29kaW5nLFxuKiBkZWNvZGluZyBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgYEJ1ZmZlcmAgaW5wdXQsXG4qIGFuZCByZXR1cm4gYSBgc3RyaW5nYCByZXN1bHRcbiovXG5jb25zdCBkZWNvZGVzID0ge1xuICAvKipcbiAgKiBAcGFyYW0ge0J1ZmZlcn0gdmFsdWUgXG4gICovXG4gIGhleE11bHRpSGFzaDogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSk7XG4gICAgcmV0dXJuIG11bHRpSC5kZWNvZGUoY2lkLm11bHRpaGFzaCkuZGlnZXN0LnRvU3RyaW5nKCdoZXgnKTtcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICBpcGZzOiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjaWQgPSBuZXcgQ0lEKHZhbHVlKS50b1YxKCk7XG4gICAgcmV0dXJuIGNpZC50b1N0cmluZyhjaWQuY29kZWMgPT09ICdsaWJwMnAta2V5JyA/ICdiYXNlMzYnIDogJ2Jhc2UzMicpXG4gIH0sXG4gIC8qKlxuICAqIEBwYXJhbSB7QnVmZmVyfSB2YWx1ZSBcbiAgKi9cbiAgaXBuczogKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgY2lkID0gbmV3IENJRCh2YWx1ZSkudG9WMSgpXG4gICAgaWYgKCFpc0NyeXB0b2dyYXBoaWNJUE5TKGNpZCkpIHtcbiAgICAgICAgLy8gVmFsdWUgaXMgbm90IGEgbGlicDJwLWtleSwgcmV0dXJuIG9yaWdpbmFsIHN0cmluZ1xuICAgICAgICBjb25zb2xlLndhcm4oJ1tlbnNkb21haW5zL2NvbnRlbnQtaGFzaF0gdXNlIG9mIG5vbi1jcnlwdG9ncmFwaGljIGlkZW50aWZpZXJzIGluIGlwbnMtbnMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkLCBtaWdyYXRlIHRvIEVEMjU1MTkgbGlicDJwLWtleScpXG4gICAgICAgIHJldHVybiBTdHJpbmcobXVsdGlILmRlY29kZShuZXcgQ0lEKHZhbHVlKS5tdWx0aWhhc2gpLmRpZ2VzdClcbiAgICAgICAgLy8gVE9ETzogc3RhcnQgdGhyb3dpbmcgYW4gZXJyb3IgKGFmdGVyIHNvbWUgZGVwcmVjYXRpb24gcGVyaW9kKVxuICAgICAgICAvLyB0aHJvdyBFcnJvcignaXBucy1ucyBhbGxvd3Mgb25seSB2YWxpZCBjcnlwdG9ncmFwaGljIGxpYnAycC1rZXkgaWRlbnRpZmllcnMsIHRyeSB1c2luZyBFRDI1NTE5IHB1YmtleSBpbnN0ZWFkJylcbiAgICB9XG4gICAgcmV0dXJuIGNpZC50b1N0cmluZygnYmFzZTM2JylcbiAgfSxcbiAgLyoqXG4gICogQHBhcmFtIHtCdWZmZXJ9IHZhbHVlIFxuICAqL1xuICB1dGY4OiAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfSxcbiAgYmFzZTY0OiAodmFsdWUpID0+IHtcbiAgICAvLyBgdHJ1ZWAgb3B0aW9uIG1ha2VzIGl0IFVSTCBzYWZlIChyZXBsYWNlcyAvIGFuZCArIHdpdGggLSBhbmQgXyApXG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tVWludDhBcnJheSh2YWx1ZSwgdHJ1ZSlcbiAgfVxufTtcblxuLyoqXG4qIGxpc3Qgb2Yga25vd24gZW5jb2RpbmcvZGVjb2RpbmcgZm9yIGEgZ2l2ZW4gY29kZWMsXG4qIGBlbmNvZGVgIHNob3VsZCBiZSBjaG9zZW4gYW1vbmcgdGhlIGBlbmNvZGVzYCBmdW5jdGlvbnNcbiogYGRlY29kZWAgc2hvdWxkIGJlIGNob3NlbiBhbW9uZyB0aGUgYGRlY29kZXNgIGZ1bmN0aW9uc1xuKi9cbmNvbnN0IHByb2ZpbGVzID0ge1xuICAnc2t5bmV0LW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5za3luZXQsXG4gICAgZGVjb2RlOiBkZWNvZGVzLmJhc2U2NCxcbiAgfSxcbiAgJ3N3YXJtLW5zJzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy5zd2FybSxcbiAgICBkZWNvZGU6IGRlY29kZXMuaGV4TXVsdGlIYXNoLFxuICB9LFxuICAnaXBmcy1ucyc6IHtcbiAgICBlbmNvZGU6IGVuY29kZXMuaXBmcyxcbiAgICBkZWNvZGU6IGRlY29kZXMuaXBmcyxcbiAgfSxcbiAgJ2lwbnMtbnMnOiB7XG4gICAgZW5jb2RlOiBlbmNvZGVzLmlwbnMsXG4gICAgZGVjb2RlOiBkZWNvZGVzLmlwbnMsXG4gIH0sXG4gICdkZWZhdWx0Jzoge1xuICAgIGVuY29kZTogZW5jb2Rlcy51dGY4LFxuICAgIGRlY29kZTogZGVjb2Rlcy51dGY4LFxuICB9LFxufTtcblxuZXhwb3J0cy5oZXhTdHJpbmdUb0J1ZmZlciA9IGhleFN0cmluZ1RvQnVmZmVyO1xuZXhwb3J0cy5wcm9maWxlcyA9IHByb2ZpbGVzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIEhES2V5ID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ2hka2V5JykpO1xudmFyIHV0aWwgPSByZXF1aXJlKCdAZXRoZXJldW1qcy91dGlsJyk7XG52YXIgcmxwID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3JscCcpKTtcbnZhciB0eCA9IHJlcXVpcmUoJ0BldGhlcmV1bWpzL3R4Jyk7XG52YXIgYmNVclJlZ2lzdHJ5RXRoID0gcmVxdWlyZSgnQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoJyk7XG52YXIgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuY29uc3Qga2V5cmluZ1R5cGUgPSBcIlFSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2VcIjtcbmNvbnN0IHBhdGhCYXNlID0gXCJtXCI7XG5jb25zdCBNQVhfSU5ERVggPSAxMDAwO1xuY29uc3QgREVGQVVMVF9DSElMRFJFTl9QQVRIID0gXCIwLypcIjtcbnZhciBLRVlSSU5HX01PREU7XG5cbihmdW5jdGlvbiAoS0VZUklOR19NT0RFKSB7XG4gIEtFWVJJTkdfTU9ERVtcImhkXCJdID0gXCJoZFwiO1xuICBLRVlSSU5HX01PREVbXCJwdWJrZXlcIl0gPSBcInB1YmtleVwiO1xufSkoS0VZUklOR19NT0RFIHx8IChLRVlSSU5HX01PREUgPSB7fSkpO1xuXG52YXIgS0VZUklOR19BQ0NPVU5UO1xuXG4oZnVuY3Rpb24gKEtFWVJJTkdfQUNDT1VOVCkge1xuICBLRVlSSU5HX0FDQ09VTlRbXCJzdGFuZGFyZFwiXSA9IFwiYWNjb3VudC5zdGFuZGFyZFwiO1xuICBLRVlSSU5HX0FDQ09VTlRbXCJsZWRnZXJfbGl2ZVwiXSA9IFwiYWNjb3VudC5sZWRnZXJfbGl2ZVwiO1xuICBLRVlSSU5HX0FDQ09VTlRbXCJsZWRnZXJfbGVnYWN5XCJdID0gXCJhY2NvdW50LmxlZGdlcl9sZWdhY3lcIjtcbn0pKEtFWVJJTkdfQUNDT1VOVCB8fCAoS0VZUklOR19BQ0NPVU5UID0ge30pKTtcblxuY2xhc3MgQmFzZUtleXJpbmcge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMudmVyc2lvbiA9IDE7XG5cbiAgICB0aGlzLmdldEludGVyYWN0aW9uID0gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2V4dGVuZHM6IG1ldGhvZCBnZXRJbnRlcmFjdGlvbiBub3QgaW1wbGVtZW50ZWQsIHBsZWFzZSBleHRlbmQgQmFzZUtleXJpbmcgYnkgb3ZlcndyaXRpbmcgdGhpcyBtZXRob2QuXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLnR5cGUgPSBrZXlyaW5nVHlwZTtcblxuICAgIHRoaXMucmVxdWVzdFNpZ25hdHVyZSA9IGFzeW5jIChfcmVxdWVzdElkLCBzaWduUmVxdWVzdCwgcmVxdWVzdFRpdGxlLCByZXF1ZXN0RGVzY3JpcHRpb24pID0+IHtcbiAgICAgIGNvbnN0IGV0aFNpZ25hdHVyZSA9IGF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXF1ZXN0U2lnbmF0dXJlKHNpZ25SZXF1ZXN0LCByZXF1ZXN0VGl0bGUsIHJlcXVlc3REZXNjcmlwdGlvbik7XG4gICAgICBjb25zdCByZXF1ZXN0SWRCdWZmZXIgPSBldGhTaWduYXR1cmUuZ2V0UmVxdWVzdElkKCk7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBldGhTaWduYXR1cmUuZ2V0U2lnbmF0dXJlKCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0SWRCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gdXVpZC5zdHJpbmdpZnkocmVxdWVzdElkQnVmZmVyKTtcblxuICAgICAgICBpZiAocmVxdWVzdElkICE9PSBfcmVxdWVzdElkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IHJlYWQgc2lnbmF0dXJlIGVycm9yOiBtaXNtYXRjaGVkIHJlcXVlc3RJZFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByID0gc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgICAgIGNvbnN0IHMgPSBzaWduYXR1cmUuc2xpY2UoMzIsIDY0KTtcbiAgICAgIGNvbnN0IHYgPSBzaWduYXR1cmUuc2xpY2UoNjQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgdlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9IREtleSA9IGNyeXB0b0hES2V5ID0+IHtcbiAgICAgIHZhciBfY3J5cHRvSERLZXkkZ2V0T3JpZ2ksIF9jcnlwdG9IREtleSRnZXRDaGlsZDtcblxuICAgICAgY29uc3QgaGRQYXRoID0gYG0vJHtjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRQYXRoKCl9YDtcbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvSERLZXkkZ2V0T3JpZ2kgPSBjcnlwdG9IREtleS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldE9yaWdpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY29uc3QgY2hpbGRyZW5QYXRoID0gKChfY3J5cHRvSERLZXkkZ2V0Q2hpbGQgPSBjcnlwdG9IREtleS5nZXRDaGlsZHJlbigpKSA9PSBudWxsID8gdm9pZCAwIDogX2NyeXB0b0hES2V5JGdldENoaWxkLmdldFBhdGgoKSkgfHwgREVGQVVMVF9DSElMRFJFTl9QQVRIO1xuICAgICAgY29uc3QgbmFtZSA9IGNyeXB0b0hES2V5LmdldE5hbWUoKTtcblxuICAgICAgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkKSB7XG4gICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgICB9IGVsc2UgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9sZWdhY3kpIHtcbiAgICAgICAgdGhpcy5rZXlyaW5nQWNjb3VudCA9IEtFWVJJTkdfQUNDT1VOVC5sZWRnZXJfbGVnYWN5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXhmcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8taGRrZXksIGNhbm5vdCBnZXQgc291cmNlIGZpbmdlcnByaW50XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB4cHViID0gY3J5cHRvSERLZXkuZ2V0QmlwMzJLZXkoKTtcbiAgICAgIHRoaXMueGZwID0geGZwO1xuICAgICAgdGhpcy54cHViID0geHB1YjtcbiAgICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoO1xuICAgICAgdGhpcy5jaGlsZHJlblBhdGggPSBjaGlsZHJlblBhdGg7XG5cbiAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQgJiYgbmFtZSAhPT0gXCJcIikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50ID0gY3J5cHRvQWNjb3VudCA9PiB7XG4gICAgICB2YXIgX2NyeXB0b0FjY291bnQkZ2V0TWFzLCBfY3J5cHRvQWNjb3VudCRnZXRPdXQ7XG5cbiAgICAgIGNvbnN0IHhmcCA9IChfY3J5cHRvQWNjb3VudCRnZXRNYXMgPSBjcnlwdG9BY2NvdW50LmdldE1hc3RlckZpbmdlcnByaW50KCkpID09IG51bGwgPyB2b2lkIDAgOiBfY3J5cHRvQWNjb3VudCRnZXRNYXMudG9TdHJpbmcoXCJoZXhcIik7XG5cbiAgICAgIGlmICgheGZwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1hY2NvdW50LCBjYW5ub3QgZ2V0IG1hc3RlciBmaW5nZXJwcmludFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54ZnAgPSB4ZnA7XG4gICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBjb25zdCBvdXRwdXRzID0gY3J5cHRvQWNjb3VudC5nZXRPdXRwdXREZXNjcmlwdG9ycygpO1xuXG4gICAgICBpZiAoIW91dHB1dHMgfHwgb3V0cHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIG5vIGNyeXB0byBvdXRwdXQgZm91bmRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChvdXRwdXRzLmxlbmd0aCAlIDUgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IG9ubHkgc3VwcG9ydCA1eCBwdWJrZXkgYWNjb3VudHMgZm9yIG5vd1wiKTtcbiAgICAgIH1cblxuICAgICAgKF9jcnlwdG9BY2NvdW50JGdldE91dCA9IGNyeXB0b0FjY291bnQuZ2V0T3V0cHV0RGVzY3JpcHRvcnMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jcnlwdG9BY2NvdW50JGdldE91dC5mb3JFYWNoKG9kID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9IREtleSA9IG9kLmdldEhES2V5KCk7XG5cbiAgICAgICAgICBpZiAoY3J5cHRvSERLZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGNyeXB0b0hES2V5LmdldEtleSgpO1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGBNLyR7Y3J5cHRvSERLZXkuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpfWA7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3Moa2V5LCB0cnVlKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgICAgIHRoaXMubmFtZSA9IGNyeXB0b0hES2V5LmdldE5hbWUoKTtcblxuICAgICAgICAgICAgaWYgKGNyeXB0b0hES2V5LmdldE5vdGUoKSA9PT0gS0VZUklOR19BQ0NPVU5ULmxlZGdlcl9saXZlKSB7XG4gICAgICAgICAgICAgIHRoaXMua2V5cmluZ0FjY291bnQgPSBLRVlSSU5HX0FDQ09VTlQubGVkZ2VyX2xpdmU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhdGhzW3V0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucGF0aHNbdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKV0gPSBwYXRoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gY2hhbmdlZDtcbiAgICB9OyAvLyBwcml2YXRlIF9fcmVhZExlZGdlckxpdmVBY2NvdW50cyA9IGFzeW5jICgpID0+IHtcbiAgICAvLyAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIC8vICAgICBpZiAocmVzdWx0LmdldFJlZ2lzdHJ5VHlwZSgpID09PSBleHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fQUNDT1VOVCkge1xuICAgIC8vICAgICAgICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX19yZWFkQ3J5cHRvQWNjb3VudChyZXN1bHQgYXMgQ3J5cHRvQWNjb3VudCk7XG4gICAgLy8gICAgICAgICBpZiAoIWNoYW5nZWQpIHtcbiAgICAvLyAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCNLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX25ld19hY2NvdW50YCk7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXN0b25lRXJyb3IjcHVia2V5X2FjY291bnQudW5leHBlY3RlZF91cnR5cGVgKTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH07XG5cblxuICAgIHRoaXMuZ2V0TmFtZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrID0gaW5kZXggPT4ge1xuICAgICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSBwYXJzZUludChpbmRleCwgMTApO1xuICAgIH07XG5cbiAgICB0aGlzLl9fZ2V0Tm9ybWFsUGFnZSA9IGFzeW5jIGluY3JlbWVudCA9PiB7XG4gICAgICB0aGlzLnBhZ2UgKz0gaW5jcmVtZW50O1xuXG4gICAgICBpZiAodGhpcy5wYWdlIDw9IDApIHtcbiAgICAgICAgdGhpcy5wYWdlID0gMTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZnJvbSA9ICh0aGlzLnBhZ2UgLSAxKSAqIHRoaXMucGVyUGFnZTtcbiAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMucGVyUGFnZTtcbiAgICAgIGNvbnN0IGFjY291bnRzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpO1xuICAgICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGJhbGFuY2U6IG51bGwsXG4gICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5kZXhlc1t1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5fX2dldExlZGdlckxpdmVQYWdlID0gYXN5bmMgaW5jcmVtZW50ID0+IHtcbiAgICAgIGNvbnN0IG5leHRQYWdlID0gdGhpcy5wYWdlICsgaW5jcmVtZW50O1xuICAgICAgY29uc3QgZnJvbSA9IChuZXh0UGFnZSAtIDEpICogdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlO1xuICAgICAgY29uc3QgYWNjb3VudHMgPSBbXTtcblxuICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWdlICs9IGluY3JlbWVudDtcbiAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICB9O1xuXG4gICAgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXggPSBhc3luYyAocGIsIGkpID0+IHtcbiAgICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgICAgdGhpcy5jaGVja0tleXJpbmcoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGRrKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHRoaXMuaGRrID0gSERLZXkuZnJvbUV4dGVuZGVkS2V5KHRoaXMueHB1Yik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjaGlsZHJlblBhdGggPSB0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLCBTdHJpbmcoaSkpLnJlcGxhY2UoL1xcKi9nLCBcIjBcIik7XG4gICAgICAgIGNvbnN0IGRrZXkgPSB0aGlzLmhkay5kZXJpdmUoYCR7cGJ9LyR7Y2hpbGRyZW5QYXRofWApO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gXCIweFwiICsgdXRpbC5wdWJsaWNUb0FkZHJlc3MoZGtleS5wdWJsaWNLZXksIHRydWUpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IE9iamVjdC5rZXlzKHRoaXMucGF0aHMpW2ldO1xuXG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhyZXN1bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5c3RvbmVFcnJvciNwdWJrZXlfYWNjb3VudC5ub19leHBlY3RlZF9hY2NvdW50YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9OyAvL2NvbW1vbiBwcm9wc1xuXG5cbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHRoaXMucGVyUGFnZSA9IDU7XG4gICAgdGhpcy5hY2NvdW50cyA9IFtdO1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgIHRoaXMudW5sb2NrZWRBY2NvdW50ID0gMDtcbiAgICB0aGlzLm5hbWUgPSBcIlFSIEhhcmR3YXJlXCI7XG4gICAgdGhpcy5rZXlyaW5nTW9kZSA9IEtFWVJJTkdfTU9ERS5oZDtcbiAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gS0VZUklOR19BQ0NPVU5ULnN0YW5kYXJkO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTsgLy9oZCBwcm9wcztcblxuICAgIHRoaXMueGZwID0gXCJcIjtcbiAgICB0aGlzLnhwdWIgPSBcIlwiO1xuICAgIHRoaXMuaGRQYXRoID0gXCJcIjtcbiAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICB0aGlzLmluZGV4ZXMgPSB7fTsgLy9wdWJrZXkgcHJvcHM7XG5cbiAgICB0aGlzLnBhdGhzID0ge307XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShvcHRzKTtcbiAgfSAvL2luaXRpYWwgcmVhZFxuXG5cbiAgYXN5bmMgcmVhZEtleXJpbmcoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudCgpO1xuICAgIHRoaXMuc3luY0tleXJpbmcocmVzdWx0KTtcbiAgfVxuXG4gIHN5bmNLZXlyaW5nKGRhdGEpIHtcbiAgICBpZiAoZGF0YS5nZXRSZWdpc3RyeVR5cGUoKS5nZXRUeXBlKCkgPT09IGJjVXJSZWdpc3RyeUV0aC5leHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VHlwZSgpKSB7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLmhkO1xuXG4gICAgICB0aGlzLl9fcmVhZENyeXB0b0hES2V5KGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gS0VZUklOR19NT0RFLnB1YmtleTtcblxuICAgICAgdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KGRhdGEpO1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrS2V5cmluZygpIHtcbiAgICBpZiAoIXRoaXMueGZwIHx8ICF0aGlzLnhwdWIgfHwgIXRoaXMuaGRQYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfa2V5cmluZzoga2V5cmluZyBub3QgZnVsZmlsbGVkLCBwbGVhc2UgY2FsbCBmdW5jdGlvbiBgcmVhZEtleXJpbmdgIGZpcnN0bHlcIik7XG4gICAgfVxuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgLy9jb21tb25cbiAgICAgIGluaXRpYWxpemVkOiB0aGlzLmluaXRpYWxpemVkLFxuICAgICAgYWNjb3VudHM6IHRoaXMuYWNjb3VudHMsXG4gICAgICBjdXJyZW50QWNjb3VudDogdGhpcy5jdXJyZW50QWNjb3VudCxcbiAgICAgIHBhZ2U6IHRoaXMucGFnZSxcbiAgICAgIHBlclBhZ2U6IHRoaXMucGVyUGFnZSxcbiAgICAgIGtleXJpbmdBY2NvdW50OiB0aGlzLmtleXJpbmdBY2NvdW50LFxuICAgICAga2V5cmluZ01vZGU6IHRoaXMua2V5cmluZ01vZGUsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICB4ZnA6IHRoaXMueGZwLFxuICAgICAgLy9oZFxuICAgICAgeHB1YjogdGhpcy54cHViLFxuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGNoaWxkcmVuUGF0aDogdGhpcy5jaGlsZHJlblBhdGgsXG4gICAgICBpbmRleGVzOiB0aGlzLmluZGV4ZXMsXG4gICAgICAvL3B1YmtleVxuICAgICAgcGF0aHM6IHRoaXMucGF0aHNcbiAgICB9KTtcbiAgfVxuXG4gIGRlc2VyaWFsaXplKG9wdHMpIHtcbiAgICBpZiAob3B0cykge1xuICAgICAgLy9jb21tb24gcHJvcHM7XG4gICAgICB0aGlzLmFjY291bnRzID0gb3B0cy5hY2NvdW50cztcbiAgICAgIHRoaXMuY3VycmVudEFjY291bnQgPSBvcHRzLmN1cnJlbnRBY2NvdW50O1xuICAgICAgdGhpcy5wYWdlID0gb3B0cy5wYWdlO1xuICAgICAgdGhpcy5wZXJQYWdlID0gb3B0cy5wZXJQYWdlO1xuICAgICAgdGhpcy5uYW1lID0gb3B0cy5uYW1lO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IG9wdHMuaW5pdGlhbGl6ZWQ7XG4gICAgICB0aGlzLmtleXJpbmdNb2RlID0gb3B0cy5rZXlyaW5nTW9kZSB8fCBLRVlSSU5HX01PREUuaGQ7XG4gICAgICB0aGlzLmtleXJpbmdBY2NvdW50ID0gb3B0cy5rZXlyaW5nQWNjb3VudCB8fCBLRVlSSU5HX0FDQ09VTlQuc3RhbmRhcmQ7XG4gICAgICB0aGlzLnhmcCA9IG9wdHMueGZwOyAvL2hkIHByb3BzO1xuXG4gICAgICB0aGlzLnhwdWIgPSBvcHRzLnhwdWI7XG4gICAgICB0aGlzLmhkUGF0aCA9IG9wdHMuaGRQYXRoO1xuICAgICAgdGhpcy5pbmRleGVzID0gb3B0cy5pbmRleGVzO1xuICAgICAgdGhpcy5wYXRocyA9IG9wdHMucGF0aHM7XG4gICAgICB0aGlzLmNoaWxkcmVuUGF0aCA9IG9wdHMuY2hpbGRyZW5QYXRoIHx8IERFRkFVTFRfQ0hJTERSRU5fUEFUSDtcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50QWNjb3VudChpbmRleCkge1xuICAgIHRoaXMuY3VycmVudEFjY291bnQgPSBpbmRleDtcbiAgfVxuXG4gIGdldEN1cnJlbnRBY2NvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRBY2NvdW50O1xuICB9XG5cbiAgZ2V0Q3VycmVudEFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudHNbdGhpcy5jdXJyZW50QWNjb3VudF07XG4gIH1cblxuICBhc3luYyBhZGRBY2NvdW50cyhuID0gMSkge1xuICAgIGNvbnN0IGZyb20gPSB0aGlzLnVubG9ja2VkQWNjb3VudDtcbiAgICBjb25zdCB0byA9IGZyb20gKyBuO1xuICAgIGNvbnN0IG5ld0FjY291bnRzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspIHtcbiAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSk7XG4gICAgICBuZXdBY2NvdW50cy5wdXNoKGFkZHJlc3MpO1xuICAgICAgdGhpcy5wYWdlID0gMDtcbiAgICAgIHRoaXMudW5sb2NrZWRBY2NvdW50Kys7XG4gICAgfVxuXG4gICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuY29uY2F0KG5ld0FjY291bnRzKTtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50cztcbiAgfVxuXG4gIGdldEZpcnN0UGFnZSgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwO1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldE5leHRQYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgxKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2dldFBhZ2UoLTEpO1xuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlKGluY3JlbWVudCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgYXdhaXQgdGhpcy5yZWFkS2V5cmluZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmtleXJpbmdNb2RlID09PSBLRVlSSU5HX01PREUuaGQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZ2V0Tm9ybWFsUGFnZShpbmNyZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2dldExlZGdlckxpdmVQYWdlKGluY3JlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0QWNjb3VudHMoKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFjY291bnRzKTtcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgIGlmICghdGhpcy5hY2NvdW50cy5tYXAoYSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICB9XG5cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoYSA9PiBhLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gIH1cblxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgdHgkMSkge1xuICAgIGNvbnN0IGRhdGFUeXBlID0gdHgkMS50eXBlID09PSAwID8gYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnRyYW5zYWN0aW9uIDogYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnR5cGVkVHJhbnNhY3Rpb247XG4gICAgbGV0IG1lc3NhZ2VUb1NpZ247XG5cbiAgICBpZiAodHgkMS50eXBlID09PSAwKSB7XG4gICAgICBtZXNzYWdlVG9TaWduID0gQnVmZmVyLmZyb20ocmxwLmVuY29kZSh0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSB0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBjaGFpbklkID0gdHgkMS5jb21tb24uY2hhaW5JZCgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG1lc3NhZ2VUb1NpZ24sIGRhdGFUeXBlLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIGNoYWluSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCAnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7XG4gICAgcmV0dXJuIHR4LlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHsgLi4udHgkMS50b0pTT04oKSxcbiAgICAgIHR5cGU6IHR4JDEudHlwZSxcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0sIHtcbiAgICAgIGNvbW1vbjogdHgkMS5jb21tb25cbiAgICB9KTtcbiAgfVxuXG4gIHNpZ25NZXNzYWdlKHdpdGhBY2NvdW50LCBkYXRhKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lnblBlcnNvbmFsTWVzc2FnZSh3aXRoQWNjb3VudCwgZGF0YSk7XG4gIH1cblxuICBhc3luYyBzaWduUGVyc29uYWxNZXNzYWdlKHdpdGhBY2NvdW50LCBtZXNzYWdlSGV4KSB7XG4gICAgY29uc3QgdXNpZ25lZEhleCA9IHV0aWwuc3RyaXBIZXhQcmVmaXgobWVzc2FnZUhleCk7XG4gICAgY29uc3QgaGRQYXRoID0gYXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkLnY0KCk7XG4gICAgY29uc3QgZXRoU2lnblJlcXVlc3QgPSBiY1VyUmVnaXN0cnlFdGguRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChCdWZmZXIuZnJvbSh1c2lnbmVkSGV4LCBcImhleFwiKSwgYmNVclJlZ2lzdHJ5RXRoLkRhdGFUeXBlLnBlcnNvbmFsTWVzc2FnZSwgaGRQYXRoLCB0aGlzLnhmcCwgcmVxdWVzdElkLCB1bmRlZmluZWQsIHdpdGhBY2NvdW50KTtcbiAgICBjb25zdCB7XG4gICAgICByLFxuICAgICAgcyxcbiAgICAgIHZcbiAgICB9ID0gYXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnblJlcXVlc3QsIFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwgJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIG1lc3NhZ2UsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO1xuICAgIHJldHVybiBcIjB4XCIgKyBCdWZmZXIuY29uY2F0KFtyLCBzLCB2XSkudG9TdHJpbmcoXCJoZXhcIik7XG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhKHdpdGhBY2NvdW50LCB0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoZFBhdGggPSBhd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3Mod2l0aEFjY291bnQpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KEJ1ZmZlci5mcm9tKEpTT04uc3RyaW5naWZ5KHR5cGVkRGF0YSksIFwidXRmLThcIiksIGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50eXBlZERhdGEsIGhkUGF0aCwgdGhpcy54ZnAsIHJlcXVlc3RJZCwgdW5kZWZpbmVkLCB3aXRoQWNjb3VudCk7XG4gICAgY29uc3Qge1xuICAgICAgcixcbiAgICAgIHMsXG4gICAgICB2XG4gICAgfSA9IGF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShyZXF1ZXN0SWQsIGV0aFNpZ25SZXF1ZXN0LCBcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsICdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhpcyBkYXRhLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtcbiAgICByZXR1cm4gXCIweFwiICsgQnVmZmVyLmNvbmNhdChbciwgcywgdl0pLnRvU3RyaW5nKFwiaGV4XCIpO1xuICB9XG5cbiAgYXN5bmMgX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgaWYgKHRoaXMua2V5cmluZ01vZGUgPT09IEtFWVJJTkdfTU9ERS5oZCkge1xuICAgICAgY29uc3QgY2hlY2tzdW1tZWRBZGRyZXNzID0gdXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXhlc1tjaGVja3N1bW1lZEFkZHJlc3NdO1xuXG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgICBpZiAoY2hlY2tzdW1tZWRBZGRyZXNzID09PSAoYXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpKSkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBhZGRyZXNzXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYCR7dGhpcy5oZFBhdGh9LyR7dGhpcy5jaGlsZHJlblBhdGgucmVwbGFjZShcIipcIiwgaW5kZXgudG9TdHJpbmcoKSkucmVwbGFjZSgvXFwqL2csIFwiMFwiKX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSB1dGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgY29uc3QgcGF0aCA9IHRoaXMucGF0aHNbY2hlY2tzdW1tZWRBZGRyZXNzXTtcblxuICAgICAgaWYgKHR5cGVvZiBwYXRoID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWRkcmVzc1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9XG5cbn1cbkJhc2VLZXlyaW5nLnR5cGUgPSBrZXlyaW5nVHlwZTtcblxuZXhwb3J0cy5CYXNlS2V5cmluZyA9IEJhc2VLZXlyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1ldGgta2V5cmluZy5janMuZGV2ZWxvcG1lbnQuanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciB0LHIsaT1lKHJlcXVpcmUoXCJoZGtleVwiKSkscz1yZXF1aXJlKFwiQGV0aGVyZXVtanMvdXRpbFwiKSxuPWUocmVxdWlyZShcInJscFwiKSksYT1yZXF1aXJlKFwiQGV0aGVyZXVtanMvdHhcIiksbz1yZXF1aXJlKFwiQGtleXN0b25laHEvYmMtdXItcmVnaXN0cnktZXRoXCIpLGg9cmVxdWlyZShcInV1aWRcIik7IWZ1bmN0aW9uKGUpe2UuaGQ9XCJoZFwiLGUucHVia2V5PVwicHVia2V5XCJ9KHR8fCh0PXt9KSksZnVuY3Rpb24oZSl7ZS5zdGFuZGFyZD1cImFjY291bnQuc3RhbmRhcmRcIixlLmxlZGdlcl9saXZlPVwiYWNjb3VudC5sZWRnZXJfbGl2ZVwiLGUubGVkZ2VyX2xlZ2FjeT1cImFjY291bnQubGVkZ2VyX2xlZ2FjeVwifShyfHwocj17fSkpO2NsYXNzIGN7Y29uc3RydWN0b3IoZSl7dGhpcy52ZXJzaW9uPTEsdGhpcy5nZXRJbnRlcmFjdGlvbj0oKT0+e3Rocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9leHRlbmRzOiBtZXRob2QgZ2V0SW50ZXJhY3Rpb24gbm90IGltcGxlbWVudGVkLCBwbGVhc2UgZXh0ZW5kIEJhc2VLZXlyaW5nIGJ5IG92ZXJ3cml0aW5nIHRoaXMgbWV0aG9kLlwiKX0sdGhpcy50eXBlPVwiUVIgSGFyZHdhcmUgV2FsbGV0IERldmljZVwiLHRoaXMucmVxdWVzdFNpZ25hdHVyZT1hc3luYyhlLHQscixpKT0+e2NvbnN0IHM9YXdhaXQgdGhpcy5nZXRJbnRlcmFjdGlvbigpLnJlcXVlc3RTaWduYXR1cmUodCxyLGkpLG49cy5nZXRSZXF1ZXN0SWQoKSxhPXMuZ2V0U2lnbmF0dXJlKCk7aWYobiYmaC5zdHJpbmdpZnkobikhPT1lKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiByZWFkIHNpZ25hdHVyZSBlcnJvcjogbWlzbWF0Y2hlZCByZXF1ZXN0SWRcIik7cmV0dXJue3I6YS5zbGljZSgwLDMyKSxzOmEuc2xpY2UoMzIsNjQpLHY6YS5zbGljZSg2NCl9fSx0aGlzLl9fcmVhZENyeXB0b0hES2V5PWU9Pnt2YXIgdCxpO2NvbnN0IHM9XCJtL1wiK2UuZ2V0T3JpZ2luKCkuZ2V0UGF0aCgpLG49bnVsbD09KHQ9ZS5nZXRPcmlnaW4oKS5nZXRTb3VyY2VGaW5nZXJwcmludCgpKT92b2lkIDA6dC50b1N0cmluZyhcImhleFwiKSxhPShudWxsPT0oaT1lLmdldENoaWxkcmVuKCkpP3ZvaWQgMDppLmdldFBhdGgoKSl8fFwiMC8qXCIsbz1lLmdldE5hbWUoKTtpZihlLmdldE5vdGUoKT09PXIuc3RhbmRhcmQ/dGhpcy5rZXlyaW5nQWNjb3VudD1yLnN0YW5kYXJkOmUuZ2V0Tm90ZSgpPT09ci5sZWRnZXJfbGVnYWN5JiYodGhpcy5rZXlyaW5nQWNjb3VudD1yLmxlZGdlcl9sZWdhY3kpLCFuKXRocm93IG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjaW52YWxpZF9kYXRhOiBpbnZhbGlkIGNyeXB0by1oZGtleSwgY2Fubm90IGdldCBzb3VyY2UgZmluZ2VycHJpbnRcIik7Y29uc3QgaD1lLmdldEJpcDMyS2V5KCk7dGhpcy54ZnA9bix0aGlzLnhwdWI9aCx0aGlzLmhkUGF0aD1zLHRoaXMuY2hpbGRyZW5QYXRoPWEsdm9pZCAwIT09byYmXCJcIiE9PW8mJih0aGlzLm5hbWU9byksdGhpcy5pbml0aWFsaXplZD0hMH0sdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50PWU9Pnt2YXIgdCxpO2NvbnN0IG49bnVsbD09KHQ9ZS5nZXRNYXN0ZXJGaW5nZXJwcmludCgpKT92b2lkIDA6dC50b1N0cmluZyhcImhleFwiKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogaW52YWxpZCBjcnlwdG8tYWNjb3VudCwgY2Fubm90IGdldCBtYXN0ZXIgZmluZ2VycHJpbnRcIik7dGhpcy54ZnA9bix0aGlzLmluaXRpYWxpemVkPSEwO2xldCBhPSExO2NvbnN0IG89ZS5nZXRPdXRwdXREZXNjcmlwdG9ycygpO2lmKCFvfHwwPT09by5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IGludmFsaWQgY3J5cHRvLWFjY291bnQsIG5vIGNyeXB0byBvdXRwdXQgZm91bmRcIik7aWYoby5sZW5ndGglNSE9MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfZGF0YTogb25seSBzdXBwb3J0IDV4IHB1YmtleSBhY2NvdW50cyBmb3Igbm93XCIpO3JldHVybiBudWxsPT0oaT1lLmdldE91dHB1dERlc2NyaXB0b3JzKCkpfHxpLmZvckVhY2goZT0+e3RyeXtjb25zdCB0PWUuZ2V0SERLZXkoKTtpZih0KXtjb25zdCBlPXQuZ2V0S2V5KCksaT1cIk0vXCIrdC5nZXRPcmlnaW4oKS5nZXRQYXRoKCksbj1cIjB4XCIrcy5wdWJsaWNUb0FkZHJlc3MoZSwhMCkudG9TdHJpbmcoXCJoZXhcIik7dGhpcy5uYW1lPXQuZ2V0TmFtZSgpLHQuZ2V0Tm90ZSgpPT09ci5sZWRnZXJfbGl2ZSYmKHRoaXMua2V5cmluZ0FjY291bnQ9ci5sZWRnZXJfbGl2ZSksdm9pZCAwPT09dGhpcy5wYXRoc1tzLnRvQ2hlY2tzdW1BZGRyZXNzKG4pXSYmKGE9ITApLHRoaXMucGF0aHNbcy50b0NoZWNrc3VtQWRkcmVzcyhuKV09aX19Y2F0Y2goZSl7dGhyb3cgbmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNpbnZhbGlkX2RhdGE6IFwiK2UpfX0pLGF9LHRoaXMuZ2V0TmFtZT0oKT0+dGhpcy5uYW1lLHRoaXMuc2V0QWNjb3VudFRvVW5sb2NrPWU9Pnt0aGlzLnVubG9ja2VkQWNjb3VudD1wYXJzZUludChlLDEwKX0sdGhpcy5fX2dldE5vcm1hbFBhZ2U9YXN5bmMgZT0+e3RoaXMucGFnZSs9ZSx0aGlzLnBhZ2U8PTAmJih0aGlzLnBhZ2U9MSk7Y29uc3QgdD0odGhpcy5wYWdlLTEpKnRoaXMucGVyUGFnZSxyPXQrdGhpcy5wZXJQYWdlLGk9W107Zm9yKGxldCBlPXQ7ZTxyO2UrKyl7Y29uc3QgdD1hd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChcIm1cIixlKTtpLnB1c2goe2FkZHJlc3M6dCxiYWxhbmNlOm51bGwsaW5kZXg6ZX0pLHRoaXMuaW5kZXhlc1tzLnRvQ2hlY2tzdW1BZGRyZXNzKHQpXT1lfXJldHVybiBpfSx0aGlzLl9fZ2V0TGVkZ2VyTGl2ZVBhZ2U9YXN5bmMgZT0+e2NvbnN0IHQ9KHRoaXMucGFnZStlLTEpKnRoaXMucGVyUGFnZSxyPXQrdGhpcy5wZXJQYWdlLGk9W107Zm9yKGxldCBlPXQ7ZTxyO2UrKyl7Y29uc3QgdD1hd2FpdCB0aGlzLl9fYWRkcmVzc0Zyb21JbmRleChcIm1cIixlKTtpLnB1c2goe2FkZHJlc3M6dCxiYWxhbmNlOm51bGwsaW5kZXg6ZX0pfXJldHVybiB0aGlzLnBhZ2UrPWUsaX0sdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXg9YXN5bmMoZSxyKT0+e2lmKHRoaXMua2V5cmluZ01vZGU9PT10LmhkKXt0aGlzLmNoZWNrS2V5cmluZygpLHRoaXMuaGRrfHwodGhpcy5oZGs9aS5mcm9tRXh0ZW5kZWRLZXkodGhpcy54cHViKSk7Y29uc3QgdD10aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLFN0cmluZyhyKSkucmVwbGFjZSgvXFwqL2csXCIwXCIpLG49dGhpcy5oZGsuZGVyaXZlKGAke2V9LyR7dH1gKSxhPVwiMHhcIitzLnB1YmxpY1RvQWRkcmVzcyhuLnB1YmxpY0tleSwhMCkudG9TdHJpbmcoXCJoZXhcIik7cmV0dXJuIHMudG9DaGVja3N1bUFkZHJlc3MoYSl9e2NvbnN0IGU9T2JqZWN0LmtleXModGhpcy5wYXRocylbcl07aWYoZSlyZXR1cm4gcy50b0NoZWNrc3VtQWRkcmVzcyhlKTt0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI3B1YmtleV9hY2NvdW50Lm5vX2V4cGVjdGVkX2FjY291bnRcIil9fSx0aGlzLnBhZ2U9MCx0aGlzLnBlclBhZ2U9NSx0aGlzLmFjY291bnRzPVtdLHRoaXMuY3VycmVudEFjY291bnQ9MCx0aGlzLnVubG9ja2VkQWNjb3VudD0wLHRoaXMubmFtZT1cIlFSIEhhcmR3YXJlXCIsdGhpcy5rZXlyaW5nTW9kZT10LmhkLHRoaXMua2V5cmluZ0FjY291bnQ9ci5zdGFuZGFyZCx0aGlzLmluaXRpYWxpemVkPSExLHRoaXMueGZwPVwiXCIsdGhpcy54cHViPVwiXCIsdGhpcy5oZFBhdGg9XCJcIix0aGlzLmNoaWxkcmVuUGF0aD1cIjAvKlwiLHRoaXMuaW5kZXhlcz17fSx0aGlzLnBhdGhzPXt9LHRoaXMuZGVzZXJpYWxpemUoZSl9YXN5bmMgcmVhZEtleXJpbmcoKXtjb25zdCBlPWF3YWl0IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZWFkQ3J5cHRvSERLZXlPckNyeXB0b0FjY291bnQoKTt0aGlzLnN5bmNLZXlyaW5nKGUpfXN5bmNLZXlyaW5nKGUpe2UuZ2V0UmVnaXN0cnlUeXBlKCkuZ2V0VHlwZSgpPT09by5leHRlbmQuUmVnaXN0cnlUeXBlcy5DUllQVE9fSERLRVkuZ2V0VHlwZSgpPyh0aGlzLmtleXJpbmdNb2RlPXQuaGQsdGhpcy5fX3JlYWRDcnlwdG9IREtleShlKSk6KHRoaXMua2V5cmluZ01vZGU9dC5wdWJrZXksdGhpcy5fX3JlYWRDcnlwdG9BY2NvdW50KGUpKX1jaGVja0tleXJpbmcoKXtpZighdGhpcy54ZnB8fCF0aGlzLnhwdWJ8fCF0aGlzLmhkUGF0aCl0aHJvdyBuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI2ludmFsaWRfa2V5cmluZzoga2V5cmluZyBub3QgZnVsZmlsbGVkLCBwbGVhc2UgY2FsbCBmdW5jdGlvbiBgcmVhZEtleXJpbmdgIGZpcnN0bHlcIil9c2VyaWFsaXplKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSh7aW5pdGlhbGl6ZWQ6dGhpcy5pbml0aWFsaXplZCxhY2NvdW50czp0aGlzLmFjY291bnRzLGN1cnJlbnRBY2NvdW50OnRoaXMuY3VycmVudEFjY291bnQscGFnZTp0aGlzLnBhZ2UscGVyUGFnZTp0aGlzLnBlclBhZ2Usa2V5cmluZ0FjY291bnQ6dGhpcy5rZXlyaW5nQWNjb3VudCxrZXlyaW5nTW9kZTp0aGlzLmtleXJpbmdNb2RlLG5hbWU6dGhpcy5uYW1lLHZlcnNpb246dGhpcy52ZXJzaW9uLHhmcDp0aGlzLnhmcCx4cHViOnRoaXMueHB1YixoZFBhdGg6dGhpcy5oZFBhdGgsY2hpbGRyZW5QYXRoOnRoaXMuY2hpbGRyZW5QYXRoLGluZGV4ZXM6dGhpcy5pbmRleGVzLHBhdGhzOnRoaXMucGF0aHN9KX1kZXNlcmlhbGl6ZShlKXtlJiYodGhpcy5hY2NvdW50cz1lLmFjY291bnRzLHRoaXMuY3VycmVudEFjY291bnQ9ZS5jdXJyZW50QWNjb3VudCx0aGlzLnBhZ2U9ZS5wYWdlLHRoaXMucGVyUGFnZT1lLnBlclBhZ2UsdGhpcy5uYW1lPWUubmFtZSx0aGlzLmluaXRpYWxpemVkPWUuaW5pdGlhbGl6ZWQsdGhpcy5rZXlyaW5nTW9kZT1lLmtleXJpbmdNb2RlfHx0LmhkLHRoaXMua2V5cmluZ0FjY291bnQ9ZS5rZXlyaW5nQWNjb3VudHx8ci5zdGFuZGFyZCx0aGlzLnhmcD1lLnhmcCx0aGlzLnhwdWI9ZS54cHViLHRoaXMuaGRQYXRoPWUuaGRQYXRoLHRoaXMuaW5kZXhlcz1lLmluZGV4ZXMsdGhpcy5wYXRocz1lLnBhdGhzLHRoaXMuY2hpbGRyZW5QYXRoPWUuY2hpbGRyZW5QYXRofHxcIjAvKlwiKX1zZXRDdXJyZW50QWNjb3VudChlKXt0aGlzLmN1cnJlbnRBY2NvdW50PWV9Z2V0Q3VycmVudEFjY291bnQoKXtyZXR1cm4gdGhpcy5jdXJyZW50QWNjb3VudH1nZXRDdXJyZW50QWRkcmVzcygpe3JldHVybiB0aGlzLmFjY291bnRzW3RoaXMuY3VycmVudEFjY291bnRdfWFzeW5jIGFkZEFjY291bnRzKGU9MSl7Y29uc3QgdD10aGlzLnVubG9ja2VkQWNjb3VudCxyPXQrZSxpPVtdO2ZvcihsZXQgZT10O2U8cjtlKyspe2NvbnN0IHQ9YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSk7aS5wdXNoKHQpLHRoaXMucGFnZT0wLHRoaXMudW5sb2NrZWRBY2NvdW50Kyt9cmV0dXJuIHRoaXMuYWNjb3VudHM9dGhpcy5hY2NvdW50cy5jb25jYXQoaSksdGhpcy5hY2NvdW50c31nZXRGaXJzdFBhZ2UoKXtyZXR1cm4gdGhpcy5wYWdlPTAsdGhpcy5fX2dldFBhZ2UoMSl9Z2V0TmV4dFBhZ2UoKXtyZXR1cm4gdGhpcy5fX2dldFBhZ2UoMSl9Z2V0UHJldmlvdXNQYWdlKCl7cmV0dXJuIHRoaXMuX19nZXRQYWdlKC0xKX1hc3luYyBfX2dldFBhZ2UoZSl7cmV0dXJuIHRoaXMuaW5pdGlhbGl6ZWR8fGF3YWl0IHRoaXMucmVhZEtleXJpbmcoKSx0aGlzLmtleXJpbmdNb2RlPT09dC5oZD90aGlzLl9fZ2V0Tm9ybWFsUGFnZShlKTp0aGlzLl9fZ2V0TGVkZ2VyTGl2ZVBhZ2UoZSl9Z2V0QWNjb3VudHMoKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMpfXJlbW92ZUFjY291bnQoZSl7aWYoIXRoaXMuYWNjb3VudHMubWFwKGU9PmUudG9Mb3dlckNhc2UoKSkuaW5jbHVkZXMoZS50b0xvd2VyQ2FzZSgpKSl0aHJvdyBuZXcgRXJyb3IoYEFkZHJlc3MgJHtlfSBub3QgZm91bmQgaW4gdGhpcyBrZXlyaW5nYCk7dGhpcy5hY2NvdW50cz10aGlzLmFjY291bnRzLmZpbHRlcih0PT50LnRvTG93ZXJDYXNlKCkhPT1lLnRvTG93ZXJDYXNlKCkpfWFzeW5jIHNpZ25UcmFuc2FjdGlvbihlLHQpe2NvbnN0IHI9MD09PXQudHlwZT9vLkRhdGFUeXBlLnRyYW5zYWN0aW9uOm8uRGF0YVR5cGUudHlwZWRUcmFuc2FjdGlvbjtsZXQgaTtpPTA9PT10LnR5cGU/QnVmZmVyLmZyb20obi5lbmNvZGUodC5nZXRNZXNzYWdlVG9TaWduKCExKSkpOnQuZ2V0TWVzc2FnZVRvU2lnbighMSk7Y29uc3Qgcz1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksYz10LmNvbW1vbi5jaGFpbklkKCksZD1oLnY0KCksdT1vLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoaSxyLHMsdGhpcy54ZnAsZCxjKSx7cjpnLHM6eSx2OnB9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZShkLHUsXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKTtyZXR1cm4gYS5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YSh7Li4udC50b0pTT04oKSx0eXBlOnQudHlwZSxyOmcsczp5LHY6cH0se2NvbW1vbjp0LmNvbW1vbn0pfXNpZ25NZXNzYWdlKGUsdCl7cmV0dXJuIHRoaXMuc2lnblBlcnNvbmFsTWVzc2FnZShlLHQpfWFzeW5jIHNpZ25QZXJzb25hbE1lc3NhZ2UoZSx0KXtjb25zdCByPXMuc3RyaXBIZXhQcmVmaXgodCksaT1hd2FpdCB0aGlzLl9wYXRoRnJvbUFkZHJlc3MoZSksbj1oLnY0KCksYT1vLkV0aFNpZ25SZXF1ZXN0LmNvbnN0cnVjdEVUSFJlcXVlc3QoQnVmZmVyLmZyb20ocixcImhleFwiKSxvLkRhdGFUeXBlLnBlcnNvbmFsTWVzc2FnZSxpLHRoaXMueGZwLG4sdm9pZCAwLGUpLHtyOmMsczpkLHY6dX09YXdhaXQgdGhpcy5yZXF1ZXN0U2lnbmF0dXJlKG4sYSxcIlNjYW4gd2l0aCB5b3VyIEtleXN0b25lXCIsJ0FmdGVyIHlvdXIgS2V5c3RvbmUgaGFzIHNpZ25lZCB0aGlzIG1lc3NhZ2UsIGNsaWNrIG9uIFwiU2NhbiBLZXlzdG9uZVwiIHRvIHJlY2VpdmUgdGhlIHNpZ25hdHVyZScpO3JldHVyblwiMHhcIitCdWZmZXIuY29uY2F0KFtjLGQsdV0pLnRvU3RyaW5nKFwiaGV4XCIpfWFzeW5jIHNpZ25UeXBlZERhdGEoZSx0KXtjb25zdCByPWF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhlKSxpPWgudjQoKSxzPW8uRXRoU2lnblJlcXVlc3QuY29uc3RydWN0RVRIUmVxdWVzdChCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeSh0KSxcInV0Zi04XCIpLG8uRGF0YVR5cGUudHlwZWREYXRhLHIsdGhpcy54ZnAsaSx2b2lkIDAsZSkse3I6bixzOmEsdjpjfT1hd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUoaSxzLFwiU2NhbiB3aXRoIHlvdXIgS2V5c3RvbmVcIiwnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoaXMgZGF0YSwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7cmV0dXJuXCIweFwiK0J1ZmZlci5jb25jYXQoW24sYSxjXSkudG9TdHJpbmcoXCJoZXhcIil9YXN5bmMgX3BhdGhGcm9tQWRkcmVzcyhlKXtpZih0aGlzLmtleXJpbmdNb2RlPT09dC5oZCl7Y29uc3QgdD1zLnRvQ2hlY2tzdW1BZGRyZXNzKGUpO2xldCByPXRoaXMuaW5kZXhlc1t0XTtpZih2b2lkIDA9PT1yKWZvcihsZXQgZT0wO2U8MWUzO2UrKylpZih0PT09YXdhaXQgdGhpcy5fX2FkZHJlc3NGcm9tSW5kZXgoXCJtXCIsZSkpe3I9ZTticmVha31pZih2b2lkIDA9PT1yKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gYWRkcmVzc1wiKTtyZXR1cm5gJHt0aGlzLmhkUGF0aH0vJHt0aGlzLmNoaWxkcmVuUGF0aC5yZXBsYWNlKFwiKlwiLHIudG9TdHJpbmcoKSkucmVwbGFjZSgvXFwqL2csXCIwXCIpfWB9e2NvbnN0IHQ9cy50b0NoZWNrc3VtQWRkcmVzcyhlKSxyPXRoaXMucGF0aHNbdF07aWYodm9pZCAwPT09cil0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFkZHJlc3NcIik7cmV0dXJuIHJ9fX1jLnR5cGU9XCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCIsZXhwb3J0cy5CYXNlS2V5cmluZz1jO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1ldGgta2V5cmluZy5janMucHJvZHVjdGlvbi5taW4uanMubWFwXG4iLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Jhc2UtZXRoLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzJylcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9iYXNlLWV0aC1rZXlyaW5nLmNqcy5kZXZlbG9wbWVudC5qcycpXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXRpbHMgPSBleHBvcnRzLmRlY29kZSA9IGV4cG9ydHMuZW5jb2RlID0gdm9pZCAwO1xuLyoqXG4gKiBSTFAgRW5jb2RpbmcgYmFzZWQgb24gaHR0cHM6Ly9ldGgud2lraS9lbi9mdW5kYW1lbnRhbHMvcmxwXG4gKiBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIGRhdGEsIGNvbnZlcnRzIGl0IHRvIFVpbnQ4QXJyYXkgaWYgbm90LFxuICogYW5kIGFkZHMgYSBsZW5ndGggZm9yIHJlY3Vyc2lvbi5cbiAqIEBwYXJhbSBpbnB1dCBXaWxsIGJlIGNvbnZlcnRlZCB0byBVaW50OEFycmF5XG4gKiBAcmV0dXJucyBVaW50OEFycmF5IG9mIGVuY29kZWQgZGF0YVxuICoqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQucHVzaChlbmNvZGUoaW5wdXRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWYgPSBjb25jYXRCeXRlcyguLi5vdXRwdXQpO1xuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoZW5jb2RlTGVuZ3RoKGJ1Zi5sZW5ndGgsIDE5MiksIGJ1Zik7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0QnVmID0gdG9CeXRlcyhpbnB1dCk7XG4gICAgaWYgKGlucHV0QnVmLmxlbmd0aCA9PT0gMSAmJiBpbnB1dEJ1ZlswXSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gaW5wdXRCdWY7XG4gICAgfVxuICAgIHJldHVybiBjb25jYXRCeXRlcyhlbmNvZGVMZW5ndGgoaW5wdXRCdWYubGVuZ3RoLCAxMjgpLCBpbnB1dEJ1Zik7XG59XG5leHBvcnRzLmVuY29kZSA9IGVuY29kZTtcbi8qKlxuICogU2xpY2VzIGEgVWludDhBcnJheSwgdGhyb3dzIGlmIHRoZSBzbGljZSBnb2VzIG91dC1vZi1ib3VuZHMgb2YgdGhlIFVpbnQ4QXJyYXkuXG4gKiBFLmcuIGBzYWZlU2xpY2UoaGV4VG9CeXRlcygnYWEnKSwgMSwgMilgIHdpbGwgdGhyb3cuXG4gKiBAcGFyYW0gaW5wdXRcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICovXG5mdW5jdGlvbiBzYWZlU2xpY2UoaW5wdXQsIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoZW5kID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgKHNhZmVTbGljZSk6IGVuZCBzbGljZSBvZiBVaW50OEFycmF5IG91dC1vZi1ib3VuZHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0LnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuLyoqXG4gKiBQYXJzZSBpbnRlZ2Vycy4gQ2hlY2sgaWYgdGhlcmUgaXMgbm8gbGVhZGluZyB6ZXJvc1xuICogQHBhcmFtIHYgVGhlIHZhbHVlIHRvIHBhcnNlXG4gKi9cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aCh2KSB7XG4gICAgaWYgKHZbMF0gPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZXh0cmEgemVyb3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlSGV4Qnl0ZShieXRlc1RvSGV4KHYpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUxlbmd0aChsZW4sIG9mZnNldCkge1xuICAgIGlmIChsZW4gPCA1Nikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtsZW4gKyBvZmZzZXRdKTtcbiAgICB9XG4gICAgY29uc3QgaGV4TGVuZ3RoID0gbnVtYmVyVG9IZXgobGVuKTtcbiAgICBjb25zdCBsTGVuZ3RoID0gaGV4TGVuZ3RoLmxlbmd0aCAvIDI7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gbnVtYmVyVG9IZXgob2Zmc2V0ICsgNTUgKyBsTGVuZ3RoKTtcbiAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGhleFRvQnl0ZXMoZmlyc3RCeXRlICsgaGV4TGVuZ3RoKSk7XG59XG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQsIHN0cmVhbSA9IGZhbHNlKSB7XG4gICAgaWYgKCFpbnB1dCB8fCBpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0Qnl0ZXMgPSB0b0J5dGVzKGlucHV0KTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShpbnB1dEJ5dGVzKTtcbiAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVkO1xuICAgIH1cbiAgICBpZiAoZGVjb2RlZC5yZW1haW5kZXIubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IHJlbWFpbmRlciBtdXN0IGJlIHplcm8nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY29kZWQuZGF0YTtcbn1cbmV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuLyoqIERlY29kZSBhbiBpbnB1dCB3aXRoIFJMUCAqL1xuZnVuY3Rpb24gX2RlY29kZShpbnB1dCkge1xuICAgIGxldCBsZW5ndGgsIGxsZW5ndGgsIGRhdGEsIGlubmVyUmVtYWluZGVyLCBkO1xuICAgIGNvbnN0IGRlY29kZWQgPSBbXTtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBpbnB1dFswXTtcbiAgICBpZiAoZmlyc3RCeXRlIDw9IDB4N2YpIHtcbiAgICAgICAgLy8gYSBzaW5nbGUgYnl0ZSB3aG9zZSB2YWx1ZSBpcyBpbiB0aGUgWzB4MDAsIDB4N2ZdIHJhbmdlLCB0aGF0IGJ5dGUgaXMgaXRzIG93biBSTFAgZW5jb2RpbmcuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5zbGljZSgwLCAxKSxcbiAgICAgICAgICAgIHJlbWFpbmRlcjogaW5wdXQuc2xpY2UoMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0Qnl0ZSA8PSAweGI3KSB7XG4gICAgICAgIC8vIHN0cmluZyBpcyAwLTU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB2YWx1ZSAweDgwIHBsdXMgdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIGZvbGxvd2VkIGJ5IHRoZSBzdHJpbmdcbiAgICAgICAgLy8gVGhlIHJhbmdlIG9mIHRoZSBmaXJzdCBieXRlIGlzIFsweDgwLCAweGI3XVxuICAgICAgICBsZW5ndGggPSBmaXJzdEJ5dGUgLSAweDdmO1xuICAgICAgICAvLyBzZXQgMHg4MCBudWxsIHRvIDBcbiAgICAgICAgaWYgKGZpcnN0Qnl0ZSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgZGF0YSA9IFVpbnQ4QXJyYXkuZnJvbShbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDIgJiYgZGF0YVswXSA8IDB4ODApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFAgZW5jb2Rpbmc6IGludmFsaWQgcHJlZml4LCBzaW5nbGUgYnl0ZSA8IDB4ODAgYXJlIG5vdCBwcmVmaXhlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdEJ5dGUgPD0gMHhiZikge1xuICAgICAgICAvLyBzdHJpbmcgaXMgZ3JlYXRlciB0aGFuIDU1IGJ5dGVzIGxvbmcuIEEgc2luZ2xlIGJ5dGUgd2l0aCB0aGUgdmFsdWUgKDB4YjcgcGx1cyB0aGUgbGVuZ3RoIG9mIHRoZSBsZW5ndGgpLFxuICAgICAgICAvLyBmb2xsb3dlZCBieSB0aGUgbGVuZ3RoLCBmb2xsb3dlZCBieSB0aGUgc3RyaW5nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGI2O1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoIC0gMSA8IGxsZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IG5vdCBlbm91Z2ggYnl0ZXMgZm9yIHN0cmluZyBsZW5ndGgnKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBSTFA6IGV4cGVjdGVkIHN0cmluZyBsZW5ndGggdG8gYmUgZ3JlYXRlciB0aGFuIDU1Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgbGVuZ3RoICsgbGxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcmVtYWluZGVyOiBpbnB1dC5zbGljZShsZW5ndGggKyBsbGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlIDw9IDB4ZjcpIHtcbiAgICAgICAgLy8gYSBsaXN0IGJldHdlZW4gMC01NSBieXRlcyBsb25nXG4gICAgICAgIGxlbmd0aCA9IGZpcnN0Qnl0ZSAtIDB4YmY7XG4gICAgICAgIGlubmVyUmVtYWluZGVyID0gc2FmZVNsaWNlKGlucHV0LCAxLCBsZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKGxlbmd0aCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBhIGxpc3Qgb3ZlciA1NSBieXRlcyBsb25nXG4gICAgICAgIGxsZW5ndGggPSBmaXJzdEJ5dGUgLSAweGY2O1xuICAgICAgICBsZW5ndGggPSBkZWNvZGVMZW5ndGgoc2FmZVNsaWNlKGlucHV0LCAxLCBsbGVuZ3RoKSk7XG4gICAgICAgIGlmIChsZW5ndGggPCA1Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFJMUDogZW5jb2RlZCBsaXN0IHRvbyBzaG9ydCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsTGVuZ3RoID0gbGxlbmd0aCArIGxlbmd0aDtcbiAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgUkxQOiB0b3RhbCBsZW5ndGggaXMgbGFyZ2VyIHRoYW4gdGhlIGRhdGEnKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclJlbWFpbmRlciA9IHNhZmVTbGljZShpbnB1dCwgbGxlbmd0aCwgdG90YWxMZW5ndGgpO1xuICAgICAgICB3aGlsZSAoaW5uZXJSZW1haW5kZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkID0gX2RlY29kZShpbm5lclJlbWFpbmRlcik7XG4gICAgICAgICAgICBkZWNvZGVkLnB1c2goZC5kYXRhKTtcbiAgICAgICAgICAgIGlubmVyUmVtYWluZGVyID0gZC5yZW1haW5kZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZWQsXG4gICAgICAgICAgICByZW1haW5kZXI6IGlucHV0LnNsaWNlKHRvdGFsTGVuZ3RoKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCBjYWNoZWRIZXhlcyA9IEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoX3YsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuZnVuY3Rpb24gYnl0ZXNUb0hleCh1aW50OGEpIHtcbiAgICAvLyBQcmUtY2FjaGluZyBjaGFycyB3aXRoIGBjYWNoZWRIZXhlc2Agc3BlZWRzIHRoaXMgdXAgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1aW50OGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGNhY2hlZEhleGVzW3VpbnQ4YVtpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5mdW5jdGlvbiBwYXJzZUhleEJ5dGUoaGV4Qnl0ZSkge1xuICAgIGNvbnN0IGJ5dGUgPSBOdW1iZXIucGFyc2VJbnQoaGV4Qnl0ZSwgMTYpO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgcmV0dXJuIGJ5dGU7XG59XG4vLyBDYWNoaW5nIHNsb3dzIGl0IGRvd24gMi0zeFxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGV4VG9CeXRlczogZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIH1cbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4VG9CeXRlczogcmVjZWl2ZWQgaW52YWxpZCB1bnBhZGRlZCBoZXgnKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGogPSBpICogMjtcbiAgICAgICAgYXJyYXlbaV0gPSBwYXJzZUhleEJ5dGUoaGV4LnNsaWNlKGosIGogKyAyKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8qKiBDb25jYXRlbmF0ZXMgdHdvIFVpbnQ4QXJyYXlzIGludG8gb25lLiAqL1xuZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgaWYgKGFycmF5cy5sZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiBhcnJheXNbMF07XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXlzLnJlZHVjZSgoYSwgYXJyKSA9PiBhICsgYXJyLmxlbmd0aCwgMCk7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgcGFkID0gMDsgaSA8IGFycmF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcnIgPSBhcnJheXNbaV07XG4gICAgICAgIHJlc3VsdC5zZXQoYXJyLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYXJyLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHV0Zikge1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodXRmKTtcbn1cbi8qKiBUcmFuc2Zvcm0gYW4gaW50ZWdlciBpbnRvIGl0cyBoZXhhZGVjaW1hbCB2YWx1ZSAqL1xuZnVuY3Rpb24gbnVtYmVyVG9IZXgoaW50ZWdlcikge1xuICAgIGlmIChpbnRlZ2VyIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZWdlciBhcyBhcmd1bWVudCwgbXVzdCBiZSB1bnNpZ25lZCEnKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gaW50ZWdlci50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJSAyID8gYDAke2hleH1gIDogaGV4O1xufVxuLyoqIFBhZCBhIHN0cmluZyB0byBiZSBldmVuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4oYSkge1xuICAgIHJldHVybiBhLmxlbmd0aCAlIDIgPyBgMCR7YX1gIDogYTtcbn1cbi8qKiBDaGVjayBpZiBhIHN0cmluZyBpcyBwcmVmaXhlZCBieSAweCAqL1xuZnVuY3Rpb24gaXNIZXhQcmVmaXhlZChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSAyICYmIHN0clswXSA9PT0gJzAnICYmIHN0clsxXSA9PT0gJ3gnO1xufVxuLyoqIFJlbW92ZXMgMHggZnJvbSBhIGdpdmVuIFN0cmluZyAqL1xuZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4vKiogVHJhbnNmb3JtIGFueXRoaW5nIGludG8gYSBVaW50OEFycmF5ICovXG5mdW5jdGlvbiB0b0J5dGVzKHYpIHtcbiAgICBpZiAodiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGlzSGV4UHJlZml4ZWQodikpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKHBhZFRvRXZlbihzdHJpcEhleFByZWZpeCh2KSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyh2KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgaWYgKCF2KSB7XG4gICAgICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4VG9CeXRlcyhudW1iZXJUb0hleCh2KSk7XG4gICAgfVxuICAgIGlmICh2ID09PSBudWxsIHx8IHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKFtdKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCd0b0J5dGVzOiByZWNlaXZlZCB1bnN1cHBvcnRlZCB0eXBlICcgKyB0eXBlb2Ygdik7XG59XG5leHBvcnRzLnV0aWxzID0ge1xuICAgIGJ5dGVzVG9IZXgsXG4gICAgY29uY2F0Qnl0ZXMsXG4gICAgaGV4VG9CeXRlcyxcbiAgICB1dGY4VG9CeXRlcyxcbn07XG5jb25zdCBSTFAgPSB7IGVuY29kZSwgZGVjb2RlIH07XG5leHBvcnRzLmRlZmF1bHQgPSBSTFA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcbid1c2Ugc3RyaWN0J1xuXG5pZiAoXCJkZXZlbG9wbWVudFwiID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21ldGFtYXNrLWFpcmdhcHBlZC1rZXlyaW5nLmNqcy5wcm9kdWN0aW9uLm1pbi5qcycpXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzJylcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBiYXNlRXRoS2V5cmluZyA9IHJlcXVpcmUoJ0BrZXlzdG9uZWhxL2Jhc2UtZXRoLWtleXJpbmcnKTtcbnZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciBvYnNTdG9yZSA9IHJlcXVpcmUoJ0BtZXRhbWFzay9vYnMtc3RvcmUnKTtcbnZhciBiY1VyUmVnaXN0cnlFdGggPSByZXF1aXJlKCdAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGgnKTtcbnZhciB1dWlkID0gcmVxdWlyZSgndXVpZCcpO1xudmFyIHR4ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKTtcbnZhciBybHAgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgncmxwJykpO1xuXG5jbGFzcyBNZXRhbWFza0ludGVyYWN0aW9uUHJvdmlkZXIgZXh0ZW5kcyBldmVudHMuRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuY2xlYW5TeW5jTGlzdGVuZXJzID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIik7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIpO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhblNpZ25MaXN0ZW5lcnMgPSByZXF1ZXN0SWQgPT4ge1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoYCR7cmVxdWVzdElkfS1zaWduZWRgKTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgKTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZWFkQ3J5cHRvSERLZXlPckNyeXB0b0FjY291bnQgPSAoKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBzeW5jOiB7XG4gICAgICAgICAgICByZWFkaW5nOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLCBjYm9yID0+IHtcbiAgICAgICAgICBjb25zdCBjcnlwdG9IREtleSA9IGJjVXJSZWdpc3RyeUV0aC5DcnlwdG9IREtleS5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCBcImhleFwiKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShjcnlwdG9IREtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIiwgY2JvciA9PiB7XG4gICAgICAgICAgY29uc3QgY3J5cHRvQWNjb3VudCA9IGJjVXJSZWdpc3RyeUV0aC5DcnlwdG9BY2NvdW50LmZyb21DQk9SKEJ1ZmZlci5mcm9tKGNib3IsIFwiaGV4XCIpKTtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKGNyeXB0b0FjY291bnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihcImtleXN0b25lLXN5bmNfY2FuY2VsXCIsICgpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNzeW5jX2NhbmNlbC4gU3luYyBwcm9jZXNzIGNhbmNlbGVkLCBwbGVhc2UgcmV0cnlcIikpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICB0aGlzLnN1Ym1pdENyeXB0b0hES2V5ID0gY2JvciA9PiB7XG4gICAgICB0aGlzLmVtaXQoXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIiwgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudCA9IGNib3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIiwgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsU3luYyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlcXVlc3RTaWduYXR1cmUgPSAoc2lnblJlcXVlc3QsIHJlcXVlc3RUaXRsZSwgcmVxdWVzdERlc2NyaXB0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB1ciA9IHNpZ25SZXF1ZXN0LnRvVVIoKTtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkQnVmZmVyID0gc2lnblJlcXVlc3QuZ2V0UmVxdWVzdElkKCk7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQuc3RyaW5naWZ5KHJlcXVlc3RJZEJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHNpZ25QYXlsb2FkID0ge1xuICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICB0eXBlOiB1ci50eXBlLFxuICAgICAgICAgICAgY2JvcjogdXIuY2Jvci50b1N0cmluZyhcImhleFwiKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGl0bGU6IHJlcXVlc3RUaXRsZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogcmVxdWVzdERlc2NyaXB0aW9uXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICAgIHNpZ246IHtcbiAgICAgICAgICAgIHJlcXVlc3Q6IHNpZ25QYXlsb2FkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKGAke3JlcXVlc3RJZH0tc2lnbmVkYCwgY2JvciA9PiB7XG4gICAgICAgICAgY29uc3QgZXRoU2lnbmF0dXJlID0gYmNVclJlZ2lzdHJ5RXRoLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShjYm9yLCBcImhleFwiKSk7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVzb2x2ZShldGhTaWduYXR1cmUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbmNlKGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIktleXN0b25lRXJyb3IjVHhfY2FuY2VsZWQuIFNpZ25pbmcgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHRoaXMuc3VibWl0U2lnbmF0dXJlID0gKHJlcXVlc3RJZCwgY2JvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KGAke3JlcXVlc3RJZH0tc2lnbmVkYCwgY2Jvcik7XG4gICAgfTtcblxuICAgIHRoaXMuY2FuY2VsUmVxdWVzdFNpZ25hdHVyZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHNpZ25QYXlsb2FkID0gdGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpLnNpZ24ucmVxdWVzdDtcblxuICAgICAgaWYgKHNpZ25QYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICByZXF1ZXN0SWRcbiAgICAgICAgfSA9IHNpZ25QYXlsb2FkO1xuICAgICAgICB0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICBzaWduOiB7fVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lbWl0KGAke3JlcXVlc3RJZH0tY2FuY2VsZWRgKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5yZXNldCA9ICgpID0+IHtcbiAgICAgIHRoaXMuY2xlYW5TeW5jTGlzdGVuZXJzKCk7XG4gICAgICBjb25zdCBzaWduUGF5bG9hZCA9IHRoaXMubWVtU3RvcmUuZ2V0U3RhdGUoKS5zaWduLnJlcXVlc3Q7XG5cbiAgICAgIGlmIChzaWduUGF5bG9hZCkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVxdWVzdElkXG4gICAgICAgIH0gPSBzaWduUGF5bG9hZDtcbiAgICAgICAgdGhpcy5jbGVhblNpZ25MaXN0ZW5lcnMocmVxdWVzdElkKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe1xuICAgICAgICBzeW5jOiB7XG4gICAgICAgICAgcmVhZGluZzogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbjoge31cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBpZiAoTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlO1xuICAgIH1cblxuICAgIHRoaXMubWVtU3RvcmUgPSBuZXcgb2JzU3RvcmUuT2JzZXJ2YWJsZVN0b3JlKHtcbiAgICAgIHN5bmM6IHtcbiAgICAgICAgcmVhZGluZzogZmFsc2VcbiAgICAgIH0sXG4gICAgICBzaWduOiB7fSxcbiAgICAgIF92ZXJzaW9uOiAxXG4gICAgfSk7XG4gICAgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyLmluc3RhbmNlID0gdGhpcztcbiAgfVxuXG59XG5cbmNsYXNzIE1ldGFNYXNrS2V5cmluZyBleHRlbmRzIGJhc2VFdGhLZXlyaW5nLkJhc2VLZXlyaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKG9wdHMpO1xuXG4gICAgdGhpcy5nZXRJbnRlcmFjdGlvbiA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgTWV0YW1hc2tJbnRlcmFjdGlvblByb3ZpZGVyKCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzZXRTdG9yZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXNldCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldE1lbVN0b3JlID0gKCkgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5tZW1TdG9yZTtcbiAgICB9O1xuXG4gICAgdGhpcy5yZW1vdmVBY2NvdW50ID0gYWRkcmVzcyA9PiB7XG4gICAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKGEgPT4gYS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hY2NvdW50cyA9IHRoaXMuYWNjb3VudHMuZmlsdGVyKGEgPT4gYS50b0xvd2VyQ2FzZSgpICE9PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgIH07XG5cbiAgICB0aGlzLmZvcmdldERldmljZSA9ICgpID0+IHtcbiAgICAgIC8vY29tbW9uIHByb3BzXG4gICAgICB0aGlzLnBhZ2UgPSAwO1xuICAgICAgdGhpcy5wZXJQYWdlID0gNTtcbiAgICAgIHRoaXMuYWNjb3VudHMgPSBbXTtcbiAgICAgIHRoaXMuY3VycmVudEFjY291bnQgPSAwO1xuICAgICAgdGhpcy5uYW1lID0gXCJRUiBIYXJkd2FyZVwiO1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlOyAvL2hkIHByb3BzO1xuXG4gICAgICB0aGlzLnhmcCA9IFwiXCI7XG4gICAgICB0aGlzLnhwdWIgPSBcIlwiO1xuICAgICAgdGhpcy5oZFBhdGggPSBcIlwiO1xuICAgICAgdGhpcy5pbmRleGVzID0ge307XG4gICAgICB0aGlzLmhkayA9IHVuZGVmaW5lZDsgLy9wdWJrZXkgcHJvcHM7XG5cbiAgICAgIHRoaXMucGF0aHMgPSB7fTtcbiAgICB9O1xuXG4gICAgdGhpcy5zdWJtaXRDcnlwdG9IREtleSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRDcnlwdG9IREtleTtcbiAgICB0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQgPSB0aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudDtcbiAgICB0aGlzLnN1Ym1pdFNpZ25hdHVyZSA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5zdWJtaXRTaWduYXR1cmU7XG4gICAgdGhpcy5jYW5jZWxTeW5jID0gdGhpcy5nZXRJbnRlcmFjdGlvbigpLmNhbmNlbFN5bmM7XG4gICAgdGhpcy5jYW5jZWxTaWduUmVxdWVzdCA9IHRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlO1xuXG4gICAgaWYgKE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZSkge1xuICAgICAgTWV0YU1hc2tLZXlyaW5nLmluc3RhbmNlLmRlc2VyaWFsaXplKG9wdHMpO1xuICAgICAgcmV0dXJuIE1ldGFNYXNrS2V5cmluZy5pbnN0YW5jZTtcbiAgICB9XG5cbiAgICBNZXRhTWFza0tleXJpbmcuaW5zdGFuY2UgPSB0aGlzO1xuICB9XG5cbiAgYXN5bmMgc2lnblRyYW5zYWN0aW9uKGFkZHJlc3MsIHR4JDEpIHtcbiAgICBjb25zdCBkYXRhVHlwZSA9IHR4JDEudHlwZSA9PT0gMCA/IGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50cmFuc2FjdGlvbiA6IGJjVXJSZWdpc3RyeUV0aC5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO1xuICAgIGxldCBtZXNzYWdlVG9TaWduO1xuXG4gICAgaWYgKHR4JDEudHlwZSA9PT0gMCkge1xuICAgICAgbWVzc2FnZVRvU2lnbiA9IHJscC5lbmNvZGUodHgkMS5nZXRNZXNzYWdlVG9TaWduKGZhbHNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lc3NhZ2VUb1NpZ24gPSB0eCQxLmdldE1lc3NhZ2VUb1NpZ24oZmFsc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMuX3BhdGhGcm9tQWRkcmVzcyhhZGRyZXNzKTtcbiAgICBjb25zdCBjaGFpbklkID0gdHgkMS5jb21tb24uY2hhaW5JZCgpO1xuICAgIGNvbnN0IHJlcXVlc3RJZCA9IHV1aWQudjQoKTtcbiAgICBjb25zdCBldGhTaWduUmVxdWVzdCA9IGJjVXJSZWdpc3RyeUV0aC5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG1lc3NhZ2VUb1NpZ24sIGRhdGFUeXBlLCBoZFBhdGgsIHRoaXMueGZwLCByZXF1ZXN0SWQsIGNoYWluSWQsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHtcbiAgICAgIHIsXG4gICAgICBzLFxuICAgICAgdlxuICAgIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3RTaWduYXR1cmUocmVxdWVzdElkLCBldGhTaWduUmVxdWVzdCwgXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCAnQWZ0ZXIgeW91ciBLZXlzdG9uZSBoYXMgc2lnbmVkIHRoZSB0cmFuc2FjdGlvbiwgY2xpY2sgb24gXCJTY2FuIEtleXN0b25lXCIgdG8gcmVjZWl2ZSB0aGUgc2lnbmF0dXJlJyk7XG4gICAgY29uc3QgdHhKc29uID0gdHgkMS50b0pTT04oKTtcbiAgICB0eEpzb24udiA9IHY7XG4gICAgdHhKc29uLnMgPSBzO1xuICAgIHR4SnNvbi5yID0gcjtcbiAgICB0eEpzb24udHlwZSA9IHR4JDEudHlwZTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHR4LlRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4SnNvbiwge1xuICAgICAgY29tbW9uOiB0eCQxLmNvbW1vblxuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgfVxuXG59XG5NZXRhTWFza0tleXJpbmcudHlwZSA9IGJhc2VFdGhLZXlyaW5nLkJhc2VLZXlyaW5nLnR5cGU7XG5cbmV4cG9ydHMuTWV0YU1hc2tLZXlyaW5nID0gTWV0YU1hc2tLZXlyaW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLmRldmVsb3BtZW50LmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGUsdD1yZXF1aXJlKFwiQGtleXN0b25laHEvYmFzZS1ldGgta2V5cmluZ1wiKSxzPXJlcXVpcmUoXCJldmVudHNcIiksbj1yZXF1aXJlKFwiQG1ldGFtYXNrL29icy1zdG9yZVwiKSxpPXJlcXVpcmUoXCJAa2V5c3RvbmVocS9iYy11ci1yZWdpc3RyeS1ldGhcIikscj1yZXF1aXJlKFwidXVpZFwiKSxjPXJlcXVpcmUoXCJAZXRoZXJldW1qcy90eFwiKSxvPShlPXJlcXVpcmUoXCJybHBcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplO2NsYXNzIGEgZXh0ZW5kcyBzLkV2ZW50RW1pdHRlcntjb25zdHJ1Y3Rvcigpe2lmKHN1cGVyKCksdGhpcy5jbGVhblN5bmNMaXN0ZW5lcnM9KCk9Pnt0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIpLHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwia2V5c3RvbmUtc3luY19jYW5jZWxcIil9LHRoaXMuY2xlYW5TaWduTGlzdGVuZXJzPWU9Pnt0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhlK1wiLXNpZ25lZFwiKSx0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhlK1wiLWNhbmNlbGVkXCIpfSx0aGlzLnJlYWRDcnlwdG9IREtleU9yQ3J5cHRvQWNjb3VudD0oKT0+bmV3IFByb21pc2UoKGUsdCk9Pnt0aGlzLm1lbVN0b3JlLnVwZGF0ZVN0YXRlKHtzeW5jOntyZWFkaW5nOiEwfX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX3N1Y2Nlc3MtaGRrZXlcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0hES2V5LmZyb21DQk9SKEJ1ZmZlci5mcm9tKHQsXCJoZXhcIikpO3RoaXMucmVzZXRTdGF0ZSgpLGUocyl9KSx0aGlzLm9uKFwia2V5c3RvbmUtc3luY19zdWNjZXNzLWFjY291bnRcIix0PT57Y29uc3Qgcz1pLkNyeXB0b0FjY291bnQuZnJvbUNCT1IoQnVmZmVyLmZyb20odCxcImhleFwiKSk7dGhpcy5yZXNldFN0YXRlKCksZShzKX0pLHRoaXMub24oXCJrZXlzdG9uZS1zeW5jX2NhbmNlbFwiLCgpPT57dGhpcy5yZXNldFN0YXRlKCksdChuZXcgRXJyb3IoXCJLZXlzdG9uZUVycm9yI3N5bmNfY2FuY2VsLiBTeW5jIHByb2Nlc3MgY2FuY2VsZWQsIHBsZWFzZSByZXRyeVwiKSl9KX0pLHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1oZGtleVwiLGUpfSx0aGlzLnN1Ym1pdENyeXB0b0FjY291bnQ9ZT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfc3VjY2Vzcy1hY2NvdW50XCIsZSl9LHRoaXMuY2FuY2VsU3luYz0oKT0+e3RoaXMuZW1pdChcImtleXN0b25lLXN5bmNfY2FuY2VsXCIpfSx0aGlzLnJlcXVlc3RTaWduYXR1cmU9KGUsdCxzKT0+bmV3IFByb21pc2UoKG4sYyk9Pntjb25zdCBvPWUudG9VUigpLGE9ZS5nZXRSZXF1ZXN0SWQoKSxoPXIuc3RyaW5naWZ5KGEpLHU9e3JlcXVlc3RJZDpoLHBheWxvYWQ6e3R5cGU6by50eXBlLGNib3I6by5jYm9yLnRvU3RyaW5nKFwiaGV4XCIpfSx0aXRsZTp0LGRlc2NyaXB0aW9uOnN9O3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e3JlcXVlc3Q6dX19KSx0aGlzLm9uY2UoaCtcIi1zaWduZWRcIixlPT57Y29uc3QgdD1pLkVUSFNpZ25hdHVyZS5mcm9tQ0JPUihCdWZmZXIuZnJvbShlLFwiaGV4XCIpKTt0aGlzLnJlc2V0U3RhdGUoKSxuKHQpfSksdGhpcy5vbmNlKGgrXCItY2FuY2VsZWRcIiwoKT0+e3RoaXMucmVzZXRTdGF0ZSgpLGMobmV3IEVycm9yKFwiS2V5c3RvbmVFcnJvciNUeF9jYW5jZWxlZC4gU2lnbmluZyBjYW5jZWxlZCwgcGxlYXNlIHJldHJ5XCIpKX0pfSksdGhpcy5zdWJtaXRTaWduYXR1cmU9KGUsdCk9Pnt0aGlzLmVtaXQoZStcIi1zaWduZWRcIix0KX0sdGhpcy5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlPSgpPT57Y29uc3QgZT10aGlzLm1lbVN0b3JlLmdldFN0YXRlKCkuc2lnbi5yZXF1ZXN0O2lmKGUpe2NvbnN0e3JlcXVlc3RJZDp0fT1lO3RoaXMubWVtU3RvcmUudXBkYXRlU3RhdGUoe3NpZ246e319KSx0aGlzLmVtaXQodCtcIi1jYW5jZWxlZFwiKX19LHRoaXMucmVzZXQ9KCk9Pnt0aGlzLmNsZWFuU3luY0xpc3RlbmVycygpO2NvbnN0IGU9dGhpcy5tZW1TdG9yZS5nZXRTdGF0ZSgpLnNpZ24ucmVxdWVzdDtpZihlKXtjb25zdHtyZXF1ZXN0SWQ6dH09ZTt0aGlzLmNsZWFuU2lnbkxpc3RlbmVycyh0KX10aGlzLnJlc2V0U3RhdGUoKX0sdGhpcy5yZXNldFN0YXRlPSgpPT57dGhpcy5tZW1TdG9yZS51cGRhdGVTdGF0ZSh7c3luYzp7cmVhZGluZzohMX0sc2lnbjp7fX0pfSxhLmluc3RhbmNlKXJldHVybiBhLmluc3RhbmNlO3RoaXMubWVtU3RvcmU9bmV3IG4uT2JzZXJ2YWJsZVN0b3JlKHtzeW5jOntyZWFkaW5nOiExfSxzaWduOnt9LF92ZXJzaW9uOjF9KSxhLmluc3RhbmNlPXRoaXN9fWNsYXNzIGggZXh0ZW5kcyB0LkJhc2VLZXlyaW5ne2NvbnN0cnVjdG9yKGUpe2lmKHN1cGVyKGUpLHRoaXMuZ2V0SW50ZXJhY3Rpb249KCk9Pm5ldyBhLHRoaXMucmVzZXRTdG9yZT0oKT0+e3RoaXMuZ2V0SW50ZXJhY3Rpb24oKS5yZXNldCgpfSx0aGlzLmdldE1lbVN0b3JlPSgpPT50aGlzLmdldEludGVyYWN0aW9uKCkubWVtU3RvcmUsdGhpcy5yZW1vdmVBY2NvdW50PWU9PntpZighdGhpcy5hY2NvdW50cy5tYXAoZT0+ZS50b0xvd2VyQ2FzZSgpKS5pbmNsdWRlcyhlLnRvTG93ZXJDYXNlKCkpKXRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2V9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKTt0aGlzLmFjY291bnRzPXRoaXMuYWNjb3VudHMuZmlsdGVyKHQ9PnQudG9Mb3dlckNhc2UoKSE9PWUudG9Mb3dlckNhc2UoKSl9LHRoaXMuZm9yZ2V0RGV2aWNlPSgpPT57dGhpcy5wYWdlPTAsdGhpcy5wZXJQYWdlPTUsdGhpcy5hY2NvdW50cz1bXSx0aGlzLmN1cnJlbnRBY2NvdW50PTAsdGhpcy5uYW1lPVwiUVIgSGFyZHdhcmVcIix0aGlzLmluaXRpYWxpemVkPSExLHRoaXMueGZwPVwiXCIsdGhpcy54cHViPVwiXCIsdGhpcy5oZFBhdGg9XCJcIix0aGlzLmluZGV4ZXM9e30sdGhpcy5oZGs9dm9pZCAwLHRoaXMucGF0aHM9e319LHRoaXMuc3VibWl0Q3J5cHRvSERLZXk9dGhpcy5nZXRJbnRlcmFjdGlvbigpLnN1Ym1pdENyeXB0b0hES2V5LHRoaXMuc3VibWl0Q3J5cHRvQWNjb3VudD10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0Q3J5cHRvQWNjb3VudCx0aGlzLnN1Ym1pdFNpZ25hdHVyZT10aGlzLmdldEludGVyYWN0aW9uKCkuc3VibWl0U2lnbmF0dXJlLHRoaXMuY2FuY2VsU3luYz10aGlzLmdldEludGVyYWN0aW9uKCkuY2FuY2VsU3luYyx0aGlzLmNhbmNlbFNpZ25SZXF1ZXN0PXRoaXMuZ2V0SW50ZXJhY3Rpb24oKS5jYW5jZWxSZXF1ZXN0U2lnbmF0dXJlLGguaW5zdGFuY2UpcmV0dXJuIGguaW5zdGFuY2UuZGVzZXJpYWxpemUoZSksaC5pbnN0YW5jZTtoLmluc3RhbmNlPXRoaXN9YXN5bmMgc2lnblRyYW5zYWN0aW9uKGUsdCl7Y29uc3Qgcz0wPT09dC50eXBlP2kuRGF0YVR5cGUudHJhbnNhY3Rpb246aS5EYXRhVHlwZS50eXBlZFRyYW5zYWN0aW9uO2xldCBuO249MD09PXQudHlwZT9vLmVuY29kZSh0LmdldE1lc3NhZ2VUb1NpZ24oITEpKTp0LmdldE1lc3NhZ2VUb1NpZ24oITEpO2NvbnN0IGE9YXdhaXQgdGhpcy5fcGF0aEZyb21BZGRyZXNzKGUpLGg9dC5jb21tb24uY2hhaW5JZCgpLHU9ci52NCgpLHk9aS5FdGhTaWduUmVxdWVzdC5jb25zdHJ1Y3RFVEhSZXF1ZXN0KG4scyxhLHRoaXMueGZwLHUsaCxlKSx7cjptLHM6Zyx2OmR9PWF3YWl0IHRoaXMucmVxdWVzdFNpZ25hdHVyZSh1LHksXCJTY2FuIHdpdGggeW91ciBLZXlzdG9uZVwiLCdBZnRlciB5b3VyIEtleXN0b25lIGhhcyBzaWduZWQgdGhlIHRyYW5zYWN0aW9uLCBjbGljayBvbiBcIlNjYW4gS2V5c3RvbmVcIiB0byByZWNlaXZlIHRoZSBzaWduYXR1cmUnKSxTPXQudG9KU09OKCk7cmV0dXJuIFMudj1kLFMucz1nLFMucj1tLFMudHlwZT10LnR5cGUsYy5UcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVR4RGF0YShTLHtjb21tb246dC5jb21tb259KX19aC50eXBlPXQuQmFzZUtleXJpbmcudHlwZSxleHBvcnRzLk1ldGFNYXNrS2V5cmluZz1oO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWV0YW1hc2stYWlyZ2FwcGVkLWtleXJpbmcuY2pzLnByb2R1Y3Rpb24ubWluLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIENvbXBvc2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgICAgIC8vIFR5cGVjYXN0OiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICBzdXBlcih7fSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGRLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRLZXldO1xuICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnJvbUNoaWxkID0gKGNoaWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RhdGVbY2hpbGRLZXldID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUodXBkYXRlRnJvbUNoaWxkKTtcbiAgICAgICAgdXBkYXRlRnJvbUNoaWxkKGNoaWxkLmdldFN0YXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IENvbXBvc2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgTWVyZ2VkU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKGNoaWxkcmVuID0gW10pIHtcbiAgICAgICAgLy8gVHlwZWNhc3Q6IFByZXNlcnZlIGV4aXN0aW5nIGJlaGF2aW9yXG4gICAgICAgIHN1cGVyKHt9KTtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIGNoaWxkcmVuXG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB0aGlzLl9hZGRDaGlsZChjaGlsZCkpO1xuICAgICAgICB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZCkge1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fdXBkYXRlV2hvbGVTdGF0ZSgpKTtcbiAgICB9XG4gICAgX3VwZGF0ZVdob2xlU3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkU3RhdGVzID0gdGhpcy5fY2hpbGRyZW4ubWFwKChjaGlsZCkgPT4gY2hpbGQuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIGFwcGx5IHNoYWxsb3cgbWVyZ2Ugb3ZlciBzdGF0ZXNcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5jaGlsZFN0YXRlcyk7XG4gICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSBNZXJnZWRTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lcmdlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PYnNlcnZhYmxlU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBzYWZlX2V2ZW50X2VtaXR0ZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQG1ldGFtYXNrL3NhZmUtZXZlbnQtZW1pdHRlclwiKSk7XG5jbGFzcyBPYnNlcnZhYmxlU3RvcmUgZXh0ZW5kcyBzYWZlX2V2ZW50X2VtaXR0ZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcihpbml0U3RhdGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKGluaXRTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBpbml0U3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdC9kZWZhdWx0IHN0YXRlOiBQcmVzZXJ2ZSBleGlzdGluZyBiZWhhdmlvclxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBnZXRTdGF0ZVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGVcbiAgICBwdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSksIHBhcnRpYWxTdGF0ZSkpO1xuICAgICAgICAgICAgLy8gaWYgbm90IG9iamVjdCwgdXNlIG5ldyB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wdXRTdGF0ZShwYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgc3Vic2NyaWJlKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5vbigndXBkYXRlJywgaGFuZGxlcik7XG4gICAgfVxuICAgIC8vIHVuc3Vic2NyaWJlIHRvIGNoYW5nZXNcbiAgICB1bnN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHByaXZhdGVcbiAgICAvL1xuICAgIC8vIHJlYWQgZnJvbSBwZXJzaXN0ZW5jZVxuICAgIF9nZXRTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cbiAgICAvLyB3cml0ZSB0byBwZXJzaXN0ZW5jZVxuICAgIF9wdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cbn1cbmV4cG9ydHMuT2JzZXJ2YWJsZVN0b3JlID0gT2JzZXJ2YWJsZVN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JzZXJ2YWJsZVN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdG9yZUFzU3RyZWFtID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtIGV4dGVuZHMgc3RyZWFtXzEuRHVwbGV4IHtcbiAgICBjb25zdHJ1Y3RvcihvYnNTdG9yZSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICAvLyBwYXNzIHZhbHVlcywgbm90IHNlcmlhbGl6YXRpb25zXG4gICAgICAgICAgICBvYmplY3RNb2RlOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gZG9udCBidWZmZXIgb3V0Z29pbmcgdXBkYXRlc1xuICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAvLyBzYXZlIGhhbmRsZXIgc28gd2UgY2FuIHVuc3Vic2NyaWJlIGxhdGVyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IChzdGF0ZSkgPT4gdGhpcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgLy8gc3Vic2NyaWJlIHRvIG9ic1N0b3JlIGNoYW5nZXNcbiAgICAgICAgdGhpcy5vYnNTdG9yZSA9IG9ic1N0b3JlO1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnN1YnNjcmliZSh0aGlzLmhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyBlbWl0IGN1cnJlbnQgc3RhdGUgb24gbmV3IGRlc3RpbmF0aW9uXG4gICAgcGlwZShkZXN0LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLnBpcGUoZGVzdCwgb3B0aW9ucyk7XG4gICAgICAgIGRlc3Qud3JpdGUodGhpcy5vYnNTdG9yZS5nZXRTdGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gd3JpdGUgZnJvbSBpbmNvbWluZyBzdHJlYW0gdG8gc3RhdGVcbiAgICBfd3JpdGUoY2h1bmssIF9lbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5wdXRTdGF0ZShjaHVuayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIC8vIG5vb3AgLSBvdXRnb2luZyBzdHJlYW0gaXMgYXNraW5nIHVzIGlmIHdlIGhhdmUgZGF0YSB3ZSBhcmVudCBnaXZpbmcgaXRcbiAgICBfcmVhZChfc2l6ZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSBmcm9tIGV2ZW50IGVtaXR0ZXJcbiAgICBfZGVzdHJveShlcnIsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUudW5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICAgICAgc3VwZXIuX2Rlc3Ryb3koZXJyLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RvcmVBc1N0cmVhbShvYnNTdG9yZSkge1xuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVN0b3JlU3RyZWFtKG9ic1N0b3JlKTtcbn1cbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHN0b3JlQXNTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc1N0cmVhbS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FzU3RyZWFtXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db21wb3NlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9NZXJnZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2Zvcm1cIiksIGV4cG9ydHMpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnN0b3JlVHJhbnNmb3JtU3RyZWFtID0gdm9pZCAwO1xuY29uc3QgdGhyb3VnaDJfMSA9IHJlcXVpcmUoXCJ0aHJvdWdoMlwiKTtcbmZ1bmN0aW9uIHN0b3JlVHJhbnNmb3JtU3RyZWFtKHN5bmNUcmFuc2Zvcm1Gbikge1xuICAgIHJldHVybiB0aHJvdWdoMl8xLm9iaigoc3RhdGUsIF9lbmNvZGluZywgY2IpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gc3luY1RyYW5zZm9ybUZuKHN0YXRlKTtcbiAgICAgICAgICAgIGNiKG51bGwsIG5ld1N0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2IoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSBzdG9yZVRyYW5zZm9ybVN0cmVhbTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zZm9ybS5qcy5tYXAiLCJ2YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJykuVHJhbnNmb3JtXG4gICwgaW5oZXJpdHMgID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG4gICwgeHRlbmQgICAgID0gcmVxdWlyZSgneHRlbmQnKVxuXG5mdW5jdGlvbiBEZXN0cm95YWJsZVRyYW5zZm9ybShvcHRzKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlXG59XG5cbmluaGVyaXRzKERlc3Ryb3lhYmxlVHJhbnNmb3JtLCBUcmFuc2Zvcm0pXG5cbkRlc3Ryb3lhYmxlVHJhbnNmb3JtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oZXJyKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHJldHVyblxuICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlXG4gIFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICBpZiAoZXJyKVxuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycilcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJylcbiAgfSlcbn1cblxuLy8gYSBub29wIF90cmFuc2Zvcm0gZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AgKGNodW5rLCBlbmMsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrKG51bGwsIGNodW5rKVxufVxuXG5cbi8vIGNyZWF0ZSBhIG5ldyBleHBvcnQgZnVuY3Rpb24sIHVzZWQgYnkgYm90aCB0aGUgbWFpbiBleHBvcnQgYW5kXG4vLyB0aGUgLmN0b3IgZXhwb3J0LCBjb250YWlucyBjb21tb24gbG9naWMgZm9yIGRlYWxpbmcgd2l0aCBhcmd1bWVudHNcbmZ1bmN0aW9uIHRocm91Z2gyIChjb25zdHJ1Y3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZsdXNoICAgICA9IHRyYW5zZm9ybVxuICAgICAgdHJhbnNmb3JtID0gb3B0aW9uc1xuICAgICAgb3B0aW9ucyAgID0ge31cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRyYW5zZm9ybSAhPSAnZnVuY3Rpb24nKVxuICAgICAgdHJhbnNmb3JtID0gbm9vcFxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaCAhPSAnZnVuY3Rpb24nKVxuICAgICAgZmx1c2ggPSBudWxsXG5cbiAgICByZXR1cm4gY29uc3RydWN0KG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpXG4gIH1cbn1cblxuXG4vLyBtYWluIGV4cG9ydCwganVzdCBtYWtlIG1lIGEgdHJhbnNmb3JtIHN0cmVhbSFcbm1vZHVsZS5leHBvcnRzID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgdmFyIHQyID0gbmV3IERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdGlvbnMpXG5cbiAgdDIuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybVxuXG4gIGlmIChmbHVzaClcbiAgICB0Mi5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiB0MlxufSlcblxuXG4vLyBtYWtlIG1lIGEgcmV1c2FibGUgcHJvdG90eXBlIHRoYXQgSSBjYW4gYG5ld2AsIG9yIGltcGxpY2l0bHkgYG5ld2Bcbi8vIHdpdGggYSBjb25zdHJ1Y3RvciBjYWxsXG5tb2R1bGUuZXhwb3J0cy5jdG9yID0gdGhyb3VnaDIoZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgZnVuY3Rpb24gVGhyb3VnaDIgKG92ZXJyaWRlKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRocm91Z2gyKSlcbiAgICAgIHJldHVybiBuZXcgVGhyb3VnaDIob3ZlcnJpZGUpXG5cbiAgICB0aGlzLm9wdGlvbnMgPSB4dGVuZChvcHRpb25zLCBvdmVycmlkZSlcblxuICAgIERlc3Ryb3lhYmxlVHJhbnNmb3JtLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKVxuICB9XG5cbiAgaW5oZXJpdHMoVGhyb3VnaDIsIERlc3Ryb3lhYmxlVHJhbnNmb3JtKVxuXG4gIFRocm91Z2gyLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIFRocm91Z2gyLnByb3RvdHlwZS5fZmx1c2ggPSBmbHVzaFxuXG4gIHJldHVybiBUaHJvdWdoMlxufSlcblxuXG5tb2R1bGUuZXhwb3J0cy5vYmogPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0oeHRlbmQoeyBvYmplY3RNb2RlOiB0cnVlLCBoaWdoV2F0ZXJNYXJrOiAxNiB9LCBvcHRpb25zKSlcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUluZnVyYU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3Qgbm9kZV9mZXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlLWZldGNoXCIpKTtcbmNvbnN0IGZldGNoX2NvbmZpZ19mcm9tX3JlcV8xID0gcmVxdWlyZShcIi4vZmV0Y2gtY29uZmlnLWZyb20tcmVxXCIpO1xuY29uc3QgbG9nZ2luZ191dGlsc18xID0gcmVxdWlyZShcIi4vbG9nZ2luZy11dGlsc1wiKTtcbmNvbnN0IGxvZyA9ICgwLCBsb2dnaW5nX3V0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyKShsb2dnaW5nX3V0aWxzXzEucHJvamVjdExvZ2dlciwgJ2NyZWF0ZS1pbmZ1cmEtbWlkZGxld2FyZScpO1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgICdFQ09OTlJFU0VUJyxcbiAgICAvLyBpZ25vcmUgc2VydmVyIHNlbnQgaHRtbCBlcnJvciBwYWdlc1xuICAgIC8vIG9yIHRydW5jYXRlZCBqc29uIHJlc3BvbnNlc1xuICAgICdTeW50YXhFcnJvcicsXG5dO1xuLyoqXG4gKiBCdWlsZHMgW2Bqc29uLXJwYy1lbmdpbmVgXShodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svanNvbi1ycGMtZW5naW5lKS1jb21wYXRpYmxlIG1pZGRsZXdhcmUgZGVzaWduZWRcbiAqIGZvciBpbnRlcmZhY2luZyB3aXRoIEluZnVyYSdzIEpTT04tUlBDIGVuZHBvaW50cy5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIFRoZSBvcHRpb25zLlxuICogQHBhcmFtIG9wdHMubmV0d29yayAtIEEgbmV0d29yayB0aGF0IEluZnVyYSBzdXBwb3J0czsgcGx1Z3MgaW50b1xuICogYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW9gIChkZWZhdWx0OiAnbWFpbm5ldCcpLlxuICogQHBhcmFtIG9wdHMubWF4QXR0ZW1wdHMgLSBUaGUgbnVtYmVyIG9mIHRpbWVzIGEgcmVxdWVzdCB0byBJbmZ1cmEgc2hvdWxkIGJlXG4gKiByZXRyaWVkIGluIHRoZSBjYXNlIG9mIGZhaWx1cmUgKGRlZmF1bHQ6IDUpLlxuICogQHBhcmFtIG9wdHMuc291cmNlIC0gQSBkZXNjcmlwdG9yIGZvciB0aGUgZW50aXR5IG1ha2luZyB0aGUgcmVxdWVzdDsgdHJhY2tlZFxuICogYnkgSW5mdXJhIGZvciBhbmFseXRpY3MgcHVycG9zZXMuXG4gKiBAcGFyYW0gb3B0cy5wcm9qZWN0SWQgLSBUaGUgSW5mdXJhIHByb2plY3QgaWQuXG4gKiBAcGFyYW0gb3B0cy5oZWFkZXJzIC0gRXh0cmEgaGVhZGVycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBtYWtlIHRoZSByZXF1ZXN0LlxuICogQHJldHVybnMgVGhlIGBqc29uLXJwYy1lbmdpbmVgLWNvbXBhdGlibGUgbWlkZGxld2FyZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5mdXJhTWlkZGxld2FyZSh7IG5ldHdvcmsgPSAnbWFpbm5ldCcsIG1heEF0dGVtcHRzID0gNSwgc291cmNlLCBwcm9qZWN0SWQsIGhlYWRlcnMgPSB7fSwgfSkge1xuICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICBpZiAoIXByb2plY3RJZCB8fCB0eXBlb2YgcHJvamVjdElkICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yICdwcm9qZWN0SWQnOiBcIiR7cHJvamVjdElkfVwiYCk7XG4gICAgfVxuICAgIGlmICghaGVhZGVycyB8fCB0eXBlb2YgaGVhZGVycyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAnaGVhZGVycyc6IFwiJHtoZWFkZXJzfVwiYCk7XG4gICAgfVxuICAgIGlmICghbWF4QXR0ZW1wdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciAnbWF4QXR0ZW1wdHMnOiBcIiR7bWF4QXR0ZW1wdHN9XCIgKCR7dHlwZW9mIG1heEF0dGVtcHRzfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgICAgICAvLyByZXRyeSBNQVhfQVRURU1QVFMgdGltZXMsIGlmIGVycm9yIG1hdGNoZXMgZmlsdGVyXG4gICAgICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gYXR0ZW1wdCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgbG9nKCdBdHRlbXB0aW5nIHJlcXVlc3QgdG8gSW5mdXJhLiBuZXR3b3JrID0gJW8sIHByb2plY3RJZCA9ICVzLCBoZWFkZXJzID0gJW8sIHJlcSA9ICVvJywgbmV0d29yaywgcHJvamVjdElkLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHBlcmZvcm1GZXRjaChuZXR3b3JrLCBwcm9qZWN0SWQsIGhlYWRlcnMsIHJlcSwgcmVzLCBzb3VyY2UpO1xuICAgICAgICAgICAgICAgIC8vIHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBhbiBlcnJvciB3YXMgY2F1Z2h0IHdoaWxlIHBlcmZvcm1pbmcgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICAvLyBpZiBub3QgcmV0cmlhYmxlLCByZXNvbHZlIHdpdGggdGhlIGVuY291bnRlcmVkIGVycm9yXG4gICAgICAgICAgICAgICAgaWYgKCFpc1JldHJpYWJsZUVycm9yKGVycikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWJvcnQgd2l0aCBlcnJvclxuICAgICAgICAgICAgICAgICAgICBsb2coJ05vbi1yZXRyaWFibGUgcmVxdWVzdCBlcnJvciBlbmNvdW50ZXJlZC4gcmVxID0gJW8sIHJlcyA9ICVvLCBlcnJvciA9ICVvJywgcmVxLCByZXMsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbW9yZSBhdHRlbXB0cyByZW1haW5pbmcsIHRocm93IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgY29uc3QgcmVtYWluaW5nQXR0ZW1wdHMgPSBtYXhBdHRlbXB0cyAtIGF0dGVtcHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFyZW1haW5pbmdBdHRlbXB0cykge1xuICAgICAgICAgICAgICAgICAgICBsb2coJ1JldHJpYWJsZSByZXF1ZXN0IGVycm9yIGVuY291bnRlcmVkLCBidXQgZXhjZWVkZWQgbWF4IGF0dGVtcHRzLiByZXEgPSAlbywgcmVzID0gJW8sIGVycm9yID0gJW8nLCByZXEsIHJlcywgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gYEluZnVyYVByb3ZpZGVyIC0gY2Fubm90IGNvbXBsZXRlIHJlcXVlc3QuIEFsbCByZXRyaWVzIGV4aGF1c3RlZC5cXG5PcmlnaW5hbCBFcnJvcjpcXG4ke2Vyci50b1N0cmluZygpfVxcblxcbmA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJpZXNFeGhhdXN0ZWRFcnIgPSBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcmV0cmllc0V4aGF1c3RlZEVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBpZ25vcmUgZXJyb3IgYW5kIHJldHJ5IGFnYWluIGFmdGVyIHRpbWVvdXRcbiAgICAgICAgICAgICAgICBsb2coJ1JldHJpYWJsZSByZXF1ZXN0IGVycm9yIGVuY291bnRlcmVkLiByZXEgPSAlbywgcmVzID0gJW8sIGVycm9yID0gJW8nLCByZXEsIHJlcywgZXJyKTtcbiAgICAgICAgICAgICAgICBsb2coJ1dhaXRpbmcgMSBzZWNvbmQgdG8gdHJ5IGFnYWluLi4uJyk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGltZW91dCgxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyByZXF1ZXN0IHdhcyBoYW5kbGVkIGNvcnJlY3RseSwgZW5kXG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUluZnVyYU1pZGRsZXdhcmUgPSBjcmVhdGVJbmZ1cmFNaWRkbGV3YXJlO1xuLyoqXG4gKiBNYWtlcyBhIHJlcXVlc3QgdG8gSW5mdXJhLCB1cGRhdGluZyB0aGUgZ2l2ZW4gcmVzcG9uc2Ugb2JqZWN0IGlmIHRoZSByZXNwb25zZVxuICogaGFzIGEgXCJzdWNjZXNzZnVsXCIgc3RhdHVzIGNvZGUgb3IgdGhyb3dpbmcgYW4gZXJyb3Igb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSBuZXR3b3JrIC0gQSBuZXR3b3JrIHRoYXQgSW5mdXJhIHN1cHBvcnRzOyBwbHVncyBpbnRvXG4gKiBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pb2AuXG4gKiBAcGFyYW0gcHJvamVjdElkIC0gVGhlIEluZnVyYSBwcm9qZWN0IGlkLlxuICogQHBhcmFtIGV4dHJhSGVhZGVycyAtIEV4dHJhIGhlYWRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSB0aGUgcmVxdWVzdC5cbiAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHBhcmFtIHJlcyAtIFRoZSBvcmlnaW5hbCByZXNwb25zZSBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHBhcmFtIHNvdXJjZSAtIEEgZGVzY3JpcHRvciBmb3IgdGhlIGVudGl0eSBtYWtpbmcgdGhlIHJlcXVlc3Q7XG4gKiB0cmFja2VkIGJ5IEluZnVyYSBmb3IgYW5hbHl0aWNzIHB1cnBvc2VzLlxuICogQHRocm93cyBhbiBlcnJvciB3aXRoIGEgZGV0YWlsZWQgbWVzc2FnZSBpZiB0aGUgSFRUUCBzdGF0dXMgY29kZSBpcyBhbnl3aGVyZVxuICogb3V0c2lkZSAyeHgsIGFuZCBlc3BlY2lhbGx5IGlmIGl0IGlzIDQwNSwgNDI5LCA1MDMsIG9yIDUwNC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGVyZm9ybUZldGNoKG5ldHdvcmssIHByb2plY3RJZCwgZXh0cmFIZWFkZXJzLCByZXEsIHJlcywgc291cmNlKSB7XG4gICAgY29uc3QgeyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfSA9ICgwLCBmZXRjaF9jb25maWdfZnJvbV9yZXFfMS5mZXRjaENvbmZpZ0Zyb21SZXEpKHtcbiAgICAgICAgbmV0d29yayxcbiAgICAgICAgcHJvamVjdElkLFxuICAgICAgICBleHRyYUhlYWRlcnMsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc291cmNlLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgKDAsIG5vZGVfZmV0Y2hfMS5kZWZhdWx0KShmZXRjaFVybCwgZmV0Y2hQYXJhbXMpO1xuICAgIGNvbnN0IHJhd0RhdGEgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgLy8gaGFuZGxlIGVycm9yc1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RGb3VuZCgpO1xuICAgICAgICAgICAgY2FzZSA0Mjk6XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgICAgIGNhc2UgNTAzOlxuICAgICAgICAgICAgY2FzZSA1MDQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZUludGVybmFsRXJyb3IocmF3RGF0YSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc3BlY2lhbCBjYXNlIGZvciBub3dcbiAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJyAmJiByYXdEYXRhID09PSAnTm90IEZvdW5kJykge1xuICAgICAgICByZXMucmVzdWx0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBwYXJzZSBKU09OXG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UocmF3RGF0YSk7XG4gICAgLy8gZmluYWxseSByZXR1cm4gcmVzdWx0XG4gICAgcmVzLnJlc3VsdCA9IGRhdGEucmVzdWx0O1xuICAgIHJlcy5lcnJvciA9IGRhdGEuZXJyb3I7XG59XG4vKipcbiAqIEJ1aWxkcyBhIEpTT04tUlBDIDIuMCBpbnRlcm5hbCBlcnJvciBvYmplY3QgZGVzY3JpYmluZyBhIHJhdGUtbGltaXRpbmdcbiAqIGVycm9yLlxuICpcbiAqIEByZXR1cm5zIFRoZSBlcnJvciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJhdGVsaW1pdEVycm9yKCkge1xuICAgIGNvbnN0IG1zZyA9IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gO1xuICAgIHJldHVybiBjcmVhdGVJbnRlcm5hbEVycm9yKG1zZyk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIEpTT04tUlBDIDIuMCBpbnRlcm5hbCBlcnJvciBvYmplY3QgZGVzY3JpYmluZyBhIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBjcmVhdGVJbnRlcm5hbEVycm9yKG1zZyk7XG59XG4vKipcbiAqIEJ1aWxkcyBhIEpTT04tUlBDIDIuMCBpbnRlcm5hbCBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIG1zZyAtIFRoZSBtZXNzYWdlLlxuICogQHJldHVybnMgVGhlIGVycm9yIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxFcnJvcihtc2cpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKG1zZyk7XG59XG4vKipcbiAqIFVwb24gbWFraW5nIGEgcmVxdWVzdCwgd2UgbWF5IGdldCBhbiBlcnJvciB0aGF0IGlzIHRlbXBvcmFyeSBhbmRcbiAqIGludGVybWl0dGVudC4gSW4gdGhlc2UgY2FzZXMgd2UgY2FuIGF0dGVtcHQgdGhlIHJlcXVlc3QgYWdhaW4gd2l0aCB0aGVcbiAqIGFzc3VtcHRpb24gdGhhdCB0aGUgZXJyb3IgaXMgdW5saWtlbHkgdG8gb2NjdXIgYWdhaW4uIEhlcmUgd2UgZGV0ZXJtaW5lIGlmIHdlXG4gKiBoYXZlIHJlY2VpdmVkIHN1Y2ggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIGVyciAtIFRoZSBlcnJvciBvYmplY3QuXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSByZXF1ZXN0IHRoYXQgcHJvZHVjZWQgdGhlIGVycm9yIGNhbiBiZSByZXRyaWVkLlxuICovXG5mdW5jdGlvbiBpc1JldHJpYWJsZUVycm9yKGVycikge1xuICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnIudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gUkVUUklBQkxFX0VSUk9SUy5zb21lKChwaHJhc2UpID0+IGVyck1lc3NhZ2UuaW5jbHVkZXMocGhyYXNlKSk7XG59XG4vKipcbiAqIEEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IHByb21pc2lmaWVzIGBzZXRUaW1lb3V0YC5cbiAqXG4gKiBAcGFyYW0gbGVuZ3RoIC0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gd2FpdC5cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBnaXZlbiB0aW1lIGhhcyBlbGFwc2VkLlxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGxlbmd0aCk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtaW5mdXJhLW1pZGRsZXdhcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVByb3ZpZGVyID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXRoX2pzb25fcnBjX21pZGRsZXdhcmVfMSA9IHJlcXVpcmUoXCJldGgtanNvbi1ycGMtbWlkZGxld2FyZVwiKTtcbmNvbnN0IGNyZWF0ZV9pbmZ1cmFfbWlkZGxld2FyZV8xID0gcmVxdWlyZShcIi4vY3JlYXRlLWluZnVyYS1taWRkbGV3YXJlXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEgcHJvdmlkZXIgKGFzIGRlZmluZWQgaW5cbiAqIFtgZXRoLWpzb24tcnBjLW1pZGRsZXdhcmVgXShodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUpXG4gKiB3aGljaCBpcyBwcmVsb2FkZWQgd2l0aCBtaWRkbGV3YXJlIHNwZWNpYWxpemVkIGZvciBpbnRlcmZhY2luZyB3aXRoIEluZnVyYVxuICogSlNPTi1SUEMgZW5kcG9pbnRzLlxuICpcbiAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyB0byB7QGxpbmsgY3JlYXRlSW5mdXJhTWlkZGxld2FyZX0uXG4gKiBAcmV0dXJucyBUaGUgcHJvdmlkZXIgYXMgcmV0dXJuZWQgYnkgYHByb3ZpZGVyRnJvbUVuZ2luZWAgKGEgcGFydCBvZlxuICogW2BldGgtanNvbi1ycGMtbWlkZGxld2FyZWBdKGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9ldGgtanNvbi1ycGMtbWlkZGxld2FyZSkpLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQcm92aWRlcihvcHRzKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IGpzb25fcnBjX2VuZ2luZV8xLkpzb25ScGNFbmdpbmUoKTtcbiAgICBlbmdpbmUucHVzaCgoMCwgY3JlYXRlX2luZnVyYV9taWRkbGV3YXJlXzEuY3JlYXRlSW5mdXJhTWlkZGxld2FyZSkob3B0cykpO1xuICAgIHJldHVybiAoMCwgZXRoX2pzb25fcnBjX21pZGRsZXdhcmVfMS5wcm92aWRlckZyb21FbmdpbmUpKGVuZ2luZSk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3ZpZGVyID0gY3JlYXRlUHJvdmlkZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGUtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoQ29uZmlnRnJvbVJlcSA9IHZvaWQgMDtcbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgYXJndW1lbnRzIHRvIGZlZWQgaW50byBgZmV0Y2hgIGluIG9yZGVyIHRvIG1ha2UgYSByZXF1ZXN0IHRvXG4gKiBJbmZ1cmEuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLm5ldHdvcmsgLSBBIG5ldHdvcmsgdGhhdCBJbmZ1cmEgc3VwcG9ydHM7IHBsdWdzIGludG9cbiAqIGBodHRwczovLyR7bmV0d29ya30uaW5mdXJhLmlvYC5cbiAqIEBwYXJhbSBvcHRpb25zLnByb2plY3RJZCAtIFRoZSBJbmZ1cmEgcHJvamVjdCBpZC5cbiAqIEBwYXJhbSBvcHRpb25zLmV4dHJhSGVhZGVycyAtIEV4dHJhIGhlYWRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgdG8gbWFrZSB0aGVcbiAqIHJlcXVlc3QuXG4gKiBAcGFyYW0gb3B0aW9ucy5yZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZVxuICogbWlkZGxld2FyZSBzdGFjay5cbiAqIEBwYXJhbSBvcHRpb25zLnNvdXJjZSAtIEEgZGVzY3JpcHRvciBmb3IgdGhlIGVudGl0eSBtYWtpbmcgdGhlIHJlcXVlc3Q7XG4gKiB0cmFja2VkIGJ5IEluZnVyYSBmb3IgYW5hbHl0aWNzIHB1cnBvc2VzLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIFVSTCBhbmQgYSBiYWcgb2Ygb3B0aW9ucywgYm90aCBvZiB3aGljaFxuICogd2lsbCBiZSBwYXNzZWQgdG8gYGZldGNoYC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hDb25maWdGcm9tUmVxKHsgbmV0d29yaywgcHJvamVjdElkLCBleHRyYUhlYWRlcnMgPSB7fSwgcmVxLCBzb3VyY2UsIH0pIHtcbiAgICBjb25zdCByZXF1ZXN0T3JpZ2luID0gcmVxLm9yaWdpbiB8fCAnaW50ZXJuYWwnO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBleHRyYUhlYWRlcnMsIHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgfSk7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBoZWFkZXJzWydJbmZ1cmEtU291cmNlJ10gPSBgJHtzb3VyY2V9LyR7cmVxdWVzdE9yaWdpbn1gO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaFVybDogYGh0dHBzOi8vJHtuZXR3b3JrfS5pbmZ1cmEuaW8vdjMvJHtwcm9qZWN0SWR9YCxcbiAgICAgICAgZmV0Y2hQYXJhbXM6IHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZVJlcShyZXEpKSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0cy5mZXRjaENvbmZpZ0Zyb21SZXEgPSBmZXRjaENvbmZpZ0Zyb21SZXE7XG4vKipcbiAqIFN0cmlwcyBvdXQgZXh0cmEga2V5cyBmcm9tIGEgcmVxdWVzdCBvYmplY3QgdGhhdCBjb3VsZCBiZSByZWplY3RlZCBieSBzdHJpY3RcbiAqIG5vZGVzIGxpa2UgcGFyaXR5LlxuICpcbiAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3Qgb2J0YWluZWQgdmlhIHRoZSBtaWRkbGV3YXJlIHN0YWNrLlxuICogQHJldHVybnMgQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgSlNPTi1SUEMgcmVxdWVzdC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplUmVxKHJlcSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkOiByZXEuaWQsXG4gICAgICAgIGpzb25ycGM6IHJlcS5qc29ucnBjLFxuICAgICAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgICAgIHBhcmFtczogcmVxLnBhcmFtcyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2gtY29uZmlnLWZyb20tcmVxLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY3JlYXRlLWluZnVyYS1taWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mZXRjaC1jb25maWctZnJvbS1yZXFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NyZWF0ZS1wcm92aWRlclwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlTW9kdWxlTG9nZ2VyID0gZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCJAbWV0YW1hc2svdXRpbHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVNb2R1bGVMb2dnZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuY3JlYXRlTW9kdWxlTG9nZ2VyOyB9IH0pO1xuZXhwb3J0cy5wcm9qZWN0TG9nZ2VyID0gKDAsIHV0aWxzXzEuY3JlYXRlUHJvamVjdExvZ2dlcikoJ2V0aC1qc29uLXJwYy1pbmZ1cmEnKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxvZ2dpbmctdXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW3VuZGVmaW5lZCwgbnVsbCwgJ1xcdTAwM2NuaWxcXHUwMDNlJ107XG4vL1xuLy8gQ2FjaGUgU3RyYXRlZ2llc1xuLy9cbmNsYXNzIEJsb2NrQ2FjaGVTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQoX3BheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrTnVtYmVySGV4LCAxNik7XG4gICAgICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl07XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgY2FjaGUgaWYgbmVjZXNhcnlcbiAgICAgICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDYWNoZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jYWNoZVtibG9ja051bWJlcl0gPSBuZXdDYWNoZTtcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUgPSBuZXdDYWNoZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmxvY2tDYWNoZTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0KHBheWxvYWQsIHJlcXVlc3RlZEJsb2NrTnVtYmVyKSB7XG4gICAgICAgIC8vIGxvb2t1cCBibG9jayBjYWNoZVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSAoMCwgY2FjaGVfMS5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKShwYXlsb2FkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIgPyBibG9ja0NhY2hlW2lkZW50aWZpZXJdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhc3luYyBzZXQocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlc3VsdCkge1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gY2FjaGVkIHRoaXMgcmVzdWx0XG4gICAgICAgIGNvbnN0IGNhbkNhY2hlUmVzdWx0ID0gdGhpcy5jYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpO1xuICAgICAgICBpZiAoIWNhbkNhY2hlUmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9ICgwLCBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQpKHBheWxvYWQsIHRydWUpO1xuICAgICAgICBpZiAoIWlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcik7XG4gICAgICAgIGJsb2NrQ2FjaGVbaWRlbnRpZmllcl0gPSByZXN1bHQ7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVxdWVzdChwYXlsb2FkKSB7XG4gICAgICAgIC8vIGNoZWNrIHJlcXVlc3QgbWV0aG9kXG4gICAgICAgIGlmICghKDAsIGNhY2hlXzEuY2FuQ2FjaGUpKHBheWxvYWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgYmxvY2tUYWdcbiAgICAgICAgY29uc3QgYmxvY2tUYWcgPSAoMCwgY2FjaGVfMS5ibG9ja1RhZ0ZvclBheWxvYWQpKHBheWxvYWQpO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhbkNhY2hlUmVzdWx0KHBheWxvYWQsIHJlc3VsdCkge1xuICAgICAgICAvLyBuZXZlciBjYWNoZSBlbXB0eSB2YWx1ZXMgKGUuZy4gdW5kZWZpbmVkKVxuICAgICAgICBpZiAoZW1wdHlWYWx1ZXMuaW5jbHVkZXMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgICAgICBpZiAocGF5bG9hZC5tZXRob2QgJiZcbiAgICAgICAgICAgIFsnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJywgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnXS5pbmNsdWRlcyhwYXlsb2FkLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0IHx8XG4gICAgICAgICAgICAgICAgIXJlc3VsdC5ibG9ja0hhc2ggfHxcbiAgICAgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID09PVxuICAgICAgICAgICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UgdHJ1ZVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICAgIGNsZWFyQmVmb3JlKG9sZEJsb2NrSGV4KSB7XG4gICAgICAgIGNvbnN0IG9sZEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KG9sZEJsb2NrSGV4LCAxNik7XG4gICAgICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jYWNoZSlcbiAgICAgICAgICAgIC5tYXAoTnVtYmVyKVxuICAgICAgICAgICAgLmZpbHRlcigobnVtKSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgICAgICAgIC5mb3JFYWNoKChudW0pID0+IGRlbGV0ZSB0aGlzLmNhY2hlW251bV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlKHsgYmxvY2tUcmFja2VyLCB9ID0ge30pIHtcbiAgICAvLyB2YWxpZGF0ZSBvcHRpb25zXG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIFBvbGxpbmdCbG9ja1RyYWNrZXIgc3BlY2lmaWVkJyk7XG4gICAgfVxuICAgIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgICBjb25zdCBibG9ja0NhY2hlID0gbmV3IEJsb2NrQ2FjaGVTdHJhdGVneSgpO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSB7XG4gICAgICAgIHBlcm1hOiBibG9ja0NhY2hlLFxuICAgICAgICBibG9jazogYmxvY2tDYWNoZSxcbiAgICAgICAgZm9yazogYmxvY2tDYWNoZSxcbiAgICB9O1xuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAgICAgLy8gYWxsb3cgY2FjaCB0byBiZSBza2lwcGVkIGlmIHNvIHNwZWNpZmllZFxuICAgICAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgICAgICBjb25zdCB0eXBlID0gKDAsIGNhY2hlXzEuY2FjaGVUeXBlRm9yUGF5bG9hZCkocmVxKTtcbiAgICAgICAgY29uc3Qgc3RyYXRlZ3kgPSBzdHJhdGVnaWVzW3R5cGVdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHN0cmF0ZWd5IGluIHBsYWNlLCBwYXNzIGl0IGRvd24gdGhlIGNoYWluLlxuICAgICAgICBpZiAoIXN0cmF0ZWd5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBzdHJhdGVneSBjYW4ndCBjYWNoZSB0aGlzIHJlcXVlc3QsIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYmxvY2sgcmVmZXJlbmNlIChudW1iZXIgb3Iga2V5d29yZClcbiAgICAgICAgbGV0IGJsb2NrVGFnID0gKDAsIGNhY2hlXzEuYmxvY2tUYWdGb3JQYXlsb2FkKShyZXEpO1xuICAgICAgICBpZiAoIWJsb2NrVGFnKSB7XG4gICAgICAgICAgICBibG9ja1RhZyA9ICdsYXRlc3QnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBleGFjdCBibG9jayBudW1iZXJcbiAgICAgICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyO1xuICAgICAgICBpZiAoYmxvY2tUYWcgPT09ICdlYXJsaWVzdCcpIHtcbiAgICAgICAgICAgIC8vIHRoaXMganVzdCBleGlzdHMgZm9yIHN5bW1ldHJ5IHdpdGggXCJsYXRlc3RcIlxuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSAnMHgwMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYmxvY2tUYWcgPT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICAvLyBmZXRjaCBsYXRlc3QgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICAgICAgLy8gY2xlYXIgYWxsIGNhY2hlIGJlZm9yZSBsYXRlc3QgYmxvY2tcbiAgICAgICAgICAgIGJsb2NrQ2FjaGUuY2xlYXJCZWZvcmUobGF0ZXN0QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBoZXggbnVtYmVyXG4gICAgICAgICAgICByZXF1ZXN0ZWRCbG9ja051bWJlciA9IGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgICAgIGNvbnN0IGNhY2hlUmVzdWx0ID0gYXdhaXQgc3RyYXRlZ3kuZ2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpO1xuICAgICAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vZGUvY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICAgICAgICAvLyBpdCdzIHNhZmUgdG8gY2FzdCByZXMucmVzdWx0IGFzIEJsb2NrLCBkdWUgdG8gcnVudGltZSB0eXBlIGNoZWNrc1xuICAgICAgICAgICAgLy8gcGVyZm9ybWVkIHdoZW4gc3RyYXRlZ3kuc2V0IGlzIGNhbGxlZFxuICAgICAgICAgICAgYXdhaXQgc3RyYXRlZ3kuc2V0KHJlcSwgcmVxdWVzdGVkQmxvY2tOdW1iZXIsIHJlcy5yZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmNyZWF0ZUJsb2NrQ2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1jYWNoZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrUmVmUmV3cml0ZU1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghYmxvY2tUcmFja2VyKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwiYmxvY2tUcmFja2VyXCIgb3B0aW9uIGlzIG1pc3NpbmcuJyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShhc3luYyAocmVxLCBfcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9ICgwLCBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleCkocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJld3JpdGUgYmxvY2tSZWYgdG8gYmxvY2stdHJhY2tlcidzIGJsb2NrIG51bWJlclxuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja051bWJlciA9IGF3YWl0IGJsb2NrVHJhY2tlci5nZXRMYXRlc3RCbG9jaygpO1xuICAgICAgICBpZiAocmVxLnBhcmFtcykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgICAgIHJlcS5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZlJld3JpdGVNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tSZWZSZXdyaXRlTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXJlZi1yZXdyaXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBwaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInBpZnlcIikpO1xuY29uc3QgY2FjaGVfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2NhY2hlXCIpO1xuZnVuY3Rpb24gY3JlYXRlQmxvY2tSZWZNaWRkbGV3YXJlKHsgcHJvdmlkZXIsIGJsb2NrVHJhY2tlciwgfSA9IHt9KSB7XG4gICAgaWYgKCFwcm92aWRlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignQmxvY2tSZWZNaWRkbGV3YXJlIC0gbWFuZGF0b3J5IFwicHJvdmlkZXJcIiBvcHRpb24gaXMgbWlzc2luZy4nKTtcbiAgICB9XG4gICAgaWYgKCFibG9ja1RyYWNrZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0Jsb2NrUmVmTWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9ICgwLCBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleCkocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IFwibGF0ZXN0XCJcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tSZWYgIT09ICdsYXRlc3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgLy8gY3JlYXRlIGNoaWxkIHJlcXVlc3Qgd2l0aCBzcGVjaWZpYyBibG9jay1yZWZcbiAgICAgICAgY29uc3QgY2hpbGRSZXF1ZXN0ID0gKDAsIGNsb25lXzEuZGVmYXVsdCkocmVxKTtcbiAgICAgICAgaWYgKGNoaWxkUmVxdWVzdC5wYXJhbXMpIHtcbiAgICAgICAgICAgIGNoaWxkUmVxdWVzdC5wYXJhbXNbYmxvY2tSZWZJbmRleF0gPSBsYXRlc3RCbG9ja051bWJlcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIGNoaWxkIHJlcXVlc3RcbiAgICAgICAgY29uc3QgY2hpbGRSZXMgPSBhd2FpdCAoMCwgcGlmeV8xLmRlZmF1bHQpKHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgLy8gY29weSBjaGlsZCByZXNwb25zZSBvbnRvIG9yaWdpbmFsIHJlc3BvbnNlXG4gICAgICAgIHJlcy5yZXN1bHQgPSBjaGlsZFJlcy5yZXN1bHQ7XG4gICAgICAgIHJlcy5lcnJvciA9IGNoaWxkUmVzLmVycm9yO1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmUgPSBjcmVhdGVCbG9ja1JlZk1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ibG9jay1yZWYuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBmdXR1cmVCbG9ja1JlZlJlcXVlc3RzID0gW1xuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLFxuICAgICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0Jyxcbl07XG4vLyBpbnNwZWN0IGlmIHJlc3BvbnNlIGNvbnRhaW5zIGEgYmxvY2sgcmVmIGhpZ2hlciB0aGFuIG91ciBsYXRlc3QgYmxvY2tcbmZ1bmN0aW9uIGNyZWF0ZUJsb2NrVHJhY2tlckluc3BlY3Rvck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIH0pIHtcbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFmdXR1cmVCbG9ja1JlZlJlcXVlc3RzLmluY2x1ZGVzKHJlcS5tZXRob2QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBub2RlL2NhbGxiYWNrLXJldHVyblxuICAgICAgICBhd2FpdCBuZXh0KCk7XG4gICAgICAgIC8vIGFib3J0IGlmIG5vIHJlc3VsdCBvciBubyBibG9jayBudW1iZXJcbiAgICAgICAgaWYgKCEoKF9hID0gcmVzLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJsb2NrTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJlcy5yZXN1bHQuYmxvY2tOdW1iZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBpZiBudW1iZXIgaXMgaGlnaGVyLCBzdWdnZXN0IGJsb2NrLXRyYWNrZXIgY2hlY2sgZm9yIGEgbmV3IGJsb2NrXG4gICAgICAgICAgICBjb25zdCBibG9ja051bWJlciA9IE51bWJlci5wYXJzZUludChyZXMucmVzdWx0LmJsb2NrTnVtYmVyLCAxNik7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogSWYgZ2V0Q3VycmVudEJsb2NrIHJldHVybnMgbnVsbCwgY3VycmVudEJsb2NrTnVtYmVyIHdpbGwgYmUgTmFOLCB3aGljaCBpcyBmaW5lLlxuICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrVHJhY2tlci5nZXRDdXJyZW50QmxvY2soKSwgMTYpO1xuICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gY3VycmVudEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgYmxvY2tUcmFja2VyLmNoZWNrRm9yTGF0ZXN0QmxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVCbG9ja1RyYWNrZXJJbnNwZWN0b3JNaWRkbGV3YXJlID0gY3JlYXRlQmxvY2tUcmFja2VySW5zcGVjdG9yTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsb2NrLXRyYWNrZXItaW5zcGVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVGZXRjaENvbmZpZ0Zyb21SZXEgPSBleHBvcnRzLmNyZWF0ZUZldGNoTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGpzb25fcnBjX2VuZ2luZV8xID0gcmVxdWlyZShcImpzb24tcnBjLWVuZ2luZVwiKTtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL2dsb2JhbC1yZXF1aXJlLEB0eXBlc2NyaXB0LWVzbGludC9uby1yZXF1aXJlLWltcG9ydHMgKi9cbmNvbnN0IGZldGNoID0gZ2xvYmFsLmZldGNoIHx8IHJlcXVpcmUoJ25vZGUtZmV0Y2gnKTtcbmNvbnN0IGJ0b2EgPSBnbG9iYWwuYnRvYSB8fCByZXF1aXJlKCdidG9hJyk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vZGUvZ2xvYmFsLXJlcXVpcmUsQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0cyAqL1xuY29uc3QgUkVUUklBQkxFX0VSUk9SUyA9IFtcbiAgICAvLyBpZ25vcmUgc2VydmVyIG92ZXJsb2FkIGVycm9yc1xuICAgICdHYXRld2F5IHRpbWVvdXQnLFxuICAgICdFVElNRURPVVQnLFxuICAgIC8vIGlnbm9yZSBzZXJ2ZXIgc2VudCBodG1sIGVycm9yIHBhZ2VzXG4gICAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICAgJ2ZhaWxlZCB0byBwYXJzZSByZXNwb25zZSBib2R5JyxcbiAgICAvLyBpZ25vcmUgZXJyb3JzIHdoZXJlIGh0dHAgcmVxIGZhaWxlZCB0byBlc3RhYmxpc2hcbiAgICAnRmFpbGVkIHRvIGZldGNoJyxcbl07XG5mdW5jdGlvbiBjcmVhdGVGZXRjaE1pZGRsZXdhcmUoeyBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBfbmV4dCkgPT4ge1xuICAgICAgICBjb25zdCB7IGZldGNoVXJsLCBmZXRjaFBhcmFtcyB9ID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHtcbiAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgIHJwY1VybCxcbiAgICAgICAgICAgIG9yaWdpbkh0dHBIZWFkZXJLZXksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgY29uc3QgbWF4QXR0ZW1wdHMgPSA1O1xuICAgICAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMDtcbiAgICAgICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCBtYXhBdHRlbXB0czsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZldGNoUmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIGZldGNoUGFyYW1zKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgaHR0cCBlcnJyb3JzXG4gICAgICAgICAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKTtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgICAgICAgICAgY29uc3QgcmF3Qm9keSA9IGF3YWl0IGZldGNoUmVzLnRleHQoKTtcbiAgICAgICAgICAgICAgICBsZXQgZmV0Y2hCb2R5O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHBhcnNlUmVzcG9uc2UoZmV0Y2hSZXMsIGZldGNoQm9keSk7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHJlc3VsdCBhbmQgZXhpdCByZXRyeSBsb29wXG4gICAgICAgICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZXRyaWFibGUgPSBSRVRSSUFCTEVfRVJST1JTLnNvbWUoKHBocmFzZSkgPT4gZXJyTXNnLmluY2x1ZGVzKHBocmFzZSkpO1xuICAgICAgICAgICAgICAgIC8vIHJlLXRocm93IGVycm9yIGlmIG5vdCByZXRyaWFibGVcbiAgICAgICAgICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZWxheSBiZWZvcmUgcmV0cnlpbmdcbiAgICAgICAgICAgIGF3YWl0IHRpbWVvdXQocmV0cnlJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hNaWRkbGV3YXJlID0gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlO1xuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yc1xuICAgIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgNDA1OlxuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKCk7XG4gICAgICAgIGNhc2UgNDE4OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKTtcbiAgICAgICAgY2FzZSA1MDM6XG4gICAgICAgIGNhc2UgNTA0OlxuICAgICAgICAgICAgdGhyb3cgY3JlYXRlVGltZW91dEVycm9yKCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBib2R5KSB7XG4gICAgLy8gY2hlY2sgZm9yIGVycm9yIGNvZGVcbiAgICBpZiAoZmV0Y2hSZXMuc3RhdHVzICE9PSAyMDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGBOb24tMjAwIHN0YXR1cyBjb2RlOiAnJHtmZXRjaFJlcy5zdGF0dXN9J2AsXG4gICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIHJwYyBlcnJvclxuICAgIGlmIChib2R5LmVycm9yKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7XG4gICAgICAgICAgICBkYXRhOiBib2R5LmVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIHN1Y2Nlc3NmdWwgcmVzdWx0XG4gICAgcmV0dXJuIGJvZHkucmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxKHsgcmVxLCBycGNVcmwsIG9yaWdpbkh0dHBIZWFkZXJLZXksIH0pIHtcbiAgICBjb25zdCBwYXJzZWRVcmwgPSBuZXcgVVJMKHJwY1VybCk7XG4gICAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybCk7XG4gICAgLy8gcHJlcGFyZSBwYXlsb2FkXG4gICAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcbiAgICAgICAgaWQ6IHJlcS5pZCxcbiAgICAgICAganNvbnJwYzogcmVxLmpzb25ycGMsXG4gICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICAgIH07XG4gICAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gICAgY29uc3Qgb3JpZ2luRG9tYWluID0gcmVxLm9yaWdpbjtcbiAgICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gICAgY29uc3Qgc2VyaWFsaXplZFBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShwYXlsb2FkKTtcbiAgICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gICAgY29uc3QgZmV0Y2hQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IHNlcmlhbGl6ZWRQYXlsb2FkLFxuICAgIH07XG4gICAgLy8gZW5jb2RlZCBhdXRoIGRldGFpbHMgYXMgaGVhZGVyIChub3QgYWxsb3dlZCBpbiBmZXRjaCB1cmwpXG4gICAgaWYgKHBhcnNlZFVybC51c2VybmFtZSAmJiBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgYXV0aFN0cmluZyA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgICAgICAgY29uc3QgZW5jb2RlZEF1dGggPSBidG9hKGF1dGhTdHJpbmcpO1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmFzaWMgJHtlbmNvZGVkQXV0aH1gO1xuICAgIH1cbiAgICAvLyBvcHRpb25hbDogYWRkIHJlcXVlc3Qgb3JpZ2luIGFzIGhlYWRlclxuICAgIGlmIChvcmlnaW5IdHRwSGVhZGVyS2V5ICYmIG9yaWdpbkRvbWFpbikge1xuICAgICAgICBmZXRjaFBhcmFtcy5oZWFkZXJzW29yaWdpbkh0dHBIZWFkZXJLZXldID0gb3JpZ2luRG9tYWluO1xuICAgIH1cbiAgICByZXR1cm4geyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfTtcbn1cbmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxO1xuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgcmVzdWx0ICs9IHBhcnNlZFVybC5wcm90b2NvbDtcbiAgICByZXN1bHQgKz0gYC8vJHtwYXJzZWRVcmwuaG9zdG5hbWV9YDtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgICAgcmVzdWx0ICs9IGA6JHtwYXJzZWRVcmwucG9ydH1gO1xuICAgIH1cbiAgICByZXN1bHQgKz0gYCR7cGFyc2VkVXJsLnBhdGhuYW1lfWA7XG4gICAgcmVzdWx0ICs9IGAke3BhcnNlZFVybC5zZWFyY2h9YDtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKSB7XG4gICAgcmV0dXJuIGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlVGltZW91dEVycm9yKCkge1xuICAgIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGA7XG4gICAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gO1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwoeyBtZXNzYWdlOiBtc2cgfSk7XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Jsb2NrLWNhY2hlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay1yZWYtcmV3cml0ZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYmxvY2stcmVmXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9ibG9jay10cmFja2VyLWluc3BlY3RvclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZmV0Y2hcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2luZmxpZ2h0LWNhY2hlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlckFzTWlkZGxld2FyZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcHJvdmlkZXJGcm9tRW5naW5lXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm92aWRlckZyb21NaWRkbGV3YXJlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9yZXRyeU9uRW1wdHlcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3dhbGxldFwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBjbG9uZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjbG9uZVwiKSk7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBjYWNoZV8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2FjaGVcIik7XG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSgpIHtcbiAgICBjb25zdCBpbmZsaWdodFJlcXVlc3RzID0ge307XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgICAgIGlmIChyZXEuc2tpcENhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjYWNoZUlkLCBpZiBjYWNoZWFibGVcbiAgICAgICAgY29uc3QgY2FjaGVJZCA9ICgwLCBjYWNoZV8xLmNhY2hlSWRlbnRpZmllckZvclBheWxvYWQpKHJlcSk7XG4gICAgICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICAgICAgaWYgKCFjYWNoZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoZWNrIGZvciBtYXRjaGluZyByZXF1ZXN0c1xuICAgICAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gaWYgZm91bmQsIHdhaXQgZm9yIHRoZSBhY3RpdmUgcmVxdWVzdCB0byBiZSBoYW5kbGVkXG4gICAgICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICAgICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIHJlc3BvbnNlIGhhbmRsZXIgYXJyYXkgZm9yIHN1YnNlcXVlbnQgcmVxdWVzdHNcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW107XG4gICAgICAgIGluZmxpZ2h0UmVxdWVzdHNbY2FjaGVJZF0gPSBhY3RpdmVSZXF1ZXN0SGFuZGxlcnM7XG4gICAgICAgIC8vIGFsbG93IHJlcXVlc3QgdG8gYmUgaGFuZGxlZCBub3JtYWxseVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm9kZS9jYWxsYmFjay1yZXR1cm5cbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICAvLyBjbGVhciBpbmZsaWdodCByZXF1ZXN0c1xuICAgICAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYWN0aXZlUmVxdWVzdEhhbmRsZXJzIHRvIGJlIGhhbmRsZWRcbiAgICAgICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyk7XG4gICAgICAgIC8vIGNvbXBsZXRlXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gY3JlYXRlQWN0aXZlUmVxdWVzdEhhbmRsZXIocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlLCBwcm9taXNlIH0gPSBkZWZlcnJlZFByb21pc2UoKTtcbiAgICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLnB1c2goKGhhbmRsZWRSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGFwcGVuZCBhIGNvcHkgb2YgdGhlIHJlc3VsdCBhbmQgZXJyb3IgdG8gdGhlIHJlc3BvbnNlXG4gICAgICAgICAgICByZXMucmVzdWx0ID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoaGFuZGxlZFJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgcmVzLmVycm9yID0gKDAsIGNsb25lXzEuZGVmYXVsdCkoaGFuZGxlZFJlcy5lcnJvcik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycykge1xuICAgICAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihyZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhdGNoIGVycm9yIHNvIGFsbCByZXF1ZXN0cyBhcmUgaGFuZGxlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZUluZmxpZ2h0Q2FjaGVNaWRkbGV3YXJlID0gY3JlYXRlSW5mbGlnaHRDYWNoZU1pZGRsZXdhcmU7XG5mdW5jdGlvbiBkZWZlcnJlZFByb21pc2UoKSB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChfcmVzb2x2ZSkgPT4ge1xuICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcmVzb2x2ZSwgcHJvbWlzZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mbGlnaHQtY2FjaGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXhwb3J0cy5wcm92aWRlckFzTWlkZGxld2FyZSA9IHZvaWQgMDtcbmZ1bmN0aW9uIHByb3ZpZGVyQXNNaWRkbGV3YXJlKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgX25leHQsIGVuZCkgPT4ge1xuICAgICAgICAvLyBzZW5kIHJlcXVlc3QgdG8gcHJvdmlkZXJcbiAgICAgICAgcHJvdmlkZXIuc2VuZEFzeW5jKHJlcSwgKGVyciwgcHJvdmlkZXJSZXMpID0+IHtcbiAgICAgICAgICAgIC8vIGZvcndhcmQgYW55IGVycm9yXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLnByb3ZpZGVyQXNNaWRkbGV3YXJlID0gcHJvdmlkZXJBc01pZGRsZXdhcmU7XG5mdW5jdGlvbiBldGhlcnNQcm92aWRlckFzTWlkZGxld2FyZShwcm92aWRlcikge1xuICAgIHJldHVybiAocmVxLCByZXMsIF9uZXh0LCBlbmQpID0+IHtcbiAgICAgICAgLy8gc2VuZCByZXF1ZXN0IHRvIHByb3ZpZGVyXG4gICAgICAgIHByb3ZpZGVyLnNlbmQocmVxLCAoZXJyLCBwcm92aWRlclJlcykgPT4ge1xuICAgICAgICAgICAgLy8gZm9yd2FyZCBhbnkgZXJyb3JcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5kKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb3B5IHByb3ZpZGVyIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocmVzLCBwcm92aWRlclJlcyk7XG4gICAgICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5leHBvcnRzLmV0aGVyc1Byb3ZpZGVyQXNNaWRkbGV3YXJlID0gZXRoZXJzUHJvdmlkZXJBc01pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckFzTWlkZGxld2FyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdmlkZXJGcm9tRW5naW5lID0gdm9pZCAwO1xuY29uc3Qgc2FmZV9ldmVudF9lbWl0dGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9zYWZlLWV2ZW50LWVtaXR0ZXJcIikpO1xuZnVuY3Rpb24gcHJvdmlkZXJGcm9tRW5naW5lKGVuZ2luZSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAvLyBoYW5kbGUgYm90aCBycGMgc2VuZCBtZXRob2RzXG4gICAgcHJvdmlkZXIuc2VuZEFzeW5jID0gKHJlcSwgY2IpID0+IHtcbiAgICAgICAgZW5naW5lLmhhbmRsZShyZXEsIGNiKTtcbiAgICB9O1xuICAgIHByb3ZpZGVyLnNlbmQgPSAocmVxLCBjYWxsYmFjaykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3QgcHJvdmlkZSBjYWxsYmFjayB0byBcInNlbmRcIiBtZXRob2QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZW5naW5lLmhhbmRsZShyZXEsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIC8vIGZvcndhcmQgbm90aWZpY2F0aW9uc1xuICAgIGlmIChlbmdpbmUub24pIHtcbiAgICAgICAgZW5naW5lLm9uKCdub3RpZmljYXRpb24nLCAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCgnZGF0YScsIG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3ZpZGVyO1xufVxuZXhwb3J0cy5wcm92aWRlckZyb21FbmdpbmUgPSBwcm92aWRlckZyb21FbmdpbmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckZyb21FbmdpbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3ZpZGVyRnJvbU1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBwcm92aWRlckZyb21FbmdpbmVfMSA9IHJlcXVpcmUoXCIuL3Byb3ZpZGVyRnJvbUVuZ2luZVwiKTtcbmZ1bmN0aW9uIHByb3ZpZGVyRnJvbU1pZGRsZXdhcmUobWlkZGxld2FyZSkge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBqc29uX3JwY19lbmdpbmVfMS5Kc29uUnBjRW5naW5lKCk7XG4gICAgZW5naW5lLnB1c2gobWlkZGxld2FyZSk7XG4gICAgY29uc3QgcHJvdmlkZXIgPSAoMCwgcHJvdmlkZXJGcm9tRW5naW5lXzEucHJvdmlkZXJGcm9tRW5naW5lKShlbmdpbmUpO1xuICAgIHJldHVybiBwcm92aWRlcjtcbn1cbmV4cG9ydHMucHJvdmlkZXJGcm9tTWlkZGxld2FyZSA9IHByb3ZpZGVyRnJvbU1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm92aWRlckZyb21NaWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlID0gdm9pZCAwO1xuY29uc3QgY2xvbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiY2xvbmVcIikpO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgcGlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwaWZ5XCIpKTtcbmNvbnN0IGNhY2hlXzEgPSByZXF1aXJlKFwiLi91dGlscy9jYWNoZVwiKTtcbi8vXG4vLyBSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIHdpbGwgcmV0cnkgYW55IHJlcXVlc3Qgd2l0aCBhbiBlbXB0eSByZXNwb25zZSB0aGF0IGhhc1xuLy8gYSBudW1iZXJlZCBibG9jayByZWZlcmVuY2UgYXQgb3IgbG93ZXIgdGhhbiB0aGUgYmxvY2tUcmFja2VyJ3MgbGF0ZXN0IGJsb2NrLlxuLy8gSXRzIHVzZWZ1bCBmb3IgZGVhbGluZyB3aXRoIGxvYWQtYmFsYW5jZWQgZXRoZXJldW0gSlNPTiBSUENcbi8vIG5vZGVzIHRoYXQgYXJlIG5vdCBhbHdheXMgaW4gc3luYyB3aXRoIGVhY2ggb3RoZXIuXG4vL1xuLy8gZW1wdHkgdmFsdWVzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZFxuLy8gYDxuaWw+YCBjb21lcyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMTY5MjVcbmNvbnN0IGVtcHR5VmFsdWVzID0gW1xuICAgIHVuZGVmaW5lZCxcbiAgICBudWxsLFxuICAgICdcXHUwMDNjbmlsXFx1MDAzZScsXG5dO1xuZnVuY3Rpb24gY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZSh7IHByb3ZpZGVyLCBibG9ja1RyYWNrZXIsIH0gPSB7fSkge1xuICAgIGlmICghcHJvdmlkZXIpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ1JldHJ5T25FbXB0eU1pZGRsZXdhcmUgLSBtYW5kYXRvcnkgXCJwcm92aWRlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICBpZiAoIWJsb2NrVHJhY2tlcikge1xuICAgICAgICB0aHJvdyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIG1hbmRhdG9yeSBcImJsb2NrVHJhY2tlclwiIG9wdGlvbiBpcyBtaXNzaW5nLicpO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYmxvY2tSZWZJbmRleCA9ICgwLCBjYWNoZV8xLmJsb2NrVGFnUGFyYW1JbmRleCkocmVxKTtcbiAgICAgICAgLy8gc2tpcCBpZiBtZXRob2QgZG9lcyBub3QgaW5jbHVkZSBibG9ja1JlZlxuICAgICAgICBpZiAoYmxvY2tSZWZJbmRleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgbm90IGV4YWN0IGJsb2NrIHJlZmVyZW5jZXNcbiAgICAgICAgbGV0IGJsb2NrUmVmID0gKF9hID0gcmVxLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2Jsb2NrUmVmSW5kZXhdO1xuICAgICAgICAvLyBvbWl0dGVkIGJsb2NrUmVmIGltcGxpZXMgXCJsYXRlc3RcIlxuICAgICAgICBpZiAoYmxvY2tSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxvY2tSZWYgPSAnbGF0ZXN0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBza2lwIGlmIG5vbi1udW1iZXIgYmxvY2sgcmVmZXJlbmNlXG4gICAgICAgIGlmIChbJ2xhdGVzdCcsICdwZW5kaW5nJ10uaW5jbHVkZXMoYmxvY2tSZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNraXAgaWYgYmxvY2sgcmVmZXJuY2UgaXMgbm90IGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIGNvbnN0IGJsb2NrUmVmTnVtYmVyID0gTnVtYmVyLnBhcnNlSW50KGJsb2NrUmVmLnNsaWNlKDIpLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYmxvY2tSZWZOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2t1cCBsYXRlc3QgYmxvY2tcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXJIZXggPSBhd2FpdCBibG9ja1RyYWNrZXIuZ2V0TGF0ZXN0QmxvY2soKTtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQobGF0ZXN0QmxvY2tOdW1iZXJIZXguc2xpY2UoMiksIDE2KTtcbiAgICAgICAgLy8gc2tpcCBpZiByZXF1ZXN0IGJsb2NrIG51bWJlciBpcyBoaWdoZXIgdGhhbiBjdXJyZW50XG4gICAgICAgIGlmIChibG9ja1JlZk51bWJlciA+IGxhdGVzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNyZWF0ZSBjaGlsZCByZXF1ZXN0IHdpdGggc3BlY2lmaWMgYmxvY2stcmVmXG4gICAgICAgIGNvbnN0IGNoaWxkUmVxdWVzdCA9ICgwLCBjbG9uZV8xLmRlZmF1bHQpKHJlcSk7XG4gICAgICAgIC8vIGF0dGVtcHQgY2hpbGQgcmVxdWVzdCB1bnRpbCBub24tZW1wdHkgcmVzcG9uc2UgaXMgcmVjZWl2ZWRcbiAgICAgICAgY29uc3QgY2hpbGRSZXNwb25zZSA9IGF3YWl0IHJldHJ5KDEwLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRlbXB0UmVzcG9uc2UgPSBhd2FpdCAoMCwgcGlmeV8xLmRlZmF1bHQpKHByb3ZpZGVyLnNlbmRBc3luYykuY2FsbChwcm92aWRlciwgY2hpbGRSZXF1ZXN0KTtcbiAgICAgICAgICAgIC8vIHZlcmlmeSByZXN1bHRcbiAgICAgICAgICAgIGlmIChlbXB0eVZhbHVlcy5pbmNsdWRlcyhhdHRlbXB0UmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXRyeU9uRW1wdHlNaWRkbGV3YXJlIC0gZW1wdHkgcmVzcG9uc2UgXCIke0pTT04uc3RyaW5naWZ5KGF0dGVtcHRSZXNwb25zZSl9XCIgZm9yIHJlcXVlc3QgXCIke0pTT04uc3RyaW5naWZ5KGNoaWxkUmVxdWVzdCl9XCJgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdHRlbXB0UmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb3B5IGNoaWxkIHJlc3BvbnNlIG9udG8gb3JpZ2luYWwgcmVzcG9uc2VcbiAgICAgICAgcmVzLnJlc3VsdCA9IGNoaWxkUmVzcG9uc2UucmVzdWx0O1xuICAgICAgICByZXMuZXJyb3IgPSBjaGlsZFJlc3BvbnNlLmVycm9yO1xuICAgICAgICByZXR1cm4gbmV4dCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcmVhdGVSZXRyeU9uRW1wdHlNaWRkbGV3YXJlID0gY3JlYXRlUmV0cnlPbkVtcHR5TWlkZGxld2FyZTtcbmFzeW5jIGZ1bmN0aW9uIHJldHJ5KG1heFJldHJpZXMsIGFzeW5jRm4pIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbWF4UmV0cmllczsgaW5kZXgrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFzeW5jRm4oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBhd2FpdCB0aW1lb3V0KDEwMDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignUmV0cnlPbkVtcHR5TWlkZGxld2FyZSAtIHJldHJpZXMgZXhoYXVzdGVkJyk7XG59XG5mdW5jdGlvbiB0aW1lb3V0KGR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXRyeU9uRW1wdHkuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNhY2hlVHlwZUZvclBheWxvYWQgPSBleHBvcnRzLmJsb2NrVGFnUGFyYW1JbmRleCA9IGV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gZXhwb3J0cy5ibG9ja1RhZ0ZvclBheWxvYWQgPSBleHBvcnRzLmNhbkNhY2hlID0gZXhwb3J0cy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkID0gdm9pZCAwO1xuY29uc3QganNvbl9zdGFibGVfc3RyaW5naWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiKSk7XG5mdW5jdGlvbiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHNraXBCbG9ja1JlZikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzaW1wbGVQYXJhbXMgPSBza2lwQmxvY2tSZWZcbiAgICAgICAgPyBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZClcbiAgICAgICAgOiAoX2EgPSBwYXlsb2FkLnBhcmFtcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgaWYgKGNhbkNhY2hlKHBheWxvYWQpKSB7XG4gICAgICAgIHJldHVybiBgJHtwYXlsb2FkLm1ldGhvZH06JHsoMCwganNvbl9zdGFibGVfc3RyaW5naWZ5XzEuZGVmYXVsdCkoc2ltcGxlUGFyYW1zKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCA9IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQ7XG5mdW5jdGlvbiBjYW5DYWNoZShwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNhY2hlVHlwZUZvclBheWxvYWQocGF5bG9hZCkgIT09ICduZXZlcic7XG59XG5leHBvcnRzLmNhbkNhY2hlID0gY2FuQ2FjaGU7XG5mdW5jdGlvbiBibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZCkge1xuICAgIGlmICghcGF5bG9hZC5wYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZCk7XG4gICAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1tpbmRleF07XG59XG5leHBvcnRzLmJsb2NrVGFnRm9yUGF5bG9hZCA9IGJsb2NrVGFnRm9yUGF5bG9hZDtcbmZ1bmN0aW9uIHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSB7XG4gICAgaWYgKCFwYXlsb2FkLnBhcmFtcykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuICAgIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICAgIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGF5bG9hZC5wYXJhbXM7XG4gICAgfVxuICAgIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gICAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDAsIGluZGV4KTtcbn1cbmV4cG9ydHMucGFyYW1zV2l0aG91dEJsb2NrVGFnID0gcGFyYW1zV2l0aG91dEJsb2NrVGFnO1xuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGJsb2NrVGFnIGlzIGF0IGluZGV4IDJcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMVxuICAgICAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQ291bnQnOlxuICAgICAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMFxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgLy8gdGhlcmUgaXMgbm8gYmxvY2tUYWdcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5ibG9ja1RhZ1BhcmFtSW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXg7XG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgICAgIGNhc2UgJ3dlYjNfY2xpZW50VmVyc2lvbic6XG4gICAgICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgICAgICBjYXNlICdldGhfZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50QnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnOlxuICAgICAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlTExMJzpcbiAgICAgICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgICAgIGNhc2UgJ3NoaF92ZXJzaW9uJzpcbiAgICAgICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAncGVybWEnO1xuICAgICAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgICAgICAgcmV0dXJuICdmb3JrJztcbiAgICAgICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICAgICAgY2FzZSAnZXRoX2dldFN0b3JhZ2VBdCc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICAgICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgICBjYXNlICdldGhfZXN0aW1hdGVHYXMnOlxuICAgICAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICAgICAgY2FzZSAndGVzdF9ibG9ja0NhY2hlJzpcbiAgICAgICAgICAgIHJldHVybiAnYmxvY2snO1xuICAgICAgICAvLyBuZXZlciBjYWNoZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICduZXZlcic7XG4gICAgfVxufVxuZXhwb3J0cy5jYWNoZVR5cGVGb3JQYXlsb2FkID0gY2FjaGVUeXBlRm9yUGF5bG9hZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhY2hlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBqc29uX3JwY19lbmdpbmVfMSA9IHJlcXVpcmUoXCJqc29uLXJwYy1lbmdpbmVcIik7XG5jb25zdCBzaWdVdGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJldGgtc2lnLXV0aWxcIikpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmZ1bmN0aW9uIGNyZWF0ZVdhbGxldE1pZGRsZXdhcmUoeyBnZXRBY2NvdW50cywgcHJvY2Vzc0RlY3J5cHRNZXNzYWdlLCBwcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleSwgcHJvY2Vzc0V0aFNpZ25NZXNzYWdlLCBwcm9jZXNzUGVyc29uYWxNZXNzYWdlLCBwcm9jZXNzVHJhbnNhY3Rpb24sIHByb2Nlc3NTaWduVHJhbnNhY3Rpb24sIHByb2Nlc3NUeXBlZE1lc3NhZ2UsIHByb2Nlc3NUeXBlZE1lc3NhZ2VWMywgcHJvY2Vzc1R5cGVkTWVzc2FnZVY0LCB9KSB7XG4gICAgaWYgKCFnZXRBY2NvdW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdHMuZ2V0QWNjb3VudHMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVTY2FmZm9sZE1pZGRsZXdhcmUpKHtcbiAgICAgICAgLy8gYWNjb3VudCBsb29rdXBzXG4gICAgICAgIGV0aF9hY2NvdW50czogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkobG9va3VwQWNjb3VudHMpLFxuICAgICAgICBldGhfY29pbmJhc2U6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGxvb2t1cERlZmF1bHRBY2NvdW50KSxcbiAgICAgICAgLy8gdHggc2lnbmF0dXJlc1xuICAgICAgICBldGhfc2VuZFRyYW5zYWN0aW9uOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShzZW5kVHJhbnNhY3Rpb24pLFxuICAgICAgICBldGhfc2lnblRyYW5zYWN0aW9uOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShzaWduVHJhbnNhY3Rpb24pLFxuICAgICAgICAvLyBtZXNzYWdlIHNpZ25hdHVyZXNcbiAgICAgICAgZXRoX3NpZ246ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGV0aFNpZ24pLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YTogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoc2lnblR5cGVkRGF0YSksXG4gICAgICAgIGV0aF9zaWduVHlwZWREYXRhX3YzOiAoMCwganNvbl9ycGNfZW5naW5lXzEuY3JlYXRlQXN5bmNNaWRkbGV3YXJlKShzaWduVHlwZWREYXRhVjMpLFxuICAgICAgICBldGhfc2lnblR5cGVkRGF0YV92NDogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoc2lnblR5cGVkRGF0YVY0KSxcbiAgICAgICAgcGVyc29uYWxfc2lnbjogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkocGVyc29uYWxTaWduKSxcbiAgICAgICAgZXRoX2dldEVuY3J5cHRpb25QdWJsaWNLZXk6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKGVuY3J5cHRpb25QdWJsaWNLZXkpLFxuICAgICAgICBldGhfZGVjcnlwdDogKDAsIGpzb25fcnBjX2VuZ2luZV8xLmNyZWF0ZUFzeW5jTWlkZGxld2FyZSkoZGVjcnlwdE1lc3NhZ2UpLFxuICAgICAgICBwZXJzb25hbF9lY1JlY292ZXI6ICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHBlcnNvbmFsUmVjb3ZlciksXG4gICAgfSk7XG4gICAgLy9cbiAgICAvLyBhY2NvdW50IGxvb2t1cHNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGxvb2t1cEFjY291bnRzKHJlcSwgcmVzKSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBnZXRBY2NvdW50cyhyZXEpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBsb29rdXBEZWZhdWx0QWNjb3VudChyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBhY2NvdW50cyA9IGF3YWl0IGdldEFjY291bnRzKHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhY2NvdW50c1swXSB8fCBudWxsO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHRyYW5zYWN0aW9uIHNpZ25hdHVyZXNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR4UGFyYW1zID0gcmVxLnBhcmFtc1swXSB8fCB7fTtcbiAgICAgICAgdHhQYXJhbXMuZnJvbSA9IGF3YWl0IHZhbGlkYXRlQW5kTm9ybWFsaXplS2V5aG9sZGVyKHR4UGFyYW1zLmZyb20sIHJlcSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzVHJhbnNhY3Rpb24odHhQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UcmFuc2FjdGlvbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NTaWduVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eFBhcmFtcyA9IHJlcS5wYXJhbXNbMF0gfHwge307XG4gICAgICAgIHR4UGFyYW1zLmZyb20gPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcih0eFBhcmFtcy5mcm9tLCByZXEpO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1NpZ25UcmFuc2FjdGlvbih0eFBhcmFtcywgcmVxKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBtZXNzYWdlIHNpZ25hdHVyZXNcbiAgICAvL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGV0aFNpZ24ocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzRXRoU2lnbk1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgY29uc3QgbXNnUGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRyYVBhcmFtcyksIHsgZnJvbTogYWRkcmVzcywgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NFdGhTaWduTWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGEocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKCFwcm9jZXNzVHlwZWRNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzFdLCByZXEpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gJ1YxJztcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1R5cGVkTWVzc2FnZShtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGFWMyhyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2VWMykge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWMyc7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2VWMyhtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHNpZ25UeXBlZERhdGFWNChyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NUeXBlZE1lc3NhZ2VWNCkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdFN1cHBvcnRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzBdLCByZXEpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgdmVyc2lvbiA9ICdWNCc7XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NUeXBlZE1lc3NhZ2VWNChtc2dQYXJhbXMsIHJlcSwgdmVyc2lvbik7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsU2lnbihyZXEsIHJlcykge1xuICAgICAgICBpZiAoIXByb2Nlc3NQZXJzb25hbE1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICAgIGNvbnN0IGZpcnN0UGFyYW0gPSByZXEucGFyYW1zWzBdO1xuICAgICAgICBjb25zdCBzZWNvbmRQYXJhbSA9IHJlcS5wYXJhbXNbMV07XG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIGNvbnN0IGV4dHJhUGFyYW1zID0gcmVxLnBhcmFtc1syXSB8fCB7fTtcbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGxldCBhZGRyZXNzLCBtZXNzYWdlO1xuICAgICAgICBpZiAocmVzZW1ibGVzQWRkcmVzcyhmaXJzdFBhcmFtKSAmJiAhcmVzZW1ibGVzQWRkcmVzcyhzZWNvbmRQYXJhbSkpIHtcbiAgICAgICAgICAgIGxldCB3YXJuaW5nID0gYFRoZSBldGhfcGVyc29uYWxTaWduIG1ldGhvZCByZXF1aXJlcyBwYXJhbXMgb3JkZXJlZCBgO1xuICAgICAgICAgICAgd2FybmluZyArPSBgW21lc3NhZ2UsIGFkZHJlc3NdLiBUaGlzIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW5jb3JyZWN0bHksIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBhbmQgaGFzIGJlZW4gY29ycmVjdGVkIGF1dG9tYXRpY2FsbHkuIGA7XG4gICAgICAgICAgICB3YXJuaW5nICs9IGBQbGVhc2Ugc3dpdGNoIHRoaXMgcGFyYW0gb3JkZXIgZm9yIHNtb290aCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLmA7XG4gICAgICAgICAgICByZXMud2FybmluZyA9IHdhcm5pbmc7XG4gICAgICAgICAgICBhZGRyZXNzID0gZmlyc3RQYXJhbTtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBzZWNvbmRQYXJhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBmaXJzdFBhcmFtO1xuICAgICAgICAgICAgYWRkcmVzcyA9IHNlY29uZFBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihhZGRyZXNzLCByZXEpO1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBmcm9tOiBhZGRyZXNzLCBkYXRhOiBtZXNzYWdlIH0pO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVxdWlyZS1hdG9taWMtdXBkYXRlc1xuICAgICAgICByZXMucmVzdWx0ID0gYXdhaXQgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIHBlcnNvbmFsUmVjb3ZlcihyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVxLnBhcmFtc1swXTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcmVxLnBhcmFtc1sxXTtcbiAgICAgICAgY29uc3QgZXh0cmFQYXJhbXMgPSByZXEucGFyYW1zWzJdIHx8IHt9O1xuICAgICAgICBjb25zdCBtc2dQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGV4dHJhUGFyYW1zKSwgeyBzaWc6IHNpZ25hdHVyZSwgZGF0YTogbWVzc2FnZSB9KTtcbiAgICAgICAgY29uc3Qgc2lnbmVyQWRkcmVzcyA9IHNpZ1V0aWwucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlKG1zZ1BhcmFtcyk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBzaWduZXJBZGRyZXNzO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBlbmNyeXB0aW9uUHVibGljS2V5KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0VuY3J5cHRpb25QdWJsaWNLZXkpIHtcbiAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdmFsaWRhdGVBbmROb3JtYWxpemVLZXlob2xkZXIocmVxLnBhcmFtc1swXSwgcmVxKTtcbiAgICAgICAgcmVzLnJlc3VsdCA9IGF3YWl0IHByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5KGFkZHJlc3MsIHJlcSk7XG4gICAgfVxuICAgIGFzeW5jIGZ1bmN0aW9uIGRlY3J5cHRNZXNzYWdlKHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc0RlY3J5cHRNZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMubWV0aG9kTm90U3VwcG9ydGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IHJlcS5wYXJhbXNbMF07XG4gICAgICAgIGNvbnN0IGFkZHJlc3MgPSBhd2FpdCB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihyZXEucGFyYW1zWzFdLCByZXEpO1xuICAgICAgICBjb25zdCBleHRyYVBhcmFtcyA9IHJlcS5wYXJhbXNbMl0gfHwge307XG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0cmFQYXJhbXMpLCB7IGZyb206IGFkZHJlc3MsIGRhdGE6IGNpcGhlcnRleHQgfSk7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBhd2FpdCBwcm9jZXNzRGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCByZXEpO1xuICAgIH1cbiAgICAvL1xuICAgIC8vIHV0aWxpdHlcbiAgICAvL1xuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUga2V5aG9sZGVyIGFkZHJlc3MsIGFuZCByZXR1cm5zIGEgbm9ybWFsaXplZCAoaS5lLiBsb3dlcmNhc2UpXG4gICAgICogY29weSBvZiBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gdmFsaWRhdGUgYW5kIG5vcm1hbGl6ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxIC0gVGhlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5vcm1hbGl6ZWQgYWRkcmVzcywgaWYgdmFsaWQuIE90aGVyd2lzZSwgdGhyb3dzXG4gICAgICogYW4gZXJyb3JcbiAgICAgKi9cbiAgICBhc3luYyBmdW5jdGlvbiB2YWxpZGF0ZUFuZE5vcm1hbGl6ZUtleWhvbGRlcihhZGRyZXNzLCByZXEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGRyZXNzID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgYWRkcmVzcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICByZXNlbWJsZXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAvLyBlbnN1cmUgYWRkcmVzcyBpcyBpbmNsdWRlZCBpbiBwcm92aWRlZCBhY2NvdW50cy4gYHN1cHByZXNzVW5hdXRob3JpemVkOiBmYWxzZWAgaXMgcGFzc2VkIHRvIGBnZXRBY2NvdW50c2BcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgYW4gXCJ1bmF1dGhvcml6ZWRcIiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHJlcXVlc3RlciBkb2VzIG5vdCBoYXZlIHRoZSBgZXRoX2FjY291bnRzYFxuICAgICAgICAgICAgLy8gcGVybWlzc2lvbi5cbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gYXdhaXQgZ2V0QWNjb3VudHMocmVxLCB7XG4gICAgICAgICAgICAgICAgc3VwcHJlc3NVbmF1dGhvcml6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkQWNjb3VudHMgPSBhY2NvdW50cy5tYXAoKF9hZGRyZXNzKSA9PiBfYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRBY2NvdW50cy5pbmNsdWRlcyhub3JtYWxpemVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZEFkZHJlc3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5wcm92aWRlci51bmF1dGhvcml6ZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgICAgICBtZXNzYWdlOiBgSW52YWxpZCBwYXJhbWV0ZXJzOiBtdXN0IHByb3ZpZGUgYW4gRXRoZXJldW0gYWRkcmVzcy5gLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmNyZWF0ZVdhbGxldE1pZGRsZXdhcmUgPSBjcmVhdGVXYWxsZXRNaWRkbGV3YXJlO1xuZnVuY3Rpb24gcmVzZW1ibGVzQWRkcmVzcyhzdHIpIHtcbiAgICAvLyBoZXggcHJlZml4IDIgKyAyMCBieXRlc1xuICAgIHJldHVybiBzdHIubGVuZ3RoID09PSAyICsgMjAgKiAyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2FsbGV0LmpzLm1hcCIsImNvbnN0IGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKVxuY29uc3QgZXRoQWJpID0gcmVxdWlyZSgnZXRoZXJldW1qcy1hYmknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICBjb25jYXRTaWc6IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gICAgY29uc3QgclNpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChyKVxuICAgIGNvbnN0IHNTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocylcbiAgICBjb25zdCB2U2lnID0gZXRoVXRpbC5idWZmZXJUb0ludCh2KVxuICAgIGNvbnN0IHJTdHIgPSBwYWRXaXRoWmVyb2VzKGV0aFV0aWwudG9VbnNpZ25lZChyU2lnKS50b1N0cmluZygnaGV4JyksIDY0KVxuICAgIGNvbnN0IHNTdHIgPSBwYWRXaXRoWmVyb2VzKGV0aFV0aWwudG9VbnNpZ25lZChzU2lnKS50b1N0cmluZygnaGV4JyksIDY0KVxuICAgIGNvbnN0IHZTdHIgPSBldGhVdGlsLnN0cmlwSGV4UHJlZml4KGV0aFV0aWwuaW50VG9IZXgodlNpZykpXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KHJTdHIuY29uY2F0KHNTdHIsIHZTdHIpKS50b1N0cmluZygnaGV4JylcbiAgfSxcblxuICBub3JtYWxpemU6IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHJldHVyblxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGV0aFV0aWwudG9CdWZmZXIoaW5wdXQpXG4gICAgICBpbnB1dCA9IGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmZmVyKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgbXNnID0gJ2V0aC1zaWctdXRpbC5ub3JtYWxpemUoKSByZXF1aXJlcyBoZXggc3RyaW5nIG9yIGludGVnZXIgaW5wdXQuJ1xuICAgICAgbXNnICs9ICcgcmVjZWl2ZWQgJyArICh0eXBlb2YgaW5wdXQpICsgJzogJyArIGlucHV0XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgIH1cblxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChpbnB1dC50b0xvd2VyQ2FzZSgpKVxuICB9LFxuXG4gIHBlcnNvbmFsU2lnbjogZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIHZhciBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgICB2YXIgbXNnSGFzaCA9IGV0aFV0aWwuaGFzaFBlcnNvbmFsTWVzc2FnZShtZXNzYWdlKVxuICAgIHZhciBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIHZhciBzZXJpYWxpemVkID0gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgICByZXR1cm4gc2VyaWFsaXplZFxuICB9LFxuXG4gIHJlY292ZXJQZXJzb25hbFNpZ25hdHVyZTogZnVuY3Rpb24gKG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IGdldFB1YmxpY0tleUZvcihtc2dQYXJhbXMpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIGNvbnN0IHNlbmRlckhleCA9IGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICAgIHJldHVybiBzZW5kZXJIZXhcbiAgfSxcblxuICBleHRyYWN0UHVibGljS2V5OiBmdW5jdGlvbiAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICByZXR1cm4gJzB4JyArIHB1YmxpY0tleS50b1N0cmluZygnaGV4JylcbiAgfSxcblxuICB0eXBlZFNpZ25hdHVyZUhhc2g6IGZ1bmN0aW9uICh0eXBlZERhdGEpIHtcbiAgICBjb25zdCBoYXNoQnVmZmVyID0gdHlwZWRTaWduYXR1cmVIYXNoKHR5cGVkRGF0YSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChoYXNoQnVmZmVyKVxuICB9LFxuXG4gIHNpZ25UeXBlZERhdGE6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgodGhpcy5jb25jYXRTaWcoc2lnLnYsIHNpZy5yLCBzaWcucykpXG4gIH0sXG5cbiAgcmVjb3ZlclR5cGVkU2lnbmF0dXJlOiBmdW5jdGlvbiAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfVxuXG59XG5cbi8qKlxuICogQHBhcmFtIHR5cGVkRGF0YSAtIEFycmF5IG9mIGRhdGEgYWxvbmcgd2l0aCB0eXBlcywgYXMgcGVyIEVJUDcxMi5cbiAqIEByZXR1cm5zIEJ1ZmZlclxuICovXG5mdW5jdGlvbiB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdFeHBlY3QgYXJndW1lbnQgdG8gYmUgbm9uLWVtcHR5IGFycmF5JylcbiAgaWYgKHR5cGVvZiB0eXBlZERhdGEgIT09ICdvYmplY3QnIHx8ICF0eXBlZERhdGEubGVuZ3RoKSB0aHJvdyBlcnJvclxuXG4gIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gJ2J5dGVzJyA/IGV0aFV0aWwudG9CdWZmZXIoZS52YWx1ZSkgOiBlLnZhbHVlXG4gIH0pXG4gIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gZS50eXBlIH0pXG4gIGNvbnN0IHNjaGVtYSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoIWUubmFtZSkgdGhyb3cgZXJyb3JcbiAgICByZXR1cm4gZS50eXBlICsgJyAnICsgZS5uYW1lXG4gIH0pXG5cbiAgcmV0dXJuIGV0aEFiaS5zb2xpZGl0eVNIQTMoXG4gICAgWydieXRlczMyJywgJ2J5dGVzMzInXSxcbiAgICBbXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKG5ldyBBcnJheSh0eXBlZERhdGEubGVuZ3RoKS5maWxsKCdzdHJpbmcnKSwgc2NoZW1hKSxcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpXG4gICAgXVxuICApXG59XG5cbmZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoaGFzaCwgc2lnKSB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFV0aWwudG9CdWZmZXIoc2lnKVxuICBjb25zdCBzaWdQYXJhbXMgPSBldGhVdGlsLmZyb21ScGNTaWcoc2lnbmF0dXJlKVxuICByZXR1cm4gZXRoVXRpbC5lY3JlY292ZXIoaGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucylcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yIChtc2dQYXJhbXMpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGV0aFV0aWwudG9CdWZmZXIobXNnUGFyYW1zLmRhdGEpXG4gIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgcmV0dXJuIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbn1cblxuXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzIChudW1iZXIsIGxlbmd0aCkge1xuICB2YXIgbXlTdHJpbmcgPSAnJyArIG51bWJlclxuICB3aGlsZSAobXlTdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbXlTdHJpbmcgPSAnMCcgKyBteVN0cmluZ1xuICB9XG4gIHJldHVybiBteVN0cmluZ1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2V0aGVyZXVtLWNyeXB0b2dyYXBoeS9rZWNjYWsnKSxcbiAgICBrZWNjYWsyMjQgPSBfcmVxdWlyZS5rZWNjYWsyMjQsXG4gICAga2VjY2FrMzg0ID0gX3JlcXVpcmUua2VjY2FrMzg0LFxuICAgIGsyNTYgPSBfcmVxdWlyZS5rZWNjYWsyNTYsXG4gICAga2VjY2FrNTEyID0gX3JlcXVpcmUua2VjY2FrNTEyO1xuXG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnLi9zZWNwMjU2azEtYWRhcHRlcicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xudmFyIHJscCA9IHJlcXVpcmUoJ3JscCcpO1xudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKTtcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKTtcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbk9iamVjdC5hc3NpZ24oZXhwb3J0cywgcmVxdWlyZSgnZXRoanMtdXRpbCcpKTtcblxuLyoqXG4gKiB0aGUgbWF4IGludGVnZXIgdGhhdCB0aGlzIFZNIGNhbiBoYW5kbGUgKGEgYGBgQk5gYGApXG4gKiBAdmFyIHtCTn0gTUFYX0lOVEVHRVJcbiAqL1xuZXhwb3J0cy5NQVhfSU5URUdFUiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicsIDE2KTtcblxuLyoqXG4gKiAyXjI1NiAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBUV09fUE9XMjU2XG4gKi9cbmV4cG9ydHMuVFdPX1BPVzI1NiA9IG5ldyBCTignMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLCAxNik7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfTlVMTF9TXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUyA9ICdjNWQyNDYwMTg2ZjcyMzNjOTI3ZTdkYjJkY2M3MDNjMGU1MDBiNjUzY2E4MjI3M2I3YmZhZDgwNDVkODVhNDcwJztcbmV4cG9ydHMuU0hBM19OVUxMX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1M7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfTlVMTFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9OVUxMID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfTlVMTCA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTEw7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBvZiBhbiBSTFAgb2YgYW4gZW1wdHkgYXJyYXkgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX0FSUkFZX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MgPSAnMWRjYzRkZThkZWM3NWQ3YWFiODViNTY3YjZjY2Q0MWFkMzEyNDUxYjk0OGE3NDEzZjBhMTQyZmQ0MGQ0OTM0Nyc7XG5leHBvcnRzLlNIQTNfUkxQX0FSUkFZX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9STFBfQVJSQVlcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZID0gQnVmZmVyLmZyb20oZXhwb3J0cy5LRUNDQUsyNTZfUkxQX0FSUkFZX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19STFBfQVJSQVkgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVk7XG5cbi8qKlxuICogS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBSTFAgb2YgbnVsbCAgKGEgYGBgU3RyaW5nYGBgKVxuICogQHZhciB7U3RyaW5nfSBLRUNDQUsyNTZfUkxQX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfUkxQX1MgPSAnNTZlODFmMTcxYmNjNTVhNmZmODM0NWU2OTJjMGY4NmU1YjQ4ZTAxYjk5NmNhZGMwMDE2MjJmYjVlMzYzYjQyMSc7XG5leHBvcnRzLlNIQTNfUkxQX1MgPSBleHBvcnRzLktFQ0NBSzI1Nl9STFBfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsIChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUFxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFAgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUCA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUDtcblxuLyoqXG4gKiBbYEJOYF0oaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMpXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5CTiA9IEJOO1xuXG4vKipcbiAqIFtgcmxwYF0oaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtanMvcmxwKVxuICogQHZhciB7RnVuY3Rpb259XG4gKi9cbmV4cG9ydHMucmxwID0gcmxwO1xuXG4vKipcbiAqIFtgc2VjcDI1NmsxYF0oaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS8pXG4gKiBAdmFyIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc2VjcDI1NmsxID0gc2VjcDI1NmsxO1xuXG4vKipcbiAqIFJldHVybnMgYSBidWZmZXIgZmlsbGVkIHdpdGggMHNcbiAqIEBtZXRob2QgemVyb3NcbiAqIEBwYXJhbSB7TnVtYmVyfSBieXRlcyAgdGhlIG51bWJlciBvZiBieXRlcyB0aGUgYnVmZmVyIHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnplcm9zID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoYnl0ZXMpLmZpbGwoMCk7XG59O1xuXG4vKipcbiAgKiBSZXR1cm5zIGEgemVybyBhZGRyZXNzXG4gICogQG1ldGhvZCB6ZXJvQWRkcmVzc1xuICAqIEByZXR1cm4ge1N0cmluZ31cbiAgKi9cbmV4cG9ydHMuemVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhZGRyZXNzTGVuZ3RoID0gMjA7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb3MoYWRkcmVzc0xlbmd0aCk7XG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KHplcm9BZGRyZXNzKTtcbn07XG5cbi8qKlxuICogTGVmdCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBtZXRob2QgbHNldExlbmd0aFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl9IG1zZyB0aGUgdmFsdWUgdG8gcGFkXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIG91dHB1dCBzaG91bGQgYmVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JpZ2h0PWZhbHNlXSB3aGV0aGVyIHRvIHN0YXJ0IHBhZGRpbmcgZm9ybSB0aGUgbGVmdCBvciByaWdodFxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aExlZnQgPSBleHBvcnRzLnNldExlbmd0aCA9IGZ1bmN0aW9uIChtc2csIGxlbmd0aCwgcmlnaHQpIHtcbiAgdmFyIGJ1ZiA9IGV4cG9ydHMuemVyb3MobGVuZ3RoKTtcbiAgbXNnID0gZXhwb3J0cy50b0J1ZmZlcihtc2cpO1xuICBpZiAocmlnaHQpIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAobXNnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgbXNnLmNvcHkoYnVmLCBsZW5ndGggLSBtc2cubGVuZ3RoKTtcbiAgICAgIHJldHVybiBidWY7XG4gICAgfVxuICAgIHJldHVybiBtc2cuc2xpY2UoLWxlbmd0aCk7XG4gIH1cbn07XG5cbi8qKlxuICogUmlnaHQgUGFkcyBhbiBgQXJyYXlgIG9yIGBCdWZmZXJgIHdpdGggbGVhZGluZyB6ZXJvcyB0aWxsIGl0IGhhcyBgbGVuZ3RoYCBieXRlcy5cbiAqIE9yIGl0IHRydW5jYXRlcyB0aGUgYmVnaW5uaW5nIGlmIGl0IGV4Y2VlZHMuXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fVxuICovXG5leHBvcnRzLnNldExlbmd0aFJpZ2h0ID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoKSB7XG4gIHJldHVybiBleHBvcnRzLnNldExlbmd0aChtc2csIGxlbmd0aCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFRyaW1zIGxlYWRpbmcgemVyb3MgZnJvbSBhIGBCdWZmZXJgIG9yIGFuIGBBcnJheWBcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ30gYVxuICogQHJldHVybiB7QnVmZmVyfEFycmF5fFN0cmluZ31cbiAqL1xuZXhwb3J0cy51bnBhZCA9IGV4cG9ydHMuc3RyaXBaZXJvcyA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnN0cmlwSGV4UHJlZml4KGEpO1xuICB2YXIgZmlyc3QgPSBhWzBdO1xuICB3aGlsZSAoYS5sZW5ndGggPiAwICYmIGZpcnN0LnRvU3RyaW5nKCkgPT09ICcwJykge1xuICAgIGEgPSBhLnNsaWNlKDEpO1xuICAgIGZpcnN0ID0gYVswXTtcbiAgfVxuICByZXR1cm4gYTtcbn07XG4vKipcbiAqIEF0dGVtcHRzIHRvIHR1cm4gYSB2YWx1ZSBpbnRvIGEgYEJ1ZmZlcmAuIEFzIGlucHV0IGl0IHN1cHBvcnRzIGBCdWZmZXJgLCBgU3RyaW5nYCwgYE51bWJlcmAsIG51bGwvdW5kZWZpbmVkLCBgQk5gIGFuZCBvdGhlciBvYmplY3RzIHdpdGggYSBgdG9BcnJheSgpYCBtZXRob2QuXG4gKiBAcGFyYW0geyp9IHYgdGhlIHZhbHVlXG4gKi9cbmV4cG9ydHMudG9CdWZmZXIgPSBmdW5jdGlvbiAodikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2KSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChleHBvcnRzLmlzSGV4U3RyaW5nKHYpKSB7XG4gICAgICAgIHYgPSBCdWZmZXIuZnJvbShleHBvcnRzLnBhZFRvRXZlbihleHBvcnRzLnN0cmlwSGV4UHJlZml4KHYpKSwgJ2hleCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICB2ID0gZXhwb3J0cy5pbnRUb0J1ZmZlcih2KTtcbiAgICB9IGVsc2UgaWYgKHYgPT09IG51bGwgfHwgdiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgIH0gZWxzZSBpZiAoQk4uaXNCTih2KSkge1xuICAgICAgdiA9IHYudG9BcnJheUxpa2UoQnVmZmVyKTtcbiAgICB9IGVsc2UgaWYgKHYudG9BcnJheSkge1xuICAgICAgLy8gY29udmVydHMgYSBCTiB0byBhIEJ1ZmZlclxuICAgICAgdiA9IEJ1ZmZlci5mcm9tKHYudG9BcnJheSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgdG8gYSBgTnVtYmVyYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQHRocm93cyBJZiB0aGUgaW5wdXQgbnVtYmVyIGV4Y2VlZHMgNTMgYml0cy5cbiAqL1xuZXhwb3J0cy5idWZmZXJUb0ludCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgcmV0dXJuIG5ldyBCTihleHBvcnRzLnRvQnVmZmVyKGJ1ZikpLnRvTnVtYmVyKCk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgaW50byBhIGhleCBgU3RyaW5nYFxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZlxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmJ1ZmZlclRvSGV4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBidWYgPSBleHBvcnRzLnRvQnVmZmVyKGJ1Zik7XG4gIHJldHVybiAnMHgnICsgYnVmLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5cbi8qKlxuICogSW50ZXJwcmV0cyBhIGBCdWZmZXJgIGFzIGEgc2lnbmVkIGludGVnZXIgYW5kIHJldHVybnMgYSBgQk5gLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBudW1cbiAqIEByZXR1cm4ge0JOfVxuICovXG5leHBvcnRzLmZyb21TaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBuZXcgQk4obnVtKS5mcm9tVHdvcygyNTYpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBCTmAgdG8gYW4gdW5zaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBpdCBhcyBhIGBCdWZmZXJgLiBBc3N1bWVzIDI1Ni1iaXQgbnVtYmVycy5cbiAqIEBwYXJhbSB7Qk59IG51bVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnRvVW5zaWduZWQgPSBmdW5jdGlvbiAobnVtKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShudW0udG9Ud29zKDI1NikudG9BcnJheSgpKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBLZWNjYWsgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBLZWNjYWsgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5rZWNjYWsgPSBmdW5jdGlvbiAoYSwgYml0cykge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgaWYgKCFiaXRzKSBiaXRzID0gMjU2O1xuXG4gIHN3aXRjaCAoYml0cykge1xuICAgIGNhc2UgMjI0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjI0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMjU2OlxuICAgICAge1xuICAgICAgICByZXR1cm4gazI1NihhKTtcbiAgICAgIH1cbiAgICBjYXNlIDM4NDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazM4NChhKTtcbiAgICAgIH1cbiAgICBjYXNlIDUxMjpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIGtlY2NhazUxMihhKTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsZCBhbGdvcml0aG06IGtlY2NhaycgKyBiaXRzKTtcbiAgICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgaW5wdXQsIGFsaWFzIGZvciBrZWNjYWsoYSwgMjU2KVxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhazI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhhKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyAoS2VjY2FrKSBoYXNoIG9mIHRoZSBpbnB1dCBbT0JTT0xFVEVdXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcGFyYW0ge051bWJlcn0gW2JpdHM9MjU2XSB0aGUgU0hBLTMgd2lkdGhcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEzID0gZXhwb3J0cy5rZWNjYWs7XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEyNTYgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5zaGEyNTYgPSBmdW5jdGlvbiAoYSkge1xuICBhID0gZXhwb3J0cy50b0J1ZmZlcihhKTtcbiAgcmV0dXJuIGNyZWF0ZUhhc2goJ3NoYTI1NicpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBSSVBFTUQxNjAgaGFzaCBvZiB0aGUgaW5wdXRcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gcGFkZGVkIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHBhZGRlZCB0byAyNTYgYml0cyBvciBub3RcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBmdW5jdGlvbiAoYSwgcGFkZGVkKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICB2YXIgaGFzaCA9IGNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShhKS5kaWdlc3QoKTtcbiAgaWYgKHBhZGRlZCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBleHBvcnRzLnNldExlbmd0aChoYXNoLCAzMik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBTSEEtMyBoYXNoIG9mIHRoZSBSTFAgZW5jb2RlZCB2ZXJzaW9uIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJscGhhc2ggPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocmxwLmVuY29kZShhKSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJpdmF0ZSBrZXkgc2F0aXNmaWVzIHRoZSBydWxlcyBvZiB0aGUgY3VydmUgc2VjcDI1NmsxLlxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFByaXZhdGUgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHVibGljIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azFcbiAqIGFuZCB0aGUgcmVxdWlyZW1lbnRzIG9mIEV0aGVyZXVtLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5LCBzYW5pdGl6ZSkge1xuICBpZiAocHVibGljS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAvLyBDb252ZXJ0IHRvIFNFQzEgZm9yIHNlY3AyNTZrMVxuICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KEJ1ZmZlci5jb25jYXQoW0J1ZmZlci5mcm9tKFs0XSksIHB1YmxpY0tleV0pKTtcbiAgfVxuXG4gIGlmICghc2FuaXRpemUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHVibGljIGtleS5cbiAqIEFjY2VwdHMgXCJFdGhlcmV1bSBwdWJsaWMga2V5c1wiIGFuZCBTRUMxIGVuY29kZWQga2V5cy5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJLZXkgVGhlIHR3byBwb2ludHMgb2YgYW4gdW5jb21wcmVzc2VkIGtleSwgdW5sZXNzIHNhbml0aXplIGlzIGVuYWJsZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Nhbml0aXplPWZhbHNlXSBBY2NlcHQgcHVibGljIGtleXMgaW4gb3RoZXIgZm9ybWF0c1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnB1YlRvQWRkcmVzcyA9IGV4cG9ydHMucHVibGljVG9BZGRyZXNzID0gZnVuY3Rpb24gKHB1YktleSwgc2FuaXRpemUpIHtcbiAgcHViS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwdWJLZXkpO1xuICBpZiAoc2FuaXRpemUgJiYgcHViS2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICBwdWJLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q29udmVydChwdWJLZXksIGZhbHNlKS5zbGljZSgxKTtcbiAgfVxuICBhc3NlcnQocHViS2V5Lmxlbmd0aCA9PT0gNjQpO1xuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKHB1YktleSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZXRoZXJldW0gcHVibGljIGtleSBvZiBhIGdpdmVuIHByaXZhdGUga2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleSBBIHByaXZhdGUga2V5IG11c3QgYmUgMjU2IGJpdHMgd2lkZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZVRvUHVibGljID0gZXhwb3J0cy5wcml2YXRlVG9QdWJsaWMgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICBwcml2YXRlS2V5ID0gZXhwb3J0cy50b0J1ZmZlcihwcml2YXRlS2V5KTtcbiAgLy8gc2tpcCB0aGUgdHlwZSBmbGFnIGFuZCB1c2UgdGhlIFgsIFkgcG9pbnRzXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlKS5zbGljZSgxKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBwdWJsaWMga2V5IHRvIHRoZSBFdGhlcmV1bSBmb3JtYXQuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuaW1wb3J0UHVibGljID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICBwdWJsaWNLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YmxpY0tleSk7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YmxpY0tleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBwdWJsaWNLZXk7XG59O1xuXG4vKipcbiAqIEVDRFNBIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtc2dIYXNoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmVjc2lnbiA9IGZ1bmN0aW9uIChtc2dIYXNoLCBwcml2YXRlS2V5KSB7XG4gIHZhciBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KTtcblxuICB2YXIgcmV0ID0ge307XG4gIHJldC5yID0gc2lnLnNpZ25hdHVyZS5zbGljZSgwLCAzMik7XG4gIHJldC5zID0gc2lnLnNpZ25hdHVyZS5zbGljZSgzMiwgNjQpO1xuICByZXQudiA9IHNpZy5yZWNvdmVyeSArIDI3O1xuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZWNjYWstMjU2IGhhc2ggb2YgYG1lc3NhZ2VgLCBwcmVmaXhlZCB3aXRoIHRoZSBoZWFkZXIgdXNlZCBieSB0aGUgYGV0aF9zaWduYCBSUEMgY2FsbC5cbiAqIFRoZSBvdXRwdXQgb2YgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZmVkIGludG8gYGVjc2lnbmAgdG8gcHJvZHVjZSB0aGUgc2FtZSBzaWduYXR1cmUgYXMgdGhlIGBldGhfc2lnbmBcbiAqIGNhbGwgZm9yIGEgZ2l2ZW4gYG1lc3NhZ2VgLCBvciBmZWQgdG8gYGVjcmVjb3ZlcmAgYWxvbmcgd2l0aCBhIHNpZ25hdHVyZSB0byByZWNvdmVyIHRoZSBwdWJsaWMga2V5XG4gKiB1c2VkIHRvIHByb2R1Y2UgdGhlIHNpZ25hdHVyZS5cbiAqIEBwYXJhbSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBoYXNoXG4gKi9cbmV4cG9ydHMuaGFzaFBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gIHZhciBwcmVmaXggPSBleHBvcnRzLnRvQnVmZmVyKCdcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcbicgKyBtZXNzYWdlLmxlbmd0aC50b1N0cmluZygpKTtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKEJ1ZmZlci5jb25jYXQoW3ByZWZpeCwgbWVzc2FnZV0pKTtcbn07XG5cbi8qKlxuICogRUNEU0EgcHVibGljIGtleSByZWNvdmVyeSBmcm9tIHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gcHVibGljS2V5XG4gKi9cbmV4cG9ydHMuZWNyZWNvdmVyID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHYsIHIsIHMpIHtcbiAgdmFyIHNpZ25hdHVyZSA9IEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoKHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGgocywgMzIpXSwgNjQpO1xuICB2YXIgcmVjb3ZlcnkgPSB2IC0gMjc7XG4gIGlmIChyZWNvdmVyeSAhPT0gMCAmJiByZWNvdmVyeSAhPT0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgdiB2YWx1ZScpO1xuICB9XG4gIHZhciBzZW5kZXJQdWJLZXkgPSBzZWNwMjU2azEucmVjb3Zlcihtc2dIYXNoLCBzaWduYXR1cmUsIHJlY292ZXJ5KTtcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHNlbmRlclB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBwYXJhbWV0ZXJzIGludG8gdGhlIGZvcm1hdCBvZiBgZXRoX3NpZ25gIFJQQyBtZXRob2RcbiAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEByZXR1cm4ge1N0cmluZ30gc2lnXG4gKi9cbmV4cG9ydHMudG9ScGNTaWcgPSBmdW5jdGlvbiAodiwgciwgcykge1xuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAodiAhPT0gMjcgJiYgdiAhPT0gMjgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVjb3ZlcnkgaWQnKTtcbiAgfVxuXG4gIC8vIGdldGggKGFuZCB0aGUgUlBDIGV0aF9zaWduIG1ldGhvZCkgdXNlcyB0aGUgNjUgYnl0ZSBmb3JtYXQgdXNlZCBieSBCaXRjb2luXG4gIC8vIEZJWE1FOiB0aGlzIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gIHJldHVybiBleHBvcnRzLmJ1ZmZlclRvSGV4KEJ1ZmZlci5jb25jYXQoW2V4cG9ydHMuc2V0TGVuZ3RoTGVmdChyLCAzMiksIGV4cG9ydHMuc2V0TGVuZ3RoTGVmdChzLCAzMiksIGV4cG9ydHMudG9CdWZmZXIodiAtIDI3KV0pKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBzaWduYXR1cmUgZm9ybWF0IG9mIHRoZSBgZXRoX3NpZ25gIFJQQyBtZXRob2QgdG8gc2lnbmF0dXJlIHBhcmFtZXRlcnNcbiAqIE5PVEU6IGFsbCBiZWNhdXNlIG9mIGEgYnVnIGluIGdldGg6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjA1M1xuICogQHBhcmFtIHtTdHJpbmd9IHNpZ1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZyb21ScGNTaWcgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHNpZyA9IGV4cG9ydHMudG9CdWZmZXIoc2lnKTtcblxuICAvLyBOT1RFOiB3aXRoIHBvdGVudGlhbCBpbnRyb2R1Y3Rpb24gb2YgY2hhaW5JZCB0aGlzIG1pZ2h0IG5lZWQgdG8gYmUgdXBkYXRlZFxuICBpZiAoc2lnLmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2lnbmF0dXJlIGxlbmd0aCcpO1xuICB9XG5cbiAgdmFyIHYgPSBzaWdbNjRdO1xuICAvLyBzdXBwb3J0IGJvdGggdmVyc2lvbnMgb2YgYGV0aF9zaWduYCByZXNwb25zZXNcbiAgaWYgKHYgPCAyNykge1xuICAgIHYgKz0gMjc7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHY6IHYsXG4gICAgcjogc2lnLnNsaWNlKDAsIDMyKSxcbiAgICBzOiBzaWcuc2xpY2UoMzIsIDY0KVxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBhZGRyZXNzIG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHJpdmF0ZVRvQWRkcmVzcyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBleHBvcnRzLnB1YmxpY1RvQWRkcmVzcyhwcml2YXRlVG9QdWJsaWMocHJpdmF0ZUtleSkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZC4gQWNjZXB0cyBjaGVja3N1bW1lZCBhZGRyZXNzZXMgdG9vXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiAoL14weFswLTlhLWZBLUZdezQwfSQvLnRlc3QoYWRkcmVzcylcbiAgKTtcbn07XG5cbi8qKlxuICAqIENoZWNrcyBpZiBhIGdpdmVuIGFkZHJlc3MgaXMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIGlzWmVyb0FkZHJlc3NcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICovXG5leHBvcnRzLmlzWmVyb0FkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICB2YXIgemVyb0FkZHJlc3MgPSBleHBvcnRzLnplcm9BZGRyZXNzKCk7XG4gIHJldHVybiB6ZXJvQWRkcmVzcyA9PT0gZXhwb3J0cy5hZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLnRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgYWRkcmVzcyA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYWRkcmVzcykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGhhc2ggPSBleHBvcnRzLmtlY2NhayhhZGRyZXNzKS50b1N0cmluZygnaGV4Jyk7XG4gIHZhciByZXQgPSAnMHgnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChwYXJzZUludChoYXNoW2ldLCAxNikgPj0gOCkge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV0udG9VcHBlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0ICs9IGFkZHJlc3NbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBhZGRyZXNzIGlzIGEgdmFsaWQgY2hlY2tzdW1tZWQgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZENoZWNrc3VtQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHJldHVybiBleHBvcnRzLmlzVmFsaWRBZGRyZXNzKGFkZHJlc3MpICYmIGV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcykgPT09IGFkZHJlc3M7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhbiBhZGRyZXNzIG9mIGEgbmV3bHkgY3JlYXRlZCBjb250cmFjdFxuICogQHBhcmFtIHtCdWZmZXJ9IGZyb20gdGhlIGFkZHJlc3Mgd2hpY2ggaXMgY3JlYXRpbmcgdGhpcyBuZXcgYWRkcmVzc1xuICogQHBhcmFtIHtCdWZmZXJ9IG5vbmNlIHRoZSBub25jZSBvZiB0aGUgZnJvbSBhY2NvdW50XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVBZGRyZXNzID0gZnVuY3Rpb24gKGZyb20sIG5vbmNlKSB7XG4gIGZyb20gPSBleHBvcnRzLnRvQnVmZmVyKGZyb20pO1xuICBub25jZSA9IG5ldyBCTihub25jZSk7XG5cbiAgaWYgKG5vbmNlLmlzWmVybygpKSB7XG4gICAgLy8gaW4gUkxQIHdlIHdhbnQgdG8gZW5jb2RlIG51bGwgaW4gdGhlIGNhc2Ugb2YgemVybyBub25jZVxuICAgIC8vIHJlYWQgdGhlIFJMUCBkb2N1bWVudGF0aW9uIGZvciBhbiBhbnN3ZXIgaWYgeW91IGRhcmVcbiAgICBub25jZSA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgbm9uY2UgPSBCdWZmZXIuZnJvbShub25jZS50b0FycmF5KCkpO1xuICB9XG5cbiAgLy8gT25seSB0YWtlIHRoZSBsb3dlciAxNjBiaXRzIG9mIHRoZSBoYXNoXG4gIHJldHVybiBleHBvcnRzLnJscGhhc2goW2Zyb20sIG5vbmNlXSkuc2xpY2UoLTIwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBzdXBwbGllZCBhZGRyZXNzIGJlbG9uZ3MgdG8gYSBwcmVjb21waWxlZCBhY2NvdW50IChCeXphbnRpdW0pXG4gKiBAcGFyYW0ge0J1ZmZlcnxTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcmVjb21waWxlZCA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciBhID0gZXhwb3J0cy51bnBhZChhZGRyZXNzKTtcbiAgcmV0dXJuIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPj0gMSAmJiBhWzBdIDw9IDg7XG59O1xuXG4vKipcbiAqIEFkZHMgXCIweFwiIHRvIGEgZ2l2ZW4gYFN0cmluZ2AgaWYgaXQgZG9lcyBub3QgYWxyZWFkeSBzdGFydCB3aXRoIFwiMHhcIlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnRzLmFkZEhleFByZWZpeCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIHJldHVybiBleHBvcnRzLmlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ciA6ICcweCcgKyBzdHI7XG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIEVDRFNBIHNpZ25hdHVyZVxuICogQG1ldGhvZCBpc1ZhbGlkU2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gdlxuICogQHBhcmFtIHtCdWZmZXJ9IHJcbiAqIEBwYXJhbSB7QnVmZmVyfSBzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtob21lc3RlYWQ9dHJ1ZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cblxuZXhwb3J0cy5pc1ZhbGlkU2lnbmF0dXJlID0gZnVuY3Rpb24gKHYsIHIsIHMsIGhvbWVzdGVhZCkge1xuICB2YXIgU0VDUDI1NksxX05fRElWXzIgPSBuZXcgQk4oJzdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmNWQ1NzZlNzM1N2E0NTAxZGRmZTkyZjQ2NjgxYjIwYTAnLCAxNik7XG4gIHZhciBTRUNQMjU2SzFfTiA9IG5ldyBCTignZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScsIDE2KTtcblxuICBpZiAoci5sZW5ndGggIT09IDMyIHx8IHMubGVuZ3RoICE9PSAzMikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHIgPSBuZXcgQk4ocik7XG4gIHMgPSBuZXcgQk4ocyk7XG5cbiAgaWYgKHIuaXNaZXJvKCkgfHwgci5ndChTRUNQMjU2SzFfTikgfHwgcy5pc1plcm8oKSB8fCBzLmd0KFNFQ1AyNTZLMV9OKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChob21lc3RlYWQgPT09IGZhbHNlICYmIG5ldyBCTihzKS5jbXAoU0VDUDI1NksxX05fRElWXzIpID09PSAxKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJ1ZmZlcmAgb3IgYEFycmF5YCB0byBKU09OXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gYmFcbiAqIEByZXR1cm4ge0FycmF5fFN0cmluZ3xudWxsfVxuICovXG5leHBvcnRzLmJhVG9KU09OID0gZnVuY3Rpb24gKGJhKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoYmEpKSB7XG4gICAgcmV0dXJuICcweCcgKyBiYS50b1N0cmluZygnaGV4Jyk7XG4gIH0gZWxzZSBpZiAoYmEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFycmF5LnB1c2goZXhwb3J0cy5iYVRvSlNPTihiYVtpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn07XG5cbi8qKlxuICogRGVmaW5lcyBwcm9wZXJ0aWVzIG9uIGEgYE9iamVjdGAuIEl0IG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCB1bmRlcmx5aW5nIGRhdGEgaXMgYmluYXJ5LlxuICogQHBhcmFtIHtPYmplY3R9IHNlbGYgdGhlIGBPYmplY3RgIHRvIGRlZmluZSBwcm9wZXJ0aWVzIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBmaWVsZHMgYW4gYXJyYXkgZmllbGRzIHRvIGRlZmluZS4gRmllbGRzIGNhbiBjb250YWluOlxuICogKiBgbmFtZWAgLSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydGllc1xuICogKiBgbGVuZ3RoYCAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgdGhlIGZpZWxkIGNhbiBoYXZlXG4gKiAqIGBhbGxvd0xlc3NgIC0gaWYgdGhlIGZpZWxkIGNhbiBiZSBsZXNzIHRoYW4gdGhlIGxlbmd0aFxuICogKiBgYWxsb3dFbXB0eWBcbiAqIEBwYXJhbSB7Kn0gZGF0YSBkYXRhIHRvIGJlIHZhbGlkYXRlZCBhZ2FpbnN0IHRoZSBkZWZpbml0aW9uc1xuICovXG5leHBvcnRzLmRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiAoc2VsZiwgZmllbGRzLCBkYXRhKSB7XG4gIHNlbGYucmF3ID0gW107XG4gIHNlbGYuX2ZpZWxkcyA9IFtdO1xuXG4gIC8vIGF0dGFjaCB0aGUgYHRvSlNPTmBcbiAgc2VsZi50b0pTT04gPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICBpZiAobGFiZWwpIHtcbiAgICAgIHZhciBvYmogPSB7fTtcbiAgICAgIHNlbGYuX2ZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBvYmpbZmllbGRdID0gJzB4JyArIHNlbGZbZmllbGRdLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIGV4cG9ydHMuYmFUb0pTT04odGhpcy5yYXcpO1xuICB9O1xuXG4gIHNlbGYuc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBybHAuZW5jb2RlKHNlbGYucmF3KTtcbiAgfTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQsIGkpIHtcbiAgICBzZWxmLl9maWVsZHMucHVzaChmaWVsZC5uYW1lKTtcbiAgICBmdW5jdGlvbiBnZXR0ZXIoKSB7XG4gICAgICByZXR1cm4gc2VsZi5yYXdbaV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcih2KSB7XG4gICAgICB2ID0gZXhwb3J0cy50b0J1ZmZlcih2KTtcblxuICAgICAgaWYgKHYudG9TdHJpbmcoJ2hleCcpID09PSAnMDAnICYmICFmaWVsZC5hbGxvd1plcm8pIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpZWxkLmFsbG93TGVzcyAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgdiA9IGV4cG9ydHMuc3RyaXBaZXJvcyh2KTtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA+PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBub3QgaGF2ZSBtb3JlICcgKyBmaWVsZC5sZW5ndGggKyAnIGJ5dGVzJyk7XG4gICAgICB9IGVsc2UgaWYgKCEoZmllbGQuYWxsb3daZXJvICYmIHYubGVuZ3RoID09PSAwKSAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgYXNzZXJ0KGZpZWxkLmxlbmd0aCA9PT0gdi5sZW5ndGgsICdUaGUgZmllbGQgJyArIGZpZWxkLm5hbWUgKyAnIG11c3QgaGF2ZSBieXRlIGxlbmd0aCBvZiAnICsgZmllbGQubGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgc2VsZi5yYXdbaV0gPSB2O1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBmaWVsZC5uYW1lLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBnZXR0ZXIsXG4gICAgICBzZXQ6IHNldHRlclxuICAgIH0pO1xuXG4gICAgaWYgKGZpZWxkLmRlZmF1bHQpIHtcbiAgICAgIHNlbGZbZmllbGQubmFtZV0gPSBmaWVsZC5kZWZhdWx0O1xuICAgIH1cblxuICAgIC8vIGF0dGFjaCBhbGlhc1xuICAgIGlmIChmaWVsZC5hbGlhcykge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLmFsaWFzLCB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIHNldDogc2V0dGVyLFxuICAgICAgICBnZXQ6IGdldHRlclxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBpZiB0aGUgY29uc3R1Y3RvciBpcyBwYXNzZWQgZGF0YVxuICBpZiAoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShleHBvcnRzLnN0cmlwSGV4UHJlZml4KGRhdGEpLCAnaGV4Jyk7XG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgZGF0YSA9IHJscC5kZWNvZGUoZGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA+IHNlbGYuX2ZpZWxkcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cm9uZyBudW1iZXIgb2YgZmllbGRzIGluIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgaXRlbXMgYXJlIGJ1ZmZlcnNcbiAgICAgIGRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICBzZWxmW3NlbGYuX2ZpZWxkc1tpXV0gPSBleHBvcnRzLnRvQnVmZmVyKGQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICgodHlwZW9mIGRhdGEgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRhdGEpKSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gICAgICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgaWYgKGtleXMuaW5kZXhPZihmaWVsZC5uYW1lKSAhPT0gLTEpIHNlbGZbZmllbGQubmFtZV0gPSBkYXRhW2ZpZWxkLm5hbWVdO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLmFsaWFzKSAhPT0gLTEpIHNlbGZbZmllbGQuYWxpYXNdID0gZGF0YVtmaWVsZC5hbGlhc107XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGRhdGEnKTtcbiAgICB9XG4gIH1cbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2VjcDI1NmsxID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L3NlY3AyNTZrMScpO1xuXG52YXIgc2VjcDI1NmsxdjMgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1saWIvaW5kZXgnKTtcbnZhciBkZXIgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1saWIvZGVyJyk7XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHByaXZhdGVLZXlcbiAqIEBtZXRob2QgcHJpdmF0ZUtleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gcHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSB7XG4gIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHByaXZhdGVLZXkgbGVuZ3RoIGlzIG5vdCAzMlxuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIEV4cG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5RXhwb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgcHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICAvLyBwcml2YXRlS2V5RXhwb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHZhciBwdWJsaWNLZXkgPSBzZWNwMjU2azF2My5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpO1xuXG4gIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpO1xufTtcblxuLyoqXG4gKiBJbXBvcnQgYSBwcml2YXRlS2V5IGluIERFUiBmb3JtYXRcbiAqIEBtZXRob2QgcHJpdmF0ZUtleUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuXG52YXIgcHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSkge1xuICAvLyBwcml2YXRlS2V5SW1wb3J0IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIHByaXZhdGVLZXkgPSBkZXIucHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KTtcbiAgaWYgKHByaXZhdGVLZXkgIT09IG51bGwgJiYgcHJpdmF0ZUtleS5sZW5ndGggPT09IDMyICYmIHByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSkpIHtcbiAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcImNvdWxkbid0IGltcG9ydCBmcm9tIERFUiBmb3JtYXRcIik7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZSBhIHByaXZhdGVLZXkgYnkgc3VidHJhY3RpbmcgaXQgZnJvbSB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludFxuICogQG1ldGhvZCBwcml2YXRlS2V5TmVnYXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIHByaXZhdGVLZXlOZWdhdGUocHJpdmF0ZUtleSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIGludmVyc2Ugb2YgYSBwcml2YXRlS2V5IChtb2R1bG8gdGhlIG9yZGVyIG9mIHRoZSBjdXJ2ZSdzIGJhc2UgcG9pbnQpLlxuICogQG1ldGhvZCBwcml2YXRlS2V5TW9kSW52ZXJzZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlNb2RJbnZlcnNlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU1vZEludmVyc2UocHJpdmF0ZUtleSkge1xuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMXYzLnByaXZhdGVLZXlNb2RJbnZlcnNlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHByaXZhdGVLZXkgYnkgYWRkaW5nIHR3ZWFrIHRvIGl0LlxuICogQG1ldGhvZCBwcml2YXRlS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlUd2Vha0FkZChwcml2YXRlS2V5LCB0d2Vhaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHR3ZWFrKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrLlxuICogQG1ldGhvZCBwcml2YXRlS2V5VHdlYWtNdWxcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHByaXZhdGVLZXlUd2Vha011bCA9IGZ1bmN0aW9uIHByaXZhdGVLZXlUd2Vha011bChwcml2YXRlS2V5LCB0d2Vhaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha011bChVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhaykpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgcHVibGljIGtleSBmb3IgYSBwcml2YXRlS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlDcmVhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNyZWF0ZSA9IGZ1bmN0aW9uIHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgcHVibGljS2V5IHRvIGNvbXByZXNzZWQgb3IgdW5jb21wcmVzc2VkIGZvcm0uXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNvbnZlcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q29udmVydCA9IGZ1bmN0aW9uIHB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5Q29udmVydChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHVibGljS2V5LlxuICogQG1ldGhvZCBwdWJsaWNLZXlWZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwdWJsaWNLZXlWZXJpZnkgPSBmdW5jdGlvbiBwdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KSB7XG4gIC8vIHNlY3AyNTZrMSB2NCB2ZXJzaW9uIHRocm93cyB3aGVuIHB1YmxpY0tleSBsZW5ndGggaXMgbm90IDMzIG9yIDY1XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoICE9PSAzMyAmJiBwdWJsaWNLZXkubGVuZ3RoICE9PSA2NSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgYWRkaW5nIHR3ZWFrIHRpbWVzIHRoZSBnZW5lcmF0b3IgdG8gaXQuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrQWRkXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha0FkZChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwdWJsaWNLZXkgYnkgbXVsdGlwbHlpbmcgaXQgYnkgYSB0d2VhayB2YWx1ZVxuICogQG1ldGhvZCBwdWJsaWNLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHR3ZWFrXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHVibGljS2V5VHdlYWtNdWwocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20odHdlYWspLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIGdpdmVuIHB1YmxpY0tleXMgdG9nZXRoZXIuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNvbWJpbmVcbiAqIEBwYXJhbSB7QXJyYXk8QnVmZmVyPn0gcHVibGljS2V5c1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb21iaW5lID0gZnVuY3Rpb24gcHVibGljS2V5Q29tYmluZShwdWJsaWNLZXlzLCBjb21wcmVzc2VkKSB7XG4gIHZhciBrZXlzID0gW107XG4gIHB1YmxpY0tleXMuZm9yRWFjaChmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gICAga2V5cy5wdXNoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb21iaW5lKGtleXMsIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29udmVydCBhIHNpZ25hdHVyZSB0byBhIG5vcm1hbGl6ZWQgbG93ZXItUyBmb3JtLlxuICogQG1ldGhvZCBzaWduYXR1cmVOb3JtYWxpemVcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIHNpZ25hdHVyZU5vcm1hbGl6ZShzaWduYXR1cmUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVOb3JtYWxpemUoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIGFuIEVDRFNBIHNpZ25hdHVyZSBpbiBERVIgZm9ybWF0LlxuICogQG1ldGhvZCBzaWduYXR1cmVFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUV4cG9ydChzaWduYXR1cmUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVFeHBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydChzaWduYXR1cmUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSkpKTtcbn07XG5cbi8qKlxuICogUGFyc2UgYSBERVIgRUNEU0Egc2lnbmF0dXJlIChub3QgZm9sbG93IGJ5IFtCSVA2Nl0oaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDA2Ni5tZWRpYXdpa2kpKS5cbiAqIEBtZXRob2Qgc2lnbmF0dXJlSW1wb3J0TGF4XG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBzaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiBzaWduYXR1cmVJbXBvcnRMYXgoc2lnbmF0dXJlKSB7XG4gIC8vIHNpZ25hdHVyZUltcG9ydExheCBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAvLyBlbnN1cmUgdGhhdCBzaWduYXR1cmUgaXMgZ3JlYXRlciB0aGFuIDBcbiAgaWYgKHNpZ25hdHVyZS5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc2lnbmF0dXJlIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpO1xuICBpZiAoc2lnT2JqID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgcGFyc2UgREVSIHNpZ25hdHVyZVwiKTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azF2My5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVDRFNBIHNpZ25hdHVyZS4gQWx3YXlzIHJldHVybiBsb3ctUyBzaWduYXR1cmUuXG4gKiBAbWV0aG9kIHNpZ25cbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ24gPSBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIHNob3VsZCBiZSBhbiBPYmplY3QnKTtcbiAgfVxuXG4gIHZhciBzaWduT3B0aW9ucyA9IHZvaWQgMDtcblxuICBpZiAob3B0aW9ucykge1xuICAgIHNpZ25PcHRpb25zID0ge307XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgQnVmZmVyJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZGF0YSkge1xuICAgICAgLy8gdmFsaWRhdGUgb3B0aW9uLmRhdGEgbGVuZ3RoXG4gICAgICBpZiAob3B0aW9ucy5kYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29wdGlvbnMuZGF0YSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICAgICAgfVxuXG4gICAgICBzaWduT3B0aW9ucy5kYXRhID0gbmV3IFVpbnQ4QXJyYXkob3B0aW9ucy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub25jZWZuID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zLm5vbmNlZm4gc2hvdWxkIGJlIGEgRnVuY3Rpb24nKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAvLyAgY29udmVydCBvcHRpb24ubm9uY2VmbiBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgIHNpZ25PcHRpb25zLm5vbmNlZm4gPSBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgYWxnbywgZGF0YSwgYXR0ZW1wdCkge1xuICAgICAgICB2YXIgYnVmZmVyQWxnbyA9IGFsZ28gIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGFsZ28pIDogbnVsbDtcbiAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSBkYXRhICE9IG51bGwgPyBCdWZmZXIuZnJvbShkYXRhKSA6IG51bGw7XG5cbiAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKCcnKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5ub25jZWZuKSB7XG4gICAgICAgICAgYnVmZmVyID0gb3B0aW9ucy5ub25jZWZuKEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLCBCdWZmZXIuZnJvbShwcml2YXRlS2V5KSwgYnVmZmVyQWxnbywgYnVmZmVyRGF0YSwgYXR0ZW1wdCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGJ1ZmZlcik7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBzaWcgPSBzZWNwMjU2azEuZWNkc2FTaWduKFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBzaWduT3B0aW9ucyk7XG5cbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEJ1ZmZlci5mcm9tKHNpZy5zaWduYXR1cmUpLFxuICAgIHJlY292ZXJ5OiBzaWcucmVjaWRcbiAgfTtcbn07XG5cbi8qKlxuICogVmVyaWZ5IGFuIEVDRFNBIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgdmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtZXNzYWdlLCBzaWduYXR1cmUsIHB1YmxpY0tleSkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjQgdmVyaWZ5IG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgYXJndW1lbnQgb3JkZXJcbiAgcmV0dXJuIHNlY3AyNTZrMS5lY2RzYVZlcmlmeShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBwdWJsaWNLZXkpO1xufTtcblxuLyoqXG4gKiBSZWNvdmVyIGFuIEVDRFNBIHB1YmxpYyBrZXkgZnJvbSBhIHNpZ25hdHVyZS5cbiAqIEBtZXRob2QgcmVjb3ZlclxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEBwYXJhbSB7TnVtYmVyfSByZWNpZFxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciByZWNvdmVyID0gZnVuY3Rpb24gcmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUsIHJlY2lkLCBjb21wcmVzc2VkKSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCByZWNvdmVyIG1ldGhvZCBoYXMgYSBkaWZmZXJlbnQgYXJndW1lbnQgb3JkZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RzYVJlY292ZXIoVWludDhBcnJheS5mcm9tKHNpZ25hdHVyZSksIHJlY2lkLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIGFwcGxpZWQgc2hhMjU2IHRvIGNvbXByZXNzZWQgcHVibGljIGtleS5cbiAqIEBtZXRob2QgZWNkaFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIGVjZGggPSBmdW5jdGlvbiBlY2RoKHB1YmxpY0tleSwgcHJpdmF0ZUtleSkge1xuICAvLyBub3RlOiBzZWNwMjU2azEgdjMgZG9lc24ndCBhbGxvdyBvcHRpb25hbCBwYXJhbWV0ZXJcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5lY2RoKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHt9KSk7XG59O1xuXG4vKipcbiAqIENvbXB1dGUgYW4gRUMgRGlmZmllLUhlbGxtYW4gc2VjcmV0IGFuZCByZXR1cm4gcHVibGljIGtleSBhcyByZXN1bHRcbiAqIEBtZXRob2QgZWNkaFVuc2FmZVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIGVjZGhVbnNhZmUocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIC8vIGVjZGhVbnNhZmUgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgLy8gZW5zdXJlIHZhbGlkIHB1YmxpY0tleSBsZW5ndGhcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3B1YmxpYyBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSB2YWxpZCBwcml2YXRlS2V5IGxlbmd0aFxuICBpZiAocHJpdmF0ZUtleS5sZW5ndGggIT09IDMyKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMuZWNkaFVuc2FmZShVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcHJpdmF0ZUtleVZlcmlmeTogcHJpdmF0ZUtleVZlcmlmeSxcbiAgcHJpdmF0ZUtleUV4cG9ydDogcHJpdmF0ZUtleUV4cG9ydCxcbiAgcHJpdmF0ZUtleUltcG9ydDogcHJpdmF0ZUtleUltcG9ydCxcbiAgcHJpdmF0ZUtleU5lZ2F0ZTogcHJpdmF0ZUtleU5lZ2F0ZSxcbiAgcHJpdmF0ZUtleU1vZEludmVyc2U6IHByaXZhdGVLZXlNb2RJbnZlcnNlLFxuICBwcml2YXRlS2V5VHdlYWtBZGQ6IHByaXZhdGVLZXlUd2Vha0FkZCxcbiAgcHJpdmF0ZUtleVR3ZWFrTXVsOiBwcml2YXRlS2V5VHdlYWtNdWwsXG5cbiAgcHVibGljS2V5Q3JlYXRlOiBwdWJsaWNLZXlDcmVhdGUsXG4gIHB1YmxpY0tleUNvbnZlcnQ6IHB1YmxpY0tleUNvbnZlcnQsXG4gIHB1YmxpY0tleVZlcmlmeTogcHVibGljS2V5VmVyaWZ5LFxuICBwdWJsaWNLZXlUd2Vha0FkZDogcHVibGljS2V5VHdlYWtBZGQsXG4gIHB1YmxpY0tleVR3ZWFrTXVsOiBwdWJsaWNLZXlUd2Vha011bCxcbiAgcHVibGljS2V5Q29tYmluZTogcHVibGljS2V5Q29tYmluZSxcblxuICBzaWduYXR1cmVOb3JtYWxpemU6IHNpZ25hdHVyZU5vcm1hbGl6ZSxcbiAgc2lnbmF0dXJlRXhwb3J0OiBzaWduYXR1cmVFeHBvcnQsXG4gIHNpZ25hdHVyZUltcG9ydDogc2lnbmF0dXJlSW1wb3J0LFxuICBzaWduYXR1cmVJbXBvcnRMYXg6IHNpZ25hdHVyZUltcG9ydExheCxcblxuICBzaWduOiBzaWduLFxuICB2ZXJpZnk6IHZlcmlmeSxcbiAgcmVjb3ZlcjogcmVjb3ZlcixcblxuICBlY2RoOiBlY2RoLFxuICBlY2RoVW5zYWZlOiBlY2RoVW5zYWZlXG59OyIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgZnJvbSBzZWNwMjU2azEgdjNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX0NPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4vLyBiZWdpblxuMHgzMCwgMHg4MSwgMHhkMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbi8vIHByaXZhdGUga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLFxuLy8gbWlkZGxlXG4weGEwLCAweDgxLCAweDg1LCAweDMwLCAweDgxLCAweDgyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LCAweGNlLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LCAweDIxLCAweDAyLCAweDc5LCAweGJlLCAweDY2LCAweDdlLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNlLCAweDg3LCAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNlLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LCAweDE3LCAweDk4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZlLCAweGJhLCAweGFlLCAweGRjLCAweGU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVlLCAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDI0LCAweDAzLCAweDIyLCAweDAwLFxuLy8gcHVibGljIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMF0pO1xuXG52YXIgRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgyLCAweDAxLCAweDEzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4YTUsIDB4MzAsIDB4ODEsIDB4YTIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4NDEsIDB4MDQsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4NDgsIDB4M2EsIDB4ZGEsIDB4NzcsIDB4MjYsIDB4YTMsIDB4YzQsIDB4NjUsIDB4NWQsIDB4YTQsIDB4ZmIsIDB4ZmMsIDB4MGUsIDB4MTEsIDB4MDgsIDB4YTgsIDB4ZmQsIDB4MTcsIDB4YjQsIDB4NDgsIDB4YTYsIDB4ODUsIDB4NTQsIDB4MTksIDB4OWMsIDB4NDcsIDB4ZDAsIDB4OGYsIDB4ZmIsIDB4MTAsIDB4ZDQsIDB4YjgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4NDQsIDB4MDMsIDB4NDIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpO1xuICBwcml2YXRlS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gOCA6IDkpO1xuICBwdWJsaWNLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyAxODEgOiAyMTQpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGxlbmd0aCA9IHByaXZhdGVLZXkubGVuZ3RoO1xuXG4gIC8vIHNlcXVlbmNlIGhlYWRlclxuICB2YXIgaW5kZXggPSAwO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDMwKSByZXR1cm4gbnVsbDtcbiAgaW5kZXggKz0gMTtcblxuICAvLyBzZXF1ZW5jZSBsZW5ndGggY29uc3RydWN0b3JcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMSB8fCAhKHByaXZhdGVLZXlbaW5kZXhdICYgMHg4MCkpIHJldHVybiBudWxsO1xuXG4gIHZhciBsZW5iID0gcHJpdmF0ZUtleVtpbmRleF0gJiAweDdmO1xuICBpbmRleCArPSAxO1xuICBpZiAobGVuYiA8IDEgfHwgbGVuYiA+IDIpIHJldHVybiBudWxsO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW5iKSByZXR1cm4gbnVsbDtcblxuICAvLyBzZXF1ZW5jZSBsZW5ndGhcbiAgdmFyIGxlbiA9IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMV0gfCAobGVuYiA+IDEgPyBwcml2YXRlS2V5W2luZGV4ICsgbGVuYiAtIDJdIDw8IDggOiAwKTtcbiAgaW5kZXggKz0gbGVuYjtcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKSByZXR1cm4gbnVsbDtcblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMyB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwMiB8fCBwcml2YXRlS2V5W2luZGV4ICsgMV0gIT09IDB4MDEgfHwgcHJpdmF0ZUtleVtpbmRleCArIDJdICE9PSAweDAxKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaW5kZXggKz0gMztcblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDE6IG9jdGV0IHN0cmluZywgdXAgdG8gMzIgYnl0ZXNcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMiB8fCBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fCBwcml2YXRlS2V5W2luZGV4ICsgMV0gPiAweDIwIHx8IGxlbmd0aCA8IGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHByaXZhdGVLZXkuc2xpY2UoaW5kZXggKyAyLCBpbmRleCArIDIgKyBwcml2YXRlS2V5W2luZGV4ICsgMV0pO1xufTtcblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKTtcbiAgdmFyIHMgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuXG4gIHZhciBsZW5ndGggPSBzaWduYXR1cmUubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlXG4gIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MzApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBieXRlXG4gIHZhciBsZW5ieXRlID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAobGVuYnl0ZSAmIDB4ODApIHtcbiAgICBpbmRleCArPSBsZW5ieXRlIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNlcXVlbmNlIHRhZyBieXRlIGZvciByXG4gIGlmIChzaWduYXR1cmVbaW5kZXgrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIGxlbmd0aCBmb3IgclxuICB2YXIgcmxlbiA9IHNpZ25hdHVyZVtpbmRleCsrXTtcbiAgaWYgKHJsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHJsZW4gLSAweDgwO1xuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmb3IgKDsgbGVuYnl0ZSA+IDAgJiYgc2lnbmF0dXJlW2luZGV4XSA9PT0gMHgwMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7fVxuICAgIGZvciAocmxlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHtcbiAgICAgIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ25hdHVyZVtpbmRleF07XG4gICAgfVxuICB9XG4gIGlmIChybGVuID4gbGVuZ3RoIC0gaW5kZXgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcmluZGV4ID0gaW5kZXg7XG4gIGluZGV4ICs9IHJsZW47XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHNcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciBzXG4gIHZhciBzbGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAoc2xlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gc2xlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHNsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBzaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gc2xlbjtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiByXG4gIGZvciAoOyBybGVuID4gMCAmJiBzaWduYXR1cmVbcmluZGV4XSA9PT0gMHgwMDsgcmxlbiAtPSAxLCByaW5kZXggKz0gMSkge31cbiAgLy8gY29weSByIHZhbHVlXG4gIGlmIChybGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcnZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbik7XG4gIHJ2YWx1ZS5jb3B5KHIsIDMyIC0gcnZhbHVlLmxlbmd0aCk7XG5cbiAgLy8gaWdub3JlIGxlYWRpbmcgemVyb3MgaW4gc1xuICBmb3IgKDsgc2xlbiA+IDAgJiYgc2lnbmF0dXJlW3NpbmRleF0gPT09IDB4MDA7IHNsZW4gLT0gMSwgc2luZGV4ICs9IDEpIHt9XG4gIC8vIGNvcHkgcyB2YWx1ZVxuICBpZiAoc2xlbiA+IDMyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHN2YWx1ZSA9IHNpZ25hdHVyZS5zbGljZShzaW5kZXgsIHNpbmRleCArIHNsZW4pO1xuICBzdmFsdWUuY29weShzLCAzMiAtIHN2YWx1ZS5sZW5ndGgpO1xuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgaXMgaW1wb3J0ZWQgZnJvbSBzZWNwMjU2azEgdjNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvc2VjcDI1NmsxLW5vZGUvYmxvYi9tYXN0ZXIvTElDRU5TRVxuXG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lYztcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKTtcbnZhciBlY3BhcmFtcyA9IGVjLmN1cnZlO1xuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGQudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZG5cXCd0IGV4cG9ydCB0byBERVIgZm9ybWF0Jyk7XG4gIH1cblxuICB2YXIgcG9pbnQgPSBlYy5nLm11bChkKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHBvaW50LmdldFgoKSwgcG9pbnQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG5cbmV4cG9ydHMucHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgYm4gPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChibi51Y21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IHJhbmdlIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpO1xufTtcblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gbmV3IEJOKHNpZ09iai5yKTtcbiAgaWYgKHIudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgciA9IG5ldyBCTigwKTtcbiAgfVxuXG4gIHZhciBzID0gbmV3IEJOKHNpZ09iai5zKTtcbiAgaWYgKHMudWNtcChlY3BhcmFtcy5uKSA+PSAwKSB7XG4gICAgcyA9IG5ldyBCTigwKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtyLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLCBzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXSk7XG59O1xuXG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwb2ludCA9IGVjLmtleUZyb21QdWJsaWMocHVibGljS2V5KTtcblxuICB2YXIgc2NhbGFyID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoc2NhbGFyLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdyknKTtcbiAgfVxuXG4gIHZhciBzaGFyZWQgPSBwb2ludC5wdWIubXVsKHNjYWxhcik7XG4gIHJldHVybiB0b1B1YmxpY0tleShzaGFyZWQuZ2V0WCgpLCBzaGFyZWQuZ2V0WSgpLCBjb21wcmVzc2VkKTtcbn07XG5cbnZhciB0b1B1YmxpY0tleSA9IGZ1bmN0aW9uIHRvUHVibGljS2V5KHgsIHksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHB1YmxpY0tleSA9IHZvaWQgMDtcblxuICBpZiAoY29tcHJlc3NlZCkge1xuICAgIHB1YmxpY0tleSA9IEJ1ZmZlci5hbGxvYygzMyk7XG4gICAgcHVibGljS2V5WzBdID0geS5pc09kZCgpID8gMHgwMyA6IDB4MDI7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gIH0gZWxzZSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDY1KTtcbiAgICBwdWJsaWNLZXlbMF0gPSAweDA0O1xuICAgIHgudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDEpO1xuICAgIHkudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMikuY29weShwdWJsaWNLZXksIDMzKTtcbiAgfVxuXG4gIHJldHVybiBwdWJsaWNLZXk7XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGlzSGV4UHJlZml4ZWQgPSByZXF1aXJlKCdpcy1oZXgtcHJlZml4ZWQnKTtcbnZhciBzdHJpcEhleFByZWZpeCA9IHJlcXVpcmUoJ3N0cmlwLWhleC1wcmVmaXgnKTtcblxuLyoqXG4gKiBQYWRzIGEgYFN0cmluZ2AgdG8gaGF2ZSBhbiBldmVuIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG91dHB1dFxuICovXG5mdW5jdGlvbiBwYWRUb0V2ZW4odmFsdWUpIHtcbiAgdmFyIGEgPSB2YWx1ZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIGlmICh0eXBlb2YgYSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBwYWRkaW5nIHRvIGV2ZW4sIHZhbHVlIG11c3QgYmUgc3RyaW5nLCBpcyBjdXJyZW50bHkgJyArIHR5cGVvZiBhICsgJywgd2hpbGUgcGFkVG9FdmVuLicpO1xuICB9XG5cbiAgaWYgKGEubGVuZ3RoICUgMikge1xuICAgIGEgPSAnMCcgKyBhO1xuICB9XG5cbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBgTnVtYmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge051bWJlcn0gaVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiBpbnRUb0hleChpKSB7XG4gIHZhciBoZXggPSBpLnRvU3RyaW5nKDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGBOdW1iZXJgIHRvIGEgYEJ1ZmZlcmBcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmZ1bmN0aW9uIGludFRvQnVmZmVyKGkpIHtcbiAgdmFyIGhleCA9IGludFRvSGV4KGkpO1xuXG4gIHJldHVybiBuZXcgQnVmZmVyKHBhZFRvRXZlbihoZXguc2xpY2UoMikpLCAnaGV4Jyk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBiaW5hcnkgc2l6ZSBvZiBhIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRCaW5hcnlTaXplKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSB3aGlsZSBnZXR0aW5nIGJpbmFyeSBzaXplLCBtZXRob2QgZ2V0QmluYXJ5U2l6ZSByZXF1aXJlcyBpbnB1dCBcXCdzdHJcXCcgdG8gYmUgdHlwZSBTdHJpbmcsIGdvdCBcXCcnICsgdHlwZW9mIHN0ciArICdcXCcuJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyLCAndXRmOCcpO1xufVxuXG4vKipcbiAqIFJldHVybnMgVFJVRSBpZiB0aGUgZmlyc3Qgc3BlY2lmaWVkIGFycmF5IGNvbnRhaW5zIGFsbCBlbGVtZW50c1xuICogZnJvbSB0aGUgc2Vjb25kIG9uZS4gRkFMU0Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7YXJyYXl9IHN1cGVyc2V0XG4gKiBAcGFyYW0ge2FycmF5fSBzdWJzZXRcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJyYXlDb250YWluc0FycmF5KHN1cGVyc2V0LCBzdWJzZXQsIHNvbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3VwZXJzZXQpICE9PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdbZXRoanMtdXRpbF0gbWV0aG9kIGFycmF5Q29udGFpbnNBcnJheSByZXF1aXJlcyBpbnB1dCBcXCdzdXBlcnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1cGVyc2V0ICsgJ1xcJycpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHN1YnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1YnNldFxcJyB0byBiZSBhbiBhcnJheSBnb3QgdHlwZSBcXCcnICsgdHlwZW9mIHN1YnNldCArICdcXCcnKTtcbiAgfVxuXG4gIHJldHVybiBzdWJzZXRbQm9vbGVhbihzb21lKSAmJiAnc29tZScgfHwgJ2V2ZXJ5J10oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHN1cGVyc2V0LmluZGV4T2YodmFsdWUpID49IDA7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b1V0ZjgoaGV4KSB7XG4gIHZhciBidWZmZXJWYWx1ZSA9IG5ldyBCdWZmZXIocGFkVG9FdmVuKHN0cmlwSGV4UHJlZml4KGhleCkucmVwbGFjZSgvXjArfDArJC9nLCAnJykpLCAnaGV4Jyk7XG5cbiAgcmV0dXJuIGJ1ZmZlclZhbHVlLnRvU3RyaW5nKCd1dGY4Jyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xuZnVuY3Rpb24gdG9Bc2NpaShoZXgpIHtcbiAgdmFyIHN0ciA9ICcnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIHZhciBpID0gMCxcbiAgICAgIGwgPSBoZXgubGVuZ3RoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKGhleC5zdWJzdHJpbmcoMCwgMikgPT09ICcweCcpIHtcbiAgICBpID0gMjtcbiAgfVxuXG4gIGZvciAoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbVV0Zjgoc3RyaW5nVmFsdWUpIHtcbiAgdmFyIHN0ciA9IG5ldyBCdWZmZXIoc3RyaW5nVmFsdWUsICd1dGY4Jyk7XG5cbiAgcmV0dXJuICcweCcgKyBwYWRUb0V2ZW4oc3RyLnRvU3RyaW5nKCdoZXgnKSkucmVwbGFjZSgvXjArfDArJC9nLCAnJyk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgYXNjaWkgc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tQXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25hbCBwYWRkaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGZyb21Bc2NpaShzdHJpbmdWYWx1ZSkge1xuICB2YXIgaGV4ID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgY29kZSA9IHN0cmluZ1ZhbHVlLmNoYXJDb2RlQXQoaSk7XG4gICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICBoZXggKz0gbi5sZW5ndGggPCAyID8gJzAnICsgbiA6IG47XG4gIH1cblxuICByZXR1cm4gJzB4JyArIGhleDtcbn1cblxuLyoqXG4gKiBnZXRLZXlzKFt7YTogMSwgYjogMn0sIHthOiAzLCBiOiA0fV0sICdhJykgPT4gWzEsIDNdXG4gKlxuICogQG1ldGhvZCBnZXRLZXlzIGdldCBzcGVjaWZpYyBrZXkgZnJvbSBpbm5lciBvYmplY3QgYXJyYXkgb2Ygb2JqZWN0c1xuICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtc1xuICogQHBhcmFtIHtTdHJpbmd9IGtleVxuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd0VtcHR5XG4gKiBAcmV0dXJucyB7QXJyYXl9IG91dHB1dCBqdXN0IGEgc2ltcGxlIGFycmF5IG9mIG91dHB1dCBrZXlzXG4gKi9cbmZ1bmN0aW9uIGdldEtleXMocGFyYW1zLCBrZXksIGFsbG93RW1wdHkpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBBcnJheSBhcyBcXCdwYXJhbXNcXCcgaW5wdXQsIGdvdCBcXCcnICsgdHlwZW9mIHBhcmFtcyArICdcXCcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgZ2V0S2V5cyBleHBlY3RpbmcgdHlwZSBTdHJpbmcgZm9yIGlucHV0IFxcJ2tleVxcJyBnb3QgXFwnJyArIHR5cGVvZiBrZXkgKyAnXFwnLicpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbXMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgdmFyIHZhbHVlID0gcGFyYW1zW2ldW2tleV07IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICBpZiAoYWxsb3dFbXB0eSAmJiAhdmFsdWUpIHtcbiAgICAgIHZhbHVlID0gJyc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWJpJyk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSXMgdGhlIHN0cmluZyBhIGhleCBzdHJpbmcuXG4gKlxuICogQG1ldGhvZCBjaGVjayBpZiBzdHJpbmcgaXMgaGV4IHN0cmluZyBvZiBzcGVjaWZpYyBsZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aFxuICogQHJldHVybnMge0Jvb2xlYW59IG91dHB1dCB0aGUgc3RyaW5nIGlzIGEgaGV4IHN0cmluZ1xuICovXG5mdW5jdGlvbiBpc0hleFN0cmluZyh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhcnJheUNvbnRhaW5zQXJyYXk6IGFycmF5Q29udGFpbnNBcnJheSxcbiAgaW50VG9CdWZmZXI6IGludFRvQnVmZmVyLFxuICBnZXRCaW5hcnlTaXplOiBnZXRCaW5hcnlTaXplLFxuICBpc0hleFByZWZpeGVkOiBpc0hleFByZWZpeGVkLFxuICBzdHJpcEhleFByZWZpeDogc3RyaXBIZXhQcmVmaXgsXG4gIHBhZFRvRXZlbjogcGFkVG9FdmVuLFxuICBpbnRUb0hleDogaW50VG9IZXgsXG4gIGZyb21Bc2NpaTogZnJvbUFzY2lpLFxuICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gIHRvQXNjaWk6IHRvQXNjaWksXG4gIHRvVXRmODogdG9VdGY4LFxuICBnZXRLZXlzOiBnZXRLZXlzLFxuICBpc0hleFN0cmluZzogaXNIZXhTdHJpbmdcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBwcm9jZXNzRm4gPSAoZm4sIG9wdHMpID0+IGZ1bmN0aW9uICgpIHtcblx0Y29uc3QgUCA9IG9wdHMucHJvbWlzZU1vZHVsZTtcblx0Y29uc3QgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG5cdH1cblxuXHRyZXR1cm4gbmV3IFAoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuXHRcdGlmIChvcHRzLmVycm9yRmlyc3QpIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdFx0cmVzdWx0cy51bnNoaWZ0KGVycik7XG5cdFx0XHRcdFx0XHRyZWplY3QocmVzdWx0cyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc29sdmUocmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGVycikge1xuXHRcdFx0XHRcdHJlamVjdChlcnIpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFyZ3MucHVzaChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChvcHRzLm11bHRpQXJncykge1xuXHRcdFx0XHRcdGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuXG5cdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHJlc3VsdHNbaV0gPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXHR9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKG9iaiwgb3B0cykgPT4ge1xuXHRvcHRzID0gT2JqZWN0LmFzc2lnbih7XG5cdFx0ZXhjbHVkZTogWy8uKyhTeW5jfFN0cmVhbSkkL10sXG5cdFx0ZXJyb3JGaXJzdDogdHJ1ZSxcblx0XHRwcm9taXNlTW9kdWxlOiBQcm9taXNlXG5cdH0sIG9wdHMpO1xuXG5cdGNvbnN0IGZpbHRlciA9IGtleSA9PiB7XG5cdFx0Y29uc3QgbWF0Y2ggPSBwYXR0ZXJuID0+IHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJyA/IGtleSA9PT0gcGF0dGVybiA6IHBhdHRlcm4udGVzdChrZXkpO1xuXHRcdHJldHVybiBvcHRzLmluY2x1ZGUgPyBvcHRzLmluY2x1ZGUuc29tZShtYXRjaCkgOiAhb3B0cy5leGNsdWRlLnNvbWUobWF0Y2gpO1xuXHR9O1xuXG5cdGxldCByZXQ7XG5cdGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0cmV0ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0aWYgKG9wdHMuZXhjbHVkZU1haW4pIHtcblx0XHRcdFx0cmV0dXJuIG9iai5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvY2Vzc0ZuKG9iaiwgb3B0cykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHJldCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikpO1xuXHR9XG5cblx0Zm9yIChjb25zdCBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZ3VhcmQtZm9yLWluXG5cdFx0Y29uc3QgeCA9IG9ialtrZXldO1xuXHRcdHJldFtrZXldID0gdHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgZmlsdGVyKGtleSkgPyBwcm9jZXNzRm4oeCwgb3B0cykgOiB4O1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG4iLCJjb25zdCB7IEV2ZW50RW1pdHRlciB9ID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IEhES2V5ID0gcmVxdWlyZSgnaGRrZXknKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBzaWdVdGlsID0gcmVxdWlyZSgnZXRoLXNpZy11dGlsJylcbmNvbnN0IHsgVHJhbnNhY3Rpb25GYWN0b3J5IH0gPSByZXF1aXJlKCdAZXRoZXJldW1qcy90eCcpXG5cbmNvbnN0IHBhdGhCYXNlID0gJ20nXG5jb25zdCBoZFBhdGhTdHJpbmcgPSBgJHtwYXRoQmFzZX0vNDQnLzYwJy8wJ2BcbmNvbnN0IHR5cGUgPSAnTGVkZ2VyIEhhcmR3YXJlJ1xuXG5jb25zdCBCUklER0VfVVJMID0gJ2h0dHBzOi8vbWV0YW1hc2suZ2l0aHViLmlvL2V0aC1sZWRnZXItYnJpZGdlLWtleXJpbmcnXG5cbmNvbnN0IE1BWF9JTkRFWCA9IDEwMDBcbmNvbnN0IE5FVFdPUktfQVBJX1VSTFMgPSB7XG4gIHJvcHN0ZW46ICdodHRwOi8vYXBpLXJvcHN0ZW4uZXRoZXJzY2FuLmlvJyxcbiAga292YW46ICdodHRwOi8vYXBpLWtvdmFuLmV0aGVyc2Nhbi5pbycsXG4gIHJpbmtlYnk6ICdodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pbycsXG4gIG1haW5uZXQ6ICdodHRwczovL2FwaS5ldGhlcnNjYW4uaW8nLFxufVxuXG5jb25zdCBDT05ORUNUSU9OX0VWRU5UID0gJ2xlZGdlci1jb25uZWN0aW9uLWNoYW5nZSdcblxuY2xhc3MgTGVkZ2VyQnJpZGdlS2V5cmluZyBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5hY2NvdW50RGV0YWlscyA9IHt9XG4gICAgdGhpcy5icmlkZ2VVcmwgPSBudWxsXG4gICAgdGhpcy50eXBlID0gdHlwZVxuICAgIHRoaXMucGFnZSA9IDBcbiAgICB0aGlzLnBlclBhZ2UgPSA1XG4gICAgdGhpcy51bmxvY2tlZEFjY291bnQgPSAwXG4gICAgdGhpcy5oZGsgPSBuZXcgSERLZXkoKVxuICAgIHRoaXMucGF0aHMgPSB7fVxuICAgIHRoaXMuaWZyYW1lID0gbnVsbFxuICAgIHRoaXMubmV0d29yayA9ICdtYWlubmV0J1xuICAgIHRoaXMuaW1wbGVtZW50RnVsbEJJUDQ0ID0gZmFsc2VcbiAgICB0aGlzLmRlc2VyaWFsaXplKG9wdHMpXG5cbiAgICB0aGlzLmlmcmFtZUxvYWRlZCA9IGZhbHNlXG4gICAgdGhpcy5fc2V0dXBJZnJhbWUoKVxuXG4gICAgdGhpcy5jdXJyZW50TWVzc2FnZUlkID0gMFxuICAgIHRoaXMubWVzc2FnZUNhbGxiYWNrcyA9IHt9XG4gICAgdGhpcy5fc2V0dXBMaXN0ZW5lcigpXG4gIH1cblxuICBzZXJpYWxpemUgKCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgaGRQYXRoOiB0aGlzLmhkUGF0aCxcbiAgICAgIGFjY291bnRzOiB0aGlzLmFjY291bnRzLFxuICAgICAgYWNjb3VudERldGFpbHM6IHRoaXMuYWNjb3VudERldGFpbHMsXG4gICAgICBicmlkZ2VVcmw6IHRoaXMuYnJpZGdlVXJsLFxuICAgICAgaW1wbGVtZW50RnVsbEJJUDQ0OiBmYWxzZSxcbiAgICB9KVxuICB9XG5cbiAgZGVzZXJpYWxpemUgKG9wdHMgPSB7fSkge1xuICAgIHRoaXMuaGRQYXRoID0gb3B0cy5oZFBhdGggfHwgaGRQYXRoU3RyaW5nXG4gICAgdGhpcy5icmlkZ2VVcmwgPSBvcHRzLmJyaWRnZVVybCB8fCBCUklER0VfVVJMXG4gICAgdGhpcy5hY2NvdW50cyA9IG9wdHMuYWNjb3VudHMgfHwgW11cbiAgICB0aGlzLmFjY291bnREZXRhaWxzID0gb3B0cy5hY2NvdW50RGV0YWlscyB8fCB7fVxuICAgIGlmICghb3B0cy5hY2NvdW50RGV0YWlscykge1xuICAgICAgdGhpcy5fbWlncmF0ZUFjY291bnREZXRhaWxzKG9wdHMpXG4gICAgfVxuXG4gICAgdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPSBvcHRzLmltcGxlbWVudEZ1bGxCSVA0NCB8fCBmYWxzZVxuXG4gICAgLy8gUmVtb3ZlIGFjY291bnRzIHRoYXQgZG9uJ3QgaGF2ZSBjb3JyZXNwb25kaW5nIGFjY291bnQgZGV0YWlsc1xuICAgIHRoaXMuYWNjb3VudHMgPSB0aGlzLmFjY291bnRzXG4gICAgICAuZmlsdGVyKChhY2NvdW50KSA9PiBPYmplY3Qua2V5cyh0aGlzLmFjY291bnREZXRhaWxzKS5pbmNsdWRlcyhldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFjY291bnQpKSlcblxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICB9XG5cbiAgX21pZ3JhdGVBY2NvdW50RGV0YWlscyAob3B0cykge1xuICAgIGlmICh0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSAmJiBvcHRzLmFjY291bnRJbmRleGVzKSB7XG4gICAgICBmb3IgKGNvbnN0IGFjY291bnQgb2YgT2JqZWN0LmtleXMob3B0cy5hY2NvdW50SW5kZXhlcykpIHtcbiAgICAgICAgdGhpcy5hY2NvdW50RGV0YWlsc1thY2NvdW50XSA9IHtcbiAgICAgICAgICBiaXA0NDogdHJ1ZSxcbiAgICAgICAgICBoZFBhdGg6IHRoaXMuX2dldFBhdGhGb3JJbmRleChvcHRzLmFjY291bnRJbmRleGVzW2FjY291bnRdKSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHRyeSB0byBtaWdyYXRlIG5vbi1MZWRnZXJMaXZlIGFjY291bnRzIHRvb1xuICAgIGlmICghdGhpcy5faXNMZWRnZXJMaXZlSGRQYXRoKCkpIHtcbiAgICAgIHRoaXMuYWNjb3VudHNcbiAgICAgICAgLmZpbHRlcigoYWNjb3VudCkgPT4gIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCkpKVxuICAgICAgICAuZm9yRWFjaCgoYWNjb3VudCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWNjb3VudCldID0ge1xuICAgICAgICAgICAgICBiaXA0NDogZmFsc2UsXG4gICAgICAgICAgICAgIGhkUGF0aDogdGhpcy5fcGF0aEZyb21BZGRyZXNzKGFjY291bnQpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBmYWlsZWQgdG8gbWlncmF0ZSBhY2NvdW50ICR7YWNjb3VudH1gKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG4gIH1cblxuICBpc1VubG9ja2VkICgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmhkayAmJiB0aGlzLmhkay5wdWJsaWNLZXkpXG4gIH1cblxuICBpc0Nvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEZXZpY2VDb25uZWN0ZWRcbiAgfVxuXG4gIHNldEFjY291bnRUb1VubG9jayAoaW5kZXgpIHtcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IHBhcnNlSW50KGluZGV4LCAxMClcbiAgfVxuXG4gIHNldEhkUGF0aCAoaGRQYXRoKSB7XG4gICAgLy8gUmVzZXQgSERLZXkgaWYgdGhlIHBhdGggY2hhbmdlc1xuICAgIGlmICh0aGlzLmhkUGF0aCAhPT0gaGRQYXRoKSB7XG4gICAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gICAgfVxuICAgIHRoaXMuaGRQYXRoID0gaGRQYXRoXG4gIH1cblxuICB1bmxvY2sgKGhkUGF0aCwgdXBkYXRlSGRrID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmlzVW5sb2NrZWQoKSAmJiAhaGRQYXRoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCdhbHJlYWR5IHVubG9ja2VkJylcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IGhkUGF0aCA/IHRoaXMuX3RvTGVkZ2VyUGF0aChoZFBhdGgpIDogdGhpcy5oZFBhdGhcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdW5sb2NrJyxcbiAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIGlmICh1cGRhdGVIZGspIHtcbiAgICAgICAgICAgIHRoaXMuaGRrLnB1YmxpY0tleSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucHVibGljS2V5LCAnaGV4JylcbiAgICAgICAgICAgIHRoaXMuaGRrLmNoYWluQ29kZSA9IEJ1ZmZlci5mcm9tKHBheWxvYWQuY2hhaW5Db2RlLCAnaGV4JylcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzb2x2ZShwYXlsb2FkLmFkZHJlc3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdVbmtub3duIGVycm9yJykpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIGFkZEFjY291bnRzIChuID0gMSkge1xuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrKClcbiAgICAgICAgLnRoZW4oYXN5bmMgKF8pID0+IHtcbiAgICAgICAgICBjb25zdCBmcm9tID0gdGhpcy51bmxvY2tlZEFjY291bnRcbiAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyBuXG4gICAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICAgICAgICBsZXQgYWRkcmVzc1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICAgICAgICAgIGFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhwYXRoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldID0ge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBjb25zaWRlciByZW5hbWluZyB0aGlzIHByb3BlcnR5LCBhcyB0aGUgY3VycmVudCBuYW1lIGlzIG1pc2xlYWRpbmdcbiAgICAgICAgICAgICAgLy8gSXQncyBjdXJyZW50bHkgdXNlZCB0byByZXByZXNlbnQgd2hldGhlciBhbiBhY2NvdW50IHVzZXMgdGhlIExlZGdlciBMaXZlIHBhdGguXG4gICAgICAgICAgICAgIGJpcDQ0OiB0aGlzLl9pc0xlZGdlckxpdmVIZFBhdGgoKSxcbiAgICAgICAgICAgICAgaGRQYXRoOiBwYXRoLFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWNjb3VudHMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5hY2NvdW50cy5wdXNoKGFkZHJlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZ2UgPSAwXG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc29sdmUodGhpcy5hY2NvdW50cylcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgZ2V0Rmlyc3RQYWdlICgpIHtcbiAgICB0aGlzLnBhZ2UgPSAwXG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXROZXh0UGFnZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nZXRQYWdlKDEpXG4gIH1cblxuICBnZXRQcmV2aW91c1BhZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9fZ2V0UGFnZSgtMSlcbiAgfVxuXG4gIGdldEFjY291bnRzICgpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWNjb3VudHMuc2xpY2UoKSlcbiAgfVxuXG4gIHJlbW92ZUFjY291bnQgKGFkZHJlc3MpIHtcbiAgICBpZiAoIXRoaXMuYWNjb3VudHMubWFwKChhKSA9PiBhLnRvTG93ZXJDYXNlKCkpLmluY2x1ZGVzKGFkZHJlc3MudG9Mb3dlckNhc2UoKSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQWRkcmVzcyAke2FkZHJlc3N9IG5vdCBmb3VuZCBpbiB0aGlzIGtleXJpbmdgKVxuICAgIH1cbiAgICB0aGlzLmFjY291bnRzID0gdGhpcy5hY2NvdW50cy5maWx0ZXIoKGEpID0+IGEudG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKVxuICAgIGRlbGV0ZSB0aGlzLmFjY291bnREZXRhaWxzW2V0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcyldXG4gIH1cblxuICBhdHRlbXB0TWFrZUFwcCAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLW1ha2UtYXBwJyxcbiAgICAgIH0sICh7IHN1Y2Nlc3MsIGVycm9yIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICB1cGRhdGVUcmFuc3BvcnRNZXRob2QgKHRyYW5zcG9ydFR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgLy8gSWYgdGhlIGlmcmFtZSBpc24ndCBsb2FkZWQgeWV0LCBsZXQncyBzdG9yZSB0aGUgZGVzaXJlZCB0cmFuc3BvcnRUeXBlIHZhbHVlIGFuZFxuICAgICAgLy8gb3B0aW1pc3RpY2FsbHkgcmV0dXJuIGEgc3VjY2Vzc2Z1bCBwcm9taXNlXG4gICAgICBpZiAoIXRoaXMuaWZyYW1lTG9hZGVkKSB7XG4gICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UgPSB7XG4gICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICByZWplY3QsXG4gICAgICAgICAgdHJhbnNwb3J0VHlwZSxcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICBhY3Rpb246ICdsZWRnZXItdXBkYXRlLXRyYW5zcG9ydCcsXG4gICAgICAgIHBhcmFtczogeyB0cmFuc3BvcnRUeXBlIH0sXG4gICAgICB9LCAoeyBzdWNjZXNzIH0pID0+IHtcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXNvbHZlKHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyIHRyYW5zcG9ydCBjb3VsZCBub3QgYmUgdXBkYXRlZCcpKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyB0eCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgZXRoZXJldW1qcy10cmFuc2FjdGlvbiBjbGFzcy5cbiAgc2lnblRyYW5zYWN0aW9uIChhZGRyZXNzLCB0eCkge1xuICAgIGxldCByYXdUeEhleFxuICAgIC8vIHRyYW5zYWN0aW9ucyBidWlsdCB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIGV0aGVyZXVtanMtdHggaGF2ZSBhXG4gICAgLy8gZ2V0Q2hhaW5JZCBtZXRob2QgdGhhdCBuZXdlciB2ZXJzaW9ucyBkbyBub3QuIE9sZGVyIHZlcnNpb25zIGFyZSBtdXRhYmxlXG4gICAgLy8gd2hpbGUgbmV3ZXIgdmVyc2lvbnMgZGVmYXVsdCB0byBiZWluZyBpbW11dGFibGUuIEV4cGVjdGVkIHNoYXBlIGFuZCB0eXBlXG4gICAgLy8gb2YgZGF0YSBmb3IgdiwgciBhbmQgcyBkaWZmZXIgKEJ1ZmZlciAob2xkKSB2cyBCTiAobmV3KSlcbiAgICBpZiAodHlwZW9mIHR4LmdldENoYWluSWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEluIHRoaXMgdmVyc2lvbiBvZiBldGhlcmV1bWpzLXR4IHdlIG11c3QgYWRkIHRoZSBjaGFpbklkIGluIGhleCBmb3JtYXRcbiAgICAgIC8vIHRvIHRoZSBpbml0aWFsIHYgdmFsdWUuIFRoZSBjaGFpbklkIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIHNlcmlhbGl6ZWRcbiAgICAgIC8vIHRyYW5zYWN0aW9uIHdoaWNoIGlzIG9ubHkgY29tbXVuaWNhdGVkIHRvIGV0aGVyZXVtanMtdHggaW4gdGhpc1xuICAgICAgLy8gdmFsdWUuIEluIG5ld2VyIHZlcnNpb25zIHRoZSBjaGFpbklkIGlzIGNvbW11bmljYXRlZCB2aWEgdGhlICdDb21tb24nXG4gICAgICAvLyBvYmplY3QuXG4gICAgICB0eC52ID0gZXRoVXRpbC5idWZmZXJUb0hleCh0eC5nZXRDaGFpbklkKCkpXG4gICAgICB0eC5yID0gJzB4MDAnXG4gICAgICB0eC5zID0gJzB4MDAnXG5cbiAgICAgIHJhd1R4SGV4ID0gdHguc2VyaWFsaXplKCkudG9TdHJpbmcoJ2hleCcpXG5cbiAgICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHR4LnYgPSBCdWZmZXIuZnJvbShwYXlsb2FkLnYsICdoZXgnKVxuICAgICAgICB0eC5yID0gQnVmZmVyLmZyb20ocGF5bG9hZC5yLCAnaGV4JylcbiAgICAgICAgdHgucyA9IEJ1ZmZlci5mcm9tKHBheWxvYWQucywgJ2hleCcpXG4gICAgICAgIHJldHVybiB0eFxuICAgICAgfSlcbiAgICB9XG5cbiAgICAvLyBUaGUgYmVsb3cgYGVuY29kZWAgY2FsbCBpcyBvbmx5IG5lY2Vzc2FyeSBmb3IgbGVnYWN5IHRyYW5zYWN0aW9ucywgYXMgYGdldE1lc3NhZ2VUb1NpZ25gXG4gICAgLy8gY2FsbHMgYHJscC5lbmNvZGVgIGludGVybmFsbHkgZm9yIG5vbi1sZWdhY3kgdHJhbnNhY3Rpb25zLiBBcyBwZXIgdGhlIFwiVHJhbnNhY3Rpb24gRXhlY3V0aW9uXCJcbiAgICAvLyBzZWN0aW9uIG9mIHRoZSBldGhlcmV1bSB5ZWxsb3cgcGFwZXIsIHRyYW5zYWN0aW9ucyBuZWVkIHRvIGJlIFwid2VsbC1mb3JtZWQgUkxQLCB3aXRoIG5vIGFkZGl0aW9uYWxcbiAgICAvLyB0cmFpbGluZyBieXRlc1wiLlxuXG4gICAgLy8gTm90ZSBhbHNvIHRoYXQgYGdldE1lc3NhZ2VUb1NpZ25gIHdpbGwgcmV0dXJuIHZhbGlkIFJMUCBmb3IgYWxsIHRyYW5zYWN0aW9uIHR5cGVzLCB3aGVyZWFzIHRoZVxuICAgIC8vIGBzZXJpYWxpemVgIG1ldGhvZCB3aWxsIG5vdCBmb3IgYW55IHRyYW5zYWN0aW9uIHR5cGUgZXhjZXB0IGxlZ2FjeS4gVGhpcyBpcyBiZWNhdXNlIGBzZXJpYWxpemVgIGluY2x1ZGVzXG4gICAgLy8gZW1wdHkgciwgcyBhbmQgdiB2YWx1ZXMgaW4gdGhlIGVuY29kZWQgcmxwLiBUaGlzIGlzIHdoeSB3ZSB1c2UgYGdldE1lc3NhZ2VUb1NpZ25gIGhlcmUgaW5zdGVhZCBvZiBgc2VyaWFsaXplYC5cbiAgICBjb25zdCBtZXNzYWdlVG9TaWduID0gdHguZ2V0TWVzc2FnZVRvU2lnbihmYWxzZSlcblxuICAgIHJhd1R4SGV4ID0gQnVmZmVyLmlzQnVmZmVyKG1lc3NhZ2VUb1NpZ24pXG4gICAgICA/IG1lc3NhZ2VUb1NpZ24udG9TdHJpbmcoJ2hleCcpXG4gICAgICA6IGV0aFV0aWwucmxwLmVuY29kZShtZXNzYWdlVG9TaWduKS50b1N0cmluZygnaGV4JylcblxuICAgIHJldHVybiB0aGlzLl9zaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgcmF3VHhIZXgsIChwYXlsb2FkKSA9PiB7XG4gICAgICAvLyBCZWNhdXNlIHR4IHdpbGwgYmUgaW1tdXRhYmxlLCBmaXJzdCBnZXQgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB0aGF0XG4gICAgICAvLyByZXByZXNlbnRzIHRoZSB0cmFuc2FjdGlvbi4gVXNpbmcgdHhEYXRhIGhlcmUgYXMgaXQgYWxpZ25zIHdpdGggdGhlXG4gICAgICAvLyBub21lbmNsYXR1cmUgb2YgZXRoZXJldW1qcy90eC5cbiAgICAgIGNvbnN0IHR4RGF0YSA9IHR4LnRvSlNPTigpXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgYSB0eXBlIHRvIHN1cHBvcnQgdHJhbnNhY3Rpb25zIHdpdGggYSB0eXBlIG90aGVyIHRoYW4gMFxuICAgICAgdHhEYXRhLnR5cGUgPSB0eC50eXBlXG4gICAgICAvLyBUaGUgZnJvbVR4RGF0YSB1dGlsaXR5IGV4cGVjdHMgdixyIGFuZCBzIHRvIGJlIGhleCBwcmVmaXhlZFxuICAgICAgdHhEYXRhLnYgPSBldGhVdGlsLmFkZEhleFByZWZpeChwYXlsb2FkLnYpXG4gICAgICB0eERhdGEuciA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHBheWxvYWQucilcbiAgICAgIHR4RGF0YS5zID0gZXRoVXRpbC5hZGRIZXhQcmVmaXgocGF5bG9hZC5zKVxuICAgICAgLy8gQWRvcHQgdGhlICdjb21tb24nIG9wdGlvbiBmcm9tIHRoZSBvcmlnaW5hbCB0cmFuc2FjdGlvbiBhbmQgc2V0IHRoZVxuICAgICAgLy8gcmV0dXJuZWQgb2JqZWN0IHRvIGJlIGZyb3plbiBpZiB0aGUgb3JpZ2luYWwgaXMgZnJvemVuLlxuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4RGF0YSwgeyBjb21tb246IHR4LmNvbW1vbiwgZnJlZXplOiBPYmplY3QuaXNGcm96ZW4odHgpIH0pXG4gICAgfSlcbiAgfVxuXG4gIF9zaWduVHJhbnNhY3Rpb24gKGFkZHJlc3MsIHJhd1R4SGV4LCBoYW5kbGVTaWduaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyhhZGRyZXNzKVxuICAgICAgICAudGhlbigoaGRQYXRoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgICAgICAgYWN0aW9uOiAnbGVkZ2VyLXNpZ24tdHJhbnNhY3Rpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIHR4OiByYXdUeEhleCxcbiAgICAgICAgICAgICAgaGRQYXRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgICh7IHN1Y2Nlc3MsIHBheWxvYWQgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcblxuICAgICAgICAgICAgICBjb25zdCBuZXdPck11dGF0ZWRUeCA9IGhhbmRsZVNpZ25pbmcocGF5bG9hZClcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBuZXdPck11dGF0ZWRUeC52ZXJpZnlTaWduYXR1cmUoKVxuICAgICAgICAgICAgICBpZiAodmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKG5ld09yTXV0YXRlZFR4KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0xlZGdlcjogVGhlIHRyYW5zYWN0aW9uIHNpZ25hdHVyZSBpcyBub3QgdmFsaWQnKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyB0cmFuc2FjdGlvbicpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChyZWplY3QpXG4gICAgfSlcbiAgfVxuXG4gIHNpZ25NZXNzYWdlICh3aXRoQWNjb3VudCwgZGF0YSkge1xuICAgIHJldHVybiB0aGlzLnNpZ25QZXJzb25hbE1lc3NhZ2Uod2l0aEFjY291bnQsIGRhdGEpXG4gIH1cblxuICAvLyBGb3IgcGVyc29uYWxfc2lnbiwgd2UgbmVlZCB0byBwcmVmaXggdGhlIG1lc3NhZ2U6XG4gIHNpZ25QZXJzb25hbE1lc3NhZ2UgKHdpdGhBY2NvdW50LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICAgICAgLnRoZW4oKGhkUGF0aCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3NlbmRNZXNzYWdlKHtcbiAgICAgICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXBlcnNvbmFsLW1lc3NhZ2UnLFxuICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgIGhkUGF0aCxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXRoVXRpbC5zdHJpcEhleFByZWZpeChtZXNzYWdlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICAoeyBzdWNjZXNzLCBwYXlsb2FkIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGxldCB2ID0gcGF5bG9hZC52IC0gMjdcbiAgICAgICAgICAgICAgdiA9IHYudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICAgIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IGAweCR7cGF5bG9hZC5yfSR7cGF5bG9hZC5zfSR7dn1gXG4gICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUoeyBkYXRhOiBtZXNzYWdlLCBzaWc6IHNpZ25hdHVyZSB9KVxuICAgICAgICAgICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoc2lnbmF0dXJlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVqZWN0KHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgdW5sb2NrQWNjb3VudEJ5QWRkcmVzcyAoYWRkcmVzcykge1xuICAgIGNvbnN0IGNoZWNrc3VtbWVkQWRkcmVzcyA9IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3MoYWRkcmVzcylcbiAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMuYWNjb3VudERldGFpbHMpLmluY2x1ZGVzKGNoZWNrc3VtbWVkQWRkcmVzcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTGVkZ2VyOiBBY2NvdW50IGZvciBhZGRyZXNzICcke2NoZWNrc3VtbWVkQWRkcmVzc30nIG5vdCBmb3VuZGApXG4gICAgfVxuICAgIGNvbnN0IHsgaGRQYXRoIH0gPSB0aGlzLmFjY291bnREZXRhaWxzW2NoZWNrc3VtbWVkQWRkcmVzc11cbiAgICBjb25zdCB1bmxvY2tlZEFkZHJlc3MgPSBhd2FpdCB0aGlzLnVubG9jayhoZFBhdGgsIGZhbHNlKVxuXG4gICAgLy8gdW5sb2NrIHJlc29sdmVzIHRvIHRoZSBhZGRyZXNzIGZvciB0aGUgZ2l2ZW4gaGRQYXRoIGFzIHJlcG9ydGVkIGJ5IHRoZSBsZWRnZXIgZGV2aWNlXG4gICAgLy8gaWYgdGhhdCBhZGRyZXNzIGlzIG5vdCB0aGUgcmVxdWVzdGVkIGFkZHJlc3MsIHRoZW4gdGhpcyBhY2NvdW50IGJlbG9uZ3MgdG8gYSBkaWZmZXJlbnQgZGV2aWNlIG9yIHNlZWRcbiAgICBpZiAodW5sb2NrZWRBZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMZWRnZXI6IEFjY291bnQgJHthZGRyZXNzfSBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIGNvbm5lY3RlZCBkZXZpY2VgKVxuICAgIH1cbiAgICByZXR1cm4gaGRQYXRoXG4gIH1cblxuICBhc3luYyBzaWduVHlwZWREYXRhICh3aXRoQWNjb3VudCwgZGF0YSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgaXNWNCA9IG9wdGlvbnMudmVyc2lvbiA9PT0gJ1Y0J1xuICAgIGlmICghaXNWNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMZWRnZXI6IE9ubHkgdmVyc2lvbiA0IG9mIHR5cGVkIGRhdGEgc2lnbmluZyBpcyBzdXBwb3J0ZWQnKVxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGRvbWFpbixcbiAgICAgIHR5cGVzLFxuICAgICAgcHJpbWFyeVR5cGUsXG4gICAgICBtZXNzYWdlLFxuICAgIH0gPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLnNhbml0aXplRGF0YShkYXRhKVxuICAgIGNvbnN0IGRvbWFpblNlcGFyYXRvckhleCA9IHNpZ1V0aWwuVHlwZWREYXRhVXRpbHMuaGFzaFN0cnVjdCgnRUlQNzEyRG9tYWluJywgZG9tYWluLCB0eXBlcywgaXNWNCkudG9TdHJpbmcoJ2hleCcpXG4gICAgY29uc3QgaGFzaFN0cnVjdE1lc3NhZ2VIZXggPSBzaWdVdGlsLlR5cGVkRGF0YVV0aWxzLmhhc2hTdHJ1Y3QocHJpbWFyeVR5cGUsIG1lc3NhZ2UsIHR5cGVzLCBpc1Y0KS50b1N0cmluZygnaGV4JylcblxuICAgIGNvbnN0IGhkUGF0aCA9IGF3YWl0IHRoaXMudW5sb2NrQWNjb3VudEJ5QWRkcmVzcyh3aXRoQWNjb3VudClcbiAgICBjb25zdCB7IHN1Y2Nlc3MsIHBheWxvYWQgfSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICAgIGFjdGlvbjogJ2xlZGdlci1zaWduLXR5cGVkLWRhdGEnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICBoZFBhdGgsXG4gICAgICAgICAgZG9tYWluU2VwYXJhdG9ySGV4LFxuICAgICAgICAgIGhhc2hTdHJ1Y3RNZXNzYWdlSGV4LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIChyZXN1bHQpID0+IHJlc29sdmUocmVzdWx0KSlcbiAgICB9KVxuXG4gICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgIGxldCB2ID0gcGF5bG9hZC52IC0gMjdcbiAgICAgIHYgPSB2LnRvU3RyaW5nKDE2KVxuICAgICAgaWYgKHYubGVuZ3RoIDwgMikge1xuICAgICAgICB2ID0gYDAke3Z9YFxuICAgICAgfVxuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gYDB4JHtwYXlsb2FkLnJ9JHtwYXlsb2FkLnN9JHt2fWBcbiAgICAgIGNvbnN0IGFkZHJlc3NTaWduZWRXaXRoID0gc2lnVXRpbC5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQoe1xuICAgICAgICBkYXRhLFxuICAgICAgICBzaWc6IHNpZ25hdHVyZSxcbiAgICAgIH0pXG4gICAgICBpZiAoZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzU2lnbmVkV2l0aCkgIT09IGV0aFV0aWwudG9DaGVja3N1bUFkZHJlc3Mod2l0aEFjY291bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGVkZ2VyOiBUaGUgc2lnbmF0dXJlIGRvZXNudCBtYXRjaCB0aGUgcmlnaHQgYWRkcmVzcycpXG4gICAgICB9XG4gICAgICByZXR1cm4gc2lnbmF0dXJlXG4gICAgfVxuICAgIHRocm93IHBheWxvYWQuZXJyb3IgfHwgbmV3IEVycm9yKCdMZWRnZXI6IFVua25vd24gZXJyb3Igd2hpbGUgc2lnbmluZyBtZXNzYWdlJylcbiAgfVxuXG4gIGV4cG9ydEFjY291bnQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnRlZCBvbiB0aGlzIGRldmljZScpXG4gIH1cblxuICBmb3JnZXREZXZpY2UgKCkge1xuICAgIHRoaXMuYWNjb3VudHMgPSBbXVxuICAgIHRoaXMucGFnZSA9IDBcbiAgICB0aGlzLnVubG9ja2VkQWNjb3VudCA9IDBcbiAgICB0aGlzLnBhdGhzID0ge31cbiAgICB0aGlzLmFjY291bnREZXRhaWxzID0ge31cbiAgICB0aGlzLmhkayA9IG5ldyBIREtleSgpXG4gIH1cblxuICAvKiBQUklWQVRFIE1FVEhPRFMgKi9cblxuICBfc2V0dXBJZnJhbWUgKCkge1xuICAgIHRoaXMuaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICB0aGlzLmlmcmFtZS5zcmMgPSB0aGlzLmJyaWRnZVVybFxuICAgIHRoaXMuaWZyYW1lLmFsbG93ID0gYGhpZCAnc3JjJ2BcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAvLyBJZiB0aGUgbGVkZ2VyIGxpdmUgcHJlZmVyZW5jZSB3YXMgc2V0IGJlZm9yZSB0aGUgaWZyYW1lIGlzIGxvYWRlZCxcbiAgICAgIC8vIHNldCBpdCBhZnRlciB0aGUgaWZyYW1lIGhhcyBsb2FkZWRcbiAgICAgIHRoaXMuaWZyYW1lTG9hZGVkID0gdHJ1ZVxuICAgICAgaWYgKHRoaXMuZGVsYXllZFByb21pc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnVwZGF0ZVRyYW5zcG9ydE1ldGhvZChcbiAgICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UudHJhbnNwb3J0VHlwZSxcbiAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5kZWxheWVkUHJvbWlzZS5yZXNvbHZlKHJlc3VsdClcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMuZGVsYXllZFByb21pc2UucmVqZWN0KGUpXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuZGVsYXllZFByb21pc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuaWZyYW1lKVxuICB9XG5cbiAgX2dldE9yaWdpbiAoKSB7XG4gICAgY29uc3QgdG1wID0gdGhpcy5icmlkZ2VVcmwuc3BsaXQoJy8nKVxuICAgIHRtcC5zcGxpY2UoLTEsIDEpXG4gICAgcmV0dXJuIHRtcC5qb2luKCcvJylcbiAgfVxuXG4gIF9zZW5kTWVzc2FnZSAobXNnLCBjYikge1xuICAgIG1zZy50YXJnZXQgPSAnTEVER0VSLUlGUkFNRSdcblxuICAgIHRoaXMuY3VycmVudE1lc3NhZ2VJZCArPSAxXG4gICAgbXNnLm1lc3NhZ2VJZCA9IHRoaXMuY3VycmVudE1lc3NhZ2VJZFxuXG4gICAgdGhpcy5tZXNzYWdlQ2FsbGJhY2tzW3RoaXMuY3VycmVudE1lc3NhZ2VJZF0gPSBjYlxuICAgIHRoaXMuaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCAnKicpXG4gIH1cblxuICBfc2V0dXBMaXN0ZW5lciAoKSB7XG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lciA9ICh7IG9yaWdpbiwgZGF0YSB9KSA9PiB7XG4gICAgICBpZiAob3JpZ2luICE9PSB0aGlzLl9nZXRPcmlnaW4oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZUNhbGxiYWNrc1tkYXRhLm1lc3NhZ2VJZF0pIHtcbiAgICAgICAgICB0aGlzLm1lc3NhZ2VDYWxsYmFja3NbZGF0YS5tZXNzYWdlSWRdKGRhdGEpXG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gPT09IENPTk5FQ1RJT05fRVZFTlQpIHtcbiAgICAgICAgICB0aGlzLmlzRGV2aWNlQ29ubmVjdGVkID0gZGF0YS5wYXlsb2FkLmNvbm5lY3RlZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ldmVudExpc3RlbmVyKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9ldmVudExpc3RlbmVyKVxuICB9XG5cbiAgYXN5bmMgX19nZXRQYWdlIChpbmNyZW1lbnQpIHtcblxuICAgIHRoaXMucGFnZSArPSBpbmNyZW1lbnRcblxuICAgIGlmICh0aGlzLnBhZ2UgPD0gMCkge1xuICAgICAgdGhpcy5wYWdlID0gMVxuICAgIH1cbiAgICBjb25zdCBmcm9tID0gKHRoaXMucGFnZSAtIDEpICogdGhpcy5wZXJQYWdlXG4gICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5wZXJQYWdlXG5cbiAgICBhd2FpdCB0aGlzLnVubG9jaygpXG4gICAgbGV0IGFjY291bnRzXG4gICAgaWYgKHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpKSB7XG4gICAgICBhY2NvdW50cyA9IGF3YWl0IHRoaXMuX2dldEFjY291bnRzQklQNDQoZnJvbSwgdG8pXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY291bnRzID0gdGhpcy5fZ2V0QWNjb3VudHNMZWdhY3koZnJvbSwgdG8pXG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgYXN5bmMgX2dldEFjY291bnRzQklQNDQgKGZyb20sIHRvKSB7XG4gICAgY29uc3QgYWNjb3VudHMgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG4gICAgICBjb25zdCBwYXRoID0gdGhpcy5fZ2V0UGF0aEZvckluZGV4KGkpXG4gICAgICBjb25zdCBhZGRyZXNzID0gYXdhaXQgdGhpcy51bmxvY2socGF0aClcbiAgICAgIGNvbnN0IHZhbGlkID0gdGhpcy5pbXBsZW1lbnRGdWxsQklQNDQgPyBhd2FpdCB0aGlzLl9oYXNQcmV2aW91c1RyYW5zYWN0aW9ucyhhZGRyZXNzKSA6IHRydWVcbiAgICAgIGFjY291bnRzLnB1c2goe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBiYWxhbmNlOiBudWxsLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgIH0pXG4gICAgICAvLyBQRVIgQklQNDRcbiAgICAgIC8vIFwiU29mdHdhcmUgc2hvdWxkIHByZXZlbnQgYSBjcmVhdGlvbiBvZiBhbiBhY2NvdW50IGlmXG4gICAgICAvLyBhIHByZXZpb3VzIGFjY291bnQgZG9lcyBub3QgaGF2ZSBhIHRyYW5zYWN0aW9uIGhpc3RvcnlcbiAgICAgIC8vIChtZWFuaW5nIG5vbmUgb2YgaXRzIGFkZHJlc3NlcyBoYXZlIGJlZW4gdXNlZCBiZWZvcmUpLlwiXG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhY2NvdW50c1xuICB9XG5cbiAgX2dldEFjY291bnRzTGVnYWN5IChmcm9tLCB0bykge1xuICAgIGNvbnN0IGFjY291bnRzID0gW11cblxuICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3NGcm9tSW5kZXgocGF0aEJhc2UsIGkpXG4gICAgICBhY2NvdW50cy5wdXNoKHtcbiAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgYmFsYW5jZTogbnVsbCxcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICB9KVxuICAgICAgdGhpcy5wYXRoc1tldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXSA9IGlcbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRzXG4gIH1cblxuICBfcGFkTGVmdEV2ZW4gKGhleCkge1xuICAgIHJldHVybiBoZXgubGVuZ3RoICUgMiA9PT0gMCA/IGhleCA6IGAwJHtoZXh9YFxuICB9XG5cbiAgX25vcm1hbGl6ZSAoYnVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZExlZnRFdmVuKGV0aFV0aWwuYnVmZmVyVG9IZXgoYnVmKS50b0xvd2VyQ2FzZSgpKVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuICBfYWRkcmVzc0Zyb21JbmRleCAocGF0aEJhc2UsIGkpIHtcbiAgICBjb25zdCBka2V5ID0gdGhpcy5oZGsuZGVyaXZlKGAke3BhdGhCYXNlfS8ke2l9YClcbiAgICBjb25zdCBhZGRyZXNzID0gZXRoVXRpbFxuICAgICAgLnB1YmxpY1RvQWRkcmVzcyhka2V5LnB1YmxpY0tleSwgdHJ1ZSlcbiAgICAgIC50b1N0cmluZygnaGV4JylcbiAgICByZXR1cm4gZXRoVXRpbC50b0NoZWNrc3VtQWRkcmVzcyhgMHgke2FkZHJlc3N9YClcbiAgfVxuXG4gIF9wYXRoRnJvbUFkZHJlc3MgKGFkZHJlc3MpIHtcbiAgICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSBldGhVdGlsLnRvQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpXG4gICAgbGV0IGluZGV4ID0gdGhpcy5wYXRoc1tjaGVja3N1bW1lZEFkZHJlc3NdXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTUFYX0lOREVYOyBpKyspIHtcbiAgICAgICAgaWYgKGNoZWNrc3VtbWVkQWRkcmVzcyA9PT0gdGhpcy5fYWRkcmVzc0Zyb21JbmRleChwYXRoQmFzZSwgaSkpIHtcbiAgICAgICAgICBpbmRleCA9IGlcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbmRleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBhZGRyZXNzJylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2dldFBhdGhGb3JJbmRleChpbmRleClcbiAgfVxuXG4gIF90b0FzY2lpIChoZXgpIHtcbiAgICBsZXQgc3RyID0gJydcbiAgICBsZXQgaSA9IDBcbiAgICBjb25zdCBsID0gaGV4Lmxlbmd0aFxuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICBpID0gMlxuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KVxuICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSlcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyXG4gIH1cblxuICBfZ2V0UGF0aEZvckluZGV4IChpbmRleCkge1xuICAgIC8vIENoZWNrIGlmIHRoZSBwYXRoIGlzIEJJUCA0NCAoTGVkZ2VyIExpdmUpXG4gICAgcmV0dXJuIHRoaXMuX2lzTGVkZ2VyTGl2ZUhkUGF0aCgpID8gYG0vNDQnLzYwJy8ke2luZGV4fScvMC8wYCA6IGAke3RoaXMuaGRQYXRofS8ke2luZGV4fWBcbiAgfVxuXG4gIF9pc0xlZGdlckxpdmVIZFBhdGggKCkge1xuICAgIHJldHVybiB0aGlzLmhkUGF0aCA9PT0gYG0vNDQnLzYwJy8wJy8wLzBgXG4gIH1cblxuICBfdG9MZWRnZXJQYXRoIChwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5yZXBsYWNlKCdtLycsICcnKVxuICB9XG5cbiAgYXN5bmMgX2hhc1ByZXZpb3VzVHJhbnNhY3Rpb25zIChhZGRyZXNzKSB7XG4gICAgY29uc3QgYXBpVXJsID0gdGhpcy5fZ2V0QXBpVXJsKClcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdpbmRvdy5mZXRjaChgJHthcGlVcmx9L2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9JHthZGRyZXNzfSZ0YWc9bGF0ZXN0JnBhZ2U9MSZvZmZzZXQ9MWApXG4gICAgY29uc3QgcGFyc2VkUmVzcG9uc2UgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBpZiAocGFyc2VkUmVzcG9uc2Uuc3RhdHVzICE9PSAnMCcgJiYgcGFyc2VkUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgX2dldEFwaVVybCAoKSB7XG4gICAgcmV0dXJuIE5FVFdPUktfQVBJX1VSTFNbdGhpcy5uZXR3b3JrXSB8fCBORVRXT1JLX0FQSV9VUkxTLm1haW5uZXRcbiAgfVxuXG59XG5cbkxlZGdlckJyaWRnZUtleXJpbmcudHlwZSA9IHR5cGVcbm1vZHVsZS5leHBvcnRzID0gTGVkZ2VyQnJpZGdlS2V5cmluZ1xuIiwiY29uc3QgeyBCdWZmZXIgfSA9IHJlcXVpcmUoJ2J1ZmZlcicpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IGV0aEFiaSA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtYWJpJylcbmNvbnN0IG5hY2wgPSByZXF1aXJlKCd0d2VldG5hY2wnKVxubmFjbC51dGlsID0gcmVxdWlyZSgndHdlZXRuYWNsLXV0aWwnKVxuXG5jb25zdCBUWVBFRF9NRVNTQUdFX1NDSEVNQSA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlczoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIG5hbWU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICAgIHR5cGU6IHsgdHlwZTogJ3N0cmluZycgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHByaW1hcnlUeXBlOiB7IHR5cGU6ICdzdHJpbmcnIH0sXG4gICAgZG9tYWluOiB7IHR5cGU6ICdvYmplY3QnIH0sXG4gICAgbWVzc2FnZTogeyB0eXBlOiAnb2JqZWN0JyB9LFxuICB9LFxuICByZXF1aXJlZDogWyd0eXBlcycsICdwcmltYXJ5VHlwZScsICdkb21haW4nLCAnbWVzc2FnZSddLFxufVxuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBzaWduaW5nIHR5cGVkIGRhdGFcbiAqL1xuY29uc3QgVHlwZWREYXRhVXRpbHMgPSB7XG5cbiAgLyoqXG4gICAqIEVuY29kZXMgYW4gb2JqZWN0IGJ5IGVuY29kaW5nIGFuZCBjb25jYXRlbmF0aW5nIGVhY2ggb2YgaXRzIG1lbWJlcnNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gT2JqZWN0IHRvIGVuY29kZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZXMgLSBUeXBlIGRlZmluaXRpb25zXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gRW5jb2RlZCByZXByZXNlbnRhdGlvbiBvZiBhbiBvYmplY3RcbiAgICovXG4gIGVuY29kZURhdGEgKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQgPSB0cnVlKSB7XG4gICAgY29uc3QgZW5jb2RlZFR5cGVzID0gWydieXRlczMyJ11cbiAgICBjb25zdCBlbmNvZGVkVmFsdWVzID0gW3RoaXMuaGFzaFR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKV1cblxuICAgIGlmICh1c2VWNCkge1xuICAgICAgY29uc3QgZW5jb2RlRmllbGQgPSAobmFtZSwgdHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gWydieXRlczMyJywgdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyA6XG4gICAgICAgICAgICBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEodHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG1pc3NpbmcgdmFsdWUgZm9yIGZpZWxkICR7bmFtZX0gb2YgdHlwZSAke3R5cGV9YClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnYnl0ZXMnKSB7XG4gICAgICAgICAgcmV0dXJuIFsnYnl0ZXMzMicsIGV0aFV0aWwua2VjY2FrKHZhbHVlKV1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIGNvbnZlcnQgc3RyaW5nIHRvIGJ1ZmZlciAtIHByZXZlbnRzIGV0aFV0aWwgZnJvbSBpbnRlcnByZXRpbmcgc3RyaW5ncyBsaWtlICcweGFiY2QnIGFzIGhleFxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2Nhayh2YWx1ZSldXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZS5sYXN0SW5kZXhPZignXScpID09PSB0eXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdHlwZS5zbGljZSgwLCB0eXBlLmxhc3RJbmRleE9mKCdbJykpXG4gICAgICAgICAgY29uc3QgdHlwZVZhbHVlUGFpcnMgPSB2YWx1ZS5tYXAoKGl0ZW0pID0+IGVuY29kZUZpZWxkKG5hbWUsIHBhcnNlZFR5cGUsIGl0ZW0pKVxuICAgICAgICAgIHJldHVybiBbJ2J5dGVzMzInLCBldGhVdGlsLmtlY2NhayhldGhBYmkucmF3RW5jb2RlKFxuICAgICAgICAgICAgdHlwZVZhbHVlUGFpcnMubWFwKChbX3R5cGVdKSA9PiBfdHlwZSksXG4gICAgICAgICAgICB0eXBlVmFsdWVQYWlycy5tYXAoKFssIF92YWx1ZV0pID0+IF92YWx1ZSksXG4gICAgICAgICAgKSldXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW3R5cGUsIHZhbHVlXVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gZW5jb2RlRmllbGQoZmllbGQubmFtZSwgZmllbGQudHlwZSwgZGF0YVtmaWVsZC5uYW1lXSlcbiAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2godHlwZSlcbiAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgICBsZXQgdmFsdWUgPSBkYXRhW2ZpZWxkLm5hbWVdXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLnR5cGUgPT09ICdieXRlcycpIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKCdieXRlczMyJylcbiAgICAgICAgICAgIHZhbHVlID0gZXRoVXRpbC5rZWNjYWsodmFsdWUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgLy8gY29udmVydCBzdHJpbmcgdG8gYnVmZmVyIC0gcHJldmVudHMgZXRoVXRpbCBmcm9tIGludGVycHJldGluZyBzdHJpbmdzIGxpa2UgJzB4YWJjZCcgYXMgaGV4XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCAndXRmOCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGV0aFV0aWwua2VjY2FrKHZhbHVlKVxuICAgICAgICAgICAgZW5jb2RlZFZhbHVlcy5wdXNoKHZhbHVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZXNbZmllbGQudHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW5jb2RlZFR5cGVzLnB1c2goJ2J5dGVzMzInKVxuICAgICAgICAgICAgdmFsdWUgPSBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZURhdGEoZmllbGQudHlwZSwgdmFsdWUsIHR5cGVzLCB1c2VWNCkpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC50eXBlLmxhc3RJbmRleE9mKCddJykgPT09IGZpZWxkLnR5cGUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcnJheXMgY3VycmVudGx5IHVuaW1wbGVtZW50ZWQgaW4gZW5jb2RlRGF0YScpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuY29kZWRUeXBlcy5wdXNoKGZpZWxkLnR5cGUpXG4gICAgICAgICAgICBlbmNvZGVkVmFsdWVzLnB1c2godmFsdWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aEFiaS5yYXdFbmNvZGUoZW5jb2RlZFR5cGVzLCBlbmNvZGVkVmFsdWVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbmNvZGVzIHRoZSB0eXBlIG9mIGFuIG9iamVjdCBieSBlbmNvZGluZyBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIGl0cyBtZW1iZXJzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBlbmNvZGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHR5cGVzIC0gVHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIEVuY29kZWQgcmVwcmVzZW50YXRpb24gb2YgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqL1xuICBlbmNvZGVUeXBlIChwcmltYXJ5VHlwZSwgdHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gJydcbiAgICBsZXQgZGVwcyA9IHRoaXMuZmluZFR5cGVEZXBlbmRlbmNpZXMocHJpbWFyeVR5cGUsIHR5cGVzKS5maWx0ZXIoKGRlcCkgPT4gZGVwICE9PSBwcmltYXJ5VHlwZSlcbiAgICBkZXBzID0gW3ByaW1hcnlUeXBlXS5jb25jYXQoZGVwcy5zb3J0KCkpXG4gICAgZm9yIChjb25zdCB0eXBlIG9mIGRlcHMpIHtcbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gdHlwZXNbdHlwZV1cbiAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyB0eXBlIGRlZmluaXRpb24gc3BlY2lmaWVkOiAke3R5cGV9YClcbiAgICAgIH1cbiAgICAgIHJlc3VsdCArPSBgJHt0eXBlfSgke3R5cGVzW3R5cGVdLm1hcCgoeyBuYW1lLCB0eXBlOiBfdHlwZSB9KSA9PiBgJHtfdHlwZX0gJHtuYW1lfWApLmpvaW4oJywnKX0pYFxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCB0eXBlcyB3aXRoaW4gYSB0eXBlIGRlZmludGlvbiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByaW1hcnlUeXBlIC0gUm9vdCB0eXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzdWx0cyAtIGN1cnJlbnQgc2V0IG9mIGFjY3VtdWxhdGVkIHR5cGVzXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBTZXQgb2YgYWxsIHR5cGVzIGZvdW5kIGluIHRoZSB0eXBlIGRlZmluaXRpb25cbiAgICovXG4gIGZpbmRUeXBlRGVwZW5kZW5jaWVzIChwcmltYXJ5VHlwZSwgdHlwZXMsIHJlc3VsdHMgPSBbXSkge1xuICAgIGNvbnN0IFtmaXJzdFdvcmRdID0gcHJpbWFyeVR5cGUubWF0Y2goL15cXHcqL3UpXG4gICAgcHJpbWFyeVR5cGUgPSBmaXJzdFdvcmRcbiAgICBpZiAocmVzdWx0cy5pbmNsdWRlcyhwcmltYXJ5VHlwZSkgfHwgdHlwZXNbcHJpbWFyeVR5cGVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHRzXG4gICAgfVxuICAgIHJlc3VsdHMucHVzaChwcmltYXJ5VHlwZSlcbiAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIHR5cGVzW3ByaW1hcnlUeXBlXSkge1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgdGhpcy5maW5kVHlwZURlcGVuZGVuY2llcyhmaWVsZC50eXBlLCB0eXBlcywgcmVzdWx0cykpIHtcbiAgICAgICAgIXJlc3VsdHMuaW5jbHVkZXMoZGVwKSAmJiByZXN1bHRzLnB1c2goZGVwKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0c1xuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFN0cnVjdCAocHJpbWFyeVR5cGUsIGRhdGEsIHR5cGVzLCB1c2VWNCA9IHRydWUpIHtcbiAgICByZXR1cm4gZXRoVXRpbC5rZWNjYWsodGhpcy5lbmNvZGVEYXRhKHByaW1hcnlUeXBlLCBkYXRhLCB0eXBlcywgdXNlVjQpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYXNoZXMgdGhlIHR5cGUgb2YgYW4gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmltYXJ5VHlwZSAtIFJvb3QgdHlwZSB0byBoYXNoXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlcyAtIFR5cGUgZGVmaW5pdGlvbnNcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBIYXNoIG9mIGFuIG9iamVjdFxuICAgKi9cbiAgaGFzaFR5cGUgKHByaW1hcnlUeXBlLCB0eXBlcykge1xuICAgIHJldHVybiBldGhVdGlsLmtlY2Nhayh0aGlzLmVuY29kZVR5cGUocHJpbWFyeVR5cGUsIHR5cGVzKSlcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyBwcm9wZXJ0aWVzIGZyb20gYSBtZXNzYWdlIG9iamVjdCB0aGF0IGFyZSBub3QgZGVmaW5lZCBwZXIgRUlQLTcxMlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIHR5cGVkIG1lc3NhZ2Ugb2JqZWN0XG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gdHlwZWQgbWVzc2FnZSBvYmplY3Qgd2l0aCBvbmx5IGFsbG93ZWQgZmllbGRzXG4gICAqL1xuICBzYW5pdGl6ZURhdGEgKGRhdGEpIHtcbiAgICBjb25zdCBzYW5pdGl6ZWREYXRhID0ge31cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhUWVBFRF9NRVNTQUdFX1NDSEVNQS5wcm9wZXJ0aWVzKSkge1xuICAgICAgZGF0YVtrZXldICYmIChzYW5pdGl6ZWREYXRhW2tleV0gPSBkYXRhW2tleV0pXG4gICAgfVxuICAgIGlmIChzYW5pdGl6ZWREYXRhLnR5cGVzKSB7XG4gICAgICBzYW5pdGl6ZWREYXRhLnR5cGVzID0geyBFSVA3MTJEb21haW46IFtdLCAuLi5zYW5pdGl6ZWREYXRhLnR5cGVzIH1cbiAgICB9XG4gICAgcmV0dXJuIHNhbml0aXplZERhdGFcbiAgfSxcblxuICAvKipcbiAgICogU2lnbnMgYSB0eXBlZCBtZXNzYWdlIGFzIHBlciBFSVAtNzEyIGFuZCByZXR1cm5zIGl0cyBrZWNjYWsgaGFzaFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWREYXRhIC0gVHlwZXMgbWVzc2FnZSBkYXRhIHRvIHNpZ25cbiAgICogQHJldHVybnMge3N0cmluZ30gLSBrZWNjYWsgaGFzaCBvZiB0aGUgcmVzdWx0aW5nIHNpZ25lZCBtZXNzYWdlXG4gICAqL1xuICBzaWduICh0eXBlZERhdGEsIHVzZVY0ID0gdHJ1ZSkge1xuICAgIGNvbnN0IHNhbml0aXplZERhdGEgPSB0aGlzLnNhbml0aXplRGF0YSh0eXBlZERhdGEpXG4gICAgY29uc3QgcGFydHMgPSBbQnVmZmVyLmZyb20oJzE5MDEnLCAnaGV4JyldXG4gICAgcGFydHMucHVzaCh0aGlzLmhhc2hTdHJ1Y3QoJ0VJUDcxMkRvbWFpbicsIHNhbml0aXplZERhdGEuZG9tYWluLCBzYW5pdGl6ZWREYXRhLnR5cGVzLCB1c2VWNCkpXG4gICAgaWYgKHNhbml0aXplZERhdGEucHJpbWFyeVR5cGUgIT09ICdFSVA3MTJEb21haW4nKSB7XG4gICAgICBwYXJ0cy5wdXNoKHRoaXMuaGFzaFN0cnVjdChzYW5pdGl6ZWREYXRhLnByaW1hcnlUeXBlLCBzYW5pdGl6ZWREYXRhLm1lc3NhZ2UsIHNhbml0aXplZERhdGEudHlwZXMsIHVzZVY0KSlcbiAgICB9XG4gICAgcmV0dXJuIGV0aFV0aWwua2VjY2FrKEJ1ZmZlci5jb25jYXQocGFydHMpKVxuICB9LFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVFlQRURfTUVTU0FHRV9TQ0hFTUEsXG4gIFR5cGVkRGF0YVV0aWxzLFxuXG4gIGNvbmNhdFNpZyAodiwgciwgcykge1xuICAgIGNvbnN0IHJTaWcgPSBldGhVdGlsLmZyb21TaWduZWQocilcbiAgICBjb25zdCBzU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHMpXG4gICAgY29uc3QgdlNpZyA9IGV0aFV0aWwuYnVmZmVyVG9JbnQodilcbiAgICBjb25zdCByU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoclNpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCBzU3RyID0gcGFkV2l0aFplcm9lcyhldGhVdGlsLnRvVW5zaWduZWQoc1NpZykudG9TdHJpbmcoJ2hleCcpLCA2NClcbiAgICBjb25zdCB2U3RyID0gZXRoVXRpbC5zdHJpcEhleFByZWZpeChldGhVdGlsLmludFRvSGV4KHZTaWcpKVxuICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeChyU3RyLmNvbmNhdChzU3RyLCB2U3RyKSkudG9TdHJpbmcoJ2hleCcpXG4gIH0sXG5cbiAgbm9ybWFsaXplIChpbnB1dCkge1xuICAgIGlmICghaW5wdXQpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gYCByZWNlaXZlZCAke3R5cGVvZiBpbnB1dH06ICR7aW5wdXR9YFxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG5cbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoaW5wdXQudG9Mb3dlckNhc2UoKSlcbiAgfSxcblxuICBwZXJzb25hbFNpZ24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICBjb25zdCBzZW5kZXJIZXggPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgICByZXR1cm4gc2VuZGVySGV4XG4gIH0sXG5cbiAgZXh0cmFjdFB1YmxpY0tleSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICByZXR1cm4gYDB4JHtwdWJsaWNLZXkudG9TdHJpbmcoJ2hleCcpfWBcbiAgfSxcblxuICB0eXBlZFNpZ25hdHVyZUhhc2ggKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YUxlZ2FjeSAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtc2dIYXNoLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbXNnSGFzaCA9IHR5cGVkU2lnbmF0dXJlSGFzaChtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBwdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gsIG1zZ1BhcmFtcy5zaWcpXG4gICAgY29uc3Qgc2VuZGVyID0gZXRoVXRpbC5wdWJsaWNUb0FkZHJlc3MocHVibGljS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHNlbmRlcilcbiAgfSxcblxuICBlbmNyeXB0IChyZWNlaXZlclB1YmxpY0tleSwgbXNnUGFyYW1zLCB2ZXJzaW9uKSB7XG5cbiAgICBzd2l0Y2ggKHZlcnNpb24pIHtcbiAgICAgIGNhc2UgJ3gyNTUxOS14c2Fsc2EyMC1wb2x5MTMwNSc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtc2dQYXJhbXMuZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBkZXRlY3Qgc2VjcmV0IG1lc3NhZ2UsIG1lc3NhZ2UgcGFyYW1zIHNob3VsZCBiZSBvZiB0aGUgZm9ybSB7ZGF0YTogXCJzZWNyZXQgbWVzc2FnZVwifSAnKVxuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYXRlIGVwaGVtZXJhbCBrZXlwYWlyXG4gICAgICAgIGNvbnN0IGVwaGVtZXJhbEtleVBhaXIgPSBuYWNsLmJveC5rZXlQYWlyKClcblxuICAgICAgICAvLyBhc3NlbWJsZSBlbmNyeXB0aW9uIHBhcmFtZXRlcnMgLSBmcm9tIHN0cmluZyB0byBVSW50OFxuICAgICAgICBsZXQgcHViS2V5VUludDhBcnJheVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHB1YktleVVJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KHJlY2VpdmVyUHVibGljS2V5KVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JhZCBwdWJsaWMga2V5JylcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1zZ1BhcmFtc1VJbnQ4QXJyYXkgPSBuYWNsLnV0aWwuZGVjb2RlVVRGOChtc2dQYXJhbXMuZGF0YSlcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnJhbmRvbUJ5dGVzKG5hY2wuYm94Lm5vbmNlTGVuZ3RoKVxuXG4gICAgICAgIC8vIGVuY3J5cHRcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkTWVzc2FnZSA9IG5hY2wuYm94KG1zZ1BhcmFtc1VJbnQ4QXJyYXksIG5vbmNlLCBwdWJLZXlVSW50OEFycmF5LCBlcGhlbWVyYWxLZXlQYWlyLnNlY3JldEtleSlcblxuICAgICAgICAvLyBoYW5kbGUgZW5jcnlwdGVkIGRhdGFcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgIHZlcnNpb246ICd4MjU1MTkteHNhbHNhMjAtcG9seTEzMDUnLFxuICAgICAgICAgIG5vbmNlOiBuYWNsLnV0aWwuZW5jb2RlQmFzZTY0KG5vbmNlKSxcbiAgICAgICAgICBlcGhlbVB1YmxpY0tleTogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlcGhlbWVyYWxLZXlQYWlyLnB1YmxpY0tleSksXG4gICAgICAgICAgY2lwaGVydGV4dDogbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0ZWRNZXNzYWdlKSxcbiAgICAgICAgfVxuICAgICAgICAvLyByZXR1cm4gZW5jcnlwdGVkIG1zZyBkYXRhXG4gICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZCcpXG5cbiAgICB9XG4gIH0sXG5cbiAgZW5jcnlwdFNhZmVseSAocmVjZWl2ZXJQdWJsaWNLZXksIG1zZ1BhcmFtcywgdmVyc2lvbikge1xuXG4gICAgY29uc3QgREVGQVVMVF9QQURESU5HX0xFTkdUSCA9ICgyICoqIDExKVxuICAgIGNvbnN0IE5BQ0xfRVhUUkFfQllURVMgPSAxNlxuXG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXNcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGVuY3J5cHQgZW1wdHkgbXNnLmRhdGEnKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgJiYgZGF0YS50b0pTT04pIHtcbiAgICAgIC8vIHJlbW92ZSB0b0pTT04gYXR0YWNrIHZlY3RvclxuICAgICAgLy8gVE9ETywgY2hlY2sgYWxsIHBvc3NpYmxlIGNoaWxkcmVuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBlbmNyeXB0IHdpdGggdG9KU09OIHByb3BlcnR5LiAgUGxlYXNlIHJlbW92ZSB0b0pTT04gcHJvcGVydHknKVxuICAgIH1cblxuICAgIC8vIGFkZCBwYWRkaW5nXG4gICAgY29uc3QgZGF0YVdpdGhQYWRkaW5nID0ge1xuICAgICAgZGF0YSxcbiAgICAgIHBhZGRpbmc6ICcnLFxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSBwYWRkaW5nXG4gICAgY29uc3QgZGF0YUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKEpTT04uc3RyaW5naWZ5KGRhdGFXaXRoUGFkZGluZyksICd1dGYtOCcpXG4gICAgY29uc3QgbW9kVmFsID0gKGRhdGFMZW5ndGggJSBERUZBVUxUX1BBRERJTkdfTEVOR1RIKVxuICAgIGxldCBwYWRMZW5ndGggPSAwXG4gICAgLy8gT25seSBwYWQgaWYgbmVjZXNzYXJ5XG4gICAgaWYgKG1vZFZhbCA+IDApIHtcbiAgICAgIHBhZExlbmd0aCA9IChERUZBVUxUX1BBRERJTkdfTEVOR1RIIC0gbW9kVmFsKSAtIE5BQ0xfRVhUUkFfQllURVMgLy8gbmFjbCBleHRyYSBieXRlc1xuICAgIH1cbiAgICBkYXRhV2l0aFBhZGRpbmcucGFkZGluZyA9ICcwJy5yZXBlYXQocGFkTGVuZ3RoKVxuXG4gICAgY29uc3QgcGFkZGVkTXNnUGFyYW1zID0geyBkYXRhOiBKU09OLnN0cmluZ2lmeShkYXRhV2l0aFBhZGRpbmcpIH1cbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0KHJlY2VpdmVyUHVibGljS2V5LCBwYWRkZWRNc2dQYXJhbXMsIHZlcnNpb24pXG4gIH0sXG5cbiAgZGVjcnlwdCAoZW5jcnlwdGVkRGF0YSwgcmVjZWl2ZXJQcml2YXRlS2V5KSB7XG5cbiAgICBzd2l0Y2ggKGVuY3J5cHRlZERhdGEudmVyc2lvbikge1xuICAgICAgY2FzZSAneDI1NTE5LXhzYWxzYTIwLXBvbHkxMzA1Jzoge1xuICAgICAgICAvLyBzdHJpbmcgdG8gYnVmZmVyIHRvIFVJbnQ4QXJyYXlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJQcml2YXRlS2V5VWludDhBcnJheSA9IG5hY2xfZGVjb2RlSGV4KHJlY2VpdmVyUHJpdmF0ZUtleSlcbiAgICAgICAgY29uc3QgcmVjaWV2ZXJFbmNyeXB0aW9uUHJpdmF0ZUtleSA9IG5hY2wuYm94LmtleVBhaXIuZnJvbVNlY3JldEtleShyZWNpZXZlclByaXZhdGVLZXlVaW50OEFycmF5KS5zZWNyZXRLZXlcblxuICAgICAgICAvLyBhc3NlbWJsZSBkZWNyeXB0aW9uIHBhcmFtZXRlcnNcbiAgICAgICAgY29uc3Qgbm9uY2UgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEubm9uY2UpXG4gICAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuY2lwaGVydGV4dClcbiAgICAgICAgY29uc3QgZXBoZW1QdWJsaWNLZXkgPSBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KGVuY3J5cHRlZERhdGEuZXBoZW1QdWJsaWNLZXkpXG5cbiAgICAgICAgLy8gZGVjcnlwdFxuICAgICAgICBjb25zdCBkZWNyeXB0ZWRNZXNzYWdlID0gbmFjbC5ib3gub3BlbihjaXBoZXJ0ZXh0LCBub25jZSwgZXBoZW1QdWJsaWNLZXksIHJlY2lldmVyRW5jcnlwdGlvblByaXZhdGVLZXkpXG5cbiAgICAgICAgLy8gcmV0dXJuIGRlY3J5cHRlZCBtc2cgZGF0YVxuICAgICAgICBsZXQgb3V0cHV0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3V0cHV0ID0gbmFjbC51dGlsLmVuY29kZVVURjgoZGVjcnlwdGVkTWVzc2FnZSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEZWNyeXB0aW9uIGZhaWxlZC4nKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RlY3J5cHRpb24gZmFpbGVkLicpXG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiB0eXBlL3ZlcnNpb24gbm90IHN1cHBvcnRlZC4nKVxuICAgIH1cbiAgfSxcblxuICBkZWNyeXB0U2FmZWx5IChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpIHtcbiAgICBjb25zdCBkYXRhV2l0aFBhZGRpbmcgPSBKU09OLnBhcnNlKHRoaXMuZGVjcnlwdChlbmNyeXB0ZWREYXRhLCByZWNlaXZlclByaXZhdGVLZXkpKVxuICAgIHJldHVybiBkYXRhV2l0aFBhZGRpbmcuZGF0YVxuICB9LFxuXG5cbiAgZ2V0RW5jcnlwdGlvblB1YmxpY0tleSAocHJpdmF0ZUtleSkge1xuICAgIGNvbnN0IHByaXZhdGVLZXlVaW50OEFycmF5ID0gbmFjbF9kZWNvZGVIZXgocHJpdmF0ZUtleSlcbiAgICBjb25zdCBlbmNyeXB0aW9uUHVibGljS2V5ID0gbmFjbC5ib3gua2V5UGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXlVaW50OEFycmF5KS5wdWJsaWNLZXlcbiAgICByZXR1cm4gbmFjbC51dGlsLmVuY29kZUJhc2U2NChlbmNyeXB0aW9uUHVibGljS2V5KVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIEEgZ2VuZXJpYyBlbnRyeSBwb2ludCBmb3IgYWxsIHR5cGVkIGRhdGEgbWV0aG9kcyB0byBiZSBwYXNzZWQsIGluY2x1ZGVzIGEgdmVyc2lvbiBwYXJhbWV0ZXIuXG4gICAqL1xuICBzaWduVHlwZWRNZXNzYWdlIChwcml2YXRlS2V5LCBtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFMZWdhY3kocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgICAgY2FzZSAnVjMnOlxuICAgICAgICByZXR1cm4gdGhpcy5zaWduVHlwZWREYXRhKHByaXZhdGVLZXksIG1zZ1BhcmFtcylcbiAgICAgIGNhc2UgJ1Y0JzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLnNpZ25UeXBlZERhdGFfdjQocHJpdmF0ZUtleSwgbXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICByZWNvdmVyVHlwZWRNZXNzYWdlIChtc2dQYXJhbXMsIHZlcnNpb24gPSAnVjQnKSB7XG4gICAgc3dpdGNoICh2ZXJzaW9uKSB7XG4gICAgICBjYXNlICdWMSc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZUxlZ2FjeShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWMyc6XG4gICAgICAgIHJldHVybiB0aGlzLnJlY292ZXJUeXBlZFNpZ25hdHVyZShtc2dQYXJhbXMpXG4gICAgICBjYXNlICdWNCc6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdGhpcy5yZWNvdmVyVHlwZWRTaWduYXR1cmVfdjQobXNnUGFyYW1zKVxuICAgIH1cbiAgfSxcblxuICBzaWduVHlwZWREYXRhIChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSwgZmFsc2UpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICBzaWduVHlwZWREYXRhX3Y0IChwcml2YXRlS2V5LCBtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gVHlwZWREYXRhVXRpbHMuc2lnbihtc2dQYXJhbXMuZGF0YSlcbiAgICBjb25zdCBzaWcgPSBldGhVdGlsLmVjc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZSAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEsIGZhbHNlKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZSwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9LFxuXG4gIHJlY292ZXJUeXBlZFNpZ25hdHVyZV92NCAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IFR5cGVkRGF0YVV0aWxzLnNpZ24obXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3QgcHVibGljS2V5ID0gcmVjb3ZlclB1YmxpY0tleShtZXNzYWdlLCBtc2dQYXJhbXMuc2lnKVxuICAgIGNvbnN0IHNlbmRlciA9IGV0aFV0aWwucHVibGljVG9BZGRyZXNzKHB1YmxpY0tleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gIH0sXG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCAodHlwZWREYXRhKSB7XG4gIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdFeHBlY3QgYXJndW1lbnQgdG8gYmUgbm9uLWVtcHR5IGFycmF5JylcbiAgaWYgKHR5cGVvZiB0eXBlZERhdGEgIT09ICdvYmplY3QnIHx8ICF0eXBlZERhdGEubGVuZ3RoKSB7XG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIGNvbnN0IGRhdGEgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gJ2J5dGVzJyA/IGV0aFV0aWwudG9CdWZmZXIoZS52YWx1ZSkgOiBlLnZhbHVlXG4gIH0pXG4gIGNvbnN0IHR5cGVzID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBlLnR5cGVcbiAgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgICByZXR1cm4gYCR7ZS50eXBlfSAke2UubmFtZX1gXG4gIH0pXG5cbiAgcmV0dXJuIGV0aEFiaS5zb2xpZGl0eVNIQTMoXG4gICAgWydieXRlczMyJywgJ2J5dGVzMzInXSxcbiAgICBbXG4gICAgICBldGhBYmkuc29saWRpdHlTSEEzKG5ldyBBcnJheSh0eXBlZERhdGEubGVuZ3RoKS5maWxsKCdzdHJpbmcnKSwgc2NoZW1hKSxcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTModHlwZXMsIGRhdGEpLFxuICAgIF0sXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleSAoaGFzaCwgc2lnKSB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGV0aFV0aWwudG9CdWZmZXIoc2lnKVxuICBjb25zdCBzaWdQYXJhbXMgPSBldGhVdGlsLmZyb21ScGNTaWcoc2lnbmF0dXJlKVxuICByZXR1cm4gZXRoVXRpbC5lY3JlY292ZXIoaGFzaCwgc2lnUGFyYW1zLnYsIHNpZ1BhcmFtcy5yLCBzaWdQYXJhbXMucylcbn1cblxuZnVuY3Rpb24gZ2V0UHVibGljS2V5Rm9yIChtc2dQYXJhbXMpIHtcbiAgY29uc3QgbWVzc2FnZSA9IGV0aFV0aWwudG9CdWZmZXIobXNnUGFyYW1zLmRhdGEpXG4gIGNvbnN0IG1zZ0hhc2ggPSBldGhVdGlsLmhhc2hQZXJzb25hbE1lc3NhZ2UobWVzc2FnZSlcbiAgcmV0dXJuIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbn1cblxuXG5mdW5jdGlvbiBwYWRXaXRoWmVyb2VzIChudW1iZXIsIGxlbmd0aCkge1xuICBsZXQgbXlTdHJpbmcgPSBgJHtudW1iZXJ9YFxuICB3aGlsZSAobXlTdHJpbmcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgbXlTdHJpbmcgPSBgMCR7bXlTdHJpbmd9YFxuICB9XG4gIHJldHVybiBteVN0cmluZ1xufVxuXG4vLyBjb252ZXJ0cyBoZXggc3RyaW5ncyB0byB0aGUgVWludDhBcnJheSBmb3JtYXQgdXNlZCBieSBuYWNsXG5mdW5jdGlvbiBuYWNsX2RlY29kZUhleCAobXNnSGV4KSB7XG4gIGNvbnN0IG1zZ0Jhc2U2NCA9IChCdWZmZXIuZnJvbShtc2dIZXgsICdoZXgnKSkudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gIHJldHVybiBuYWNsLnV0aWwuZGVjb2RlQmFzZTY0KG1zZ0Jhc2U2NClcbn1cblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpLFxuICAgIGtlY2NhazIyNCA9IF9yZXF1aXJlLmtlY2NhazIyNCxcbiAgICBrZWNjYWszODQgPSBfcmVxdWlyZS5rZWNjYWszODQsXG4gICAgazI1NiA9IF9yZXF1aXJlLmtlY2NhazI1NixcbiAgICBrZWNjYWs1MTIgPSBfcmVxdWlyZS5rZWNjYWs1MTI7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1hZGFwdGVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgcmxwID0gcmVxdWlyZSgncmxwJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCByZXF1aXJlKCdldGhqcy11dGlsJykpO1xuXG4vKipcbiAqIHRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZSAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBNQVhfSU5URUdFUlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuXG4vKipcbiAqIDJeMjU2IChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IFRXT19QT1cyNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9OVUxMX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuZXhwb3J0cy5TSEEzX05VTExfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9OVUxMXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTDtcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfQVJSQVlfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3JztcbmV4cG9ydHMuU0hBM19STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUF9BUlJBWVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsICAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbmV4cG9ydHMuU0hBM19STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQO1xuXG4vKipcbiAqIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcylcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkJOID0gQk47XG5cbi8qKlxuICogW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5ybHAgPSBybHA7XG5cbi8qKlxuICogW2BzZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlLylcbiAqIEB2YXIge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwc1xuICogQG1ldGhvZCB6ZXJvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIHplcm9BZGRyZXNzXG4gICogQHJldHVybiB7U3RyaW5nfVxuICAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoemVyb0FkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQG1ldGhvZCBsc2V0TGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHtCb29sZWFufSBbcmlnaHQ9ZmFsc2VdIHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gIGlmIChyaWdodCkge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfSBhXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfVxuICovXG5leHBvcnRzLnVucGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYSk7XG4gIHZhciBmaXJzdCA9IGFbMF07XG4gIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgZmlyc3QgPSBhWzBdO1xuICB9XG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB7Kn0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGV4cG9ydHMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMucGFkVG9FdmVuKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHYgPSBleHBvcnRzLmludFRvQnVmZmVyKHYpO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IG51bVxuICogQHJldHVybiB7Qk59XG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCTn0gbnVtXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIEtlY2NhayB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICBpZiAoIWJpdHMpIGJpdHMgPSAyNTY7XG5cbiAgc3dpdGNoIChiaXRzKSB7XG4gICAgY2FzZSAyMjQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICB9XG4gICAgY2FzZSAyNTY6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMzg0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgNTEyOlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobToga2VjY2FrJyArIGJpdHMpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIChLZWNjYWspIGhhc2ggb2YgdGhlIGlucHV0IFtPQlNPTEVURV1cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBTSEEtMyB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTMgPSBleHBvcnRzLmtlY2NhaztcblxuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtCb29sZWFufSBwYWRkZWQgd2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICB9XG5cbiAgaWYgKCFzYW5pdGl6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICBwdWJLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YktleSk7XG4gIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHByaXZhdGVLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHB1YmxpY0tleSA9IGV4cG9ydHMudG9CdWZmZXIocHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRUNEU0Egc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuXG4gIHZhciByZXQgPSB7fTtcbiAgcmV0LnIgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgcmV0LnMgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCk7XG4gIHJldC52ID0gc2lnLnJlY292ZXJ5ICsgMjc7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGhhc2hcbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIHByZWZpeCA9IGV4cG9ydHMudG9CdWZmZXIoJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcblxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcykge1xuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGgociwgMzIpLCBleHBvcnRzLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gIHZhciByZWNvdmVyeSA9IHYgLSAyNztcbiAgaWYgKHJlY292ZXJ5ICE9PSAwICYmIHJlY292ZXJ5ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gIH1cbiAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7U3RyaW5nfSBzaWdcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNvdmVyeSBpZCcpO1xuICB9XG5cbiAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgLy8gRklYTUU6IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUgLSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgZXhwb3J0cy50b0J1ZmZlcih2IC0gMjcpXSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgc2lnID0gZXhwb3J0cy50b0J1ZmZlcihzaWcpO1xuXG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmIChzaWcubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgdiA9IHNpZ1s2NF07XG4gIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICBpZiAodiA8IDI3KSB7XG4gICAgdiArPSAyNztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdjogdixcbiAgICByOiBzaWcuc2xpY2UoMCwgMzIpLFxuICAgIHM6IHNpZy5zbGljZSgzMiwgNjQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b29cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuICgvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKVxuICApO1xufTtcblxuLyoqXG4gICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgaXNaZXJvQWRkcmVzc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgcmV0dXJuIHplcm9BZGRyZXNzID09PSBleHBvcnRzLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBhZGRyZXNzID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzaCA9IGV4cG9ydHMua2VjY2FrKGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIHJldCA9ICcweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnJvbSB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbm9uY2UgdGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgZnJvbSA9IGV4cG9ydHMudG9CdWZmZXIoZnJvbSk7XG4gIG5vbmNlID0gbmV3IEJOKG5vbmNlKTtcblxuICBpZiAobm9uY2UuaXNaZXJvKCkpIHtcbiAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgIG5vbmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub25jZSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMucmxwaGFzaChbZnJvbSwgbm9uY2VdKS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSlcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIGEgPSBleHBvcnRzLnVucGFkKGFkZHJlc3MpO1xuICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG5cbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgRUNEU0Egc2lnbmF0dXJlXG4gKiBAbWV0aG9kIGlzVmFsaWRTaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hvbWVzdGVhZD10cnVlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkKSB7XG4gIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuXG4gIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgciA9IG5ldyBCTihyKTtcbiAgcyA9IG5ldyBCTihzKTtcblxuICBpZiAoci5pc1plcm8oKSB8fCByLmd0KFNFQ1AyNTZLMV9OKSB8fCBzLmlzWmVybygpIHx8IHMuZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhvbWVzdGVhZCA9PT0gZmFsc2UgJiYgbmV3IEJOKHMpLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT05cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBiYVxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICByZXR1cm4gJzB4JyArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIHsqfSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgc2VsZi5yYXcgPSBbXTtcbiAgc2VsZi5fZmllbGRzID0gW107XG5cbiAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIG9ialtmaWVsZF0gPSAnMHgnICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5iYVRvSlNPTih0aGlzLnJhdyk7XG4gIH07XG5cbiAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICB9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgIHYgPSBleHBvcnRzLnRvQnVmZmVyKHYpO1xuXG4gICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICB2ID0gZXhwb3J0cy5zdHJpcFplcm9zKHYpO1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IG5vdCBoYXZlIG1vcmUgJyArIGZpZWxkLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICcgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGV4cG9ydHMudG9CdWZmZXIoZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSkgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSkgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG5cbnZhciBzZWNwMjU2azF2MyA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9pbmRleCcpO1xudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9kZXInKTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIC8vIHByaXZhdGVLZXlFeHBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMXYzLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCk7XG5cbiAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCk7XG59O1xuXG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5cbnZhciBwcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KSB7XG4gIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgcHJpdmF0ZUtleSA9IGRlci5wcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpO1xuICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgcHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBwcml2YXRlS2V5O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiKTtcbn07XG5cbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU5lZ2F0ZShwcml2YXRlS2V5KSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiBwcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KSB7XG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMucHJpdmF0ZUtleU1vZEludmVyc2UoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBhZGRpbmcgdHdlYWsgdG8gaXQuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgdHdlYWspKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciBhIHByaXZhdGVLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNyZWF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwdWJsaWNLZXkgdG8gY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgZm9ybS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29udmVydFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gcHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwdWJsaWNLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIHB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHVibGljS2V5IGxlbmd0aCBpcyBub3QgMzMgb3IgNjVcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBhZGRpbmcgdHdlYWsgdGltZXMgdGhlIGdlbmVyYXRvciB0byBpdC5cbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrIHZhbHVlXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgcHVibGljS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICBrZXlzLnB1c2goVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xuICB9KTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbWJpbmUoa2V5cywgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmF0dXJlIHRvIGEgbm9ybWFsaXplZCBsb3dlci1TIGZvcm0uXG4gKiBAbWV0aG9kIHNpZ25hdHVyZU5vcm1hbGl6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKG5vdCBmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRMYXhcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpIHtcbiAgLy8gc2lnbmF0dXJlSW1wb3J0TGF4IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSk7XG4gIGlmIChzaWdPYmogPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMXYzLnNpZ25hdHVyZUltcG9ydChzaWdPYmopO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRUNEU0Egc2lnbmF0dXJlLiBBbHdheXMgcmV0dXJuIGxvdy1TIHNpZ25hdHVyZS5cbiAqIEBtZXRob2Qgc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHNpZ25PcHRpb25zID0gdm9pZCAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc2lnbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgIGlmIChvcHRpb25zLmRhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgIC8vICBjb252ZXJ0IG9wdGlvbi5ub25jZWZuIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgc2lnbk9wdGlvbnMubm9uY2VmbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBhbGdvLCBkYXRhLCBhdHRlbXB0KSB7XG4gICAgICAgIHZhciBidWZmZXJBbGdvID0gYWxnbyAhPSBudWxsID8gQnVmZmVyLmZyb20oYWxnbykgOiBudWxsO1xuICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcblxuICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICBidWZmZXIgPSBvcHRpb25zLm5vbmNlZm4oQnVmZmVyLmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHByaXZhdGVLZXkpLCBidWZmZXJBbGdvLCBidWZmZXJEYXRhLCBhdHRlbXB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5lY2RzYVNpZ24oVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHNpZ25PcHRpb25zKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgcmVjb3Zlcnk6IHNpZy5yZWNpZFxuICB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0Egc2lnbmF0dXJlLlxuICogQG1ldGhvZCB2ZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgdmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCB2ZXJpZnkgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJlY292ZXIgYW4gRUNEU0EgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICogQG1ldGhvZCByZWNvdmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJlY2lkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHJlY292ZXIgPSBmdW5jdGlvbiByZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjaWQsIGNvbXByZXNzZWQpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHJlY292ZXIgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgcmVjaWQsIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaCA9IGZ1bmN0aW9uIGVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2MyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIHBhcmFtZXRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZGgoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwge30pKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIHJldHVybiBwdWJsaWMga2V5IGFzIHJlc3VsdFxuICogQG1ldGhvZCBlY2RoVW5zYWZlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoVW5zYWZlID0gZnVuY3Rpb24gZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgLy8gZWNkaFVuc2FmZSBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAvLyBlbnN1cmUgdmFsaWQgcHVibGljS2V5IGxlbmd0aFxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHVibGljIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbGlkIHByaXZhdGVLZXkgbGVuZ3RoXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcml2YXRlS2V5VmVyaWZ5OiBwcml2YXRlS2V5VmVyaWZ5LFxuICBwcml2YXRlS2V5RXhwb3J0OiBwcml2YXRlS2V5RXhwb3J0LFxuICBwcml2YXRlS2V5SW1wb3J0OiBwcml2YXRlS2V5SW1wb3J0LFxuICBwcml2YXRlS2V5TmVnYXRlOiBwcml2YXRlS2V5TmVnYXRlLFxuICBwcml2YXRlS2V5TW9kSW52ZXJzZTogcHJpdmF0ZUtleU1vZEludmVyc2UsXG4gIHByaXZhdGVLZXlUd2Vha0FkZDogcHJpdmF0ZUtleVR3ZWFrQWRkLFxuICBwcml2YXRlS2V5VHdlYWtNdWw6IHByaXZhdGVLZXlUd2Vha011bCxcblxuICBwdWJsaWNLZXlDcmVhdGU6IHB1YmxpY0tleUNyZWF0ZSxcbiAgcHVibGljS2V5Q29udmVydDogcHVibGljS2V5Q29udmVydCxcbiAgcHVibGljS2V5VmVyaWZ5OiBwdWJsaWNLZXlWZXJpZnksXG4gIHB1YmxpY0tleVR3ZWFrQWRkOiBwdWJsaWNLZXlUd2Vha0FkZCxcbiAgcHVibGljS2V5VHdlYWtNdWw6IHB1YmxpY0tleVR3ZWFrTXVsLFxuICBwdWJsaWNLZXlDb21iaW5lOiBwdWJsaWNLZXlDb21iaW5lLFxuXG4gIHNpZ25hdHVyZU5vcm1hbGl6ZTogc2lnbmF0dXJlTm9ybWFsaXplLFxuICBzaWduYXR1cmVFeHBvcnQ6IHNpZ25hdHVyZUV4cG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0OiBzaWduYXR1cmVJbXBvcnQsXG4gIHNpZ25hdHVyZUltcG9ydExheDogc2lnbmF0dXJlSW1wb3J0TGF4LFxuXG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5LFxuICByZWNvdmVyOiByZWNvdmVyLFxuXG4gIGVjZGg6IGVjZGgsXG4gIGVjZGhVbnNhZmU6IGVjZGhVbnNhZmVcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4MjEsIDB4MDIsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHhhNSwgMHgzMCwgMHg4MSwgMHhhMiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHg0MSwgMHgwNCwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHg0OCwgMHgzYSwgMHhkYSwgMHg3NywgMHgyNiwgMHhhMywgMHhjNCwgMHg2NSwgMHg1ZCwgMHhhNCwgMHhmYiwgMHhmYywgMHgwZSwgMHgxMSwgMHgwOCwgMHhhOCwgMHhmZCwgMHgxNywgMHhiNCwgMHg0OCwgMHhhNiwgMHg4NSwgMHg1NCwgMHgxOSwgMHg5YywgMHg0NywgMHhkMCwgMHg4ZiwgMHhmYiwgMHgxMCwgMHhkNCwgMHhiOCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHg0NCwgMHgwMywgMHg0MiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCk7XG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgbGVuZ3RoID0gcHJpdmF0ZUtleS5sZW5ndGg7XG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVybiBudWxsO1xuICBpbmRleCArPSAxO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBjb25zdHJ1Y3RvclxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gIGluZGV4ICs9IDE7XG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuIG51bGw7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICBpbmRleCArPSBsZW5iO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fCBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpbmRleCArPSAzO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHwgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5cbiAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChsZW5ieXRlICYgMHg4MCkge1xuICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gcmxlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gcmxlbjtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChzbGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAoc2xlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBzbGVuO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ25hdHVyZVtyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gIGZvciAoOyBzbGVuID4gMCAmJiBzaWduYXR1cmVbc2luZGV4XSA9PT0gMHgwMDsgc2xlbiAtPSAxLCBzaW5kZXggKz0gMSkge31cbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjO1xuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkblxcJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXQnKTtcbiAgfVxuXG4gIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkocG9pbnQuZ2V0WCgpLCBwb2ludC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGJuLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpO1xuICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICByID0gbmV3IEJOKDApO1xuICB9XG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICBpZiAocy51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICBzID0gbmV3IEJOKDApO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3IudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMildKTtcbn07XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChzY2FsYXIudWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICB9XG5cbiAgdmFyIHNoYXJlZCA9IHBvaW50LnB1Yi5tdWwoc2NhbGFyKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHNoYXJlZC5nZXRYKCksIHNoYXJlZC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxudmFyIHRvUHVibGljS2V5ID0gZnVuY3Rpb24gdG9QdWJsaWNLZXkoeCwgeSwgY29tcHJlc3NlZCkge1xuICB2YXIgcHVibGljS2V5ID0gdm9pZCAwO1xuXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMjtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgIHB1YmxpY0tleVswXSA9IDB4MDQ7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgeS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMzMpO1xuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG52YXIgY3MgPSByZXF1aXJlKCdjb2luc3RyaW5nJylcbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdzZWNwMjU2azEnKVxuXG52YXIgTUFTVEVSX1NFQ1JFVCA9IEJ1ZmZlci5mcm9tKCdCaXRjb2luIHNlZWQnLCAndXRmOCcpXG52YXIgSEFSREVORURfT0ZGU0VUID0gMHg4MDAwMDAwMFxudmFyIExFTiA9IDc4XG5cbi8vIEJpdGNvaW4gaGFyZGNvZGVkIGJ5IGRlZmF1bHQsIGNhbiB1c2UgcGFja2FnZSBgY29pbmluZm9gIGZvciBvdGhlcnNcbnZhciBCSVRDT0lOX1ZFUlNJT05TID0ge3ByaXZhdGU6IDB4MDQ4OEFERTQsIHB1YmxpYzogMHgwNDg4QjIxRX1cblxuZnVuY3Rpb24gSERLZXkgKHZlcnNpb25zKSB7XG4gIHRoaXMudmVyc2lvbnMgPSB2ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TXG4gIHRoaXMuZGVwdGggPSAwXG4gIHRoaXMuaW5kZXggPSAwXG4gIHRoaXMuX3ByaXZhdGVLZXkgPSBudWxsXG4gIHRoaXMuX3B1YmxpY0tleSA9IG51bGxcbiAgdGhpcy5jaGFpbkNvZGUgPSBudWxsXG4gIHRoaXMuX2ZpbmdlcnByaW50ID0gMFxuICB0aGlzLnBhcmVudEZpbmdlcnByaW50ID0gMFxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAnZmluZ2VycHJpbnQnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZmluZ2VycHJpbnQgfSB9KVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ2lkZW50aWZpZXInLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5faWRlbnRpZmllciB9IH0pXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHViS2V5SGFzaCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmlkZW50aWZpZXIgfSB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHJpdmF0ZUtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaXZhdGVLZXlcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc3NlcnQuZXF1YWwodmFsdWUubGVuZ3RoLCAzMiwgJ1ByaXZhdGUga2V5IG11c3QgYmUgMzIgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkodmFsdWUpID09PSB0cnVlLCAnSW52YWxpZCBwcml2YXRlIGtleScpXG5cbiAgICB0aGlzLl9wcml2YXRlS2V5ID0gdmFsdWVcbiAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5Q3JlYXRlKHZhbHVlLCB0cnVlKVxuICAgIHRoaXMuX2lkZW50aWZpZXIgPSBoYXNoMTYwKHRoaXMucHVibGljS2V5KVxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gdGhpcy5faWRlbnRpZmllci5zbGljZSgwLCA0KS5yZWFkVUludDMyQkUoMClcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3B1YmxpY0tleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3B1YmxpY0tleVxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzc2VydCh2YWx1ZS5sZW5ndGggPT09IDMzIHx8IHZhbHVlLmxlbmd0aCA9PT0gNjUsICdQdWJsaWMga2V5IG11c3QgYmUgMzMgb3IgNjUgYnl0ZXMuJylcbiAgICBhc3NlcnQoc2VjcDI1NmsxLnB1YmxpY0tleVZlcmlmeSh2YWx1ZSkgPT09IHRydWUsICdJbnZhbGlkIHB1YmxpYyBrZXknKVxuXG4gICAgdGhpcy5fcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQodmFsdWUsIHRydWUpIC8vIGZvcmNlIGNvbXByZXNzZWQgcG9pbnRcbiAgICB0aGlzLl9pZGVudGlmaWVyID0gaGFzaDE2MCh0aGlzLnB1YmxpY0tleSlcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IHRoaXMuX2lkZW50aWZpZXIuc2xpY2UoMCwgNCkucmVhZFVJbnQzMkJFKDApXG4gICAgdGhpcy5fcHJpdmF0ZUtleSA9IG51bGxcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhES2V5LnByb3RvdHlwZSwgJ3ByaXZhdGVFeHRlbmRlZEtleScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3ByaXZhdGVLZXkpIHJldHVybiBjcy5lbmNvZGUoc2VyaWFsaXplKHRoaXMsIHRoaXMudmVyc2lvbnMucHJpdmF0ZSwgQnVmZmVyLmNvbmNhdChbQnVmZmVyLmFsbG9jKDEsIDApLCB0aGlzLnByaXZhdGVLZXldKSkpXG4gICAgZWxzZSByZXR1cm4gbnVsbFxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoSERLZXkucHJvdG90eXBlLCAncHVibGljRXh0ZW5kZWRLZXknLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjcy5lbmNvZGUoc2VyaWFsaXplKHRoaXMsIHRoaXMudmVyc2lvbnMucHVibGljLCB0aGlzLnB1YmxpY0tleSkpXG4gIH1cbn0pXG5cbkhES2V5LnByb3RvdHlwZS5kZXJpdmUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAocGF0aCA9PT0gJ20nIHx8IHBhdGggPT09ICdNJyB8fCBwYXRoID09PSBcIm0nXCIgfHwgcGF0aCA9PT0gXCJNJ1wiKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHZhciBlbnRyaWVzID0gcGF0aC5zcGxpdCgnLycpXG4gIHZhciBoZGtleSA9IHRoaXNcbiAgZW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChjLCBpKSB7XG4gICAgaWYgKGkgPT09IDApIHtcbiAgICAgIGFzc2VydChjLCAnbScsICdJbnZhbGlkIHBhdGgnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGhhcmRlbmVkID0gKGMubGVuZ3RoID4gMSkgJiYgKGNbYy5sZW5ndGggLSAxXSA9PT0gXCInXCIpXG4gICAgdmFyIGNoaWxkSW5kZXggPSBwYXJzZUludChjLCAxMCkgLy8gJiAoSEFSREVORURfT0ZGU0VUIC0gMSlcbiAgICBhc3NlcnQoY2hpbGRJbmRleCA8IEhBUkRFTkVEX09GRlNFVCwgJ0ludmFsaWQgaW5kZXgnKVxuICAgIGlmIChoYXJkZW5lZCkgY2hpbGRJbmRleCArPSBIQVJERU5FRF9PRkZTRVRcblxuICAgIGhka2V5ID0gaGRrZXkuZGVyaXZlQ2hpbGQoY2hpbGRJbmRleClcbiAgfSlcblxuICByZXR1cm4gaGRrZXlcbn1cblxuSERLZXkucHJvdG90eXBlLmRlcml2ZUNoaWxkID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gIHZhciBpc0hhcmRlbmVkID0gaW5kZXggPj0gSEFSREVORURfT0ZGU0VUXG4gIHZhciBpbmRleEJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSg0KVxuICBpbmRleEJ1ZmZlci53cml0ZVVJbnQzMkJFKGluZGV4LCAwKVxuXG4gIHZhciBkYXRhXG5cbiAgaWYgKGlzSGFyZGVuZWQpIHsgLy8gSGFyZGVuZWQgY2hpbGRcbiAgICBhc3NlcnQodGhpcy5wcml2YXRlS2V5LCAnQ291bGQgbm90IGRlcml2ZSBoYXJkZW5lZCBjaGlsZCBrZXknKVxuXG4gICAgdmFyIHBrID0gdGhpcy5wcml2YXRlS2V5XG4gICAgdmFyIHpiID0gQnVmZmVyLmFsbG9jKDEsIDApXG4gICAgcGsgPSBCdWZmZXIuY29uY2F0KFt6YiwgcGtdKVxuXG4gICAgLy8gZGF0YSA9IDB4MDAgfHwgc2VyMjU2KGtwYXIpIHx8IHNlcjMyKGluZGV4KVxuICAgIGRhdGEgPSBCdWZmZXIuY29uY2F0KFtwaywgaW5kZXhCdWZmZXJdKVxuICB9IGVsc2UgeyAvLyBOb3JtYWwgY2hpbGRcbiAgICAvLyBkYXRhID0gc2VyUChwb2ludChrcGFyKSkgfHwgc2VyMzIoaW5kZXgpXG4gICAgLy8gICAgICA9IHNlclAoS3BhcikgfHwgc2VyMzIoaW5kZXgpXG4gICAgZGF0YSA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucHVibGljS2V5LCBpbmRleEJ1ZmZlcl0pXG4gIH1cblxuICB2YXIgSSA9IGNyeXB0by5jcmVhdGVIbWFjKCdzaGE1MTInLCB0aGlzLmNoYWluQ29kZSkudXBkYXRlKGRhdGEpLmRpZ2VzdCgpXG4gIHZhciBJTCA9IEkuc2xpY2UoMCwgMzIpXG4gIHZhciBJUiA9IEkuc2xpY2UoMzIpXG5cbiAgdmFyIGhkID0gbmV3IEhES2V5KHRoaXMudmVyc2lvbnMpXG5cbiAgLy8gUHJpdmF0ZSBwYXJlbnQga2V5IC0+IHByaXZhdGUgY2hpbGQga2V5XG4gIGlmICh0aGlzLnByaXZhdGVLZXkpIHtcbiAgICAvLyBraSA9IHBhcnNlMjU2KElMKSArIGtwYXIgKG1vZCBuKVxuICAgIHRyeSB7XG4gICAgICBoZC5wcml2YXRlS2V5ID0gc2VjcDI1NmsxLnByaXZhdGVLZXlUd2Vha0FkZCh0aGlzLnByaXZhdGVLZXksIElMKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAocHJpdmF0ZUtleSArIElMKSA9PT0gMFxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gSW4gY2FzZSBwYXJzZTI1NihJTCkgPj0gbiBvciBraSA9PSAwLCBvbmUgc2hvdWxkIHByb2NlZWQgd2l0aCB0aGUgbmV4dCB2YWx1ZSBmb3IgaVxuICAgICAgcmV0dXJuIHRoaXMuZGVyaXZlKGluZGV4ICsgMSlcbiAgICB9XG4gIC8vIFB1YmxpYyBwYXJlbnQga2V5IC0+IHB1YmxpYyBjaGlsZCBrZXlcbiAgfSBlbHNlIHtcbiAgICAvLyBLaSA9IHBvaW50KHBhcnNlMjU2KElMKSkgKyBLcGFyXG4gICAgLy8gICAgPSBHKklMICsgS3BhclxuICAgIHRyeSB7XG4gICAgICBoZC5wdWJsaWNLZXkgPSBzZWNwMjU2azEucHVibGljS2V5VHdlYWtBZGQodGhpcy5wdWJsaWNLZXksIElMLCB0cnVlKVxuICAgICAgLy8gdGhyb3cgaWYgSUwgPj0gbiB8fCAoZyoqSUwgKyBwdWJsaWNLZXkpIGlzIGluZmluaXR5XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBJbiBjYXNlIHBhcnNlMjU2KElMKSA+PSBuIG9yIEtpIGlzIHRoZSBwb2ludCBhdCBpbmZpbml0eSwgb25lIHNob3VsZCBwcm9jZWVkIHdpdGggdGhlIG5leHQgdmFsdWUgZm9yIGlcbiAgICAgIHJldHVybiB0aGlzLmRlcml2ZShpbmRleCArIDEsIGlzSGFyZGVuZWQpXG4gICAgfVxuICB9XG5cbiAgaGQuY2hhaW5Db2RlID0gSVJcbiAgaGQuZGVwdGggPSB0aGlzLmRlcHRoICsgMVxuICBoZC5wYXJlbnRGaW5nZXJwcmludCA9IHRoaXMuZmluZ2VycHJpbnQvLyAucmVhZFVJbnQzMkJFKDApXG4gIGhkLmluZGV4ID0gaW5kZXhcblxuICByZXR1cm4gaGRcbn1cblxuSERLZXkucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiAoaGFzaCkge1xuICByZXR1cm4gc2VjcDI1NmsxLnNpZ24oaGFzaCwgdGhpcy5wcml2YXRlS2V5KS5zaWduYXR1cmVcbn1cblxuSERLZXkucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIChoYXNoLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkoaGFzaCwgc2lnbmF0dXJlLCB0aGlzLnB1YmxpY0tleSlcbn1cblxuSERLZXkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB4cHJpdjogdGhpcy5wcml2YXRlRXh0ZW5kZWRLZXksXG4gICAgeHB1YjogdGhpcy5wdWJsaWNFeHRlbmRlZEtleVxuICB9XG59XG5cbkhES2V5LmZyb21NYXN0ZXJTZWVkID0gZnVuY3Rpb24gKHNlZWRCdWZmZXIsIHZlcnNpb25zKSB7XG4gIHZhciBJID0gY3J5cHRvLmNyZWF0ZUhtYWMoJ3NoYTUxMicsIE1BU1RFUl9TRUNSRVQpLnVwZGF0ZShzZWVkQnVmZmVyKS5kaWdlc3QoKVxuICB2YXIgSUwgPSBJLnNsaWNlKDAsIDMyKVxuICB2YXIgSVIgPSBJLnNsaWNlKDMyKVxuXG4gIHZhciBoZGtleSA9IG5ldyBIREtleSh2ZXJzaW9ucylcbiAgaGRrZXkuY2hhaW5Db2RlID0gSVJcbiAgaGRrZXkucHJpdmF0ZUtleSA9IElMXG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LmZyb21FeHRlbmRlZEtleSA9IGZ1bmN0aW9uIChiYXNlNThrZXksIHZlcnNpb25zKSB7XG4gIC8vID0+IHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgdmVyc2lvbnMgPSB2ZXJzaW9ucyB8fCBCSVRDT0lOX1ZFUlNJT05TXG4gIHZhciBoZGtleSA9IG5ldyBIREtleSh2ZXJzaW9ucylcblxuICB2YXIga2V5QnVmZmVyID0gY3MuZGVjb2RlKGJhc2U1OGtleSlcblxuICB2YXIgdmVyc2lvbiA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoMClcbiAgYXNzZXJ0KHZlcnNpb24gPT09IHZlcnNpb25zLnByaXZhdGUgfHwgdmVyc2lvbiA9PT0gdmVyc2lvbnMucHVibGljLCAnVmVyc2lvbiBtaXNtYXRjaDogZG9lcyBub3QgbWF0Y2ggcHJpdmF0ZSBvciBwdWJsaWMnKVxuXG4gIGhka2V5LmRlcHRoID0ga2V5QnVmZmVyLnJlYWRVSW50OCg0KVxuICBoZGtleS5wYXJlbnRGaW5nZXJwcmludCA9IGtleUJ1ZmZlci5yZWFkVUludDMyQkUoNSlcbiAgaGRrZXkuaW5kZXggPSBrZXlCdWZmZXIucmVhZFVJbnQzMkJFKDkpXG4gIGhka2V5LmNoYWluQ29kZSA9IGtleUJ1ZmZlci5zbGljZSgxMywgNDUpXG5cbiAgdmFyIGtleSA9IGtleUJ1ZmZlci5zbGljZSg0NSlcbiAgaWYgKGtleS5yZWFkVUludDgoMCkgPT09IDApIHsgLy8gcHJpdmF0ZVxuICAgIGFzc2VydCh2ZXJzaW9uID09PSB2ZXJzaW9ucy5wcml2YXRlLCAnVmVyc2lvbiBtaXNtYXRjaDogdmVyc2lvbiBkb2VzIG5vdCBtYXRjaCBwcml2YXRlJylcbiAgICBoZGtleS5wcml2YXRlS2V5ID0ga2V5LnNsaWNlKDEpIC8vIGN1dCBvZmYgZmlyc3QgMHgwIGJ5dGVcbiAgfSBlbHNlIHtcbiAgICBhc3NlcnQodmVyc2lvbiA9PT0gdmVyc2lvbnMucHVibGljLCAnVmVyc2lvbiBtaXNtYXRjaDogdmVyc2lvbiBkb2VzIG5vdCBtYXRjaCBwdWJsaWMnKVxuICAgIGhka2V5LnB1YmxpY0tleSA9IGtleVxuICB9XG5cbiAgcmV0dXJuIGhka2V5XG59XG5cbkhES2V5LmZyb21KU09OID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gSERLZXkuZnJvbUV4dGVuZGVkS2V5KG9iai54cHJpdilcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplIChoZGtleSwgdmVyc2lvbiwga2V5KSB7XG4gIC8vID0+IHZlcnNpb24oNCkgfHwgZGVwdGgoMSkgfHwgZmluZ2VycHJpbnQoNCkgfHwgaW5kZXgoNCkgfHwgY2hhaW4oMzIpIHx8IGtleSgzMylcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShMRU4pXG5cbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmVyc2lvbiwgMClcbiAgYnVmZmVyLndyaXRlVUludDgoaGRrZXkuZGVwdGgsIDQpXG5cbiAgdmFyIGZpbmdlcnByaW50ID0gaGRrZXkuZGVwdGggPyBoZGtleS5wYXJlbnRGaW5nZXJwcmludCA6IDB4MDAwMDAwMDBcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoZmluZ2VycHJpbnQsIDUpXG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGhka2V5LmluZGV4LCA5KVxuXG4gIGhka2V5LmNoYWluQ29kZS5jb3B5KGJ1ZmZlciwgMTMpXG4gIGtleS5jb3B5KGJ1ZmZlciwgNDUpXG5cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBoYXNoMTYwIChidWYpIHtcbiAgdmFyIHNoYSA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmKS5kaWdlc3QoKVxuICByZXR1cm4gY3J5cHRvLmNyZWF0ZUhhc2goJ3JtZDE2MCcpLnVwZGF0ZShzaGEpLmRpZ2VzdCgpXG59XG5cbkhES2V5LkhBUkRFTkVEX09GRlNFVCA9IEhBUkRFTkVEX09GRlNFVFxubW9kdWxlLmV4cG9ydHMgPSBIREtleVxuIiwiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJykocmVxdWlyZSgnLi9saWIvZWxsaXB0aWMnKSlcbiIsIid1c2Ugc3RyaWN0J1xudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xuXG4vLyBUeXBlRXJyb3JcbmV4cG9ydHMuaXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB0aHJvdyBUeXBlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBmdW5jdGlvbiAodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsdWUpICE9PSAnW29iamVjdCBCb29sZWFuXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkgdGhyb3cgVHlwZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IEZ1bmN0aW9uXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzTnVtYmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgTnVtYmVyXScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICh0b1N0cmluZy5jYWxsKHZhbHVlKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHRocm93IFR5cGVFcnJvcihtZXNzYWdlKVxufVxuXG4vLyBSYW5nZUVycm9yXG5leHBvcnRzLmlzQnVmZmVyTGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlciwgbGVuZ3RoLCBtZXNzYWdlKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0J1ZmZlckxlbmd0aDIgPSBmdW5jdGlvbiAoYnVmZmVyLCBsZW5ndGgxLCBsZW5ndGgyLCBtZXNzYWdlKSB7XG4gIGlmIChidWZmZXIubGVuZ3RoICE9PSBsZW5ndGgxICYmIGJ1ZmZlci5sZW5ndGggIT09IGxlbmd0aDIpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cblxuZXhwb3J0cy5pc0xlbmd0aEdUWmVybyA9IGZ1bmN0aW9uICh2YWx1ZSwgbWVzc2FnZSkge1xuICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB0aHJvdyBSYW5nZUVycm9yKG1lc3NhZ2UpXG59XG5cbmV4cG9ydHMuaXNOdW1iZXJJbkludGVydmFsID0gZnVuY3Rpb24gKG51bWJlciwgeCwgeSwgbWVzc2FnZSkge1xuICBpZiAobnVtYmVyIDw9IHggfHwgbnVtYmVyID49IHkpIHRocm93IFJhbmdlRXJyb3IobWVzc2FnZSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyXG52YXIgYmlwNjYgPSByZXF1aXJlKCdiaXA2NicpXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbiAgLy8gYmVnaW5cbiAgMHgzMCwgMHg4MSwgMHhkMywgMHgwMiwgMHgwMSwgMHgwMSwgMHgwNCwgMHgyMCxcbiAgLy8gcHJpdmF0ZSBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgLy8gbWlkZGxlXG4gIDB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsXG4gIDB4Y0UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsXG4gIDB4MjEsIDB4MDIsIDB4NzksIDB4YkUsIDB4NjYsIDB4N0UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y0UsIDB4ODcsXG4gIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y0UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsXG4gIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsXG4gIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZkUsIDB4YmEsIDB4YUUsIDB4ZGMsIDB4RTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NUUsXG4gIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4gIC8vIHB1YmxpYyBrZXlcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbiAgMHgwMFxuXSlcblxudmFyIEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQgPSBCdWZmZXIuZnJvbShbXG4gIC8vIGJlZ2luXG4gIDB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4gIC8vIHByaXZhdGUga2V5XG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIC8vIG1pZGRsZVxuICAweGEwLCAweDgxLCAweGE1LCAweDMwLCAweDgxLCAweGEyLCAweDAyLCAweDAxLCAweDAxLCAweDMwLCAweDJjLCAweDA2LCAweDA3LCAweDJhLCAweDg2LCAweDQ4LFxuICAweGNFLCAweDNkLCAweDAxLCAweDAxLCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZFLCAweGZmLCAweGZmLCAweGZjLCAweDJmLCAweDMwLCAweDA2LCAweDA0LCAweDAxLCAweDAwLCAweDA0LCAweDAxLCAweDA3LCAweDA0LFxuICAweDQxLCAweDA0LCAweDc5LCAweGJFLCAweDY2LCAweDdFLCAweGY5LCAweGRjLCAweGJiLCAweGFjLCAweDU1LCAweGEwLCAweDYyLCAweDk1LCAweGNFLCAweDg3LFxuICAweDBiLCAweDA3LCAweDAyLCAweDliLCAweGZjLCAweGRiLCAweDJkLCAweGNFLCAweDI4LCAweGQ5LCAweDU5LCAweGYyLCAweDgxLCAweDViLCAweDE2LCAweGY4LFxuICAweDE3LCAweDk4LCAweDQ4LCAweDNhLCAweGRhLCAweDc3LCAweDI2LCAweGEzLCAweGM0LCAweDY1LCAweDVkLCAweGE0LCAweGZiLCAweGZjLCAweDBFLCAweDExLFxuICAweDA4LCAweGE4LCAweGZkLCAweDE3LCAweGI0LCAweDQ4LCAweGE2LCAweDg1LCAweDU0LCAweDE5LCAweDljLCAweDQ3LCAweGQwLCAweDhmLCAweGZiLCAweDEwLFxuICAweGQ0LCAweGI4LCAweDAyLCAweDIxLCAweDAwLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZmLFxuICAweGZmLCAweGZmLCAweGZmLCAweGZmLCAweGZFLCAweGJhLCAweGFFLCAweGRjLCAweEU2LCAweGFmLCAweDQ4LCAweGEwLCAweDNiLCAweGJmLCAweGQyLCAweDVFLFxuICAweDhjLCAweGQwLCAweDM2LCAweDQxLCAweDQxLCAweDAyLCAweDAxLCAweDAxLCAweGExLCAweDQ0LCAweDAzLCAweDQyLCAweDAwLFxuICAvLyBwdWJsaWMga2V5XG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4gIDB4MDBcbl0pXG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHJlc3VsdCA9IEJ1ZmZlci5mcm9tKGNvbXByZXNzZWQgPyBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA6IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9VTkNPTVBSRVNTRUQpXG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSlcbiAgcHVibGljS2V5LmNvcHkocmVzdWx0LCBjb21wcmVzc2VkID8gMTgxIDogMjE0KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleUltcG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBsZW5ndGggPSBwcml2YXRlS2V5Lmxlbmd0aFxuXG4gIC8vIHNlcXVlbmNlIGhlYWRlclxuICB2YXIgaW5kZXggPSAwXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVyblxuICBpbmRleCArPSAxXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGNvbnN0cnVjdG9yXG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgIShwcml2YXRlS2V5W2luZGV4XSAmIDB4ODApKSByZXR1cm5cblxuICB2YXIgbGVuYiA9IHByaXZhdGVLZXlbaW5kZXhdICYgMHg3ZlxuICBpbmRleCArPSAxXG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuXG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVyblxuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApXG4gIGluZGV4ICs9IGxlbmJcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgbGVuKSByZXR1cm5cblxuICAvLyBzZXF1ZW5jZSBlbGVtZW50IDA6IHZlcnNpb24gbnVtYmVyICg9MSlcbiAgaWYgKGxlbmd0aCA8IGluZGV4ICsgMyB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MDIgfHxcbiAgICAgIHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDJdICE9PSAweDAxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaW5kZXggKz0gM1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8XG4gICAgICBwcml2YXRlS2V5W2luZGV4XSAhPT0gMHgwNCB8fFxuICAgICAgcHJpdmF0ZUtleVtpbmRleCArIDFdID4gMHgyMCB8fFxuICAgICAgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSlcbn1cblxuZXhwb3J0cy5zaWduYXR1cmVFeHBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgc2lnT2JqLnJdKVxuICBmb3IgKHZhciBsZW5SID0gMzMsIHBvc1IgPSAwOyBsZW5SID4gMSAmJiByW3Bvc1JdID09PSAweDAwICYmICEocltwb3NSICsgMV0gJiAweDgwKTsgLS1sZW5SLCArK3Bvc1IpO1xuXG4gIHZhciBzID0gQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzBdKSwgc2lnT2JqLnNdKVxuICBmb3IgKHZhciBsZW5TID0gMzMsIHBvc1MgPSAwOyBsZW5TID4gMSAmJiBzW3Bvc1NdID09PSAweDAwICYmICEoc1twb3NTICsgMV0gJiAweDgwKTsgLS1sZW5TLCArK3Bvc1MpO1xuXG4gIHJldHVybiBiaXA2Ni5lbmNvZGUoci5zbGljZShwb3NSKSwgcy5zbGljZShwb3NTKSlcbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMClcblxuICB0cnkge1xuICAgIHZhciBzaWdPYmogPSBiaXA2Ni5kZWNvZGUoc2lnKVxuICAgIGlmIChzaWdPYmouci5sZW5ndGggPT09IDMzICYmIHNpZ09iai5yWzBdID09PSAweDAwKSBzaWdPYmouciA9IHNpZ09iai5yLnNsaWNlKDEpXG4gICAgaWYgKHNpZ09iai5yLmxlbmd0aCA+IDMyKSB0aHJvdyBuZXcgRXJyb3IoJ1IgbGVuZ3RoIGlzIHRvbyBsb25nJylcbiAgICBpZiAoc2lnT2JqLnMubGVuZ3RoID09PSAzMyAmJiBzaWdPYmouc1swXSA9PT0gMHgwMCkgc2lnT2JqLnMgPSBzaWdPYmoucy5zbGljZSgxKVxuICAgIGlmIChzaWdPYmoucy5sZW5ndGggPiAzMikgdGhyb3cgbmV3IEVycm9yKCdTIGxlbmd0aCBpcyB0b28gbG9uZycpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVyblxuICB9XG5cbiAgc2lnT2JqLnIuY29weShyLCAzMiAtIHNpZ09iai5yLmxlbmd0aClcbiAgc2lnT2JqLnMuY29weShzLCAzMiAtIHNpZ09iai5zLmxlbmd0aClcblxuICByZXR1cm4geyByOiByLCBzOiBzIH1cbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnRMYXggPSBmdW5jdGlvbiAoc2lnKSB7XG4gIHZhciByID0gQnVmZmVyLmFsbG9jKDMyLCAwKVxuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMClcblxuICB2YXIgbGVuZ3RoID0gc2lnLmxlbmd0aFxuICB2YXIgaW5kZXggPSAwXG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ1tpbmRleCsrXSAhPT0gMHgzMCkgcmV0dXJuXG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWdbaW5kZXgrK11cbiAgaWYgKGxlbmJ5dGUgJiAweDgwKSB7XG4gICAgaW5kZXggKz0gbGVuYnl0ZSAtIDB4ODBcbiAgICBpZiAoaW5kZXggPiBsZW5ndGgpIHJldHVyblxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ1tpbmRleCsrXSAhPT0gMHgwMikgcmV0dXJuXG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnW2luZGV4KytdXG4gIGlmIChybGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBybGVuIC0gMHg4MFxuICAgIGlmIChpbmRleCArIGxlbmJ5dGUgPiBsZW5ndGgpIHJldHVyblxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWdbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpO1xuICAgIGZvciAocmxlbiA9IDA7IGxlbmJ5dGUgPiAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHJsZW4gPSAocmxlbiA8PCA4KSArIHNpZ1tpbmRleF1cbiAgfVxuICBpZiAocmxlbiA+IGxlbmd0aCAtIGluZGV4KSByZXR1cm5cbiAgdmFyIHJpbmRleCA9IGluZGV4XG4gIGluZGV4ICs9IHJsZW5cblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnW2luZGV4KytdICE9PSAweDAyKSByZXR1cm5cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWdbaW5kZXgrK11cbiAgaWYgKHNsZW4gJiAweDgwKSB7XG4gICAgbGVuYnl0ZSA9IHNsZW4gLSAweDgwXG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkgcmV0dXJuXG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ1tpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSk7XG4gICAgZm9yIChzbGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkgc2xlbiA9IChzbGVuIDw8IDgpICsgc2lnW2luZGV4XVxuICB9XG4gIGlmIChzbGVuID4gbGVuZ3RoIC0gaW5kZXgpIHJldHVyblxuICB2YXIgc2luZGV4ID0gaW5kZXhcbiAgaW5kZXggKz0gc2xlblxuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ1tyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKTtcbiAgLy8gY29weSByIHZhbHVlXG4gIGlmIChybGVuID4gMzIpIHJldHVyblxuICB2YXIgcnZhbHVlID0gc2lnLnNsaWNlKHJpbmRleCwgcmluZGV4ICsgcmxlbilcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKVxuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHNcbiAgZm9yICg7IHNsZW4gPiAwICYmIHNpZ1tzaW5kZXhdID09PSAweDAwOyBzbGVuIC09IDEsIHNpbmRleCArPSAxKTtcbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHJldHVyblxuICB2YXIgc3ZhbHVlID0gc2lnLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbilcbiAgc3ZhbHVlLmNvcHkocywgMzIgLSBzdmFsdWUubGVuZ3RoKVxuXG4gIHJldHVybiB7IHI6IHIsIHM6IHMgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbnZhciBjcmVhdGVIYXNoID0gcmVxdWlyZSgnY3JlYXRlLWhhc2gnKVxudmFyIEJOID0gcmVxdWlyZSgnYm4uanMnKVxudmFyIEVDID0gcmVxdWlyZSgnZWxsaXB0aWMnKS5lY1xuXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuLi9tZXNzYWdlcy5qc29uJylcblxudmFyIGVjID0gbmV3IEVDKCdzZWNwMjU2azEnKVxudmFyIGVjcGFyYW1zID0gZWMuY3VydmVcblxuZnVuY3Rpb24gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkgKGZpcnN0LCB4QnVmZmVyKSB7XG4gIHZhciB4ID0gbmV3IEJOKHhCdWZmZXIpXG5cbiAgLy8gb3ZlcmZsb3dcbiAgaWYgKHguY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG4gIHggPSB4LnRvUmVkKGVjcGFyYW1zLnJlZClcblxuICAvLyBjb21wdXRlIGNvcnJlc3BvbmRpbmcgWVxuICB2YXIgeSA9IHgucmVkU3FyKCkucmVkSU11bCh4KS5yZWRJQWRkKGVjcGFyYW1zLmIpLnJlZFNxcnQoKVxuICBpZiAoKGZpcnN0ID09PSAweDAzKSAhPT0geS5pc09kZCgpKSB5ID0geS5yZWROZWcoKVxuXG4gIHJldHVybiBlYy5rZXlQYWlyKHsgcHViOiB7IHg6IHgsIHk6IHkgfSB9KVxufVxuXG5mdW5jdGlvbiBsb2FkVW5jb21wcmVzc2VkUHVibGljS2V5IChmaXJzdCwgeEJ1ZmZlciwgeUJ1ZmZlcikge1xuICB2YXIgeCA9IG5ldyBCTih4QnVmZmVyKVxuICB2YXIgeSA9IG5ldyBCTih5QnVmZmVyKVxuXG4gIC8vIG92ZXJmbG93XG4gIGlmICh4LmNtcChlY3BhcmFtcy5wKSA+PSAwIHx8IHkuY21wKGVjcGFyYW1zLnApID49IDApIHJldHVybiBudWxsXG5cbiAgeCA9IHgudG9SZWQoZWNwYXJhbXMucmVkKVxuICB5ID0geS50b1JlZChlY3BhcmFtcy5yZWQpXG5cbiAgLy8gaXMgb2RkIGZsYWdcbiAgaWYgKChmaXJzdCA9PT0gMHgwNiB8fCBmaXJzdCA9PT0gMHgwNykgJiYgeS5pc09kZCgpICE9PSAoZmlyc3QgPT09IDB4MDcpKSByZXR1cm4gbnVsbFxuXG4gIC8vIHgqeCp4ICsgYiA9IHkqeVxuICB2YXIgeDMgPSB4LnJlZFNxcigpLnJlZElNdWwoeClcbiAgaWYgKCF5LnJlZFNxcigpLnJlZElTdWIoeDMucmVkSUFkZChlY3BhcmFtcy5iKSkuaXNaZXJvKCkpIHJldHVybiBudWxsXG5cbiAgcmV0dXJuIGVjLmtleVBhaXIoeyBwdWI6IHsgeDogeCwgeTogeSB9IH0pXG59XG5cbmZ1bmN0aW9uIGxvYWRQdWJsaWNLZXkgKHB1YmxpY0tleSkge1xuICB2YXIgZmlyc3QgPSBwdWJsaWNLZXlbMF1cbiAgc3dpdGNoIChmaXJzdCkge1xuICAgIGNhc2UgMHgwMjpcbiAgICBjYXNlIDB4MDM6XG4gICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZENvbXByZXNzZWRQdWJsaWNLZXkoZmlyc3QsIHB1YmxpY0tleS5zbGljZSgxLCAzMykpXG4gICAgY2FzZSAweDA0OlxuICAgIGNhc2UgMHgwNjpcbiAgICBjYXNlIDB4MDc6XG4gICAgICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHJldHVybiBudWxsXG4gICAgICByZXR1cm4gbG9hZFVuY29tcHJlc3NlZFB1YmxpY0tleShmaXJzdCwgcHVibGljS2V5LnNsaWNlKDEsIDMzKSwgcHVibGljS2V5LnNsaWNlKDMzLCA2NSkpXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgdmFyIGJuID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIHJldHVybiBibi5jbXAoZWNwYXJhbXMubikgPCAwICYmICFibi5pc1plcm8oKVxufVxuXG5leHBvcnRzLnByaXZhdGVLZXlFeHBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgY29tcHJlc3NlZCkge1xuICB2YXIgZCA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoZC5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBkLmlzWmVybygpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfRVhQT1JUX0RFUl9GQUlMKVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShlYy5rZXlGcm9tUHJpdmF0ZShwcml2YXRlS2V5KS5nZXRQdWJsaWMoY29tcHJlc3NlZCwgdHJ1ZSkpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleU5lZ2F0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KVxuICByZXR1cm4gYm4uaXNaZXJvKCkgPyBCdWZmZXIuYWxsb2MoMzIpIDogZWNwYXJhbXMubi5zdWIoYm4pLnVtb2QoZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9SQU5HRV9JTlZBTElEKVxuXG4gIHJldHVybiBibi5pbnZtKGVjcGFyYW1zLm4pLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG59XG5cbmV4cG9ydHMucHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHZhciBibiA9IG5ldyBCTih0d2VhaylcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFdFQUtfQUREX0ZBSUwpXG5cbiAgYm4uaWFkZChuZXcgQk4ocHJpdmF0ZUtleSkpXG4gIGlmIChibi5jbXAoZWNwYXJhbXMubikgPj0gMCkgYm4uaXN1YihlY3BhcmFtcy5uKVxuICBpZiAoYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gYm4udG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbn1cblxuZXhwb3J0cy5wcml2YXRlS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSwgdHdlYWspIHtcbiAgdmFyIGJuID0gbmV3IEJOKHR3ZWFrKVxuICBpZiAoYm4uY21wKGVjcGFyYW1zLm4pID49IDAgfHwgYm4uaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UV0VBS19NVUxfRkFJTClcblxuICBibi5pbXVsKG5ldyBCTihwcml2YXRlS2V5KSlcbiAgaWYgKGJuLmNtcChlY3BhcmFtcy5uKSkgYm4gPSBibi51bW9kKGVjcGFyYW1zLm4pXG5cbiAgcmV0dXJuIGJuLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpXG59XG5cbmV4cG9ydHMucHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIGQgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKGQuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgZC5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfQ1JFQVRFX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGVjLmtleUZyb21Qcml2YXRlKHByaXZhdGVLZXkpLmdldFB1YmxpYyhjb21wcmVzc2VkLCB0cnVlKSlcbn1cblxuZXhwb3J0cy5wdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocGFpci5nZXRQdWJsaWMoY29tcHJlc3NlZCwgdHJ1ZSkpXG59XG5cbmV4cG9ydHMucHVibGljS2V5VmVyaWZ5ID0gZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICByZXR1cm4gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpICE9PSBudWxsXG59XG5cbmV4cG9ydHMucHVibGljS2V5VHdlYWtBZGQgPSBmdW5jdGlvbiAocHVibGljS2V5LCB0d2VhaywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpciA9IGxvYWRQdWJsaWNLZXkocHVibGljS2V5KVxuICBpZiAocGFpciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcblxuICB0d2VhayA9IG5ldyBCTih0d2VhaylcbiAgaWYgKHR3ZWFrLmNtcChlY3BhcmFtcy5uKSA+PSAwKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTClcblxuICB2YXIgcG9pbnQgPSBlY3BhcmFtcy5nLm11bCh0d2VhaykuYWRkKHBhaXIucHViKVxuICBpZiAocG9pbnQuaXNJbmZpbml0eSgpKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UV0VBS19BRERfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleVR3ZWFrTXVsID0gZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBhaXIgPSBsb2FkUHVibGljS2V5KHB1YmxpY0tleSlcbiAgaWYgKHBhaXIgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1BBUlNFX0ZBSUwpXG5cbiAgdHdlYWsgPSBuZXcgQk4odHdlYWspXG4gIGlmICh0d2Vhay5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCB0d2Vhay5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFdFQUtfTVVMX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhaXIucHViLm11bCh0d2VhaykuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICB2YXIgcGFpcnMgPSBuZXcgQXJyYXkocHVibGljS2V5cy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHVibGljS2V5cy5sZW5ndGg7ICsraSkge1xuICAgIHBhaXJzW2ldID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXlzW2ldKVxuICAgIGlmIChwYWlyc1tpXSA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfUEFSU0VfRkFJTClcbiAgfVxuXG4gIHZhciBwb2ludCA9IHBhaXJzWzBdLnB1YlxuICBmb3IgKHZhciBqID0gMTsgaiA8IHBhaXJzLmxlbmd0aDsgKytqKSBwb2ludCA9IHBvaW50LmFkZChwYWlyc1tqXS5wdWIpXG4gIGlmIChwb2ludC5pc0luZmluaXR5KCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0NPTUJJTkVfRkFJTClcblxuICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxufVxuXG5leHBvcnRzLnNpZ25hdHVyZU5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSlcbiAgdmFyIHMgPSBuZXcgQk4oc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkpXG4gIGlmIChyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHMuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oc2lnbmF0dXJlKVxuICBpZiAocy5jbXAoZWMubmgpID09PSAxKSBlY3BhcmFtcy5uLnN1YihzKS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHJlc3VsdCwgMzIpXG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5leHBvcnRzLnNpZ25hdHVyZUV4cG9ydCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBzaWduYXR1cmUuc2xpY2UoMCwgMzIpXG4gIHZhciBzID0gc2lnbmF0dXJlLnNsaWNlKDMyLCA2NClcbiAgaWYgKG5ldyBCTihyKS5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBuZXcgQk4ocykuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcblxuICByZXR1cm4geyByOiByLCBzOiBzIH1cbn1cblxuZXhwb3J0cy5zaWduYXR1cmVJbXBvcnQgPSBmdW5jdGlvbiAoc2lnT2JqKSB7XG4gIHZhciByID0gbmV3IEJOKHNpZ09iai5yKVxuICBpZiAoci5jbXAoZWNwYXJhbXMubikgPj0gMCkgciA9IG5ldyBCTigwKVxuXG4gIHZhciBzID0gbmV3IEJOKHNpZ09iai5zKVxuICBpZiAocy5jbXAoZWNwYXJhbXMubikgPj0gMCkgcyA9IG5ldyBCTigwKVxuXG4gIHJldHVybiBCdWZmZXIuY29uY2F0KFtcbiAgICByLnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLFxuICAgIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMilcbiAgXSlcbn1cblxuZXhwb3J0cy5zaWduID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHByaXZhdGVLZXksIG5vbmNlZm4sIGRhdGEpIHtcbiAgaWYgKHR5cGVvZiBub25jZWZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGdldE5vbmNlID0gbm9uY2VmblxuICAgIG5vbmNlZm4gPSBmdW5jdGlvbiAoY291bnRlcikge1xuICAgICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UobWVzc2FnZSwgcHJpdmF0ZUtleSwgbnVsbCwgZGF0YSwgY291bnRlcilcbiAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKG5vbmNlKSB8fCBub25jZS5sZW5ndGggIT09IDMyKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTl9GQUlMKVxuXG4gICAgICByZXR1cm4gbmV3IEJOKG5vbmNlKVxuICAgIH1cbiAgfVxuXG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpXG4gIGlmIChkLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IGQuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOX0ZBSUwpXG5cbiAgdmFyIHJlc3VsdCA9IGVjLnNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgeyBjYW5vbmljYWw6IHRydWUsIGs6IG5vbmNlZm4sIHBlcnM6IGRhdGEgfSlcbiAgcmV0dXJuIHtcbiAgICBzaWduYXR1cmU6IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgcmVzdWx0LnIudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksXG4gICAgICByZXN1bHQucy50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKVxuICAgIF0pLFxuICAgIHJlY292ZXJ5OiByZXN1bHQucmVjb3ZlcnlQYXJhbVxuICB9XG59XG5cbmV4cG9ydHMudmVyaWZ5ID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIHZhciBzaWdPYmogPSB7IHI6IHNpZ25hdHVyZS5zbGljZSgwLCAzMiksIHM6IHNpZ25hdHVyZS5zbGljZSgzMiwgNjQpIH1cblxuICB2YXIgc2lnciA9IG5ldyBCTihzaWdPYmoucilcbiAgdmFyIHNpZ3MgPSBuZXcgQk4oc2lnT2JqLnMpXG4gIGlmIChzaWdyLmNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNpZ3MuY21wKGVjcGFyYW1zLm4pID49IDApIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfRkFJTClcbiAgaWYgKHNpZ3MuY21wKGVjLm5oKSA9PT0gMSB8fCBzaWdyLmlzWmVybygpIHx8IHNpZ3MuaXNaZXJvKCkpIHJldHVybiBmYWxzZVxuXG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHJldHVybiBlYy52ZXJpZnkobWVzc2FnZSwgc2lnT2JqLCB7IHg6IHBhaXIucHViLngsIHk6IHBhaXIucHViLnkgfSlcbn1cblxuZXhwb3J0cy5yZWNvdmVyID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjb3ZlcnksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHNpZ09iaiA9IHsgcjogc2lnbmF0dXJlLnNsaWNlKDAsIDMyKSwgczogc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCkgfVxuXG4gIHZhciBzaWdyID0gbmV3IEJOKHNpZ09iai5yKVxuICB2YXIgc2lncyA9IG5ldyBCTihzaWdPYmoucylcbiAgaWYgKHNpZ3IuY21wKGVjcGFyYW1zLm4pID49IDAgfHwgc2lncy5jbXAoZWNwYXJhbXMubikgPj0gMCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMKVxuXG4gIHRyeSB7XG4gICAgaWYgKHNpZ3IuaXNaZXJvKCkgfHwgc2lncy5pc1plcm8oKSkgdGhyb3cgbmV3IEVycm9yKClcblxuICAgIHZhciBwb2ludCA9IGVjLnJlY292ZXJQdWJLZXkobWVzc2FnZSwgc2lnT2JqLCByZWNvdmVyeSlcbiAgICByZXR1cm4gQnVmZmVyLmZyb20ocG9pbnQuZW5jb2RlKHRydWUsIGNvbXByZXNzZWQpKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfUkVDT1ZFUl9GQUlMKVxuICB9XG59XG5cbmV4cG9ydHMuZWNkaCA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNoYXJlZCA9IGV4cG9ydHMuZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIHRydWUpXG4gIHJldHVybiBjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoc2hhcmVkKS5kaWdlc3QoKVxufVxuXG5leHBvcnRzLmVjZGhVbnNhZmUgPSBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBwYWlyID0gbG9hZFB1YmxpY0tleShwdWJsaWNLZXkpXG4gIGlmIChwYWlyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMKVxuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSlcbiAgaWYgKHNjYWxhci5jbXAoZWNwYXJhbXMubikgPj0gMCB8fCBzY2FsYXIuaXNaZXJvKCkpIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RIX0ZBSUwpXG5cbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHBhaXIucHViLm11bChzY2FsYXIpLmVuY29kZSh0cnVlLCBjb21wcmVzc2VkKSlcbn1cbiIsIid1c2Ugc3RyaWN0J1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4vYXNzZXJ0JylcbnZhciBkZXIgPSByZXF1aXJlKCcuL2RlcicpXG52YXIgbWVzc2FnZXMgPSByZXF1aXJlKCcuL21lc3NhZ2VzLmpzb24nKVxuXG5mdW5jdGlvbiBpbml0Q29tcHJlc3NlZFZhbHVlICh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZGVmYXVsdFZhbHVlXG5cbiAgYXNzZXJ0LmlzQm9vbGVhbih2YWx1ZSwgbWVzc2FnZXMuQ09NUFJFU1NFRF9UWVBFX0lOVkFMSUQpXG4gIHJldHVybiB2YWx1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzZWNwMjU2azEpIHtcbiAgcmV0dXJuIHtcbiAgICBwcml2YXRlS2V5VmVyaWZ5OiBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIHJldHVybiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkocHJpdmF0ZUtleSlcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleUV4cG9ydDogZnVuY3Rpb24gKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuICAgICAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMS5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIGNvbXByZXNzZWQpXG5cbiAgICAgIHJldHVybiBkZXIucHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBwdWJsaWNLZXksIGNvbXByZXNzZWQpXG4gICAgfSxcblxuICAgIHByaXZhdGVLZXlJbXBvcnQ6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuXG4gICAgICBwcml2YXRlS2V5ID0gZGVyLnByaXZhdGVLZXlJbXBvcnQocHJpdmF0ZUtleSlcbiAgICAgIGlmIChwcml2YXRlS2V5ICYmIHByaXZhdGVLZXkubGVuZ3RoID09PSAzMiAmJiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkgcmV0dXJuIHByaXZhdGVLZXlcblxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0lNUE9SVF9ERVJfRkFJTClcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU5lZ2F0ZTogZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlOZWdhdGUocHJpdmF0ZUtleSlcbiAgICB9LFxuXG4gICAgcHJpdmF0ZUtleU1vZEludmVyc2U6IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtBZGQ6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcih0d2VhaywgbWVzc2FnZXMuVFdFQUtfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHR3ZWFrLCAzMiwgbWVzc2FnZXMuVFdFQUtfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKVxuICAgIH0sXG5cbiAgICBwcml2YXRlS2V5VHdlYWtNdWw6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCB0d2Vhaykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHByaXZhdGVLZXksIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChwcml2YXRlS2V5LCAzMiwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcih0d2VhaywgbWVzc2FnZXMuVFdFQUtfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHR3ZWFrLCAzMiwgbWVzc2FnZXMuVFdFQUtfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDcmVhdGU6IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHJpdmF0ZUtleSwgbWVzc2FnZXMuRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKHByaXZhdGVLZXksIDMyLCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgY29tcHJlc3NlZClcbiAgICB9LFxuXG4gICAgcHVibGljS2V5Q29udmVydDogZnVuY3Rpb24gKHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHB1YmxpY0tleSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgyKHB1YmxpY0tleSwgMzMsIDY1LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlWZXJpZnk6IGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkocHVibGljS2V5KVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha0FkZDogZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlUd2Vha011bDogZnVuY3Rpb24gKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHR3ZWFrLCBtZXNzYWdlcy5UV0VBS19UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgodHdlYWssIDMyLCBtZXNzYWdlcy5UV0VBS19MRU5HVEhfSU5WQUxJRClcblxuICAgICAgY29tcHJlc3NlZCA9IGluaXRDb21wcmVzc2VkVmFsdWUoY29tcHJlc3NlZCwgdHJ1ZSlcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBwdWJsaWNLZXlDb21iaW5lOiBmdW5jdGlvbiAocHVibGljS2V5cywgY29tcHJlc3NlZCkge1xuICAgICAgYXNzZXJ0LmlzQXJyYXkocHVibGljS2V5cywgbWVzc2FnZXMuRUNfUFVCTElDX0tFWVNfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHB1YmxpY0tleXMsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlTX0xFTkdUSF9JTlZBTElEKVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdWJsaWNLZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXlzW2ldLCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXlzW2ldLCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG4gICAgICB9XG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5Q29tYmluZShwdWJsaWNLZXlzLCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBzaWduYXR1cmVOb3JtYWxpemU6IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgICAgIGFzc2VydC5pc0J1ZmZlcihzaWduYXR1cmUsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgoc2lnbmF0dXJlLCA2NCwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShzaWduYXR1cmUpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUV4cG9ydDogZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIHZhciBzaWdPYmogPSBzZWNwMjU2azEuc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSlcbiAgICAgIHJldHVybiBkZXIuc2lnbmF0dXJlRXhwb3J0KHNpZ09iailcbiAgICB9LFxuXG4gICAgc2lnbmF0dXJlSW1wb3J0OiBmdW5jdGlvbiAoc2lnKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIoc2lnLCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTGVuZ3RoR1RaZXJvKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgc2lnT2JqID0gZGVyLnNpZ25hdHVyZUltcG9ydChzaWcpXG4gICAgICBpZiAoc2lnT2JqKSByZXR1cm4gc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChzaWdPYmopXG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfUEFSU0VfREVSX0ZBSUwpXG4gICAgfSxcblxuICAgIHNpZ25hdHVyZUltcG9ydExheDogZnVuY3Rpb24gKHNpZykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZywgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0xlbmd0aEdUWmVybyhzaWcsIG1lc3NhZ2VzLkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgdmFyIHNpZ09iaiA9IGRlci5zaWduYXR1cmVJbXBvcnRMYXgoc2lnKVxuICAgICAgaWYgKHNpZ09iaikgcmV0dXJuIHNlY3AyNTZrMS5zaWduYXR1cmVJbXBvcnQoc2lnT2JqKVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0RFUl9GQUlMKVxuICAgIH0sXG5cbiAgICBzaWduOiBmdW5jdGlvbiAobWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICAgICAgYXNzZXJ0LmlzQnVmZmVyKG1lc3NhZ2UsIG1lc3NhZ2VzLk1TRzMyX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChtZXNzYWdlLCAzMiwgbWVzc2FnZXMuTVNHMzJfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICB2YXIgZGF0YSA9IG51bGxcbiAgICAgIHZhciBub25jZWZuID0gbnVsbFxuICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBhc3NlcnQuaXNPYmplY3Qob3B0aW9ucywgbWVzc2FnZXMuT1BUSU9OU19UWVBFX0lOVkFMSUQpXG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYXNzZXJ0LmlzQnVmZmVyKG9wdGlvbnMuZGF0YSwgbWVzc2FnZXMuT1BUSU9OU19EQVRBX1RZUEVfSU5WQUxJRClcbiAgICAgICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgob3B0aW9ucy5kYXRhLCAzMiwgbWVzc2FnZXMuT1BUSU9OU19EQVRBX0xFTkdUSF9JTlZBTElEKVxuICAgICAgICAgIGRhdGEgPSBvcHRpb25zLmRhdGFcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGFzc2VydC5pc0Z1bmN0aW9uKG9wdGlvbnMubm9uY2VmbiwgbWVzc2FnZXMuT1BUSU9OU19OT05DRUZOX1RZUEVfSU5WQUxJRClcbiAgICAgICAgICBub25jZWZuID0gb3B0aW9ucy5ub25jZWZuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS5zaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIG5vbmNlZm4sIGRhdGEpXG4gICAgfSxcblxuICAgIHZlcmlmeTogZnVuY3Rpb24gKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwdWJsaWNLZXksIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoMihwdWJsaWNLZXksIDMzLCA2NSwgbWVzc2FnZXMuRUNfUFVCTElDX0tFWV9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgcmV0dXJuIHNlY3AyNTZrMS52ZXJpZnkobWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkpXG4gICAgfSxcblxuICAgIHJlY292ZXI6IGZ1bmN0aW9uIChtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIobWVzc2FnZSwgbWVzc2FnZXMuTVNHMzJfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzQnVmZmVyTGVuZ3RoKG1lc3NhZ2UsIDMyLCBtZXNzYWdlcy5NU0czMl9MRU5HVEhfSU5WQUxJRClcblxuICAgICAgYXNzZXJ0LmlzQnVmZmVyKHNpZ25hdHVyZSwgbWVzc2FnZXMuRUNEU0FfU0lHTkFUVVJFX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aChzaWduYXR1cmUsIDY0LCBtZXNzYWdlcy5FQ0RTQV9TSUdOQVRVUkVfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc051bWJlcihyZWNvdmVyeSwgbWVzc2FnZXMuUkVDT1ZFUllfSURfVFlQRV9JTlZBTElEKVxuICAgICAgYXNzZXJ0LmlzTnVtYmVySW5JbnRlcnZhbChyZWNvdmVyeSwgLTEsIDQsIG1lc3NhZ2VzLlJFQ09WRVJZX0lEX1ZBTFVFX0lOVkFMSUQpXG5cbiAgICAgIGNvbXByZXNzZWQgPSBpbml0Q29tcHJlc3NlZFZhbHVlKGNvbXByZXNzZWQsIHRydWUpXG5cbiAgICAgIHJldHVybiBzZWNwMjU2azEucmVjb3ZlcihtZXNzYWdlLCBzaWduYXR1cmUsIHJlY292ZXJ5LCBjb21wcmVzc2VkKVxuICAgIH0sXG5cbiAgICBlY2RoOiBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLmVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KVxuICAgIH0sXG5cbiAgICBlY2RoVW5zYWZlOiBmdW5jdGlvbiAocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gICAgICBhc3NlcnQuaXNCdWZmZXIocHVibGljS2V5LCBtZXNzYWdlcy5FQ19QVUJMSUNfS0VZX1RZUEVfSU5WQUxJRClcbiAgICAgIGFzc2VydC5pc0J1ZmZlckxlbmd0aDIocHVibGljS2V5LCAzMywgNjUsIG1lc3NhZ2VzLkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSUQpXG5cbiAgICAgIGFzc2VydC5pc0J1ZmZlcihwcml2YXRlS2V5LCBtZXNzYWdlcy5FQ19QUklWQVRFX0tFWV9UWVBFX0lOVkFMSUQpXG4gICAgICBhc3NlcnQuaXNCdWZmZXJMZW5ndGgocHJpdmF0ZUtleSwgMzIsIG1lc3NhZ2VzLkVDX1BSSVZBVEVfS0VZX0xFTkdUSF9JTlZBTElEKVxuXG4gICAgICBjb21wcmVzc2VkID0gaW5pdENvbXByZXNzZWRWYWx1ZShjb21wcmVzc2VkLCB0cnVlKVxuXG4gICAgICByZXR1cm4gc2VjcDI1NmsxLmVjZGhVbnNhZmUocHVibGljS2V5LCBwcml2YXRlS2V5LCBjb21wcmVzc2VkKVxuICAgIH1cbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIkNPTVBSRVNTRURfVFlQRV9JTlZBTElEXCI6IFwiY29tcHJlc3NlZCBzaG91bGQgYmUgYSBib29sZWFuXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfVFlQRV9JTlZBTElEXCI6IFwicHJpdmF0ZSBrZXkgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfTEVOR1RIX0lOVkFMSURcIjogXCJwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX1JBTkdFX0lOVkFMSURcIjogXCJwcml2YXRlIGtleSByYW5nZSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfVFdFQUtfQUREX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2Ugb3IgcmVzdWx0aW5nIHByaXZhdGUga2V5IGlzIGludmFsaWRcIixcbiAgXCJFQ19QUklWQVRFX0tFWV9UV0VBS19NVUxfRkFJTFwiOiBcInR3ZWFrIG91dCBvZiByYW5nZVwiLFxuICBcIkVDX1BSSVZBVEVfS0VZX0VYUE9SVF9ERVJfRkFJTFwiOiBcImNvdWxkbid0IGV4cG9ydCB0byBERVIgZm9ybWF0XCIsXG4gIFwiRUNfUFJJVkFURV9LRVlfSU1QT1JUX0RFUl9GQUlMXCI6IFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiLFxuICBcIkVDX1BVQkxJQ19LRVlTX1RZUEVfSU5WQUxJRFwiOiBcInB1YmxpYyBrZXlzIHNob3VsZCBiZSBhbiBBcnJheVwiLFxuICBcIkVDX1BVQkxJQ19LRVlTX0xFTkdUSF9JTlZBTElEXCI6IFwicHVibGljIGtleXMgQXJyYXkgc2hvdWxkIGhhdmUgYXQgbGVhc3QgMSBlbGVtZW50XCIsXG4gIFwiRUNfUFVCTElDX0tFWV9UWVBFX0lOVkFMSURcIjogXCJwdWJsaWMga2V5IHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIkVDX1BVQkxJQ19LRVlfTEVOR1RIX0lOVkFMSURcIjogXCJwdWJsaWMga2V5IGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9QQVJTRV9GQUlMXCI6IFwidGhlIHB1YmxpYyBrZXkgY291bGQgbm90IGJlIHBhcnNlZCBvciBpcyBpbnZhbGlkXCIsXG4gIFwiRUNfUFVCTElDX0tFWV9DUkVBVEVfRkFJTFwiOiBcInByaXZhdGUgd2FzIGludmFsaWQsIHRyeSBhZ2FpblwiLFxuICBcIkVDX1BVQkxJQ19LRVlfVFdFQUtfQUREX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2Ugb3IgcmVzdWx0aW5nIHB1YmxpYyBrZXkgaXMgaW52YWxpZFwiLFxuICBcIkVDX1BVQkxJQ19LRVlfVFdFQUtfTVVMX0ZBSUxcIjogXCJ0d2VhayBvdXQgb2YgcmFuZ2VcIixcbiAgXCJFQ19QVUJMSUNfS0VZX0NPTUJJTkVfRkFJTFwiOiBcInRoZSBzdW0gb2YgdGhlIHB1YmxpYyBrZXlzIGlzIG5vdCB2YWxpZFwiLFxuICBcIkVDREhfRkFJTFwiOiBcInNjYWxhciB3YXMgaW52YWxpZCAoemVybyBvciBvdmVyZmxvdylcIixcbiAgXCJFQ0RTQV9TSUdOQVRVUkVfVFlQRV9JTlZBTElEXCI6IFwic2lnbmF0dXJlIHNob3VsZCBiZSBhIEJ1ZmZlclwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9MRU5HVEhfSU5WQUxJRFwiOiBcInNpZ25hdHVyZSBsZW5ndGggaXMgaW52YWxpZFwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9QQVJTRV9GQUlMXCI6IFwiY291bGRuJ3QgcGFyc2Ugc2lnbmF0dXJlXCIsXG4gIFwiRUNEU0FfU0lHTkFUVVJFX1BBUlNFX0RFUl9GQUlMXCI6IFwiY291bGRuJ3QgcGFyc2UgREVSIHNpZ25hdHVyZVwiLFxuICBcIkVDRFNBX1NJR05BVFVSRV9TRVJJQUxJWkVfREVSX0ZBSUxcIjogXCJjb3VsZG4ndCBzZXJpYWxpemUgc2lnbmF0dXJlIHRvIERFUiBmb3JtYXRcIixcbiAgXCJFQ0RTQV9TSUdOX0ZBSUxcIjogXCJub25jZSBnZW5lcmF0aW9uIGZ1bmN0aW9uIGZhaWxlZCBvciBwcml2YXRlIGtleSBpcyBpbnZhbGlkXCIsXG4gIFwiRUNEU0FfUkVDT1ZFUl9GQUlMXCI6IFwiY291bGRuJ3QgcmVjb3ZlciBwdWJsaWMga2V5IGZyb20gc2lnbmF0dXJlXCIsXG4gIFwiTVNHMzJfVFlQRV9JTlZBTElEXCI6IFwibWVzc2FnZSBzaG91bGQgYmUgYSBCdWZmZXJcIixcbiAgXCJNU0czMl9MRU5HVEhfSU5WQUxJRFwiOiBcIm1lc3NhZ2UgbGVuZ3RoIGlzIGludmFsaWRcIixcbiAgXCJPUFRJT05TX1RZUEVfSU5WQUxJRFwiOiBcIm9wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdFwiLFxuICBcIk9QVElPTlNfREFUQV9UWVBFX0lOVkFMSURcIjogXCJvcHRpb25zLmRhdGEgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiT1BUSU9OU19EQVRBX0xFTkdUSF9JTlZBTElEXCI6IFwib3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkXCIsXG4gIFwiT1BUSU9OU19OT05DRUZOX1RZUEVfSU5WQUxJRFwiOiBcIm9wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvblwiLFxuICBcIlJFQ09WRVJZX0lEX1RZUEVfSU5WQUxJRFwiOiBcInJlY292ZXJ5IHNob3VsZCBiZSBhIE51bWJlclwiLFxuICBcIlJFQ09WRVJZX0lEX1ZBTFVFX0lOVkFMSURcIjogXCJyZWNvdmVyeSBzaG91bGQgaGF2ZSB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCA0XCIsXG4gIFwiVFdFQUtfVFlQRV9JTlZBTElEXCI6IFwidHdlYWsgc2hvdWxkIGJlIGEgQnVmZmVyXCIsXG4gIFwiVFdFQUtfTEVOR1RIX0lOVkFMSURcIjogXCJ0d2VhayBsZW5ndGggaXMgaW52YWxpZFwiXG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgQ29tcG9zZWRTdG9yZSBleHRlbmRzIE9ic2VydmFibGVTdG9yZV8xLk9ic2VydmFibGVTdG9yZSB7XG4gICAgY29uc3RydWN0b3IoY2hpbGRyZW4pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gc2V0IGRlZmF1bHQgc3RhdGVcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoe30pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBjaGlsZHJlblxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuIHx8IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9jaGlsZHJlbikuZm9yRWFjaCgoY2hpbGRLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bY2hpbGRLZXldO1xuICAgICAgICAgICAgdGhpcy5fYWRkQ2hpbGQoY2hpbGRLZXksIGNoaWxkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGlsZChjaGlsZEtleSwgY2hpbGQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlRnJvbUNoaWxkID0gKGNoaWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgc3RhdGVbY2hpbGRLZXldID0gY2hpbGRWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjaGlsZC5zdWJzY3JpYmUodXBkYXRlRnJvbUNoaWxkKTtcbiAgICAgICAgdXBkYXRlRnJvbUNoaWxkKGNoaWxkLmdldFN0YXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29tcG9zZWRTdG9yZSA9IENvbXBvc2VkU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3NlZFN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2NhbFN0b3JhZ2VTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IE9ic2VydmFibGVTdG9yZV8xID0gcmVxdWlyZShcIi4vT2JzZXJ2YWJsZVN0b3JlXCIpO1xuY2xhc3MgTG9jYWxTdG9yYWdlU3RvcmUgZXh0ZW5kcyBPYnNlcnZhYmxlU3RvcmVfMS5PYnNlcnZhYmxlU3RvcmUge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYWxTdG9yYWdlU3RvcmUgLSBjYW5cXCd0IGZpbmQgbG9jYWxTdG9yYWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghb3B0cy5zdG9yYWdlS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsU3RvcmFnZVN0b3JlIC0gbm8gc3RvcmFnZUtleSBzcGVjaWZpZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmFnZUtleSA9IG9wdHMuc3RvcmFnZUtleTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBnbG9iYWwubG9jYWxTdG9yYWdlLmdldEl0ZW0odGhpcy5fc3RvcmFnZUtleSk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkID8gSlNPTi5wYXJzZShzZXJpYWxpemVkKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IEpTT04uc3RyaW5naWZ5KG5ld1N0YXRlKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbC5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9zdG9yYWdlS2V5LCBzZXJpYWxpemVkKTtcbiAgICB9XG59XG5leHBvcnRzLkxvY2FsU3RvcmFnZVN0b3JlID0gTG9jYWxTdG9yYWdlU3RvcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Mb2NhbFN0b3JhZ2VTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVyZ2VkU3RvcmUgPSB2b2lkIDA7XG5jb25zdCBPYnNlcnZhYmxlU3RvcmVfMSA9IHJlcXVpcmUoXCIuL09ic2VydmFibGVTdG9yZVwiKTtcbmNsYXNzIE1lcmdlZFN0b3JlIGV4dGVuZHMgT2JzZXJ2YWJsZVN0b3JlXzEuT2JzZXJ2YWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGlsZHJlbiA9IFtdKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBkZWZhdWx0IHN0YXRlXG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKHt9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICAvLyBzdWJzY3JpYmUgdG8gY2hpbGRyZW5cbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHRoaXMuX2FkZENoaWxkKGNoaWxkKSk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdob2xlU3RhdGUoKTtcbiAgICB9XG4gICAgX2FkZENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNoaWxkLnN1YnNjcmliZSgoKSA9PiB0aGlzLl91cGRhdGVXaG9sZVN0YXRlKCkpO1xuICAgIH1cbiAgICBfdXBkYXRlV2hvbGVTdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRTdGF0ZXMgPSB0aGlzLl9jaGlsZHJlbi5tYXAoKGNoaWxkKSA9PiBjaGlsZC5nZXRTdGF0ZSgpKTtcbiAgICAgICAgLy8gYXBwbHkgc2hhbGxvdyBtZXJnZSBvdmVyIHN0YXRlc1xuICAgICAgICBjb25zdCBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLmNoaWxkU3RhdGVzKTtcbiAgICAgICAgdGhpcy5wdXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5NZXJnZWRTdG9yZSA9IE1lcmdlZFN0b3JlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VkU3RvcmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IHZvaWQgMDtcbmNvbnN0IHNhZmVfZXZlbnRfZW1pdHRlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAbWV0YW1hc2svc2FmZS1ldmVudC1lbWl0dGVyXCIpKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZSBleHRlbmRzIHNhZmVfZXZlbnRfZW1pdHRlcl8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGluaXRTdGF0ZSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIHNldCBpbml0IHN0YXRlXG4gICAgICAgIHRoaXMuX3N0YXRlID0gaW5pdFN0YXRlO1xuICAgIH1cbiAgICAvLyB3cmFwcGVyIGFyb3VuZCBpbnRlcm5hbCBnZXRTdGF0ZVxuICAgIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLy8gd3JhcHBlciBhcm91bmQgaW50ZXJuYWwgcHV0U3RhdGVcbiAgICBwdXRTdGF0ZShuZXdTdGF0ZSkge1xuICAgICAgICB0aGlzLl9wdXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgbmV3U3RhdGUpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZShwYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgLy8gaWYgbm9uLW51bGwgb2JqZWN0LCBtZXJnZVxuICAgICAgICBpZiAocGFydGlhbFN0YXRlICYmIHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLnB1dFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBvYmplY3QsIHVzZSBuZXcgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHV0U3RhdGUocGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzdWJzY3JpYmUgdG8gY2hhbmdlc1xuICAgIHN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMub24oJ3VwZGF0ZScsIGhhbmRsZXIpO1xuICAgIH1cbiAgICAvLyB1bnN1YnNjcmliZSB0byBjaGFuZ2VzXG4gICAgdW5zdWJzY3JpYmUoaGFuZGxlcikge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCd1cGRhdGUnLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLy9cbiAgICAvLyBwcml2YXRlXG4gICAgLy9cbiAgICAvLyByZWFkIGZyb20gcGVyc2lzdGVuY2VcbiAgICBfZ2V0U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gICAgLy8gd3JpdGUgdG8gcGVyc2lzdGVuY2VcbiAgICBfcHV0U3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLk9ic2VydmFibGVTdG9yZSA9IE9ic2VydmFibGVTdG9yZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9ic2VydmFibGVTdG9yZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVBc1N0cmVhbSA9IHZvaWQgMDtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNsYXNzIE9ic2VydmFibGVTdG9yZVN0cmVhbSBleHRlbmRzIHN0cmVhbV8xLkR1cGxleCB7XG4gICAgY29uc3RydWN0b3Iob2JzU3RvcmUpIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgLy8gcGFzcyB2YWx1ZXMsIG5vdCBzZXJpYWxpemF0aW9uc1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGRvbnQgYnVmZmVyIG91dGdvaW5nIHVwZGF0ZXNcbiAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgLy8gc2F2ZSBoYW5kbGVyIHNvIHdlIGNhbiB1bnN1YnNjcmliZSBsYXRlclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSAoc3RhdGUpID0+IHRoaXMucHVzaChzdGF0ZSk7XG4gICAgICAgIC8vIHN1YnNjcmliZSB0byBvYnNTdG9yZSBjaGFuZ2VzXG4gICAgICAgIHRoaXMub2JzU3RvcmUgPSBvYnNTdG9yZTtcbiAgICAgICAgdGhpcy5vYnNTdG9yZS5zdWJzY3JpYmUodGhpcy5oYW5kbGVyKTtcbiAgICB9XG4gICAgLy8gZW1pdCBjdXJyZW50IHN0YXRlIG9uIG5ldyBkZXN0aW5hdGlvblxuICAgIHBpcGUoZGVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waXBlKGRlc3QsIG9wdGlvbnMpO1xuICAgICAgICBkZXN0LndyaXRlKHRoaXMub2JzU3RvcmUuZ2V0U3RhdGUoKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIHdyaXRlIGZyb20gaW5jb21pbmcgc3RyZWFtIHRvIHN0YXRlXG4gICAgX3dyaXRlKGNodW5rLCBfZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMub2JzU3RvcmUucHV0U3RhdGUoY2h1bmspO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAvLyBub29wIC0gb3V0Z29pbmcgc3RyZWFtIGlzIGFza2luZyB1cyBpZiB3ZSBoYXZlIGRhdGEgd2UgYXJlbnQgZ2l2aW5nIGl0XG4gICAgX3JlYWQoX3NpemUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBldmVudCBlbWl0dGVyXG4gICAgX2Rlc3Ryb3koZXJyLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9ic1N0b3JlLnVuc3Vic2NyaWJlKHRoaXMuaGFuZGxlcik7XG4gICAgICAgIHN1cGVyLl9kZXN0cm95KGVyciwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHN0b3JlQXNTdHJlYW0ob2JzU3RvcmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdG9yZVN0cmVhbShvYnNTdG9yZSk7XG59XG5leHBvcnRzLnN0b3JlQXNTdHJlYW0gPSBzdG9yZUFzU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXNTdHJlYW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc1N0cmVhbVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zZWRTdG9yZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTG9jYWxTdG9yYWdlU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL01lcmdlZFN0b3JlXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9PYnNlcnZhYmxlU3RvcmVcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RyYW5zZm9ybVwiKSwgZXhwb3J0cyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3RvcmVUcmFuc2Zvcm1TdHJlYW0gPSB2b2lkIDA7XG5jb25zdCB0aHJvdWdoMl8xID0gcmVxdWlyZShcInRocm91Z2gyXCIpO1xuZnVuY3Rpb24gc3RvcmVUcmFuc2Zvcm1TdHJlYW0oc3luY1RyYW5zZm9ybUZuKSB7XG4gICAgcmV0dXJuIHRocm91Z2gyXzEub2JqKChzdGF0ZSwgX2VuY29kaW5nLCBjYikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBzeW5jVHJhbnNmb3JtRm4oc3RhdGUpO1xuICAgICAgICAgICAgY2IobnVsbCwgbmV3U3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjYihlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5zdG9yZVRyYW5zZm9ybVN0cmVhbSA9IHN0b3JlVHJhbnNmb3JtU3RyZWFtO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNmb3JtLmpzLm1hcCIsInZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKS5UcmFuc2Zvcm1cbiAgLCBpbmhlcml0cyAgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbiAgLCB4dGVuZCAgICAgPSByZXF1aXJlKCd4dGVuZCcpXG5cbmZ1bmN0aW9uIERlc3Ryb3lhYmxlVHJhbnNmb3JtKG9wdHMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0cylcbiAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2Vcbn1cblxuaW5oZXJpdHMoRGVzdHJveWFibGVUcmFuc2Zvcm0sIFRyYW5zZm9ybSlcblxuRGVzdHJveWFibGVUcmFuc2Zvcm0ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihlcnIpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgcmV0dXJuXG4gIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWVcbiAgXG4gIHZhciBzZWxmID0gdGhpc1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGlmIChlcnIpXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIHNlbGYuZW1pdCgnY2xvc2UnKVxuICB9KVxufVxuXG4vLyBhIG5vb3AgX3RyYW5zZm9ybSBmdW5jdGlvblxuZnVuY3Rpb24gbm9vcCAoY2h1bmssIGVuYywgY2FsbGJhY2spIHtcbiAgY2FsbGJhY2sobnVsbCwgY2h1bmspXG59XG5cblxuLy8gY3JlYXRlIGEgbmV3IGV4cG9ydCBmdW5jdGlvbiwgdXNlZCBieSBib3RoIHRoZSBtYWluIGV4cG9ydCBhbmRcbi8vIHRoZSAuY3RvciBleHBvcnQsIGNvbnRhaW5zIGNvbW1vbiBsb2dpYyBmb3IgZGVhbGluZyB3aXRoIGFyZ3VtZW50c1xuZnVuY3Rpb24gdGhyb3VnaDIgKGNvbnN0cnVjdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMsIHRyYW5zZm9ybSwgZmx1c2gpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZmx1c2ggICAgID0gdHJhbnNmb3JtXG4gICAgICB0cmFuc2Zvcm0gPSBvcHRpb25zXG4gICAgICBvcHRpb25zICAgPSB7fVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtICE9ICdmdW5jdGlvbicpXG4gICAgICB0cmFuc2Zvcm0gPSBub29wXG5cbiAgICBpZiAodHlwZW9mIGZsdXNoICE9ICdmdW5jdGlvbicpXG4gICAgICBmbHVzaCA9IG51bGxcblxuICAgIHJldHVybiBjb25zdHJ1Y3Qob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaClcbiAgfVxufVxuXG5cbi8vIG1haW4gZXhwb3J0LCBqdXN0IG1ha2UgbWUgYSB0cmFuc2Zvcm0gc3RyZWFtIVxubW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICB2YXIgdDIgPSBuZXcgRGVzdHJveWFibGVUcmFuc2Zvcm0ob3B0aW9ucylcblxuICB0Mi5fdHJhbnNmb3JtID0gdHJhbnNmb3JtXG5cbiAgaWYgKGZsdXNoKVxuICAgIHQyLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIHQyXG59KVxuXG5cbi8vIG1ha2UgbWUgYSByZXVzYWJsZSBwcm90b3R5cGUgdGhhdCBJIGNhbiBgbmV3YCwgb3IgaW1wbGljaXRseSBgbmV3YFxuLy8gd2l0aCBhIGNvbnN0cnVjdG9yIGNhbGxcbm1vZHVsZS5leHBvcnRzLmN0b3IgPSB0aHJvdWdoMihmdW5jdGlvbiAob3B0aW9ucywgdHJhbnNmb3JtLCBmbHVzaCkge1xuICBmdW5jdGlvbiBUaHJvdWdoMiAob3ZlcnJpZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGhyb3VnaDIpKVxuICAgICAgcmV0dXJuIG5ldyBUaHJvdWdoMihvdmVycmlkZSlcblxuICAgIHRoaXMub3B0aW9ucyA9IHh0ZW5kKG9wdGlvbnMsIG92ZXJyaWRlKVxuXG4gICAgRGVzdHJveWFibGVUcmFuc2Zvcm0uY2FsbCh0aGlzLCB0aGlzLm9wdGlvbnMpXG4gIH1cblxuICBpbmhlcml0cyhUaHJvdWdoMiwgRGVzdHJveWFibGVUcmFuc2Zvcm0pXG5cbiAgVGhyb3VnaDIucHJvdG90eXBlLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgVGhyb3VnaDIucHJvdG90eXBlLl9mbHVzaCA9IGZsdXNoXG5cbiAgcmV0dXJuIFRocm91Z2gyXG59KVxuXG5cbm1vZHVsZS5leHBvcnRzLm9iaiA9IHRocm91Z2gyKGZ1bmN0aW9uIChvcHRpb25zLCB0cmFuc2Zvcm0sIGZsdXNoKSB7XG4gIHZhciB0MiA9IG5ldyBEZXN0cm95YWJsZVRyYW5zZm9ybSh4dGVuZCh7IG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IDE2IH0sIG9wdGlvbnMpKVxuXG4gIHQyLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm1cblxuICBpZiAoZmx1c2gpXG4gICAgdDIuX2ZsdXNoID0gZmx1c2hcblxuICByZXR1cm4gdDJcbn0pXG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNFcXVhbCA9IGV4cG9ydHMuc2VsZWN0SG9va3MgPSB2b2lkIDA7XG4vKipcbiAqIFJldHVybnMgdGhlIHN1YnNldCBvZiB0aGUgc3BlY2lmaWVkIGBob29rc2AgdGhhdCBhcmUgaW5jbHVkZWQgaW4gdGhlXG4gKiBgaG9va05hbWVzYCBvYmplY3QuIFRoaXMgaXMgYSBQcmluY2lwbGUgb2YgTGVhc3QgQXV0aG9yaXR5IChQT0xBKSBtZWFzdXJlXG4gKiB0byBlbnN1cmUgdGhhdCBlYWNoIFJQQyBtZXRob2QgaW1wbGVtZW50YXRpb24gb25seSBoYXMgYWNjZXNzIHRvIHRoZVxuICogQVBJIFwiaG9va3NcIiBpdCBuZWVkcyB0byBkbyBpdHMgam9iLlxuICpcbiAqIEBwYXJhbSBob29rcyAtIFRoZSBob29rcyB0byBzZWxlY3QgZnJvbS5cbiAqIEBwYXJhbSBob29rTmFtZXMgLSBUaGUgbmFtZXMgb2YgdGhlIGhvb2tzIHRvIHNlbGVjdC5cbiAqIEByZXR1cm5zIFRoZSBzZWxlY3RlZCBob29rcy5cbiAqIEB0ZW1wbGF0ZSBIb29rcyAtIFRoZSBob29rcyB0byBzZWxlY3QgZnJvbS5cbiAqIEB0ZW1wbGF0ZSBIb29rTmFtZSAtIFRoZSBuYW1lcyBvZiB0aGUgaG9va3MgdG8gc2VsZWN0LlxuICovXG5mdW5jdGlvbiBzZWxlY3RIb29rcyhob29rcywgaG9va05hbWVzKSB7XG4gICAgaWYgKGhvb2tOYW1lcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoaG9va05hbWVzKS5yZWR1Y2UoKGhvb2tTdWJzZXQsIF9ob29rTmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaG9va05hbWUgPSBfaG9va05hbWU7XG4gICAgICAgICAgICBob29rU3Vic2V0W2hvb2tOYW1lXSA9IGhvb2tzW2hvb2tOYW1lXTtcbiAgICAgICAgICAgIHJldHVybiBob29rU3Vic2V0O1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnRzLnNlbGVjdEhvb2tzID0gc2VsZWN0SG9va3M7XG4vKipcbiAqIENoZWNrcyBpZiBhcnJheSBgYWAgaXMgZXF1YWwgdG8gYXJyYXkgYGJgLiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCBkbyBhIGRlZXBcbiAqIGVxdWFsaXR5IGNoZWNrLiBJdCBvbmx5IGNoZWNrcyBpZiB0aGUgYXJyYXlzIGFyZSB0aGUgc2FtZSBsZW5ndGggYW5kIGlmIGVhY2hcbiAqIGVsZW1lbnQgaW4gYGFgIGlzIGVxdWFsIHRvIChgPT09YCkgdGhlIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBgYmAuXG4gKlxuICogQHBhcmFtIGEgLSBUaGUgZmlyc3QgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSBiIC0gVGhlIHNlY29uZCBhcnJheSB0byBjb21wYXJlLlxuICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWFsLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBiW2luZGV4XSk7XG59XG5leHBvcnRzLmlzRXF1YWwgPSBpc0VxdWFsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfSU5URVJWQUwgPSB2b2lkIDA7XG5jb25zdCBjb250cm9sbGVyc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9jb250cm9sbGVyc1wiKTtcbmNvbnN0IGJpZ251bWJlcl9qc18xID0gcmVxdWlyZShcImJpZ251bWJlci5qc1wiKTtcbmNvbnN0IGJpZ251bWJlcl8xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiKTtcbmNvbnN0IHByb3ZpZGVyc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L3Byb3ZpZGVyc1wiKTtcbmNvbnN0IGJ5dGVzXzEgPSByZXF1aXJlKFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIik7XG5jb25zdCBtYXBWYWx1ZXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL21hcFZhbHVlc1wiKSk7XG5jb25zdCBjbG9uZURlZXBfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSk7XG5jb25zdCB0eXBlc18xID0gcmVxdWlyZShcIi4vdHlwZXNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0YW50c1wiKTtcbmNvbnN0IHsgc2FmZWx5RXhlY3V0ZSB9ID0gY29udHJvbGxlcnNfMS51dGlsO1xuY29uc3QgU0VDT05EID0gMTAwMDtcbmV4cG9ydHMuREVGQVVMVF9JTlRFUlZBTCA9IFNFQ09ORCAqIDU7XG5jbGFzcyBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIgZXh0ZW5kcyBjb250cm9sbGVyc18xLkJhc2VDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih7IG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXROb25jZUxvY2ssIGdldE5ldHdvcmssIHByb3ZpZGVyLCBjb25maXJtRXh0ZXJuYWxUcmFuc2FjdGlvbiwgdHJhY2tNZXRhTWV0cmljc0V2ZW50LCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBpbnRlcnZhbDogZXhwb3J0cy5ERUZBVUxUX0lOVEVSVkFMLFxuICAgICAgICAgICAgY2hhaW5JZDogY29uc3RhbnRzXzEuQ0hBSU5fSURTLkVUSEVSRVVNLFxuICAgICAgICAgICAgY2xpZW50SWQ6ICdkZWZhdWx0JyxcbiAgICAgICAgICAgIHN1cHBvcnRlZENoYWluSWRzOiBbY29uc3RhbnRzXzEuQ0hBSU5fSURTLkVUSEVSRVVNLCBjb25zdGFudHNfMS5DSEFJTl9JRFMuUklOS0VCWV0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge1xuICAgICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZToge1xuICAgICAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zOiB7fSxcbiAgICAgICAgICAgICAgICB1c2VyT3B0SW46IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBmZWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsVHhGZWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIHRyYWRlVHhGZWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsaXZlbmVzczogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0Tm9uY2VMb2NrID0gZ2V0Tm9uY2VMb2NrO1xuICAgICAgICB0aGlzLmdldE5ldHdvcmsgPSBnZXROZXR3b3JrO1xuICAgICAgICB0aGlzLmV0aGVyc1Byb3ZpZGVyID0gbmV3IHByb3ZpZGVyc18xLldlYjNQcm92aWRlcihwcm92aWRlcik7XG4gICAgICAgIHRoaXMuY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb24gPSBjb25maXJtRXh0ZXJuYWxUcmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy50cmFja01ldGFNZXRyaWNzRXZlbnQgPSB0cmFja01ldGFNZXRyaWNzRXZlbnQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVTbWFydFRyYW5zYWN0aW9uc0ZvckNoYWluSWQoKTtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKHsgcHJvdmlkZXI6IG5ld1Byb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gbmV3UHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgICAgICB0aGlzLmluaXRpYWxpemVTbWFydFRyYW5zYWN0aW9uc0ZvckNoYWluSWQoKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tQb2xsKHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5ldGhlcnNQcm92aWRlciA9IG5ldyBwcm92aWRlcnNfMS5XZWIzUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoKGN1cnJlbnRTdGF0ZSkgPT4gdGhpcy5jaGVja1BvbGwoY3VycmVudFN0YXRlKSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgYXN5bmMgZmV0Y2gocmVxdWVzdCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNsaWVudElkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCAoY2xpZW50SWQgJiYgeyAnWC1DbGllbnQtSWQnOiBjbGllbnRJZCB9KSkgfSk7XG4gICAgICAgIHJldHVybiB1dGlsc18xLmhhbmRsZUZldGNoKHJlcXVlc3QsIGZldGNoT3B0aW9ucyk7XG4gICAgfVxuICAgIGNoZWNrUG9sbChzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zIH0gPSBzdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1N0YXRlO1xuICAgICAgICBjb25zdCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPSBzbWFydFRyYW5zYWN0aW9uc1t0aGlzLmNvbmZpZy5jaGFpbklkXTtcbiAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9ucyA9IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9PT0gbnVsbCB8fCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5maWx0ZXIodXRpbHNfMS5pc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVvdXRIYW5kbGUgJiYgKHBlbmRpbmdUcmFuc2FjdGlvbnMgPT09IG51bGwgfHwgcGVuZGluZ1RyYW5zYWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ1RyYW5zYWN0aW9ucy5sZW5ndGgpID4gMCkge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50aW1lb3V0SGFuZGxlICYmIChwZW5kaW5nVHJhbnNhY3Rpb25zID09PSBudWxsIHx8IHBlbmRpbmdUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlbmRpbmdUcmFuc2FjdGlvbnMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdGlhbGl6ZVNtYXJ0VHJhbnNhY3Rpb25zRm9yQ2hhaW5JZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuc3VwcG9ydGVkQ2hhaW5JZHMuaW5jbHVkZXModGhpcy5jb25maWcuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc1N0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUpLCB7IHNtYXJ0VHJhbnNhY3Rpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUuc21hcnRUcmFuc2FjdGlvbnMpLCB7IFt0aGlzLmNvbmZpZy5jaGFpbklkXTogKF9hID0gc21hcnRUcmFuc2FjdGlvbnNTdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1t0aGlzLmNvbmZpZy5jaGFpbklkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10gfSkgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc3VwcG9ydGVkQ2hhaW5JZHMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMudGltZW91dEhhbmRsZSAmJiBjbGVhckludGVydmFsKHRoaXMudGltZW91dEhhbmRsZSk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkQ2hhaW5JZHMuaW5jbHVkZXMoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBzYWZlbHlFeGVjdXRlKCgpID0+IHRoaXMudXBkYXRlU21hcnRUcmFuc2FjdGlvbnMoKSk7XG4gICAgICAgIHRoaXMudGltZW91dEhhbmRsZSA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHNhZmVseUV4ZWN1dGUoKCkgPT4gdGhpcy51cGRhdGVTbWFydFRyYW5zYWN0aW9ucygpKTtcbiAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBhc3luYyBzdG9wKCkge1xuICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVvdXRIYW5kbGUpO1xuICAgICAgICB0aGlzLnRpbWVvdXRIYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldE9wdEluU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLnNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUpLCB7IHVzZXJPcHRJbjogc3RhdGUgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0cmFja1N0eFN0YXR1c0NoYW5nZShzbWFydFRyYW5zYWN0aW9uLCBwcmV2U21hcnRUcmFuc2FjdGlvbikge1xuICAgICAgICBpZiAoIXByZXZTbWFydFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHRyYWNrIHRoZSBmaXJzdCBTVFgsIGJlY2F1c2UgaXQgZG9lc24ndCBoYXZlIGFsbCBuZWNlc3NhcnkgcGFyYW1zLlxuICAgICAgICB9XG4gICAgICAgIGxldCB1cGRhdGVkU21hcnRUcmFuc2FjdGlvbiA9IGNsb25lRGVlcF8xLmRlZmF1bHQoc21hcnRUcmFuc2FjdGlvbik7XG4gICAgICAgIHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjbG9uZURlZXBfMS5kZWZhdWx0KHByZXZTbWFydFRyYW5zYWN0aW9uKSksIHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKCF1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi5zd2FwTWV0YURhdGEgfHxcbiAgICAgICAgICAgICh1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi5zdGF0dXMgPT09IHByZXZTbWFydFRyYW5zYWN0aW9uLnN0YXR1cyAmJlxuICAgICAgICAgICAgICAgIHByZXZTbWFydFRyYW5zYWN0aW9uLnN3YXBNZXRhRGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gSWYgc3RhdHVzIGhhc24ndCBjaGFuZ2VkLCBkb24ndCB0cmFjayBpdCBhZ2Fpbi5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5zaXRpdmVQcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgc3R4X3N0YXR1czogdXBkYXRlZFNtYXJ0VHJhbnNhY3Rpb24uc3RhdHVzLFxuICAgICAgICAgICAgdG9rZW5fZnJvbV9zeW1ib2w6IHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uLnNvdXJjZVRva2VuU3ltYm9sLFxuICAgICAgICAgICAgdG9rZW5fdG9fc3ltYm9sOiB1cGRhdGVkU21hcnRUcmFuc2FjdGlvbi5kZXN0aW5hdGlvblRva2VuU3ltYm9sLFxuICAgICAgICAgICAgcHJvY2Vzc2luZ190aW1lOiB1dGlsc18xLmdldFN0eFByb2Nlc3NpbmdUaW1lKHVwZGF0ZWRTbWFydFRyYW5zYWN0aW9uLnRpbWUpLFxuICAgICAgICAgICAgc3R4X2VuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW50X3N0eF9lbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgc3R4X3VzZXJfb3B0X2luOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyYWNrTWV0YU1ldHJpY3NFdmVudCh7XG4gICAgICAgICAgICBldmVudDogJ1NUWCBTdGF0dXMgVXBkYXRlZCcsXG4gICAgICAgICAgICBjYXRlZ29yeTogJ3N3YXBzJyxcbiAgICAgICAgICAgIHNlbnNpdGl2ZVByb3BlcnRpZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc05ld1NtYXJ0VHJhbnNhY3Rpb24oc21hcnRUcmFuc2FjdGlvblV1aWQpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgeyBzbWFydFRyYW5zYWN0aW9uc1N0YXRlIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zIH0gPSBzbWFydFRyYW5zYWN0aW9uc1N0YXRlO1xuICAgICAgICBjb25zdCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPSBzbWFydFRyYW5zYWN0aW9uc1tjaGFpbklkXTtcbiAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zID09PSBudWxsIHx8IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoc3R4KSA9PiBzdHgudXVpZCA9PT0gc21hcnRUcmFuc2FjdGlvblV1aWQpO1xuICAgICAgICByZXR1cm4gY3VycmVudEluZGV4ID09PSAtMSB8fCBjdXJyZW50SW5kZXggPT09IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdXBkYXRlU21hcnRUcmFuc2FjdGlvbihzbWFydFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBzbWFydFRyYW5zYWN0aW9ucyB9ID0gc21hcnRUcmFuc2FjdGlvbnNTdGF0ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zID0gc21hcnRUcmFuc2FjdGlvbnNbY2hhaW5JZF07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9PT0gbnVsbCB8fCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5maW5kSW5kZXgoKHN0eCkgPT4gc3R4LnV1aWQgPT09IHNtYXJ0VHJhbnNhY3Rpb24udXVpZCk7XG4gICAgICAgIGNvbnN0IGlzTmV3U21hcnRUcmFuc2FjdGlvbiA9IHRoaXMuaXNOZXdTbWFydFRyYW5zYWN0aW9uKHNtYXJ0VHJhbnNhY3Rpb24udXVpZCk7XG4gICAgICAgIHRoaXMudHJhY2tTdHhTdGF0dXNDaGFuZ2Uoc21hcnRUcmFuc2FjdGlvbiwgaXNOZXdTbWFydFRyYW5zYWN0aW9uXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnNbY3VycmVudEluZGV4XSk7XG4gICAgICAgIGlmIChpc05ld1NtYXJ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIGFkZCBzbWFydCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgY2FuY2VsbGVkTm9uY2VJbmRleCA9IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5maW5kSW5kZXgoKHN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKF9hID0gc3R4LnR4UGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9uY2UpID09PSAoKF9iID0gc21hcnRUcmFuc2FjdGlvbi50eFBhcmFtcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm5vbmNlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoKF9jID0gc3R4LnN0YXR1cykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnN0YXJ0c1dpdGgoJ2NhbmNlbGxlZCcpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBjbG9uZURlZXBfMS5kZWZhdWx0KHNtYXJ0VHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgaGlzdG9yeSA9IFtzbmFwc2hvdF07XG4gICAgICAgICAgICBjb25zdCBoaXN0b3JpZmllZFNtYXJ0VHJhbnNhY3Rpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb24pLCB7IGhpc3RvcnkgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0U21hcnRUcmFuc2FjdGlvbnMgPSBjYW5jZWxsZWROb25jZUluZGV4ID4gLTFcbiAgICAgICAgICAgICAgICA/IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAuc2xpY2UoMCwgY2FuY2VsbGVkTm9uY2VJbmRleClcbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMuc2xpY2UoY2FuY2VsbGVkTm9uY2VJbmRleCArIDEpKVxuICAgICAgICAgICAgICAgICAgICAuY29uY2F0KGhpc3RvcmlmaWVkU21hcnRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICA6IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5jb25jYXQoaGlzdG9yaWZpZWRTbWFydFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc1N0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUpLCB7IHNtYXJ0VHJhbnNhY3Rpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUuc21hcnRUcmFuc2FjdGlvbnMpLCB7IFtjaGFpbklkXTogbmV4dFNtYXJ0VHJhbnNhY3Rpb25zIH0pIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChzbWFydFRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuU1VDQ0VTUyB8fFxuICAgICAgICAgICAgc21hcnRUcmFuc2FjdGlvbi5zdGF0dXMgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlJFVkVSVEVEKSAmJlxuICAgICAgICAgICAgIXNtYXJ0VHJhbnNhY3Rpb24uY29uZmlybWVkKSB7XG4gICAgICAgICAgICAvLyBjb25maXJtIHNtYXJ0IHRyYW5zYWN0aW9uXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbiA9IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9uc1tjdXJyZW50SW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgbmV4dFNtYXJ0VHJhbnNhY3Rpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGN1cnJlbnRTbWFydFRyYW5zYWN0aW9uKSwgc21hcnRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB0aGlzLmNvbmZpcm1TbWFydFRyYW5zYWN0aW9uKG5leHRTbWFydFRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc1N0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUpLCB7IHNtYXJ0VHJhbnNhY3Rpb25zOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGUuc21hcnRUcmFuc2FjdGlvbnMpLCB7IFtjaGFpbklkXTogc21hcnRUcmFuc2FjdGlvbnNTdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1tjaGFpbklkXS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXggPT09IGN1cnJlbnRJbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpdGVtKSwgc21hcnRUcmFuc2FjdGlvbikgOiBpdGVtO1xuICAgICAgICAgICAgICAgICAgICB9KSB9KSB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZVNtYXJ0VHJhbnNhY3Rpb25zKCkge1xuICAgICAgICBjb25zdCB7IHNtYXJ0VHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlLnNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyA9IHNtYXJ0VHJhbnNhY3Rpb25zID09PSBudWxsIHx8IHNtYXJ0VHJhbnNhY3Rpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbWFydFRyYW5zYWN0aW9uc1tjaGFpbklkXTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zVG9VcGRhdGUgPSBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIodXRpbHNfMS5pc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nKVxuICAgICAgICAgICAgLm1hcCgoc21hcnRUcmFuc2FjdGlvbikgPT4gc21hcnRUcmFuc2FjdGlvbi51dWlkKTtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uc1RvVXBkYXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmV0Y2hTbWFydFRyYW5zYWN0aW9uc1N0YXR1cyh0cmFuc2FjdGlvbnNUb1VwZGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29uZmlybVNtYXJ0VHJhbnNhY3Rpb24oc21hcnRUcmFuc2FjdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgdHhIYXNoID0gKF9hID0gc21hcnRUcmFuc2FjdGlvbi5zdGF0dXNNZXRhZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1pbmVkSGFzaDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uUmVjZWlwdCA9IGF3YWl0IHRoaXMuZXRoZXJzUHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KHR4SGFzaCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGF3YWl0IHRoaXMuZXRoZXJzUHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24odHhIYXNoKTtcbiAgICAgICAgICAgIGNvbnN0IG1heEZlZVBlckdhcyA9IChfYiA9IHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgICAgICBjb25zdCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IChfYyA9IHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvblJlY2VpcHQgPT09IG51bGwgfHwgdHJhbnNhY3Rpb25SZWNlaXB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0cmFuc2FjdGlvblJlY2VpcHQuYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9ja0RhdGEgPSBhd2FpdCB0aGlzLmV0aGVyc1Byb3ZpZGVyLmdldEJsb2NrKHRyYW5zYWN0aW9uUmVjZWlwdCA9PT0gbnVsbCB8fCB0cmFuc2FjdGlvblJlY2VpcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zYWN0aW9uUmVjZWlwdC5ibG9ja051bWJlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VGZWVQZXJHYXMgPSBibG9ja0RhdGEgPT09IG51bGwgfHwgYmxvY2tEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja0RhdGEuYmFzZUZlZVBlckdhcy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR4UmVjZWlwdCA9IG1hcFZhbHVlc18xLmRlZmF1bHQodHJhbnNhY3Rpb25SZWNlaXB0LCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgYmlnbnVtYmVyXzEuQmlnTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFR4UGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzbWFydFRyYW5zYWN0aW9uLnR4UGFyYW1zKSwgeyBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNhbGwgY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFR4TWV0YSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbiksIHsgaWQ6IHNtYXJ0VHJhbnNhY3Rpb24udXVpZCwgc3RhdHVzOiAnY29uZmlybWVkJywgaGFzaDogdHhIYXNoLCB0eFBhcmFtczogdXBkYXRlZFR4UGFyYW1zIH0pO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSB0eE1ldGEgc25hcHNob3QgZm9yIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IHV0aWxzXzEuc25hcHNob3RGcm9tVHhNZXRhKG9yaWdpbmFsVHhNZXRhKTtcbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyIHByZXZpb3VzIHR4IHN0YXRlIG9ialxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB1dGlsc18xLnJlcGxheUhpc3Rvcnkob3JpZ2luYWxUeE1ldGEuaGlzdG9yeSk7XG4gICAgICAgICAgICAgICAgLy8gZ2VuZXJhdGUgaGlzdG9yeSBlbnRyeSBhbmQgYWRkIHRvIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHV0aWxzXzEuZ2VuZXJhdGVIaXN0b3J5RW50cnkocHJldmlvdXNTdGF0ZSwgc25hcHNob3QsICd0eFN0YXRlTWFuYWdlcjogc2V0dGluZyBzdGF0dXMgdG8gY29uZmlybWVkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhNZXRhID0gZW50cnkubGVuZ3RoID4gMFxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxUeE1ldGEpLCB7IGhpc3Rvcnk6IG9yaWdpbmFsVHhNZXRhLmhpc3RvcnkuY29uY2F0KGVudHJ5KSB9KSA6IG9yaWdpbmFsVHhNZXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybUV4dGVybmFsVHJhbnNhY3Rpb24odHhNZXRhLCB0eFJlY2VpcHQsIGJhc2VGZWVQZXJHYXMpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tNZXRhTWV0cmljc0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdTVFggQ29uZmlybWVkJyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6ICdzd2FwcycsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTbWFydFRyYW5zYWN0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc21hcnRUcmFuc2FjdGlvbiksIHsgY29uZmlybWVkOiB0cnVlIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy50cmFja01ldGFNZXRyaWNzRXZlbnQoe1xuICAgICAgICAgICAgICAgIGV2ZW50OiAnU1RYIENvbmZpcm1hdGlvbiBGYWlsZWQnLFxuICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAnc3dhcHMnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjb25maXJtIGVycm9yJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gISBBc2sgYmFja2VuZCBBUEkgdG8gYWNjZXB0IGxpc3Qgb2YgdXVpZHMgYXMgcGFyYW1zXG4gICAgYXN5bmMgZmV0Y2hTbWFydFRyYW5zYWN0aW9uc1N0YXR1cyh1dWlkcykge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgIHV1aWRzOiB1dWlkcy5qb2luKCcsJyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLkJBVENIX1NUQVRVUywgY2hhaW5JZCl9PyR7cGFyYW1zLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHRoaXMuZmV0Y2godXJsKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZm9yRWFjaCgoW3V1aWQsIHN0eFN0YXR1c10pID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU21hcnRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgc3RhdHVzTWV0YWRhdGE6IHN0eFN0YXR1cyxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHV0aWxzXzEuY2FsY3VsYXRlU3RhdHVzKHN0eFN0YXR1cyksXG4gICAgICAgICAgICAgICAgY2FuY2VsbGFibGU6IHV0aWxzXzEuaXNTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGFibGUoc3R4U3RhdHVzKSxcbiAgICAgICAgICAgICAgICB1dWlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgYXN5bmMgYWRkTm9uY2VUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlTG9jayA9IGF3YWl0IHRoaXMuZ2V0Tm9uY2VMb2NrKHRyYW5zYWN0aW9uLmZyb20pO1xuICAgICAgICBjb25zdCBub25jZSA9IG5vbmNlTG9jay5uZXh0Tm9uY2U7XG4gICAgICAgIG5vbmNlTG9jay5yZWxlYXNlTG9jaygpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbiksIHsgbm9uY2U6IGAweCR7bm9uY2UudG9TdHJpbmcoMTYpfWAgfSk7XG4gICAgfVxuICAgIGNsZWFyRmVlcygpIHtcbiAgICAgICAgY29uc3QgZmVlcyA9IHtcbiAgICAgICAgICAgIGFwcHJvdmFsVHhGZWVzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0cmFkZVR4RmVlczogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBzbWFydFRyYW5zYWN0aW9uc1N0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuc21hcnRUcmFuc2FjdGlvbnNTdGF0ZSksIHsgZmVlcyB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmZWVzO1xuICAgIH1cbiAgICBhc3luYyBnZXRGZWVzKHRyYWRlVHgsIGFwcHJvdmFsVHgpIHtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gW107XG4gICAgICAgIGxldCB1bnNpZ25lZFRyYWRlVHJhbnNhY3Rpb25XaXRoTm9uY2U7XG4gICAgICAgIGlmIChhcHByb3ZhbFR4KSB7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZEFwcHJvdmFsVHJhbnNhY3Rpb25XaXRoTm9uY2UgPSBhd2FpdCB0aGlzLmFkZE5vbmNlVG9UcmFuc2FjdGlvbihhcHByb3ZhbFR4KTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHVuc2lnbmVkQXBwcm92YWxUcmFuc2FjdGlvbldpdGhOb25jZSk7XG4gICAgICAgICAgICB1bnNpZ25lZFRyYWRlVHJhbnNhY3Rpb25XaXRoTm9uY2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYWRlVHgpLCB7IFxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFwcHJvdmFsIHR4LCB0aGUgdHJhZGUgdHgncyBub25jZSBpcyBpbmNyZWFzZWQgYnkgMS5cbiAgICAgICAgICAgICAgICBub25jZTogdXRpbHNfMS5pbmNyZW1lbnROb25jZUluSGV4KHVuc2lnbmVkQXBwcm92YWxUcmFuc2FjdGlvbldpdGhOb25jZS5ub25jZSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bnNpZ25lZFRyYWRlVHJhbnNhY3Rpb25XaXRoTm9uY2UgPSBhd2FpdCB0aGlzLmFkZE5vbmNlVG9UcmFuc2FjdGlvbih0cmFkZVR4KTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbnMucHVzaCh1bnNpZ25lZFRyYWRlVHJhbnNhY3Rpb25XaXRoTm9uY2UpO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaCh1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLkdFVF9GRUVTLCBjaGFpbklkKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHhzOiB0cmFuc2FjdGlvbnMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBhcHByb3ZhbFR4RmVlcztcbiAgICAgICAgbGV0IHRyYWRlVHhGZWVzO1xuICAgICAgICBpZiAoYXBwcm92YWxUeCkge1xuICAgICAgICAgICAgYXBwcm92YWxUeEZlZXMgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudHhzWzBdO1xuICAgICAgICAgICAgdHJhZGVUeEZlZXMgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudHhzWzFdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdHJhZGVUeEZlZXMgPSBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEudHhzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1N0YXRlKSwgeyBmZWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJvdmFsVHhGZWVzLFxuICAgICAgICAgICAgICAgICAgICB0cmFkZVR4RmVlcyxcbiAgICAgICAgICAgICAgICB9IH0pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFwcHJvdmFsVHhGZWVzLFxuICAgICAgICAgICAgdHJhZGVUeEZlZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vICogQWZ0ZXIgdGhpcyBzdWNjZXNzZnVsIGNhbGwgY2xpZW50IG11c3QgYWRkIGEgbm9uY2UgcmVwcmVzZW50YXRpdmUgdG9cbiAgICAvLyAqIHRyYW5zYWN0aW9uIGNvbnRyb2xsZXIgZXh0ZXJuYWwgdHJhbnNhY3Rpb25zIGxpc3RcbiAgICBhc3luYyBzdWJtaXRTaWduZWRUcmFuc2FjdGlvbnMoeyB0eFBhcmFtcywgc2lnbmVkVHJhbnNhY3Rpb25zLCBzaWduZWRDYW5jZWxlZFRyYW5zYWN0aW9ucywgfSkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5mZXRjaCh1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLlNVQk1JVF9UUkFOU0FDVElPTlMsIGNoYWluSWQpLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByYXdUeHM6IHNpZ25lZFRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICByYXdDYW5jZWxUeHM6IHNpZ25lZENhbmNlbGVkVHJhbnNhY3Rpb25zLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgY29uc3QgbWV0YW1hc2tOZXR3b3JrSWQgPSB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgbGV0IHByZVR4QmFsYW5jZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByZVR4QmFsYW5jZUJOID0gYXdhaXQgdGhpcy5ldGhlcnNQcm92aWRlci5nZXRCYWxhbmNlKHR4UGFyYW1zID09PSBudWxsIHx8IHR4UGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eFBhcmFtcy5mcm9tKTtcbiAgICAgICAgICAgIHByZVR4QmFsYW5jZSA9IG5ldyBiaWdudW1iZXJfanNfMS5CaWdOdW1iZXIocHJlVHhCYWxhbmNlQk4udG9IZXhTdHJpbmcoKSkudG9TdHJpbmcoMTYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdldGhlcnMgZXJyb3InLCBlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBub25jZUxvY2sgPSBhd2FpdCB0aGlzLmdldE5vbmNlTG9jayh0eFBhcmFtcyA9PT0gbnVsbCB8fCB0eFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhQYXJhbXMuZnJvbSk7XG4gICAgICAgIGNvbnN0IG5vbmNlID0gYnl0ZXNfMS5oZXhsaWZ5KG5vbmNlTG9jay5uZXh0Tm9uY2UpO1xuICAgICAgICBpZiAodHhQYXJhbXMgJiYgISh0eFBhcmFtcyA9PT0gbnVsbCB8fCB0eFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhQYXJhbXMubm9uY2UpKSB7XG4gICAgICAgICAgICB0eFBhcmFtcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgbm9uY2VEZXRhaWxzIH0gPSBub25jZUxvY2s7XG4gICAgICAgIHRoaXMudXBkYXRlU21hcnRUcmFuc2FjdGlvbih7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgbm9uY2VEZXRhaWxzLFxuICAgICAgICAgICAgbWV0YW1hc2tOZXR3b3JrSWQsXG4gICAgICAgICAgICBwcmVUeEJhbGFuY2UsXG4gICAgICAgICAgICBzdGF0dXM6IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlBFTkRJTkcsXG4gICAgICAgICAgICB0aW1lLFxuICAgICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgICB1dWlkOiBkYXRhLnV1aWQsXG4gICAgICAgICAgICBjYW5jZWxsYWJsZTogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG5vbmNlTG9jay5yZWxlYXNlTG9jaygpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgLy8gVE9ETzogVGhpcyBzaG91bGQgcmV0dXJuIGlmIHRoZSBjYW5jZWxsYXRpb24gd2FzIG9uIGNoYWluIG9yIG5vdCAoZm9yIG5vbmNlIG1hbmFnZW1lbnQpXG4gICAgLy8gQWZ0ZXIgdGhpcyBzdWNjZXNzZnVsIGNhbGwgY2xpZW50IG11c3QgdXBkYXRlIG5vbmNlIHJlcHJlc2VudGF0aXZlXG4gICAgLy8gaW4gdHJhbnNhY3Rpb24gY29udHJvbGxlciBleHRlcm5hbCB0cmFuc2FjdGlvbnMgbGlzdFxuICAgIGFzeW5jIGNhbmNlbFNtYXJ0VHJhbnNhY3Rpb24odXVpZCkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBhd2FpdCB0aGlzLmZldGNoKHV0aWxzXzEuZ2V0QVBJUmVxdWVzdFVSTCh0eXBlc18xLkFQSVR5cGUuQ0FOQ0VMLCBjaGFpbklkKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7IHV1aWQgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaExpdmVuZXNzKCkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBsZXQgbGl2ZW5lc3MgPSBmYWxzZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1dGlsc18xLmdldEFQSVJlcXVlc3RVUkwodHlwZXNfMS5BUElUeXBlLkxJVkVORVNTLCBjaGFpbklkKSk7XG4gICAgICAgICAgICBsaXZlbmVzcyA9IEJvb2xlYW4ocmVzcG9uc2UubGFzdEJsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1wiZmV0Y2hMaXZlbmVzc1wiIEFQSSBjYWxsIGZhaWxlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zU3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5zbWFydFRyYW5zYWN0aW9uc1N0YXRlKSwgeyBsaXZlbmVzcyB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsaXZlbmVzcztcbiAgICB9XG4gICAgYXN5bmMgc2V0U3RhdHVzUmVmcmVzaEludGVydmFsKGludGVydmFsKSB7XG4gICAgICAgIGlmIChpbnRlcnZhbCAhPT0gdGhpcy5jb25maWcuaW50ZXJ2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgaW50ZXJ2YWwgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUcmFuc2FjdGlvbnMoeyBhZGRyZXNzRnJvbSwgc3RhdHVzLCB9KSB7XG4gICAgICAgIGNvbnN0IHsgc21hcnRUcmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGUuc21hcnRUcmFuc2FjdGlvbnNTdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgY3VycmVudFNtYXJ0VHJhbnNhY3Rpb25zID0gc21hcnRUcmFuc2FjdGlvbnMgPT09IG51bGwgfHwgc21hcnRUcmFuc2FjdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNtYXJ0VHJhbnNhY3Rpb25zW2NoYWluSWRdO1xuICAgICAgICBpZiAoIWN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucyB8fCBjdXJyZW50U21hcnRUcmFuc2FjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRTbWFydFRyYW5zYWN0aW9ucy5maWx0ZXIoKHN0eCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgcmV0dXJuIHN0eC5zdGF0dXMgPT09IHN0YXR1cyAmJiAoKF9hID0gc3R4LnR4UGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZnJvbSkgPT09IGFkZHJlc3NGcm9tO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNIQUlOX0lEUyA9IGV4cG9ydHMuQVBJX0JBU0VfVVJMID0gdm9pZCAwO1xuZXhwb3J0cy5BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly90cmFuc2FjdGlvbi5tZXRhc3dhcC5jb2RlZmkubmV0d29yayc7XG5leHBvcnRzLkNIQUlOX0lEUyA9IHtcbiAgICBFVEhFUkVVTTogJzB4MScsXG4gICAgUklOS0VCWTogJzB4NCcsXG4gICAgQlNDOiAnMHgzOCcsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29uc3RhbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bmFzc2lnbmVkLWltcG9ydFxucmVxdWlyZShcImlzb21vcnBoaWMtZmV0Y2hcIik7XG5jb25zdCBTbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9TbWFydFRyYW5zYWN0aW9uc0NvbnRyb2xsZXJcIikpO1xuZXhwb3J0cy5kZWZhdWx0ID0gU21hcnRUcmFuc2FjdGlvbnNDb250cm9sbGVyXzEuZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLyoqIEFQSSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5jZWxsYXRpb25SZWFzb25Ub1N0YXR1c01hcCA9IGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzID0gZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uID0gZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uTWluZWRUeCA9IGV4cG9ydHMuQVBJVHlwZSA9IHZvaWQgMDtcbnZhciBBUElUeXBlO1xuKGZ1bmN0aW9uIChBUElUeXBlKSB7XG4gICAgQVBJVHlwZVtBUElUeXBlW1wiR0VUX0ZFRVNcIl0gPSAwXSA9IFwiR0VUX0ZFRVNcIjtcbiAgICBBUElUeXBlW0FQSVR5cGVbXCJFU1RJTUFURV9HQVNcIl0gPSAxXSA9IFwiRVNUSU1BVEVfR0FTXCI7XG4gICAgQVBJVHlwZVtBUElUeXBlW1wiU1VCTUlUX1RSQU5TQUNUSU9OU1wiXSA9IDJdID0gXCJTVUJNSVRfVFJBTlNBQ1RJT05TXCI7XG4gICAgQVBJVHlwZVtBUElUeXBlW1wiQ0FOQ0VMXCJdID0gM10gPSBcIkNBTkNFTFwiO1xuICAgIEFQSVR5cGVbQVBJVHlwZVtcIkJBVENIX1NUQVRVU1wiXSA9IDRdID0gXCJCQVRDSF9TVEFUVVNcIjtcbiAgICBBUElUeXBlW0FQSVR5cGVbXCJMSVZFTkVTU1wiXSA9IDVdID0gXCJMSVZFTkVTU1wiO1xufSkoQVBJVHlwZSA9IGV4cG9ydHMuQVBJVHlwZSB8fCAoZXhwb3J0cy5BUElUeXBlID0ge30pKTtcbi8qKiBTbWFydFRyYW5zYWN0aW9ucyAqL1xudmFyIFNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4O1xuKGZ1bmN0aW9uIChTbWFydFRyYW5zYWN0aW9uTWluZWRUeCkge1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4W1wiTk9UX01JTkVEXCJdID0gXCJub3RfbWluZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uTWluZWRUeFtcIlNVQ0NFU1NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uTWluZWRUeFtcIkNBTkNFTExFRFwiXSA9IFwiY2FuY2VsbGVkXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvbk1pbmVkVHhbXCJSRVZFUlRFRFwiXSA9IFwicmV2ZXJ0ZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uTWluZWRUeFtcIlVOS05PV05cIl0gPSBcInVua25vd25cIjtcbn0pKFNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4ID0gZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uTWluZWRUeCB8fCAoZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uTWluZWRUeCA9IHt9KSk7XG52YXIgU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbjtcbihmdW5jdGlvbiAoU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbikge1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb25bXCJXT1VMRF9SRVZFUlRcIl0gPSBcIndvdWxkX3JldmVydFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb25bXCJUT09fQ0hFQVBcIl0gPSBcInRvb19jaGVhcFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb25bXCJERUFETElORV9NSVNTRURcIl0gPSBcImRlYWRsaW5lX21pc3NlZFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb25bXCJJTlZBTElEX05PTkNFXCJdID0gXCJpbnZhbGlkX25vbmNlXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbltcIlVTRVJfQ0FOQ0VMTEVEXCJdID0gXCJ1c2VyX2NhbmNlbGxlZFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb25bXCJOT1RfQ0FOQ0VMTEVEXCJdID0gXCJub3RfY2FuY2VsbGVkXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhdGlvblJlYXNvbltcIlBSRVZJT1VTX1RYX0NBTkNFTExFRFwiXSA9IFwicHJldmlvdXNfdHhfY2FuY2VsbGVkXCI7XG59KShTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uID0gZXhwb3J0cy5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uIHx8IChleHBvcnRzLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24gPSB7fSkpO1xudmFyIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcztcbihmdW5jdGlvbiAoU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzKSB7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiUEVORElOR1wiXSA9IFwicGVuZGluZ1wiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIlNVQ0NFU1NcIl0gPSBcInN1Y2Nlc3NcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJSRVZFUlRFRFwiXSA9IFwicmV2ZXJ0ZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJVTktOT1dOXCJdID0gXCJ1bmtub3duXCI7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiQ0FOQ0VMTEVEXCJdID0gXCJjYW5jZWxsZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJDQU5DRUxMRURfV09VTERfUkVWRVJUXCJdID0gXCJjYW5jZWxsZWRfd291bGRfcmV2ZXJ0XCI7XG4gICAgU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzW1wiQ0FOQ0VMTEVEX1RPT19DSEVBUFwiXSA9IFwiY2FuY2VsbGVkX3Rvb19jaGVhcFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIkNBTkNFTExFRF9ERUFETElORV9NSVNTRURcIl0gPSBcImNhbmNlbGxlZF9kZWFkbGluZV9taXNzZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJDQU5DRUxMRURfSU5WQUxJRF9OT05DRVwiXSA9IFwiY2FuY2VsbGVkX2ludmFsaWRfbm9uY2VcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJDQU5DRUxMRURfVVNFUl9DQU5DRUxMRURcIl0gPSBcImNhbmNlbGxlZF91c2VyX2NhbmNlbGxlZFwiO1xuICAgIFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1tcIkNBTkNFTExFRF9QUkVWSU9VU19UWF9DQU5DRUxMRURcIl0gPSBcImNhbmNlbGxlZF9wcmV2aW91c190eF9jYW5jZWxsZWRcIjtcbiAgICBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXNbXCJSRVNPTFZFRFwiXSA9IFwicmVzb2x2ZWRcIjtcbn0pKFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcyA9IGV4cG9ydHMuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzIHx8IChleHBvcnRzLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcyA9IHt9KSk7XG5leHBvcnRzLmNhbmNlbGxhdGlvblJlYXNvblRvU3RhdHVzTWFwID0ge1xuICAgIFtTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLldPVUxEX1JFVkVSVF06IFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5DQU5DRUxMRURfV09VTERfUkVWRVJULFxuICAgIFtTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLlRPT19DSEVBUF06IFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5DQU5DRUxMRURfVE9PX0NIRUFQLFxuICAgIFtTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLkRFQURMSU5FX01JU1NFRF06IFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5DQU5DRUxMRURfREVBRExJTkVfTUlTU0VELFxuICAgIFtTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLklOVkFMSURfTk9OQ0VdOiBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuQ0FOQ0VMTEVEX0lOVkFMSURfTk9OQ0UsXG4gICAgW1NtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uVVNFUl9DQU5DRUxMRURdOiBTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXMuQ0FOQ0VMTEVEX1VTRVJfQ0FOQ0VMTEVELFxuICAgIFtTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLlBSRVZJT1VTX1RYX0NBTkNFTExFRF06IFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5DQU5DRUxMRURfUFJFVklPVVNfVFhfQ0FOQ0VMTEVELFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbmNyZW1lbnROb25jZUluSGV4ID0gZXhwb3J0cy5pc1NtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYWJsZSA9IGV4cG9ydHMuaGFuZGxlRmV0Y2ggPSBleHBvcnRzLm1hcEtleXNUb0NhbWVsID0gZXhwb3J0cy5nZXRTdHhQcm9jZXNzaW5nVGltZSA9IGV4cG9ydHMuc25hcHNob3RGcm9tVHhNZXRhID0gZXhwb3J0cy5yZXBsYXlIaXN0b3J5ID0gZXhwb3J0cy5nZW5lcmF0ZUhpc3RvcnlFbnRyeSA9IGV4cG9ydHMuY2FsY3VsYXRlU3RhdHVzID0gZXhwb3J0cy5nZXRBUElSZXF1ZXN0VVJMID0gZXhwb3J0cy5pc1NtYXJ0VHJhbnNhY3Rpb25TdGF0dXNSZXNvbHZlZCA9IGV4cG9ydHMuaXNTbWFydFRyYW5zYWN0aW9uUGVuZGluZyA9IHZvaWQgMDtcbmNvbnN0IGZhc3RfanNvbl9wYXRjaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJmYXN0LWpzb24tcGF0Y2hcIikpO1xuY29uc3QgbG9kYXNoXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaFwiKSk7XG5jb25zdCBiaWdudW1iZXJfanNfMSA9IHJlcXVpcmUoXCJiaWdudW1iZXIuanNcIik7XG5jb25zdCBieXRlc18xID0gcmVxdWlyZShcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCIpO1xuY29uc3QgdHlwZXNfMSA9IHJlcXVpcmUoXCIuL3R5cGVzXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi9jb25zdGFudHNcIik7XG5mdW5jdGlvbiBpc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nKHNtYXJ0VHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gc21hcnRUcmFuc2FjdGlvbi5zdGF0dXMgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlBFTkRJTkc7XG59XG5leHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvblBlbmRpbmcgPSBpc1NtYXJ0VHJhbnNhY3Rpb25QZW5kaW5nO1xuY29uc3QgaXNTbWFydFRyYW5zYWN0aW9uU3RhdHVzUmVzb2x2ZWQgPSAoc3R4U3RhdHVzKSA9PiBzdHhTdGF0dXMgPT09ICd1dWlkX25vdF9mb3VuZCc7XG5leHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvblN0YXR1c1Jlc29sdmVkID0gaXNTbWFydFRyYW5zYWN0aW9uU3RhdHVzUmVzb2x2ZWQ7XG4vLyBUT0RPIHVzZSBhY3R1YWwgdXJsIG9uY2UgQVBJIGlzIGRlZmluZWRcbmZ1bmN0aW9uIGdldEFQSVJlcXVlc3RVUkwoYXBpVHlwZSwgY2hhaW5JZCkge1xuICAgIGNvbnN0IGNoYWluSWREZWMgPSBwYXJzZUludChjaGFpbklkLCAxNik7XG4gICAgc3dpdGNoIChhcGlUeXBlKSB7XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkdFVF9GRUVTOiB7XG4gICAgICAgICAgICByZXR1cm4gYCR7Y29uc3RhbnRzXzEuQVBJX0JBU0VfVVJMfS9uZXR3b3Jrcy8ke2NoYWluSWREZWN9L2dldEZlZXNgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkVTVElNQVRFX0dBUzoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9lc3RpbWF0ZUdhc2A7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlc18xLkFQSVR5cGUuU1VCTUlUX1RSQU5TQUNUSU9OUzoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9zdWJtaXRUcmFuc2FjdGlvbnNgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkNBTkNFTDoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9jYW5jZWxgO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgdHlwZXNfMS5BUElUeXBlLkJBVENIX1NUQVRVUzoge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLkFQSV9CQVNFX1VSTH0vbmV0d29ya3MvJHtjaGFpbklkRGVjfS9iYXRjaFN0YXR1c2A7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSB0eXBlc18xLkFQSVR5cGUuTElWRU5FU1M6IHtcbiAgICAgICAgICAgIHJldHVybiBgJHtjb25zdGFudHNfMS5BUElfQkFTRV9VUkx9L25ldHdvcmtzLyR7Y2hhaW5JZERlY30vaGVhbHRoYDtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgQVBJVHlwZWApOyAvLyBJdCBjYW4gbmV2ZXIgZ2V0IGhlcmUgdGhhbmtzIHRvIFR5cGVTY3JpcHQuXG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmdldEFQSVJlcXVlc3RVUkwgPSBnZXRBUElSZXF1ZXN0VVJMO1xuY29uc3QgY2FsY3VsYXRlU3RhdHVzID0gKHN0eFN0YXR1cykgPT4ge1xuICAgIGlmIChleHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvblN0YXR1c1Jlc29sdmVkKHN0eFN0YXR1cykpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlJFU09MVkVEO1xuICAgIH1cbiAgICBjb25zdCBjYW5jZWxsYXRpb25zID0gW1xuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uV09VTERfUkVWRVJULFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uVE9PX0NIRUFQLFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uREVBRExJTkVfTUlTU0VELFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uSU5WQUxJRF9OT05DRSxcbiAgICAgICAgdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLlVTRVJfQ0FOQ0VMTEVELFxuICAgICAgICB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYXRpb25SZWFzb24uUFJFVklPVVNfVFhfQ0FOQ0VMTEVELFxuICAgIF07XG4gICAgaWYgKChzdHhTdGF0dXMgPT09IG51bGwgfHwgc3R4U3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHhTdGF0dXMubWluZWRUeCkgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHguTk9UX01JTkVEKSB7XG4gICAgICAgIGlmIChzdHhTdGF0dXMuY2FuY2VsbGF0aW9uUmVhc29uID09PVxuICAgICAgICAgICAgdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLk5PVF9DQU5DRUxMRUQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5QRU5ESU5HO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQ2FuY2VsbGF0aW9uID0gY2FuY2VsbGF0aW9ucy5maW5kSW5kZXgoKGNhbmNlbGxhdGlvbikgPT4gY2FuY2VsbGF0aW9uID09PSBzdHhTdGF0dXMuY2FuY2VsbGF0aW9uUmVhc29uKSA+IC0xO1xuICAgICAgICBpZiAoc3R4U3RhdHVzLmNhbmNlbGxhdGlvblJlYXNvbiAmJiBpc0NhbmNlbGxhdGlvbikge1xuICAgICAgICAgICAgaWYgKCFzdHhTdGF0dXMuaXNTZXR0bGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlBFTkRJTkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZXNfMS5jYW5jZWxsYXRpb25SZWFzb25Ub1N0YXR1c01hcFtzdHhTdGF0dXMuY2FuY2VsbGF0aW9uUmVhc29uXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgoc3R4U3RhdHVzID09PSBudWxsIHx8IHN0eFN0YXR1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R4U3RhdHVzLm1pbmVkVHgpID09PSB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4LlNVQ0NFU1MpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlNVQ0NFU1M7XG4gICAgfVxuICAgIGVsc2UgaWYgKChzdHhTdGF0dXMgPT09IG51bGwgfHwgc3R4U3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHhTdGF0dXMubWluZWRUeCkgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHguQ0FOQ0VMTEVEKSB7XG4gICAgICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5DQU5DRUxMRUQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKChzdHhTdGF0dXMgPT09IG51bGwgfHwgc3R4U3RhdHVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHhTdGF0dXMubWluZWRUeCkgPT09IHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvbk1pbmVkVHguUkVWRVJURUQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlJFVkVSVEVEO1xuICAgIH1cbiAgICBlbHNlIGlmICgoc3R4U3RhdHVzID09PSBudWxsIHx8IHN0eFN0YXR1cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R4U3RhdHVzLm1pbmVkVHgpID09PSB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4LlVOS05PV04pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzXzEuU21hcnRUcmFuc2FjdGlvblN0YXR1c2VzLlVOS05PV047XG4gICAgfVxuICAgIHJldHVybiB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlcy5VTktOT1dOO1xufTtcbmV4cG9ydHMuY2FsY3VsYXRlU3RhdHVzID0gY2FsY3VsYXRlU3RhdHVzO1xuLyoqXG4gIEdlbmVyYXRlcyBhbiBhcnJheSBvZiBoaXN0b3J5IG9iamVjdHMgc2Vuc2UgdGhlIHByZXZpb3VzIHN0YXRlLlxuICBUaGUgb2JqZWN0IGhhcyB0aGUga2V5c1xuICAgIG9wICh0aGUgb3BlcmF0aW9uIHBlcmZvcm1lZCksXG4gICAgcGF0aCAodGhlIGtleSBhbmQgaWYgYSBuZXN0ZWQgb2JqZWN0IHRoZW4gZWFjaCBrZXkgd2lsbCBiZSBzZXBhcmF0ZWQgd2l0aCBhIGAvYClcbiAgICB2YWx1ZVxuICB3aXRoIHRoZSBmaXJzdCBlbnRyeSBoYXZpbmcgdGhlIG5vdGUgYW5kIGEgdGltZXN0YW1wIHdoZW4gdGhlIGNoYW5nZSB0b29rIHBsYWNlXG4gIEBwYXJhbSB7T2JqZWN0fSBwcmV2aW91c1N0YXRlIC0gdGhlIHByZXZpb3VzIHN0YXRlIG9mIHRoZSBvYmplY3RcbiAgQHBhcmFtIHtPYmplY3R9IG5ld1N0YXRlIC0gdGhlIHVwZGF0ZSBvYmplY3RcbiAgQHBhcmFtIHtzdHJpbmd9IFtub3RlXSAtIGEgb3B0aW9uYWwgbm90ZSBmb3IgdGhlIHN0YXRlIGNoYW5nZVxuICBAcmV0dXJucyB7QXJyYXl9XG4qL1xuZnVuY3Rpb24gZ2VuZXJhdGVIaXN0b3J5RW50cnkocHJldmlvdXNTdGF0ZSwgbmV3U3RhdGUsIG5vdGUpIHtcbiAgICBjb25zdCBlbnRyeSA9IGZhc3RfanNvbl9wYXRjaF8xLmRlZmF1bHQuY29tcGFyZShwcmV2aW91c1N0YXRlLCBuZXdTdGF0ZSk7XG4gICAgLy8gQWRkIGEgbm90ZSB0byB0aGUgZmlyc3Qgb3AsIHNpbmNlIGl0IGJyZWFrcyBpZiB3ZSBhcHBlbmQgaXQgdG8gdGhlIGVudHJ5XG4gICAgaWYgKGVudHJ5WzBdKSB7XG4gICAgICAgIGlmIChub3RlKSB7XG4gICAgICAgICAgICBlbnRyeVswXS5ub3RlID0gbm90ZTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeVswXS50aW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59XG5leHBvcnRzLmdlbmVyYXRlSGlzdG9yeUVudHJ5ID0gZ2VuZXJhdGVIaXN0b3J5RW50cnk7XG4vKipcbiAgUmVjb3ZlcnMgcHJldmlvdXMgdHhNZXRhIHN0YXRlIG9ialxuICBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbmZ1bmN0aW9uIHJlcGxheUhpc3RvcnkoX3Nob3J0SGlzdG9yeSkge1xuICAgIGNvbnN0IHNob3J0SGlzdG9yeSA9IGxvZGFzaF8xLmRlZmF1bHQuY2xvbmVEZWVwKF9zaG9ydEhpc3RvcnkpO1xuICAgIHJldHVybiBzaG9ydEhpc3RvcnkucmVkdWNlKCh2YWwsIGVudHJ5KSA9PiBmYXN0X2pzb25fcGF0Y2hfMS5kZWZhdWx0LmFwcGx5UGF0Y2godmFsLCBlbnRyeSkubmV3RG9jdW1lbnQpO1xufVxuZXhwb3J0cy5yZXBsYXlIaXN0b3J5ID0gcmVwbGF5SGlzdG9yeTtcbi8qKlxuICogU25hcHNob3Qge0Bjb2RlIHR4TWV0YX1cbiAqIEBwYXJhbSB7T2JqZWN0fSB0eE1ldGEgLSB0aGUgdHggbWV0YWRhdGEgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIGRlZXAgY2xvbmUgd2l0aG91dCBoaXN0b3J5XG4gKi9cbmZ1bmN0aW9uIHNuYXBzaG90RnJvbVR4TWV0YSh0eE1ldGEpIHtcbiAgICBjb25zdCBzaGFsbG93ID0gT2JqZWN0LmFzc2lnbih7fSwgdHhNZXRhKTtcbiAgICBkZWxldGUgc2hhbGxvdy5oaXN0b3J5O1xuICAgIHJldHVybiBsb2Rhc2hfMS5kZWZhdWx0LmNsb25lRGVlcChzaGFsbG93KTtcbn1cbmV4cG9ydHMuc25hcHNob3RGcm9tVHhNZXRhID0gc25hcHNob3RGcm9tVHhNZXRhO1xuLyoqXG4gKiBSZXR1cm5zIHByb2Nlc3NpbmcgdGltZSBmb3IgYW4gU1RYIGluIHNlY29uZHMuXG4gKiBAcGFyYW0ge251bWJlcn0gc21hcnRUcmFuc2FjdGlvblN1Ym1pdHRlZHRpbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFByb2Nlc3NpbmcgdGltZSBpbiBzZWNvbmRzLlxuICovXG5jb25zdCBnZXRTdHhQcm9jZXNzaW5nVGltZSA9IChzbWFydFRyYW5zYWN0aW9uU3VibWl0dGVkdGltZSkgPT4ge1xuICAgIGlmICghc21hcnRUcmFuc2FjdGlvblN1Ym1pdHRlZHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKERhdGUubm93KCkgLSBzbWFydFRyYW5zYWN0aW9uU3VibWl0dGVkdGltZSkgLyAxMDAwKTtcbn07XG5leHBvcnRzLmdldFN0eFByb2Nlc3NpbmdUaW1lID0gZ2V0U3R4UHJvY2Vzc2luZ1RpbWU7XG5jb25zdCBtYXBLZXlzVG9DYW1lbCA9IChvYmopID0+IHtcbiAgICBpZiAoIWxvZGFzaF8xLmRlZmF1bHQuaXNPYmplY3Qob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCBtYXBwZWRWYWx1ZXMgPSBsb2Rhc2hfMS5kZWZhdWx0Lm1hcFZhbHVlcyhvYmosICh2YWwpID0+IHtcbiAgICAgICAgaWYgKGxvZGFzaF8xLmRlZmF1bHQuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLm1hcChleHBvcnRzLm1hcEtleXNUb0NhbWVsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsb2Rhc2hfMS5kZWZhdWx0LmlzT2JqZWN0KHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLm1hcEtleXNUb0NhbWVsKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcmV0dXJuIGxvZGFzaF8xLmRlZmF1bHQubWFwS2V5cyhtYXBwZWRWYWx1ZXMsICh2YWx1ZSwga2V5KSA9PiBsb2Rhc2hfMS5kZWZhdWx0LmNhbWVsQ2FzZShrZXkpKTtcbn07XG5leHBvcnRzLm1hcEtleXNUb0NhbWVsID0gbWFwS2V5c1RvQ2FtZWw7XG5hc3luYyBmdW5jdGlvbiBoYW5kbGVGZXRjaChyZXF1ZXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcbiAgICBjb25zdCBqc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc29sZS5sb2coYHJlc3BvbnNlYCwgcmVzcG9uc2UpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoIGVycm9yOiR7SlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7IHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzIH0sIGV4cG9ydHMubWFwS2V5c1RvQ2FtZWwoanNvbikpKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzb247XG59XG5leHBvcnRzLmhhbmRsZUZldGNoID0gaGFuZGxlRmV0Y2g7XG5jb25zdCBpc1NtYXJ0VHJhbnNhY3Rpb25DYW5jZWxsYWJsZSA9IChzdHhTdGF0dXMpID0+IHtcbiAgICByZXR1cm4gKHN0eFN0YXR1cy5taW5lZFR4ID09PSB0eXBlc18xLlNtYXJ0VHJhbnNhY3Rpb25NaW5lZFR4Lk5PVF9NSU5FRCAmJlxuICAgICAgICAoIXN0eFN0YXR1cy5jYW5jZWxsYXRpb25SZWFzb24gfHxcbiAgICAgICAgICAgIHN0eFN0YXR1cy5jYW5jZWxsYXRpb25SZWFzb24gPT09XG4gICAgICAgICAgICAgICAgdHlwZXNfMS5TbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGF0aW9uUmVhc29uLk5PVF9DQU5DRUxMRUQpKTtcbn07XG5leHBvcnRzLmlzU21hcnRUcmFuc2FjdGlvbkNhbmNlbGxhYmxlID0gaXNTbWFydFRyYW5zYWN0aW9uQ2FuY2VsbGFibGU7XG5jb25zdCBpbmNyZW1lbnROb25jZUluSGV4ID0gKG5vbmNlSW5IZXgpID0+IHtcbiAgICBjb25zdCBub25jZUluRGVjID0gbmV3IGJpZ251bWJlcl9qc18xLkJpZ051bWJlcihub25jZUluSGV4LCAxNikudG9TdHJpbmcoMTApO1xuICAgIHJldHVybiBieXRlc18xLmhleGxpZnkoTnVtYmVyKG5vbmNlSW5EZWMpICsgMSk7XG59O1xuZXhwb3J0cy5pbmNyZW1lbnROb25jZUluSGV4ID0gaW5jcmVtZW50Tm9uY2VJbkhleDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5CYXNlQ29udHJvbGxlciA9IHZvaWQgMDtcbi8qKlxuICogQ29udHJvbGxlciBjbGFzcyB0aGF0IHByb3ZpZGVzIGNvbmZpZ3VyYXRpb24sIHN0YXRlIG1hbmFnZW1lbnQsIGFuZCBzdWJzY3JpcHRpb25zXG4gKi9cbmNsYXNzIEJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQmFzZUNvbnRyb2xsZXIgaW5zdGFuY2UuIEJvdGggaW5pdGlhbCBzdGF0ZSBhbmQgaW5pdGlhbFxuICAgICAqIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcmUgbWVyZ2VkIHdpdGggZGVmYXVsdHMgdXBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSwgc3RhdGUgPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGVmYXVsdCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlclxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWZhdWx0IHN0YXRlIHNldCBvbiB0aGlzIGNvbnRyb2xsZXJcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGlmIGxpc3RlbmVycyBhcmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdCYXNlQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IHRoaXMuZGVmYXVsdFN0YXRlO1xuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzID0gW107XG4gICAgICAgIC8vIFVzZSBhc3NpZ24gc2luY2UgZ2VuZXJpY3MgY2FuJ3QgYmUgc3ByZWFkOiBodHRwczovL2dpdC5pby92cFJoWVxuICAgICAgICB0aGlzLmluaXRpYWxTdGF0ZSA9IHN0YXRlO1xuICAgICAgICB0aGlzLmluaXRpYWxDb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIGNvbnRyb2xsZXIuIFRoaXMgc2V0cyBlYWNoIGNvbmZpZyBvcHRpb24gYXMgYSBtZW1iZXJcbiAgICAgKiB2YXJpYWJsZSBvbiB0aGlzIGluc3RhbmNlIGFuZCB0cmlnZ2VycyBhbnkgZGVmaW5lZCBzZXR0ZXJzLiBUaGlzXG4gICAgICogYWxzbyBzZXRzIGluaXRpYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGFueSBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGlzIGNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxDb25maWcgPSB0aGlzLmRlZmF1bHRDb25maWc7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKHRoaXMuaW5pdGlhbENvbmZpZyk7XG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMuaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBjdXJyZW50IGNvbnRyb2xsZXIgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbENvbmZpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gTmV3IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIGNvbmZpZyBpbnN0ZWFkIG9mIG1lcmdpbmcuXG4gICAgICogQHBhcmFtIGZ1bGxVcGRhdGUgLSBCb29sZWFuIHRoYXQgZGVmaW5lcyBpZiB0aGUgdXBkYXRlIGlzIHBhcnRpYWwgb3Igbm90LlxuICAgICAqL1xuICAgIGNvbmZpZ3VyZShjb25maWcsIG92ZXJ3cml0ZSA9IGZhbHNlLCBmdWxsVXBkYXRlID0gdHJ1ZSkge1xuICAgICAgICBpZiAoZnVsbFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5pbnRlcm5hbENvbmZpZyA9IG92ZXJ3cml0ZVxuICAgICAgICAgICAgICAgID8gY29uZmlnXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKHRoaXMuaW50ZXJuYWxDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmludGVybmFsQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNba2V5XSA9IHRoaXMuaW50ZXJuYWxDb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5pbnRlcm5hbENvbmZpZ1trZXldICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludGVybmFsQ29uZmlnW2tleV0gPSBjb25maWdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gY29uZmlnW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vdGlmaWVzIGFsbCBzdWJzY3JpYmVkIGxpc3RlbmVycyBvZiBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiB7XG4gICAgICAgICAgICBsaXN0ZW5lcih0aGlzLmludGVybmFsU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBuZXcgbGlzdGVuZXIgdG8gYmUgbm90aWZpZWQgb2Ygc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIFRoZSBjYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmludGVybmFsTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV4aXN0aW5nIGxpc3RlbmVyIGZyb20gcmVjZWl2aW5nIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBUaGUgY2FsbGJhY2sgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiBhIGxpc3RlbmVyIGlzIGZvdW5kIGFuZCB1bnN1YnNjcmliZWQuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUobGlzdGVuZXIpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmludGVybmFsTGlzdGVuZXJzLmZpbmRJbmRleCgoY2IpID0+IGxpc3RlbmVyID09PSBjYik7XG4gICAgICAgIGluZGV4ID4gLTEgJiYgdGhpcy5pbnRlcm5hbExpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gaW5kZXggPiAtMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBjb250cm9sbGVyIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIC0gVGhlIG5ldyBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIC0gT3ZlcndyaXRlIHN0YXRlIGluc3RlYWQgb2YgbWVyZ2luZy5cbiAgICAgKi9cbiAgICB1cGRhdGUoc3RhdGUsIG92ZXJ3cml0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxTdGF0ZSA9IG92ZXJ3cml0ZVxuICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZSlcbiAgICAgICAgICAgIDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRlcm5hbFN0YXRlLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMubm90aWZ5KCk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlQ29udHJvbGxlciA9IEJhc2VDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQmFzZUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZXhwb3J0cy5nZXRBbm9ueW1pemVkU3RhdGUgPSBleHBvcnRzLkJhc2VDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgaW1tZXJfMSA9IHJlcXVpcmUoXCJpbW1lclwiKTtcbigwLCBpbW1lcl8xLmVuYWJsZVBhdGNoZXMpKCk7XG4vKipcbiAqIENvbnRyb2xsZXIgY2xhc3MgdGhhdCBwcm92aWRlcyBzdGF0ZSBtYW5hZ2VtZW50LCBzdWJzY3JpcHRpb25zLCBhbmQgc3RhdGUgbWV0YWRhdGFcbiAqL1xuY2xhc3MgQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBCYXNlQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIENvbnRyb2xsZXIgbWVzc2FnaW5nIHN5c3RlbS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXRhZGF0YSAtIFN0YXRlIG1ldGFkYXRhLCBkZXNjcmliaW5nIGhvdyB0byBcImFub255bWl6ZVwiIHRoZSBzdGF0ZSwgYW5kIHdoaWNoXG4gICAgICogcGFydHMgc2hvdWxkIGJlIHBlcnNpc3RlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbnRyb2xsZXIsIHVzZWQgYXMgYSBuYW1lc3BhY2UgZm9yIGV2ZW50cyBhbmQgYWN0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG1lc3NlbmdlciwgbWV0YWRhdGEsIG5hbWUsIHN0YXRlLCB9KSB7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtID0gbWVzc2VuZ2VyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmludGVybmFsU3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5tZXRhZGF0YSA9IG1ldGFkYXRhO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7bmFtZX06Z2V0U3RhdGVgLCAoKSA9PiB0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGN1cnJlbnQgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxTdGF0ZTtcbiAgICB9XG4gICAgc2V0IHN0YXRlKF8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cm9sbGVyIHN0YXRlIGNhbm5vdCBiZSBkaXJlY3RseSBtdXRhdGVkOyB1c2UgJ3VwZGF0ZScgbWV0aG9kIGluc3RlYWQuYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgY29udHJvbGxlciBzdGF0ZS4gQWNjZXB0cyBhIGNhbGxiYWNrIHRoYXQgaXMgcGFzc2VkIGEgZHJhZnQgY29weVxuICAgICAqIG9mIHRoZSBjb250cm9sbGVyIHN0YXRlLiBJZiBhIHZhbHVlIGlzIHJldHVybmVkLCBpdCBpcyBzZXQgYXMgdGhlIG5ld1xuICAgICAqIHN0YXRlLiBPdGhlcndpc2UsIGFueSBjaGFuZ2VzIG1hZGUgd2l0aGluIHRoYXQgY2FsbGJhY2sgdG8gdGhlIGRyYWZ0IGFyZVxuICAgICAqIGFwcGxpZWQgdG8gdGhlIGNvbnRyb2xsZXIgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayBmb3IgdXBkYXRpbmcgc3RhdGUsIHBhc3NlZCBhIGRyYWZ0IHN0YXRlXG4gICAgICogb2JqZWN0LiBSZXR1cm4gYSBuZXcgc3RhdGUgb2JqZWN0IG9yIG11dGF0ZSB0aGUgZHJhZnQgdG8gdXBkYXRlIHN0YXRlLlxuICAgICAqL1xuICAgIHVwZGF0ZShjYWxsYmFjaykge1xuICAgICAgICAvLyBXZSBydW4gaW50byB0czI1ODksIFwiaW5maW5pdGUgdHlwZSBkZXB0aFwiLCBpZiB3ZSBkb24ndCBjYXN0XG4gICAgICAgIC8vIHByb2R1Y2VXaXRoUGF0Y2hlcyBoZXJlLlxuICAgICAgICAvLyBUaGUgZmluYWwsIG9taXR0ZWQgbWVtYmVyIG9mIHRoZSByZXR1cm5lZCB0dXBsZSBhcmUgdGhlIGludmVyc2UgcGF0Y2hlcy5cbiAgICAgICAgY29uc3QgW25leHRTdGF0ZSwgcGF0Y2hlc10gPSBpbW1lcl8xLnByb2R1Y2VXaXRoUGF0Y2hlcyh0aGlzLmludGVybmFsU3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5wdWJsaXNoKGAke3RoaXMubmFtZX06c3RhdGVDaGFuZ2VgLCBuZXh0U3RhdGUsIHBhdGNoZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgY29udHJvbGxlciBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLiBUaGlzIHNob3VsZCBiZSBleHRlbmRlZFxuICAgICAqIGJ5IGFueSBzdWJjbGFzc2VzIHRvIGNsZWFuIHVwIGFueSBhZGRpdGlvbmFsIGNvbm5lY3Rpb25zIG9yIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIFRoZSBvbmx5IGNsZWFudXAgcGVyZm9ybWVkIGhlcmUgaXMgdG8gcmVtb3ZlIGxpc3RlbmVycy4gV2hpbGUgdGVjaG5pY2FsbHlcbiAgICAgKiB0aGlzIGlzIG5vdCByZXF1aXJlZCB0byBlbnN1cmUgdGhpcyBpbnN0YW5jZSBpcyBnYXJiYWdlIGNvbGxlY3RlZCwgaXQgYXRcbiAgICAgKiBsZWFzdCBlbnN1cmVzIHRoaXMgaW5zdGFuY2Ugd29uJ3QgYmUgcmVzcG9uc2libGUgZm9yIHByZXZlbnRpbmcgdGhlXG4gICAgICogbGlzdGVuZXJzIGZyb20gYmVpbmcgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2xlYXJFdmVudFN1YnNjcmlwdGlvbnMoYCR7dGhpcy5uYW1lfTpzdGF0ZUNoYW5nZWApO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzZUNvbnRyb2xsZXIgPSBCYXNlQ29udHJvbGxlcjtcbi8qKlxuICogUmV0dXJucyBhbiBhbm9ueW1pemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb250cm9sbGVyIHN0YXRlLlxuICpcbiAqIEJ5IFwiYW5vbnltaXplZFwiIHdlIG1lYW4gdGhhdCBpdCBzaG91bGQgbm90IGNvbnRhaW4gYW55IGluZm9ybWF0aW9uIHRoYXQgY291bGQgYmUgcGVyc29uYWxseVxuICogaWRlbnRpZmlhYmxlLlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBjb250cm9sbGVyIHN0YXRlLlxuICogQHBhcmFtIG1ldGFkYXRhIC0gVGhlIGNvbnRyb2xsZXIgc3RhdGUgbWV0YWRhdGEsIHdoaWNoIGRlc2NyaWJlcyBob3cgdG8gZGVyaXZlIHRoZVxuICogYW5vbnltaXplZCBzdGF0ZS5cbiAqIEByZXR1cm5zIFRoZSBhbm9ueW1pemVkIGNvbnRyb2xsZXIgc3RhdGUuXG4gKi9cbmZ1bmN0aW9uIGdldEFub255bWl6ZWRTdGF0ZShzdGF0ZSwgbWV0YWRhdGEpIHtcbiAgICByZXR1cm4gZGVyaXZlU3RhdGVGcm9tTWV0YWRhdGEoc3RhdGUsIG1ldGFkYXRhLCAnYW5vbnltb3VzJyk7XG59XG5leHBvcnRzLmdldEFub255bWl6ZWRTdGF0ZSA9IGdldEFub255bWl6ZWRTdGF0ZTtcbi8qKlxuICogUmV0dXJucyB0aGUgc3Vic2V0IG9mIHN0YXRlIHRoYXQgc2hvdWxkIGJlIHBlcnNpc3RlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGUgLSBUaGUgY29udHJvbGxlciBzdGF0ZS5cbiAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBjb250cm9sbGVyIHN0YXRlIG1ldGFkYXRhLCB3aGljaCBkZXNjcmliZXMgd2hpY2ggcGllY2VzIG9mIHN0YXRlIHNob3VsZCBiZSBwZXJzaXN0ZWQuXG4gKiBAcmV0dXJucyBUaGUgc3Vic2V0IG9mIGNvbnRyb2xsZXIgc3RhdGUgdGhhdCBzaG91bGQgYmUgcGVyc2lzdGVkLlxuICovXG5mdW5jdGlvbiBnZXRQZXJzaXN0ZW50U3RhdGUoc3RhdGUsIG1ldGFkYXRhKSB7XG4gICAgcmV0dXJuIGRlcml2ZVN0YXRlRnJvbU1ldGFkYXRhKHN0YXRlLCBtZXRhZGF0YSwgJ3BlcnNpc3QnKTtcbn1cbmV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZ2V0UGVyc2lzdGVudFN0YXRlO1xuLyoqXG4gKiBVc2UgdGhlIG1ldGFkYXRhIHRvIGRlcml2ZSBzdGF0ZSBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG1ldGFkYXRhIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBmdWxsIGNvbnRyb2xsZXIgc3RhdGUuXG4gKiBAcGFyYW0gbWV0YWRhdGEgLSBUaGUgY29udHJvbGxlciBtZXRhZGF0YS5cbiAqIEBwYXJhbSBtZXRhZGF0YVByb3BlcnR5IC0gVGhlIG1ldGFkYXRhIHByb3BlcnR5IHRvIHVzZSB0byBkZXJpdmUgc3RhdGUuXG4gKiBAcmV0dXJucyBUaGUgbWV0YWRhdGEtZGVyaXZlZCBjb250cm9sbGVyIHN0YXRlLlxuICovXG5mdW5jdGlvbiBkZXJpdmVTdGF0ZUZyb21NZXRhZGF0YShzdGF0ZSwgbWV0YWRhdGEsIG1ldGFkYXRhUHJvcGVydHkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc3RhdGUpLnJlZHVjZSgocGVyc2lzdGVkU3RhdGUsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eU1ldGFkYXRhID0gbWV0YWRhdGFba2V5XVttZXRhZGF0YVByb3BlcnR5XTtcbiAgICAgICAgY29uc3Qgc3RhdGVQcm9wZXJ0eSA9IHN0YXRlW2tleV07XG4gICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHlNZXRhZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGVyc2lzdGVkU3RhdGVba2V5XSA9IHByb3BlcnR5TWV0YWRhdGEoc3RhdGVQcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvcGVydHlNZXRhZGF0YSkge1xuICAgICAgICAgICAgcGVyc2lzdGVkU3RhdGVba2V5XSA9IHN0YXRlUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBlcnNpc3RlZFN0YXRlO1xuICAgIH0sIHt9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VDb250cm9sbGVyVjIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbXBvc2FibGVDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDb250cm9sbGVyXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gY29tcG9zZSBtdWx0aXBsZSBjb250cm9sbGVycyB0b2dldGhlclxuICovXG5jbGFzcyBDb21wb3NhYmxlQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDb21wb3NhYmxlQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cm9sbGVycyAtIE1hcCBvZiBuYW1lcyB0byBjb250cm9sbGVyIGluc3RhbmNlcy5cbiAgICAgKiBAcGFyYW0gbWVzc2VuZ2VyIC0gVGhlIGNvbnRyb2xsZXIgbWVzc2FnaW5nIHN5c3RlbSwgdXNlZCBmb3IgY29tbXVuaWNhdGluZyB3aXRoIEJhc2VDb250cm9sbGVyVjIgY29udHJvbGxlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29udHJvbGxlcnMsIG1lc3Nlbmdlcikge1xuICAgICAgICBzdXBlcih1bmRlZmluZWQsIGNvbnRyb2xsZXJzLnJlZHVjZSgoc3RhdGUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgIHN0YXRlW2NvbnRyb2xsZXIubmFtZV0gPSBjb250cm9sbGVyLnN0YXRlO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LCB7fSkpO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbXBvc2FibGVDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBjb250cm9sbGVycztcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0gPSBtZXNzZW5nZXI7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMuZm9yRWFjaCgoY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lIH0gPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuc3Vic2NyaWJlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnN1YnNjcmliZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBbbmFtZV06IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tZXNzYWdpbmdTeXN0ZW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5zdWJzY3JpYmUoYCR7bmFtZX06c3RhdGVDaGFuZ2VgLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBbbmFtZV06IHN0YXRlIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNZXNzYWdpbmcgc3lzdGVtIHJlcXVpcmVkIGlmIGFueSBCYXNlQ29udHJvbGxlclYyIGNvbnRyb2xsZXJzIGFyZSB1c2VkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGF0IHN0YXRlIHJlcHJlc2VudGF0aW9uLCBvbmUgdGhhdCBpc24ndCBrZXllZFxuICAgICAqIG9mIGNvbnRyb2xsZXIgbmFtZS4gSW5zdGVhZCwgYWxsIGNoaWxkIGNvbnRyb2xsZXIgc3RhdGUgaXMgbWVyZ2VkXG4gICAgICogdG9nZXRoZXIgaW50byBhIHNpbmdsZSwgZmxhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBNZXJnZWQgc3RhdGUgcmVwcmVzZW50YXRpb24gb2YgYWxsIGNoaWxkIGNvbnRyb2xsZXJzLlxuICAgICAqL1xuICAgIGdldCBmbGF0U3RhdGUoKSB7XG4gICAgICAgIGxldCBmbGF0U3RhdGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgICAgIGZsYXRTdGF0ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmxhdFN0YXRlKSwgY29udHJvbGxlci5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZsYXRTdGF0ZTtcbiAgICB9XG59XG5leHBvcnRzLkNvbXBvc2FibGVDb250cm9sbGVyID0gQ29tcG9zYWJsZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb3NhYmxlQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvc2FibGVDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db250cm9sbGVyTWVzc2VuZ2VyID0gZXhwb3J0cy5SZXN0cmljdGVkQ29udHJvbGxlck1lc3NlbmdlciA9IHZvaWQgMDtcbi8qKlxuICogQSByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyLlxuICpcbiAqIFRoaXMgYWN0cyBhcyBhIHdyYXBwZXIgYXJvdW5kIHRoZSBjb250cm9sbGVyIG1lc3NlbmdlciBpbnN0YW5jZSB0aGF0IHJlc3RyaWN0cyBhY2Nlc3MgdG8gYWN0aW9uc1xuICogYW5kIGV2ZW50cy5cbiAqXG4gKiBAdGVtcGxhdGUgTiAtIFRoZSBuYW1lc3BhY2UgZm9yIHRoaXMgbWVzc2VuZ2VyLiBUeXBpY2FsbHkgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgY29udHJvbGxlciBvclxuICogbW9kdWxlIHRoYXQgdGhpcyBtZXNzZW5nZXIgaGFzIGJlZW4gY3JlYXRlZCBmb3IuIFRoZSBhdXRob3JpdHkgdG8gcHVibGlzaCBldmVudHMgYW5kIHJlZ2lzdGVyXG4gKiBhY3Rpb25zIHVuZGVyIHRoaXMgbmFtZXNwYWNlIGlzIGdyYW50ZWQgdG8gdGhpcyByZXN0cmljdGVkIG1lc3NlbmdlciBpbnN0YW5jZS5cbiAqIEB0ZW1wbGF0ZSBBY3Rpb24gLSBBIHR5cGUgdW5pb24gb2YgYWxsIEFjdGlvbiB0eXBlcy5cbiAqIEB0ZW1wbGF0ZSBFdmVudCAtIEEgdHlwZSB1bmlvbiBvZiBhbGwgRXZlbnQgdHlwZXMuXG4gKiBAdGVtcGxhdGUgQWxsb3dlZEFjdGlvbiAtIEEgdHlwZSB1bmlvbiBvZiB0aGUgJ3R5cGUnIHN0cmluZyBmb3IgYW55IGFsbG93ZWQgYWN0aW9ucy5cbiAqIEB0ZW1wbGF0ZSBBbGxvd2VkRXZlbnQgLSBBIHR5cGUgdW5pb24gb2YgdGhlICd0eXBlJyBzdHJpbmcgZm9yIGFueSBhbGxvd2VkIGV2ZW50cy5cbiAqL1xuY2xhc3MgUmVzdHJpY3RlZENvbnRyb2xsZXJNZXNzZW5nZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICpcbiAgICAgKiBUaGUgcHJvdmlkZWQgYWxsb3dsaXN0cyBncmFudCB0aGUgYWJpbGl0eSB0byBjYWxsIHRoZSBsaXN0ZWQgYWN0aW9ucyBhbmQgc3Vic2NyaWJlIHRvIHRoZVxuICAgICAqIGxpc3RlZCBldmVudHMuIFRoZSBcIm5hbWVcIiBwcm92aWRlZCBncmFudHMgb3duZXJzaGlwIG9mIGFueSBhY3Rpb25zIGFuZCBldmVudHMgdW5kZXIgdGhhdFxuICAgICAqIG5hbWVzcGFjZS4gT3duZXJzaGlwIGFsbG93cyByZWdpc3RlcmluZyBhY3Rpb25zIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgYXMgd2VsbCBhc1xuICAgICAqIHVucmVnaXN0ZXJpbmcgYWN0aW9ucyBhbmQgY2xlYXJpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb250cm9sbGVyTWVzc2VuZ2VyIC0gVGhlIGNvbnRyb2xsZXIgbWVzc2VuZ2VyIGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgd3JhcHBlZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRoaW5nIHRoaXMgbWVzc2VuZ2VyIHdpbGwgYmUgaGFuZGVkIHRvIChlLmcuIHRoZVxuICAgICAqIGNvbnRyb2xsZXIgbmFtZSkuIFRoaXMgZ3JhbnRzIFwib3duZXJzaGlwXCIgb2YgYWN0aW9ucyBhbmQgZXZlbnRzIHVuZGVyIHRoaXMgbmFtZXNwYWNlIHRvIHRoZVxuICAgICAqIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEFjdGlvbnMgLSBUaGUgbGlzdCBvZiBhY3Rpb25zIHRoYXQgdGhpcyByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICogc2hvdWxkIGJlIGFsb3dlZCB0byBjYWxsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRFdmVudHMgLSBUaGUgbGlzdCBvZiBldmVudHMgdGhhdCB0aGlzIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKiBzaG91bGQgYmUgYWxsb3dlZCB0byBzdWJzY3JpYmUgdG8uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBjb250cm9sbGVyTWVzc2VuZ2VyLCBuYW1lLCBhbGxvd2VkQWN0aW9ucywgYWxsb3dlZEV2ZW50cywgfSkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIgPSBjb250cm9sbGVyTWVzc2VuZ2VyO1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXJOYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5hbGxvd2VkQWN0aW9ucyA9IGFsbG93ZWRBY3Rpb25zIHx8IG51bGw7XG4gICAgICAgIHRoaXMuYWxsb3dlZEV2ZW50cyA9IGFsbG93ZWRFdmVudHMgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gYWN0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgcmVnaXN0ZXJlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbCB2aWEgdGhlIGBjYWxsYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBUaGUgYWN0aW9uIHR5cGUgdGhpcyBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgdW5kZXIgKm11c3QqIGJlIGluIHRoZSBjdXJyZW50IG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgYWN0aW9uIGhhbmRsZXIuIFRoaXMgZnVuY3Rpb24gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgYGNhbGxgIG1ldGhvZCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGUuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gYSBoYW5kbGVyIGhhcyBiZWVuIHJlZ2lzdGVyZWQgZm9yIHRoaXMgYWN0aW9uIHR5cGUgYWxyZWFkeS5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBBY3Rpb24gdHlwZSBzdHJpbmdzIHRoYXQgYXJlIG5hbWVzcGFjZWQgYnkgTi5cbiAgICAgKi9cbiAgICByZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uLCBoYW5kbGVyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWFjdGlvbi5zdGFydHNXaXRoKGAke3RoaXMuY29udHJvbGxlck5hbWV9OmApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgYWxsb3dlZCByZWdpc3RlcmluZyBhY3Rpb24gaGFuZGxlcnMgcHJlZml4ZWQgYnkgJyR7dGhpcy5jb250cm9sbGVyTmFtZX06J2ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uLCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5yZWdpc3RlciBhbiBhY3Rpb24gaGFuZGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBwcmV2ZW50IHRoaXMgYWN0aW9uIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogVGhlIGFjdGlvbiB0eXBlIGJlaW5nIHVucmVnaXN0ZXJlZCAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFjdGlvbiAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBBY3Rpb24gdHlwZSBzdHJpbmdzIHRoYXQgYXJlIG5hbWVzcGFjZWQgYnkgTi5cbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihhY3Rpb24pIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovIC8vIEJyYW5jaCB1bnJlYWNoYWJsZSB3aXRoIHZhbGlkIHR5cGVzXG4gICAgICAgIGlmICghYWN0aW9uLnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIHVucmVnaXN0ZXJpbmcgYWN0aW9uIGhhbmRsZXJzIHByZWZpeGVkIGJ5ICcke3RoaXMuY29udHJvbGxlck5hbWV9OidgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJNZXNzZW5nZXIudW5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBhbiBhY3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgY2FsbCB0aGUgYWN0aW9uIGhhbmRsZXIgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gYWN0aW9uIHR5cGUsIHBhc3NpbmdcbiAgICAgKiBhbG9uZyBhbnkgcGFyYW1ldGVycyBnaXZlbi5cbiAgICAgKlxuICAgICAqIFRoZSBhY3Rpb24gdHlwZSBiZWluZyBjYWxsZWQgbXVzdCBiZSBvbiB0aGUgYWN0aW9uIGFsbG93bGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb24gLSBUaGUgYWN0aW9uIHR5cGUuIFRoaXMgaXMgYSB1bnFpdWUgaWRlbnRpZmllciBmb3IgdGhpcyBhY3Rpb24uXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBhY3Rpb24gcGFyYW1ldGVycy4gVGhlc2UgbXVzdCBtYXRjaCB0aGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVycyBvZiB0aGVcbiAgICAgKiByZWdpc3RlcmVkIGFjdGlvbiBoYW5kbGVyLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIG5vIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gICAgICogQHRlbXBsYXRlIFQgLSBBIHR5cGUgdW5pb24gb2YgYWxsb3dlZCBBY3Rpb24gdHlwZSBzdHJpbmdzLlxuICAgICAqIEByZXR1cm5zIFRoZSBhY3Rpb24gcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIGNhbGwoYWN0aW9uLCAuLi5wYXJhbXMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gLy8gQnJhbmNoZXMgdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAodGhpcy5hbGxvd2VkQWN0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3Rpb25zIGFsbG93ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5hbGxvd2VkQWN0aW9ucy5pbmNsdWRlcyhhY3Rpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiBtaXNzaW5nIGZyb20gYWxsb3cgbGlzdDogJHthY3Rpb259YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5jYWxsKGFjdGlvbiwgLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFB1Ymxpc2hlcyB0aGUgZ2l2ZW4gcGF5bG9hZCB0byBhbGwgc3Vic2NyaWJlcnMgb2YgdGhlIGdpdmVuIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBUaGUgZXZlbnQgdHlwZSBiZWluZyBwdWJsaXNoZWQgKm11c3QqIGJlIGluIHRoZSBjdXJyZW50IG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIHBheWxvYWQgLSBUaGUgZXZlbnQgcGF5bG9hZC4gVGhlIHR5cGUgb2YgdGhlIHBhcmFtZXRlcnMgZm9yIGVhY2ggZXZlbnQgaGFuZGxlciBtdXN0XG4gICAgICogbWF0Y2ggdGhlIHR5cGUgb2YgdGhpcyBwYXlsb2FkLlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncyB0aGF0IGFyZSBuYW1lc3BhY2VkIGJ5IE4uXG4gICAgICovXG4gICAgcHVibGlzaChldmVudCwgLi4ucGF5bG9hZCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gQnJhbmNoIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKCFldmVudC5zdGFydHNXaXRoKGAke3RoaXMuY29udHJvbGxlck5hbWV9OmApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE9ubHkgYWxsb3dlZCBwdWJsaXNoaW5nIGV2ZW50cyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnB1Ymxpc2goZXZlbnQsIC4uLnBheWxvYWQpO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIsIHNlbGVjdG9yKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIC8vIEJyYW5jaGVzIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldmVudHMgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFsbG93ZWRFdmVudHMuaW5jbHVkZXMoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50IG1pc3NpbmcgZnJvbSBhbGxvdyBsaXN0OiAke2V2ZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci5zdWJzY3JpYmUoZXZlbnQsIGhhbmRsZXIsIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLnN1YnNjcmliZShldmVudCwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlIGZyb20gYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYXMgYW4gZXZlbnQgaGFuZGxlciBmb3IgdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhlIGV2ZW50IHR5cGUgYmVpbmcgdW5zdWJzY3JpYmVkIHRvIG11c3QgYmUgb24gdGhlIGV2ZW50IGFsbG93bGlzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBldmVudCB0eXBlLiBUaGlzIGlzIGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgZXZlbnQuXG4gICAgICogQHBhcmFtIGhhbmRsZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byB1bnJlZ2lzdGVyLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIHRoZSBnaXZlbiBldmVudCBoYW5kbGVyIGlzIG5vdCByZWdpc3RlcmVkIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIGFsbG93ZWQgRXZlbnQgdHlwZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIC8vIEJyYW5jaGVzIHVucmVhY2hhYmxlIHdpdGggdmFsaWQgdHlwZXNcbiAgICAgICAgaWYgKHRoaXMuYWxsb3dlZEV2ZW50cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldmVudHMgYWxsb3dlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLmFsbG93ZWRFdmVudHMuaW5jbHVkZXMoZXZlbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV2ZW50IG1pc3NpbmcgZnJvbSBhbGxvdyBsaXN0OiAke2V2ZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udHJvbGxlck1lc3Nlbmdlci51bnN1YnNjcmliZShldmVudCwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIHN1YnNjcmlwdGlvbnMgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcmVtb3ZlIGFsbCBzdWJzY3JpYmVkIGhhbmRsZXJzIGZvciB0aGlzIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhlIGV2ZW50IHR5cGUgYmVpbmcgY2xlYXJlZCAqbXVzdCogYmUgaW4gdGhlIGN1cnJlbnQgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAdGVtcGxhdGUgRSAtIEEgdHlwZSB1bmlvbiBvZiBFdmVudCB0eXBlIHN0cmluZ3MgdGhhdCBhcmUgbmFtZXNwYWNlZCBieSBOLlxuICAgICAqL1xuICAgIGNsZWFyRXZlbnRTdWJzY3JpcHRpb25zKGV2ZW50KSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqLyAvLyBCcmFuY2ggdW5yZWFjaGFibGUgd2l0aCB2YWxpZCB0eXBlc1xuICAgICAgICBpZiAoIWV2ZW50LnN0YXJ0c1dpdGgoYCR7dGhpcy5jb250cm9sbGVyTmFtZX06YCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgT25seSBhbGxvd2VkIGNsZWFyaW5nIGV2ZW50cyBwcmVmaXhlZCBieSAnJHt0aGlzLmNvbnRyb2xsZXJOYW1lfTonYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250cm9sbGVyTWVzc2VuZ2VyLmNsZWFyRXZlbnRTdWJzY3JpcHRpb25zKGV2ZW50KTtcbiAgICB9XG59XG5leHBvcnRzLlJlc3RyaWN0ZWRDb250cm9sbGVyTWVzc2VuZ2VyID0gUmVzdHJpY3RlZENvbnRyb2xsZXJNZXNzZW5nZXI7XG4vKipcbiAqIEEgbWVzc2FnaW5nIHN5c3RlbSBmb3IgY29udHJvbGxlcnMuXG4gKlxuICogVGhlIGNvbnRyb2xsZXIgbWVzc2VuZ2VyIGFsbG93cyByZWdpc3RlcmluZyBmdW5jdGlvbnMgYXMgJ2FjdGlvbnMnIHRoYXQgY2FuIGJlIGNhbGxlZCBlbHNld2hlcmUsXG4gKiBhbmQgaXQgYWxsb3dzIHB1Ymxpc2hpbmcgYW5kIHN1YnNjcmliaW5nIHRvIGV2ZW50cy4gQm90aCBhY3Rpb25zIGFuZCBldmVudHMgYXJlIGlkZW50aWZpZWQgYnlcbiAqIHVuaXF1ZSBzdHJpbmdzLlxuICpcbiAqIEB0ZW1wbGF0ZSBBY3Rpb24gLSBBIHR5cGUgdW5pb24gb2YgYWxsIEFjdGlvbiB0eXBlcy5cbiAqIEB0ZW1wbGF0ZSBFdmVudCAtIEEgdHlwZSB1bmlvbiBvZiBhbGwgRXZlbnQgdHlwZXMuXG4gKi9cbmNsYXNzIENvbnRyb2xsZXJNZXNzZW5nZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjYWNoZSBvZiBzZWxlY3RvciByZXR1cm4gdmFsdWVzIGZvciB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudFBheWxvYWRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYW4gYWN0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgbWFrZSB0aGUgcmVnaXN0ZXJlZCBmdW5jdGlvbiBhdmFpbGFibGUgdG8gY2FsbCB2aWEgdGhlIGBjYWxsYCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uVHlwZSAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gaGFuZGxlciAtIFRoZSBhY3Rpb24gaGFuZGxlci4gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCB3aGVuIHRoZSBgY2FsbGAgbWV0aG9kIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHRoZSBnaXZlbiBhY3Rpb24gdHlwZS5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiBhIGhhbmRsZXIgaGFzIGJlZW4gcmVnaXN0ZXJlZCBmb3IgdGhpcyBhY3Rpb24gdHlwZSBhbHJlYWR5LlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgcmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGFjdGlvblR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aW9ucy5oYXMoYWN0aW9uVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBoYW5kbGVyIGZvciAke2FjdGlvblR5cGV9IGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWN0aW9ucy5zZXQoYWN0aW9uVHlwZSwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYW4gYWN0aW9uIGhhbmRsZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHdpbGwgcHJldmVudCB0aGlzIGFjdGlvbiBmcm9tIGJlaW5nIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY3Rpb25UeXBlIC0gVGhlIGFjdGlvbiB0eXBlLiBUaGlzIGlzIGEgdW5xaXVlIGlkZW50aWZpZXIgZm9yIHRoaXMgYWN0aW9uLlxuICAgICAqIEB0ZW1wbGF0ZSBUIC0gQSB0eXBlIHVuaW9uIG9mIEFjdGlvbiB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgdW5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYWN0aW9uVHlwZSkge1xuICAgICAgICB0aGlzLmFjdGlvbnMuZGVsZXRlKGFjdGlvblR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGFsbCBhY3Rpb24gaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBUaGlzIHByZXZlbnRzIGFsbCBhY3Rpb25zIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqL1xuICAgIGNsZWFyQWN0aW9ucygpIHtcbiAgICAgICAgdGhpcy5hY3Rpb25zLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgYW4gYWN0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiB3aWxsIGNhbGwgdGhlIGFjdGlvbiBoYW5kbGVyIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGFjdGlvbiB0eXBlLCBwYXNzaW5nXG4gICAgICogYWxvbmcgYW55IHBhcmFtZXRlcnMgZ2l2ZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWN0aW9uVHlwZSAtIFRoZSBhY3Rpb24gdHlwZS4gVGhpcyBpcyBhIHVucWl1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGFjdGlvbi5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIGFjdGlvbiBwYXJhbWV0ZXJzLiBUaGVzZSBtdXN0IG1hdGNoIHRoZSB0eXBlIG9mIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZVxuICAgICAqIHJlZ2lzdGVyZWQgYWN0aW9uIGhhbmRsZXIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gbm8gaGFuZGxlciBoYXMgYmVlbiByZWdpc3RlcmVkIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAgICAgKiBAdGVtcGxhdGUgVCAtIEEgdHlwZSB1bmlvbiBvZiBBY3Rpb24gdHlwZSBzdHJpbmdzLlxuICAgICAqIEByZXR1cm5zIFRoZSBhY3Rpb24gcmV0dXJuIHZhbHVlLlxuICAgICAqL1xuICAgIGNhbGwoYWN0aW9uVHlwZSwgLi4ucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmFjdGlvbnMuZ2V0KGFjdGlvblR5cGUpO1xuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBoYW5kbGVyIGZvciAke2FjdGlvblR5cGV9IGhhcyBub3QgYmVlbiByZWdpc3RlcmVkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaCBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFB1Ymxpc2hlcyB0aGUgZ2l2ZW4gcGF5bG9hZCB0byBhbGwgc3Vic2NyaWJlcnMgb2YgdGhlIGdpdmVuIGV2ZW50IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnRUeXBlIC0gVGhlIGV2ZW50IHR5cGUuIFRoaXMgaXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAcGFyYW0gcGF5bG9hZCAtIFRoZSBldmVudCBwYXlsb2FkLiBUaGUgdHlwZSBvZiB0aGUgcGFyYW1ldGVycyBmb3IgZWFjaCBldmVudCBoYW5kbGVyIG11c3RcbiAgICAgKiBtYXRjaCB0aGUgdHlwZSBvZiB0aGlzIHBheWxvYWQuXG4gICAgICogQHRlbXBsYXRlIEUgLSBBIHR5cGUgdW5pb24gb2YgRXZlbnQgdHlwZSBzdHJpbmdzLlxuICAgICAqL1xuICAgIHB1Ymxpc2goZXZlbnRUeXBlLCAuLi5wYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmIChzdWJzY3JpYmVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaGFuZGxlciwgc2VsZWN0b3JdIG9mIHN1YnNjcmliZXJzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5ldmVudFBheWxvYWRDYWNoZS5nZXQoaGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gc2VsZWN0b3IoLi4ucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudFBheWxvYWRDYWNoZS5zZXQoaGFuZGxlciwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcihuZXdWYWx1ZSwgcHJldmlvdXNWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXIoLi4ucGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN1YnNjcmliZShldmVudFR5cGUsIGhhbmRsZXIsIHNlbGVjdG9yKSB7XG4gICAgICAgIGxldCBzdWJzY3JpYmVycyA9IHRoaXMuZXZlbnRzLmdldChldmVudFR5cGUpO1xuICAgICAgICBpZiAoIXN1YnNjcmliZXJzKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNldChldmVudFR5cGUsIHN1YnNjcmliZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJzY3JpYmVycy5zZXQoaGFuZGxlciwgc2VsZWN0b3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnN1YnNjcmliZSBmcm9tIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogVW5yZWdpc3RlcnMgdGhlIGdpdmVuIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSBnaXZlbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIC0gVGhlIGV2ZW50IGhhbmRsZXIgdG8gdW5yZWdpc3Rlci5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgd2hlbiB0aGUgZ2l2ZW4gZXZlbnQgaGFuZGxlciBpcyBub3QgcmVnaXN0ZXJlZCBmb3IgdGhpcyBldmVudC5cbiAgICAgKiBAdGVtcGxhdGUgRSAtIEEgdHlwZSB1bmlvbiBvZiBFdmVudCB0eXBlIHN0cmluZ3MuXG4gICAgICovXG4gICAgdW5zdWJzY3JpYmUoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJzID0gdGhpcy5ldmVudHMuZ2V0KGV2ZW50VHlwZSk7XG4gICAgICAgIGlmICghc3Vic2NyaWJlcnMgfHwgIXN1YnNjcmliZXJzLmhhcyhoYW5kbGVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdWJzY3JpcHRpb24gbm90IGZvdW5kIGZvciBldmVudDogJHtldmVudFR5cGV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSBzdWJzY3JpYmVycy5nZXQoaGFuZGxlcik7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5ldmVudFBheWxvYWRDYWNoZS5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBzdWJzY3JpcHRpb25zIGZvciBhIHNwZWNpZmljIGV2ZW50LlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSBhbGwgc3Vic2NyaWJlZCBoYW5kbGVycyBmb3IgdGhpcyBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudFR5cGUgLSBUaGUgZXZlbnQgdHlwZS4gVGhpcyBpcyBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGlzIGV2ZW50LlxuICAgICAqIEB0ZW1wbGF0ZSBFIC0gQSB0eXBlIHVuaW9uIG9mIEV2ZW50IHR5cGUgc3RyaW5ncy5cbiAgICAgKi9cbiAgICBjbGVhckV2ZW50U3Vic2NyaXB0aW9ucyhldmVudFR5cGUpIHtcbiAgICAgICAgdGhpcy5ldmVudHMuZGVsZXRlKGV2ZW50VHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBzdWJzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIHJlbW92ZSBhbGwgc3Vic2NyaWJlZCBoYW5kbGVycyBmb3IgYWxsIGV2ZW50cy5cbiAgICAgKi9cbiAgICBjbGVhclN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSB3cmFwcGVyIGFyb3VuZCB0aGUgY29udHJvbGxlciBtZXNzZW5nZXIgaW5zdGFuY2UgdGhhdCByZXN0cmljdHMgYWNjZXNzIHRvIGFjdGlvbnNcbiAgICAgKiBhbmQgZXZlbnRzLiBUaGUgcHJvdmlkZWQgYWxsb3dsaXN0cyBncmFudCB0aGUgYWJpbGl0eSB0byBjYWxsIHRoZSBsaXN0ZWQgYWN0aW9ucyBhbmQgc3Vic2NyaWJlXG4gICAgICogdG8gdGhlIGxpc3RlZCBldmVudHMuIFRoZSBcIm5hbWVcIiBwcm92aWRlZCBncmFudHMgb3duZXJzaGlwIG9mIGFueSBhY3Rpb25zIGFuZCBldmVudHMgdW5kZXJcbiAgICAgKiB0aGF0IG5hbWVzcGFjZS4gT3duZXJzaGlwIGFsbG93cyByZWdpc3RlcmluZyBhY3Rpb25zIGFuZCBwdWJsaXNoaW5nIGV2ZW50cywgYXMgd2VsbCBhc1xuICAgICAqIHVucmVnaXN0ZXJpbmcgYWN0aW9ucyBhbmQgY2xlYXJpbmcgZXZlbnQgc3Vic2NyaXB0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gQ29udHJvbGxlciBtZXNzZW5nZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHRoaW5nIHRoaXMgbWVzc2VuZ2VyIHdpbGwgYmUgaGFuZGVkIHRvIChlLmcuIHRoZVxuICAgICAqIGNvbnRyb2xsZXIgbmFtZSkuIFRoaXMgZ3JhbnRzIFwib3duZXJzaGlwXCIgb2YgYWN0aW9ucyBhbmQgZXZlbnRzIHVuZGVyIHRoaXMgbmFtZXNwYWNlIHRvIHRoZVxuICAgICAqIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWxsb3dlZEFjdGlvbnMgLSBUaGUgbGlzdCBvZiBhY3Rpb25zIHRoYXQgdGhpcyByZXN0cmljdGVkIGNvbnRyb2xsZXIgbWVzc2VuZ2VyXG4gICAgICogc2hvdWxkIGJlIGFsb3dlZCB0byBjYWxsLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFsbG93ZWRFdmVudHMgLSBUaGUgbGlzdCBvZiBldmVudHMgdGhhdCB0aGlzIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXJcbiAgICAgKiBzaG91bGQgYmUgYWxsb3dlZCB0byBzdWJzY3JpYmUgdG8uXG4gICAgICogQHRlbXBsYXRlIE4gLSBUaGUgbmFtZXNwYWNlIGZvciB0aGlzIG1lc3Nlbmdlci4gVHlwaWNhbGx5IHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGNvbnRyb2xsZXIgb3JcbiAgICAgKiBtb2R1bGUgdGhhdCB0aGlzIG1lc3NlbmdlciBoYXMgYmVlbiBjcmVhdGVkIGZvci4gVGhlIGF1dGhvcml0eSB0byBwdWJsaXNoIGV2ZW50cyBhbmQgcmVnaXN0ZXJcbiAgICAgKiBhY3Rpb25zIHVuZGVyIHRoaXMgbmFtZXNwYWNlIGlzIGdyYW50ZWQgdG8gdGhpcyByZXN0cmljdGVkIG1lc3NlbmdlciBpbnN0YW5jZS5cbiAgICAgKiBAdGVtcGxhdGUgQWxsb3dlZEFjdGlvbiAtIEEgdHlwZSB1bmlvbiBvZiB0aGUgJ3R5cGUnIHN0cmluZyBmb3IgYW55IGFsbG93ZWQgYWN0aW9ucy5cbiAgICAgKiBAdGVtcGxhdGUgQWxsb3dlZEV2ZW50IC0gQSB0eXBlIHVuaW9uIG9mIHRoZSAndHlwZScgc3RyaW5nIGZvciBhbnkgYWxsb3dlZCBldmVudHMuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3RyaWN0ZWQgY29udHJvbGxlciBtZXNzZW5nZXIuXG4gICAgICovXG4gICAgZ2V0UmVzdHJpY3RlZCh7IG5hbWUsIGFsbG93ZWRBY3Rpb25zLCBhbGxvd2VkRXZlbnRzLCB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdHJpY3RlZENvbnRyb2xsZXJNZXNzZW5nZXIoe1xuICAgICAgICAgICAgY29udHJvbGxlck1lc3NlbmdlcjogdGhpcyxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhbGxvd2VkQWN0aW9ucyxcbiAgICAgICAgICAgIGFsbG93ZWRFdmVudHMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29udHJvbGxlck1lc3NlbmdlciA9IENvbnRyb2xsZXJNZXNzZW5nZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db250cm9sbGVyTWVzc2VuZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bbm5vdW5jZW1lbnRDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBhbm5vdW5jZW1lbnRzOiB7fSxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgZm9yIG1hbmFnaW5nIGluLWFwcCBhbm5vdW5jZW1lbnRzLlxuICovXG5jbGFzcyBBbm5vdW5jZW1lbnRDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEFubm91bmNlbWVudENvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlIHx8IGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLl9hZGRBbm5vdW5jZW1lbnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHRoZSBhbm5vdW5jZW1lbnRzIGluIHN0YXRlIHdpdGggdGhlIGFubm91bmNlbWVudHMgZnJvbSBmaWxlXG4gICAgICogdG8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBuZXcgYW5ub3VuY2VtZW50c1xuICAgICAqIGlmIHllcywgdGhlIG5ldyBhbm5vdW5jZW1lbnQgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3RhdGUgd2l0aCBhIGZsYWcgaW5kaWNhdGluZ1xuICAgICAqIHRoYXQgdGhlIGFubm91bmNlbWVudCBpcyBub3Qgc2VlbiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBfYWRkQW5ub3VuY2VtZW50cygpIHtcbiAgICAgICAgY29uc3QgbmV3QW5ub3VuY2VtZW50cyA9IHt9O1xuICAgICAgICBjb25zdCB7IGFsbEFubm91bmNlbWVudHMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBPYmplY3QudmFsdWVzKGFsbEFubm91bmNlbWVudHMpLmZvckVhY2goKGFubm91bmNlbWVudCkgPT4ge1xuICAgICAgICAgICAgbmV3QW5ub3VuY2VtZW50c1thbm5vdW5jZW1lbnQuaWRdID0gdGhpcy5zdGF0ZS5hbm5vdW5jZW1lbnRzW2Fubm91bmNlbWVudC5pZF1cbiAgICAgICAgICAgICAgICA/IHRoaXMuc3RhdGUuYW5ub3VuY2VtZW50c1thbm5vdW5jZW1lbnQuaWRdXG4gICAgICAgICAgICAgICAgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFubm91bmNlbWVudCksIHsgaXNTaG93bjogZmFsc2UgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFubm91bmNlbWVudHM6IG5ld0Fubm91bmNlbWVudHMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiB0aGUgc3RhdHVzIG9mIHRoZSBzcGVjaWZpZWQgYW5ub3VuY2VtZW50c1xuICAgICAqIG9uY2UgaXQgaXMgcmVhZCBieSB0aGUgdXNlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3ZWRJZHMgLSBUaGUgYW5ub3VuY2VtZW50IElEcyB0byBtYXJrIGFzIHZpZXdlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVWaWV3ZWQodmlld2VkSWRzKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlQW5ub3VuY2VtZW50cyA9IHRoaXMuc3RhdGUuYW5ub3VuY2VtZW50cztcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBPYmplY3Qua2V5cyh2aWV3ZWRJZHMpLm1hcChOdW1iZXIpKSB7XG4gICAgICAgICAgICBzdGF0ZUFubm91bmNlbWVudHNbaWRdLmlzU2hvd24gPSB2aWV3ZWRJZHNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYW5ub3VuY2VtZW50czogc3RhdGVBbm5vdW5jZW1lbnRzIH0sIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQW5ub3VuY2VtZW50Q29udHJvbGxlciA9IEFubm91bmNlbWVudENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bbm5vdW5jZW1lbnRDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoRXhjaGFuZ2VSYXRlID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIEdldCB0aGUgQ3J5cHRvQ29tcGFyZSBBUEkgVVJMIGZvciBnZXR0aW5nIHRoZSBjb252ZXJzaW9uIHJhdGUgZnJvbSB0aGUgZ2l2ZW4gbmF0aXZlIGN1cnJlbmN5IHRvXG4gKiB0aGUgZ2l2ZW4gY3VycmVuY3kuIE9wdGlvbmFsbHksIHRoZSBjb252ZXJzaW9uIHJhdGUgZnJvbSB0aGUgbmF0aXZlIGN1cnJlbmN5IHRvIFVTRCBjYW4gYWxzbyBiZVxuICogaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSBjdXJyZW50Q3VycmVuY3kgLSBUaGUgY3VycmVuY3kgdG8gZ2V0IGEgY29udmVyc2lvbiByYXRlIGZvci5cbiAqIEBwYXJhbSBuYXRpdmVDdXJyZW5jeSAtIFRoZSBuYXRpdmUgY3VycmVuY3kgdG8gY29udmVydCBmcm9tLlxuICogQHBhcmFtIGluY2x1ZGVVU0RSYXRlIC0gV2hldGhlciBvciBub3QgdGhlIG5hdGl2ZSBjdXJyZW5jeSB0byBVU0QgY29udmVyc2lvbiByYXRlIHNob3VsZCBiZVxuICogaW5jbHVkZWQgaW4gdGhlIHJlc3BvbnNlIGFzIHdlbGwuXG4gKiBAcmV0dXJucyBUaGUgQVBJIFVSTCBmb3IgZ2V0dGluZyB0aGUgY29udmVyc2lvbiByYXRlLlxuICovXG5mdW5jdGlvbiBnZXRQcmljaW5nVVJMKGN1cnJlbnRDdXJyZW5jeSwgbmF0aXZlQ3VycmVuY3ksIGluY2x1ZGVVU0RSYXRlKSB7XG4gICAgcmV0dXJuIChgaHR0cHM6Ly9taW4tYXBpLmNyeXB0b2NvbXBhcmUuY29tL2RhdGEvcHJpY2U/ZnN5bT1gICtcbiAgICAgICAgYCR7bmF0aXZlQ3VycmVuY3kudG9VcHBlckNhc2UoKX0mdHN5bXM9JHtjdXJyZW50Q3VycmVuY3kudG9VcHBlckNhc2UoKX1gICtcbiAgICAgICAgYCR7aW5jbHVkZVVTRFJhdGUgJiYgY3VycmVudEN1cnJlbmN5LnRvVXBwZXJDYXNlKCkgIT09ICdVU0QnID8gJyxVU0QnIDogJyd9YCk7XG59XG4vKipcbiAqIEZldGNoZXMgdGhlIGV4Y2hhbmdlIHJhdGUgZm9yIGEgZ2l2ZW4gY3VycmVuY3kuXG4gKlxuICogQHBhcmFtIGN1cnJlbmN5IC0gSVNPIDQyMTcgY3VycmVuY3kgY29kZS5cbiAqIEBwYXJhbSBuYXRpdmVDdXJyZW5jeSAtIFN5bWJvbCBmb3IgYmFzZSBhc3NldC5cbiAqIEBwYXJhbSBpbmNsdWRlVVNEUmF0ZSAtIFdoZXRoZXIgdG8gYWRkIHRoZSBVU0QgcmF0ZSB0byB0aGUgZmV0Y2guXG4gKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBleGNoYW5nZSByYXRlIGZvciBnaXZlbiBjdXJyZW5jeS5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hFeGNoYW5nZVJhdGUoY3VycmVuY3ksIG5hdGl2ZUN1cnJlbmN5LCBpbmNsdWRlVVNEUmF0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB5aWVsZCAoMCwgdXRpbF8xLmhhbmRsZUZldGNoKShnZXRQcmljaW5nVVJMKGN1cnJlbmN5LCBuYXRpdmVDdXJyZW5jeSwgaW5jbHVkZVVTRFJhdGUpKTtcbiAgICAgICAgLypcbiAgICAgICAgRXhhbXBsZSBleHBlY3RlZCBlcnJvciByZXNwb25zZSAoaWYgcGFpciBpcyBub3QgZm91bmQpXG4gICAgICAgIHtcbiAgICAgICAgICBSZXNwb25zZTogXCJFcnJvclwiLFxuICAgICAgICAgIE1lc3NhZ2U6IFwiY2NjYWdnX29yX2V4Y2hhbmdlIG1hcmtldCBkb2VzIG5vdCBleGlzdCBmb3IgdGhpcyBjb2luIHBhaXIgKEVUSC08Tk9OX0VYSVNURU5UX1RPS0VOPilcIixcbiAgICAgICAgICBIYXNXYXJuaW5nOiBmYWxzZSxcbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICBpZiAoanNvbi5SZXNwb25zZSA9PT0gJ0Vycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGpzb24uTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udmVyc2lvblJhdGUgPSBOdW1iZXIoanNvbltjdXJyZW5jeS50b1VwcGVyQ2FzZSgpXSk7XG4gICAgICAgIGNvbnN0IHVzZENvbnZlcnNpb25SYXRlID0gTnVtYmVyKGpzb24uVVNEKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoY29udmVyc2lvblJhdGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmVzcG9uc2UgZm9yICR7Y3VycmVuY3kudG9VcHBlckNhc2UoKX06ICR7anNvbltjdXJyZW5jeS50b1VwcGVyQ2FzZSgpXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5jbHVkZVVTRFJhdGUgJiYgIU51bWJlci5pc0Zpbml0ZSh1c2RDb252ZXJzaW9uUmF0ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCByZXNwb25zZSBmb3IgdXNkQ29udmVyc2lvblJhdGU6ICR7anNvbi5VU0R9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgICAgICAgICAgdXNkQ29udmVyc2lvblJhdGUsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoRXhjaGFuZ2VSYXRlID0gZmV0Y2hFeGNoYW5nZVJhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8tY29tcGFyZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaFRva2VuTWV0YWRhdGEgPSBleHBvcnRzLmZldGNoVG9rZW5MaXN0ID0gZXhwb3J0cy5UT0tFTl9NRVRBREFUQV9OT19TVVBQT1JUX0VSUk9SID0gZXhwb3J0cy5UT0tFTl9FTkRfUE9JTlRfQVBJID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5leHBvcnRzLlRPS0VOX0VORF9QT0lOVF9BUEkgPSAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsnO1xuZXhwb3J0cy5UT0tFTl9NRVRBREFUQV9OT19TVVBQT1JUX0VSUk9SID0gJ1Rva2VuU2VydmljZSBFcnJvcjogTmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IGZldGNoVG9rZW5NZXRhZGF0YSc7XG4vKipcbiAqIEdldCB0aGUgdG9rZW5zIFVSTCBmb3IgYSBzcGVjaWZpYyBuZXR3b3JrLlxuICpcbiAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIG9mIHRoZSBuZXR3b3JrIHRoZSB0b2tlbnMgcmVxdWVzdGVkIGFyZSBvbi5cbiAqIEByZXR1cm5zIFRoZSB0b2tlbnMgVVJMLlxuICovXG5mdW5jdGlvbiBnZXRUb2tlbnNVUkwoY2hhaW5JZCkge1xuICAgIHJldHVybiBgJHtleHBvcnRzLlRPS0VOX0VORF9QT0lOVF9BUEl9L3Rva2Vucy8ke2NoYWluSWR9YDtcbn1cbi8qKlxuICogR2V0IHRoZSB0b2tlbiBtZXRhZGF0YSBVUkwgZm9yIHRoZSBnaXZlbiBuZXR3b3JrIGFuZCB0b2tlbi5cbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjaGFpbiBJRCBvZiB0aGUgbmV0d29yayB0aGUgdG9rZW4gaXMgb24uXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIHRva2VuIGFkZHJlc3MuXG4gKiBAcmV0dXJucyBUaGUgdG9rZW4gbWV0YWRhdGEgVVJMLlxuICovXG5mdW5jdGlvbiBnZXRUb2tlbk1ldGFkYXRhVVJMKGNoYWluSWQsIHRva2VuQWRkcmVzcykge1xuICAgIHJldHVybiBgJHtleHBvcnRzLlRPS0VOX0VORF9QT0lOVF9BUEl9L3Rva2VuLyR7Y2hhaW5JZH0/YWRkcmVzcz0ke3Rva2VuQWRkcmVzc31gO1xufVxuY29uc3QgdGVuU2Vjb25kc0luTWlsbGlzZWNvbmRzID0gMTAwMDA7XG4vLyBUb2tlbiBsaXN0IGF2ZXJhZ2VzIDEuNiBNQiBpbiBzaXplXG4vLyB0aW1lb3V0RmV0Y2ggYnkgZGVmYXVsdCBoYXMgYSA1MDBtcyB0aW1lb3V0LCB3aGljaCB3aWxsIGFsbW9zdCBhbHdheXMgdGltZW91dCBnaXZlbiB0aGUgcmVzcG9uc2Ugc2l6ZS5cbmNvbnN0IGRlZmF1bHRUaW1lb3V0ID0gdGVuU2Vjb25kc0luTWlsbGlzZWNvbmRzO1xuLyoqXG4gKiBGZXRjaCB0aGUgbGlzdCBvZiB0b2tlbiBtZXRhZGF0YSBmb3IgYSBnaXZlbiBuZXR3b3JrLiBUaGlzIHJlcXVlc3QgaXMgY2FuY2VsbGFibGUgdXNpbmcgdGhlXG4gKiBhYm9ydCBzaWduYWwgcGFzc2VkIGluLlxuICpcbiAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIG9mIHRoZSBuZXR3b3JrIHRoZSByZXF1ZXN0ZWQgdG9rZW5zIGFyZSBvbi5cbiAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIFRoZSBhYm9ydCBzaWduYWwgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIGZldGNoIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IC0gVGhlIGZldGNoIHRpbWVvdXQuXG4gKiBAcmV0dXJucyBUaGUgdG9rZW4gbGlzdCwgb3IgYHVuZGVmaW5lZGAgaWYgdGhlIHJlcXVlc3Qgd2FzIGNhbmNlbGxlZC5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hUb2tlbkxpc3QoY2hhaW5JZCwgYWJvcnRTaWduYWwsIHsgdGltZW91dCA9IGRlZmF1bHRUaW1lb3V0IH0gPSB7fSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHRva2VuVVJMID0gZ2V0VG9rZW5zVVJMKGNoYWluSWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHF1ZXJ5QXBpKHRva2VuVVJMLCBhYm9ydFNpZ25hbCwgdGltZW91dCk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFRva2VuTGlzdCA9IGZldGNoVG9rZW5MaXN0O1xuLyoqXG4gKiBGZXRjaCBtZXRhZGF0YSBmb3IgdGhlIHRva2VuIGFkZHJlc3MgcHJvdmlkZWQgZm9yIGEgZ2l2ZW4gbmV0d29yay4gVGhpcyByZXF1ZXN0IGlzIGNhbmNlbGxhYmxlXG4gKiB1c2luZyB0aGUgYWJvcnQgc2lnbmFsIHBhc3NlZCBpbi5cbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjaGFpbiBJRCBvZiB0aGUgbmV0d29yayB0aGUgdG9rZW4gaXMgb24uXG4gKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuIHRvIGZldGNoIG1ldGFkYXRhIGZvci5cbiAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIFRoZSBhYm9ydCBzaWduYWwgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIGZldGNoIG9wdGlvbnMuXG4gKiBAcGFyYW0gb3B0aW9ucy50aW1lb3V0IC0gVGhlIGZldGNoIHRpbWVvdXQuXG4gKiBAcmV0dXJucyBUaGUgdG9rZW4gbWV0YWRhdGEsIG9yIGB1bmRlZmluZWRgIGlmIHRoZSByZXF1ZXN0IHdhcyBlaXRoZXIgYWJvcnRlZCBvciBmYWlsZWQuXG4gKi9cbmZ1bmN0aW9uIGZldGNoVG9rZW5NZXRhZGF0YShjaGFpbklkLCB0b2tlbkFkZHJlc3MsIGFib3J0U2lnbmFsLCB7IHRpbWVvdXQgPSBkZWZhdWx0VGltZW91dCB9ID0ge30pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoISgwLCB1dGlsXzEuaXNUb2tlbkxpc3RTdXBwb3J0ZWRGb3JOZXR3b3JrKShjaGFpbklkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGV4cG9ydHMuVE9LRU5fTUVUQURBVEFfTk9fU1VQUE9SVF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9rZW5NZXRhZGF0YVVSTCA9IGdldFRva2VuTWV0YWRhdGFVUkwoY2hhaW5JZCwgdG9rZW5BZGRyZXNzKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBxdWVyeUFwaSh0b2tlbk1ldGFkYXRhVVJMLCBhYm9ydFNpZ25hbCwgdGltZW91dCk7XG4gICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSnNvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaFRva2VuTWV0YWRhdGEgPSBmZXRjaFRva2VuTWV0YWRhdGE7XG4vKipcbiAqIFBlcmZvcm0gZmV0Y2ggcmVxdWVzdCBhZ2FpbnN0IHRoZSBhcGkuXG4gKlxuICogQHBhcmFtIGFwaVVSTCAtIFRoZSBVUkwgb2YgdGhlIEFQSSB0byBmZXRjaC5cbiAqIEBwYXJhbSBhYm9ydFNpZ25hbCAtIFRoZSBhYm9ydCBzaWduYWwgdXNlZCB0byBjYW5jZWwgdGhlIHJlcXVlc3QgaWYgbmVjZXNzYXJ5LlxuICogQHBhcmFtIHRpbWVvdXQgLSBUaGUgZmV0Y2ggdGltZW91dC5cbiAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHJlcXVlc3QgcmVzcG9uc2UuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5QXBpKGFwaVVSTCwgYWJvcnRTaWduYWwsIHRpbWVvdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBmZXRjaE9wdGlvbnMgPSB7XG4gICAgICAgICAgICByZWZlcnJlcjogYXBpVVJMLFxuICAgICAgICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgbW9kZTogJ2NvcnMnLFxuICAgICAgICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGNhY2hlOiAnZGVmYXVsdCcsXG4gICAgICAgIH07XG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gbmV3IHdpbmRvdy5IZWFkZXJzKCk7XG4gICAgICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCAoMCwgdXRpbF8xLnRpbWVvdXRGZXRjaCkoYXBpVVJMLCBmZXRjaE9wdGlvbnMsIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlcXVlc3QgaXMgYWJvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG59XG4vKipcbiAqIFBhcnNlIGFuIEFQSSByZXNwb25zZSBhbmQgcmV0dXJuIHRoZSByZXNwb25zZSBKU09OIGRhdGEuXG4gKlxuICogQHBhcmFtIGFwaVJlc3BvbnNlIC0gVGhlIEFQSSByZXNwb25zZSB0byBwYXJzZS5cbiAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBKU09OIGRhdGEuXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIHJlc3BvbnNlIGluY2x1ZGVzIGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBwYXJzZUpzb25SZXNwb25zZShhcGlSZXNwb25zZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlT2JqID0geWllbGQgYXBpUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAvLyBhcGkgbWF5IHJldHVybiBlcnJvcnMgYXMganNvbiB3aXRob3V0IHNldHRpbmcgYW4gZXJyb3IgaHR0cCBzdGF0dXMgY29kZVxuICAgICAgICBpZiAocmVzcG9uc2VPYmogPT09IG51bGwgfHwgcmVzcG9uc2VPYmogPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlT2JqLmVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRva2VuU2VydmljZSBFcnJvcjogJHtyZXNwb25zZU9iai5lcnJvcn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2VPYmo7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbi1zZXJ2aWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcHByb3ZhbENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdBcHByb3ZhbENvbnRyb2xsZXInO1xuY29uc3Qgc3RhdGVNZXRhZGF0YSA9IHtcbiAgICBwZW5kaW5nQXBwcm92YWxzOiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IHRydWUgfSxcbiAgICBwZW5kaW5nQXBwcm92YWxDb3VudDogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxufTtcbmNvbnN0IGdldEFscmVhZHlQZW5kaW5nTWVzc2FnZSA9IChvcmlnaW4sIHR5cGUpID0+IGBSZXF1ZXN0IG9mIHR5cGUgJyR7dHlwZX0nIGFscmVhZHkgcGVuZGluZyBmb3Igb3JpZ2luICR7b3JpZ2lufS4gUGxlYXNlIHdhaXQuYDtcbmNvbnN0IGdldERlZmF1bHRTdGF0ZSA9ICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwZW5kaW5nQXBwcm92YWxzOiB7fSxcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsQ291bnQ6IDAsXG4gICAgfTtcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgZm9yIG1hbmFnaW5nIHJlcXVlc3RzIHRoYXQgcmVxdWlyZSB1c2VyIGFwcHJvdmFsLlxuICpcbiAqIEVuYWJsZXMgbGltaXRpbmcgdGhlIG51bWJlciBvZiBwZW5kaW5nIHJlcXVlc3RzIGJ5IG9yaWdpbiBhbmQgdHlwZSwgY291bnRpbmdcbiAqIHBlbmRpbmcgcmVxdWVzdHMsIGFuZCBtb3JlLlxuICpcbiAqIEFkZGluZyBhIHJlcXVlc3QgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIHdoZW4gdGhlIHJlcXVlc3RcbiAqIGlzIGFwcHJvdmVkIG9yIGRlbmllZCwgcmVzcGVjdGl2ZWx5LlxuICovXG5jbGFzcyBBcHByb3ZhbENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdCBhbiBBcHByb3ZhbCBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNob3dBcHByb3ZhbFJlcXVlc3QgLSBGdW5jdGlvbiBmb3Igb3BlbmluZyB0aGUgVUkgc3VjaCB0aGF0XG4gICAgICogdGhlIHJlcXVlc3QgY2FuIGJlIGRpc3BsYXllZCB0byB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5tZXNzZW5nZXIgLSBUaGUgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3NlbmdlciBmb3IgdGhlIEFwcHJvdmFsIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhdGUgLSBUaGUgaW5pdGlhbCBjb250cm9sbGVyIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2VuZ2VyLCBzaG93QXBwcm92YWxSZXF1ZXN0LCBzdGF0ZSA9IHt9LCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWU6IGNvbnRyb2xsZXJOYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGE6IHN0YXRlTWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXREZWZhdWx0U3RhdGUoKSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FwcHJvdmFscyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb3JpZ2lucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fc2hvd0FwcHJvdmFsUmVxdWVzdCA9IHNob3dBcHByb3ZhbFJlcXVlc3Q7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgaGVscGVyIGZvciByZWdpc3RlcmluZyB0aGlzIGNvbnRyb2xsZXIncyBtZXNzYWdpbmcgc3lzdGVtXG4gICAgICogYWN0aW9ucy5cbiAgICAgKi9cbiAgICByZWdpc3Rlck1lc3NhZ2VIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpjbGVhclJlcXVlc3RzYCwgdGhpcy5jbGVhci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTphZGRSZXF1ZXN0YCwgKG9wdHMsIHNob3VsZFNob3dSZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2hvd1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KG9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpoYXNSZXF1ZXN0YCwgdGhpcy5oYXMuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06YWNjZXB0UmVxdWVzdGAsIHRoaXMuYWNjZXB0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OnJlamVjdFJlcXVlc3RgLCB0aGlzLnJlamVjdC5iaW5kKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBhcHByb3ZhbCByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gYXJndW1lbnRzLCBjYWxscyB0aGUgc2hvdyBhcHByb3ZhbFxuICAgICAqIHJlcXVlc3QgZnVuY3Rpb24sIGFuZCByZXR1cm5zIHRoZSBhc3NvY2lhdGVkIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgYXBwcm92YWwgcGVyIG9yaWdpbiBhbmQgdHlwZS4gQW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gICAgICogYXR0ZW1wdGluZyB0byBhZGQgYW4gaW52YWxpZCBvciBkdXBsaWNhdGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuIEEgcmFuZG9tIGlkIHdpbGwgYmVcbiAgICAgKiBnZW5lcmF0ZWQgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMucmVxdWVzdERhdGEgLSBBZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LFxuICAgICAqIGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBhZGRBbmRTaG93QXBwcm92YWxSZXF1ZXN0KG9wdHMpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IHRoaXMuX2FkZChvcHRzLm9yaWdpbiwgb3B0cy50eXBlLCBvcHRzLmlkLCBvcHRzLnJlcXVlc3REYXRhKTtcbiAgICAgICAgdGhpcy5fc2hvd0FwcHJvdmFsUmVxdWVzdCgpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBhcHByb3ZhbCByZXF1ZXN0IHBlciB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFuZCByZXR1cm5zIHRoZSBhcHByb3ZhbFxuICAgICAqIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBUaGVyZSBjYW4gb25seSBiZSBvbmUgYXBwcm92YWwgcGVyIG9yaWdpbiBhbmQgdHlwZS4gQW4gZXJyb3IgaXMgdGhyb3duIGlmXG4gICAgICogYXR0ZW1wdGluZyB0byBhZGQgYW4gaW52YWxpZCBvciBkdXBsaWNhdGUgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuIEEgcmFuZG9tIGlkIHdpbGwgYmVcbiAgICAgKiBnZW5lcmF0ZWQgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgKiBAcGFyYW0gb3B0cy5vcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9wdHMucmVxdWVzdERhdGEgLSBBZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LFxuICAgICAqIGlmIGFueS5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKi9cbiAgICBhZGQob3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkKG9wdHMub3JpZ2luLCBvcHRzLnR5cGUsIG9wdHMuaWQsIG9wdHMucmVxdWVzdERhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmZvIGZvciB0aGUgYXBwcm92YWwgcmVxdWVzdCB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgYXBwcm92YWwgcmVxdWVzdCBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUgaWQuXG4gICAgICovXG4gICAgZ2V0KGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnBlbmRpbmdBcHByb3ZhbHNbaWRdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgcGVuZGluZyBhcHByb3ZhbHMsIGJ5IG9yaWdpbiBhbmQvb3IgdHlwZS5cbiAgICAgKlxuICAgICAqIElmIG9ubHkgYG9yaWdpbmAgaXMgc3BlY2lmaWVkLCBhbGwgYXBwcm92YWxzIGZvciB0aGF0IG9yaWdpbiB3aWxsIGJlXG4gICAgICogY291bnRlZCwgcmVnYXJkbGVzcyBvZiB0eXBlLlxuICAgICAqIElmIG9ubHkgYHR5cGVgIGlzIHNwZWNpZmllZCwgYWxsIGFwcHJvdmFscyBmb3IgdGhhdCB0eXBlIHdpbGwgYmUgY291bnRlZCxcbiAgICAgKiByZWdhcmRsZXNzIG9mIG9yaWdpbi5cbiAgICAgKiBJZiBib3RoIGBvcmlnaW5gIGFuZCBgdHlwZWAgYXJlIHNwZWNpZmllZCwgMCBvciAxIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIFRoZSBhcHByb3ZhbCBjb3VudCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIEFuIGFwcHJvdmFsIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0gb3B0cy50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgYXBwcm92YWwgcmVxdWVzdCBjb3VudCBmb3IgdGhlIGdpdmVuIG9yaWdpbiBhbmQvb3JcbiAgICAgKiB0eXBlLlxuICAgICAqL1xuICAgIGdldEFwcHJvdmFsQ291bnQob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICghb3B0cy5vcmlnaW4gJiYgIW9wdHMudHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgb3JpZ2luLCB0eXBlLCBvciBib3RoLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luLCB0eXBlOiBfdHlwZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKG9yaWdpbiAmJiBfdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihCb29sZWFuKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoX3R5cGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbikge1xuICAgICAgICAgICAgcmV0dXJuICgoX2IgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2l6ZSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IFwidHlwZVwiIHdhcyBzcGVjaWZpZWRcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBhcHByb3ZhbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFscykpIHtcbiAgICAgICAgICAgIGlmIChhcHByb3ZhbC50eXBlID09PSBfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRvdGFsIGNvdW50IG9mIGFsbCBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3RzIGZvciBhbGwgb3JpZ2lucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSB0b3RhbCBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3QgY291bnQuXG4gICAgICovXG4gICAgZ2V0VG90YWxBcHByb3ZhbENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wZW5kaW5nQXBwcm92YWxDb3VudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZXJlJ3MgYSBwZW5kaW5nIGFwcHJvdmFsIHJlcXVlc3QgcGVyIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuICAgICAqIEF0IGxlYXN0IG9uZSBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQuIEFuIGVycm9yIHdpbGwgYmUgdGhyb3duIGlmIHRoZVxuICAgICAqIHBhcmFtZXRlcnMgYXJlIGludmFsaWQuXG4gICAgICpcbiAgICAgKiBJZiBgaWRgIGlzIHNwZWNpZmllZCwgYWxsIG90aGVyIHBhcmFtZXRlcnMgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIElmIGBpZGAgaXMgbm90IHNwZWNpZmllZCwgdGhlIG1ldGhvZCB3aWxsIGNoZWNrIGZvciByZXF1ZXN0cyB0aGF0IG1hdGNoXG4gICAgICogYWxsIG9mIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gT3B0aW9ucyBiYWcuXG4gICAgICogQHBhcmFtIG9wdHMuaWQgLSBUaGUgSUQgdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRzLm9yaWdpbiAtIFRoZSBvcmlnaW4gdG8gY2hlY2sgZm9yLlxuICAgICAqIEBwYXJhbSBvcHRzLnR5cGUgLSBUaGUgdHlwZSB0byBjaGVjayBmb3IuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIGEgbWF0Y2hpbmcgYXBwcm92YWwgaXMgZm91bmQsIGFuZCBgZmFsc2VgIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICBoYXMob3B0cyA9IHt9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBpZCwgb3JpZ2luLCB0eXBlOiBfdHlwZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgaWQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXBwcm92YWxzLmhhcyhpZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90eXBlICYmIHR5cGVvZiBfdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF5IG5vdCBzcGVjaWZ5IG5vbi1zdHJpbmcgdHlwZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ2luKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9yaWdpbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heSBub3Qgc3BlY2lmeSBub24tc3RyaW5nIG9yaWdpbi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIG9yaWdpbiBhbmQgdHlwZSBwYWlyIGlmIHR5cGUgYWxzbyBzcGVjaWZpZWRcbiAgICAgICAgICAgIGlmIChfdHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMoX3R5cGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9vcmlnaW5zLmhhcyhvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdHlwZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBhcHByb3ZhbCBvZiBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFscykpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwcm92YWwudHlwZSA9PT0gX3R5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IGEgdmFsaWQgY29tYmluYXRpb24gb2YgaWQsIG9yaWdpbiwgYW5kIHR5cGUuJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBwcm9taXNlIG9mIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZCwgYW5kIGRlbGV0ZXMgdGhlXG4gICAgICogYXBwcm92YWwuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIGFwcHJvdmFsIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gcmVzb2x2ZSB0aGUgYXBwcm92YWwgcHJvbWlzZSB3aXRoLlxuICAgICAqL1xuICAgIGFjY2VwdChpZCwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVsZXRlQXBwcm92YWxBbmRHZXRDYWxsYmFja3MoaWQpLnJlc29sdmUodmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwcm9taXNlIG9mIHRoZSBhcHByb3ZhbCB3aXRoIHRoZSBnaXZlbiBpZCwgYW5kIGRlbGV0ZXMgdGhlXG4gICAgICogYXBwcm92YWwuIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIGFwcHJvdmFsIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gcmVqZWN0IHRoZSBhcHByb3ZhbCBwcm9taXNlIHdpdGguXG4gICAgICovXG4gICAgcmVqZWN0KGlkLCBlcnJvcikge1xuICAgICAgICB0aGlzLl9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhbmQgZGVsZXRlcyBhbGwgYXBwcm92YWwgcmVxdWVzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVqZWN0aW9uRXJyb3IgLSBUaGUgRXRoZXJldW1ScGNFcnJvciB0byByZWplY3QgdGhlIGFwcHJvdmFsXG4gICAgICogcmVxdWVzdHMgd2l0aC5cbiAgICAgKi9cbiAgICBjbGVhcihyZWplY3Rpb25FcnJvcikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMuX2FwcHJvdmFscy5rZXlzKCkpIHtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0KGlkLCByZWplY3Rpb25FcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb3JpZ2lucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiBnZXREZWZhdWx0U3RhdGUoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudGF0aW9uIG9mIGFkZCBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIGFzc29jaWF0ZWQgd2l0aCB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHJldHVybnMgVGhlIGFwcHJvdmFsIHByb21pc2UuXG4gICAgICovXG4gICAgX2FkZChvcmlnaW4sIHR5cGUsIGlkID0gKDAsIG5hbm9pZF8xLm5hbm9pZCkoKSwgcmVxdWVzdERhdGEpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl92YWxpZGF0ZUFkZFBhcmFtcyhpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl9vcmlnaW5zLmdldChvcmlnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMucmVzb3VyY2VVbmF2YWlsYWJsZShnZXRBbHJlYWR5UGVuZGluZ01lc3NhZ2Uob3JpZ2luLCB0eXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIHBlbmRpbmcgYXBwcm92YWxcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2FwcHJvdmFscy5zZXQoaWQsIHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgdGhpcy5fYWRkUGVuZGluZ0FwcHJvdmFsT3JpZ2luKG9yaWdpbiwgdHlwZSk7XG4gICAgICAgICAgICB0aGlzLl9hZGRUb1N0b3JlKGlkLCBvcmlnaW4sIHR5cGUsIHJlcXVlc3REYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBwYXJhbWV0ZXJzIHRvIHRoZSBhZGQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSB0eXBlIC0gVGhlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSByZXF1ZXN0RGF0YSAtIFRoZSByZXF1ZXN0IGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF92YWxpZGF0ZUFkZFBhcmFtcyhpZCwgb3JpZ2luLCB0eXBlLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gbnVsbDtcbiAgICAgICAgaWYgKCFpZCB8fCB0eXBlb2YgaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnTXVzdCBzcGVjaWZ5IG5vbi1lbXB0eSBzdHJpbmcgaWQuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9hcHByb3ZhbHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gYEFwcHJvdmFsIHJlcXVlc3Qgd2l0aCBpZCAnJHtpZH0nIGFscmVhZHkgZXhpc3RzLmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIW9yaWdpbiB8fCB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ011c3Qgc3BlY2lmeSBub24tZW1wdHkgc3RyaW5nIG9yaWdpbi4nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gJ011c3Qgc3BlY2lmeSBub24tZW1wdHkgc3RyaW5nIHR5cGUuJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0RGF0YSAmJlxuICAgICAgICAgICAgKHR5cGVvZiByZXF1ZXN0RGF0YSAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShyZXF1ZXN0RGF0YSkpKSB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSAnUmVxdWVzdCBkYXRhIG11c3QgYmUgYSBwbGFpbiBvYmplY3QgaWYgc3BlY2lmaWVkLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKGVycm9yTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBlbnRyeSB0byBfb3JpZ2lucy5cbiAgICAgKiBQZXJmb3JtcyBubyB2YWxpZGF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX2FkZFBlbmRpbmdBcHByb3ZhbE9yaWdpbihvcmlnaW4sIHR5cGUpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luU2V0ID0gdGhpcy5fb3JpZ2lucy5nZXQob3JpZ2luKSB8fCBuZXcgU2V0KCk7XG4gICAgICAgIG9yaWdpblNldC5hZGQodHlwZSk7XG4gICAgICAgIGlmICghdGhpcy5fb3JpZ2lucy5oYXMob3JpZ2luKSkge1xuICAgICAgICAgICAgdGhpcy5fb3JpZ2lucy5zZXQob3JpZ2luLCBvcmlnaW5TZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnkgdG8gdGhlIHN0b3JlLlxuICAgICAqIFBlcmZvcm1zIG5vIHZhbGlkYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3REYXRhIC0gVGhlIHJlcXVlc3QgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGFwcHJvdmFsIHJlcXVlc3QuXG4gICAgICovXG4gICAgX2FkZFRvU3RvcmUoaWQsIG9yaWdpbiwgdHlwZSwgcmVxdWVzdERhdGEpIHtcbiAgICAgICAgY29uc3QgYXBwcm92YWwgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgcmVxdWVzdERhdGE6IHJlcXVlc3REYXRhIHx8IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogdHMoMjU4OSlcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsc1tpZF0gPSBhcHByb3ZhbDtcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsQ291bnQgPSBPYmplY3Qua2V5cyhkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgdGhlIGFwcHJvdmFsIHdpdGggdGhlIGdpdmVuIGlkLiBUaGUgYXBwcm92YWwgcHJvbWlzZSBtdXN0IGJlXG4gICAgICogcmVzb2x2ZWQgb3IgcmVqZWN0IGJlZm9yZSB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICogRGVsZXRpb24gaXMgYW4gaW50ZXJuYWwgb3BlcmF0aW9uIGJlY2F1c2UgYXBwcm92YWwgc3RhdGUgaXMgc29sZWx5XG4gICAgICogbWFuYWdlZCBieSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgLSBUaGUgaWQgb2YgdGhlIGFwcHJvdmFsIHJlcXVlc3QgdG8gYmUgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBfZGVsZXRlKGlkKSB7XG4gICAgICAgIHRoaXMuX2FwcHJvdmFscy5kZWxldGUoaWQpO1xuICAgICAgICAvLyBUaGlzIG1ldGhvZCBpcyBvbmx5IGNhbGxlZCBhZnRlciB2ZXJpZnlpbmcgdGhhdCB0aGUgYXBwcm92YWwgd2l0aCB0aGVcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlkIGV4aXN0cy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgeyBvcmlnaW4sIHR5cGUgfSA9IHRoaXMuc3RhdGUucGVuZGluZ0FwcHJvdmFsc1tpZF07XG4gICAgICAgIHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikuZGVsZXRlKHR5cGUpO1xuICAgICAgICBpZiAodGhpcy5faXNFbXB0eU9yaWdpbihvcmlnaW4pKSB7XG4gICAgICAgICAgICB0aGlzLl9vcmlnaW5zLmRlbGV0ZShvcmlnaW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgZHJhZnRTdGF0ZS5wZW5kaW5nQXBwcm92YWxzW2lkXTtcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUucGVuZGluZ0FwcHJvdmFsQ291bnQgPSBPYmplY3Qua2V5cyhkcmFmdFN0YXRlLnBlbmRpbmdBcHByb3ZhbHMpLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFwcHJvdmFsIGNhbGxiYWNrcyBmb3IgdGhlIGdpdmVuIGlkLCBkZWxldGVzIHRoZSBlbnRyeSwgYW5kIHRoZW5cbiAgICAgKiByZXR1cm5zIHRoZSBjYWxsYmFja3MgZm9yIHByb21pc2UgcmVzb2x1dGlvbi5cbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gYXBwcm92YWwgaXMgZm91bmQgZm9yIHRoZSBnaXZlbiBpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgYXBwcm92YWwgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcHJvbWlzZSBjYWxsYmFja3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBhcHByb3ZhbCByZXF1ZXN0LlxuICAgICAqL1xuICAgIF9kZWxldGVBcHByb3ZhbEFuZEdldENhbGxiYWNrcyhpZCkge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLl9hcHByb3ZhbHMuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXBwcm92YWwgcmVxdWVzdCB3aXRoIGlkICcke2lkfScgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbGV0ZShpZCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFja3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgYXBwcm92YWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgKiBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBvcmlnaW4gaGFzIG5vIGFwcHJvdmFscywgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIF9pc0VtcHR5T3JpZ2luKG9yaWdpbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAhKChfYSA9IHRoaXMuX29yaWdpbnMuZ2V0KG9yaWdpbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKTtcbiAgICB9XG59XG5leHBvcnRzLkFwcHJvdmFsQ29udHJvbGxlciA9IEFwcHJvdmFsQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFwcHJvdmFsQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFwcHJvdmFsQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBldGhfcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXF1ZXJ5XCIpKTtcbmNvbnN0IGFzeW5jX211dGV4XzEgPSByZXF1aXJlKFwiYXN5bmMtbXV0ZXhcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCB0cmFja3MgaW5mb3JtYXRpb24gZm9yIGFsbCBhY2NvdW50cyBpbiB0aGUgY3VycmVudCBrZXljaGFpblxuICovXG5jbGFzcyBBY2NvdW50VHJhY2tlckNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIEFjY291bnRUcmFja2VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBwcmVmZXJlbmNlIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRJZGVudGl0aWVzIC0gR2V0cyB0aGUgaWRlbnRpdGllcyBmcm9tIHRoZSBQcmVmZXJlbmNlcyBzdG9yZS5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIGdldElkZW50aXRpZXMsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBY2NvdW50VHJhY2tlckNvbnRyb2xsZXInO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVmcmVzaGVzIGFsbCBhY2NvdW50cyBpbiB0aGUgY3VycmVudCBrZXljaGFpbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmcmVzaCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3luY0FjY291bnRzKCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUuYWNjb3VudHMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBhZGRyZXNzIGluIGFjY291bnRzKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQpKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHlpZWxkICgwLCB1dGlsXzEucXVlcnkpKHRoaXMuZXRoUXVlcnksICdnZXRCYWxhbmNlJywgW2FkZHJlc3NdKTtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHNbYWRkcmVzc10gPSB7IGJhbGFuY2U6ICgwLCB1dGlsXzEuQk5Ub0hleCkoYmFsYW5jZSkgfTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGFjY291bnRzIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IDEwMDAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHsgYWNjb3VudHM6IHt9IH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmdldElkZW50aXRpZXMgPSBnZXRJZGVudGl0aWVzO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgc3luY0FjY291bnRzKCkge1xuICAgICAgICBjb25zdCB7IGFjY291bnRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBhZGRyZXNzZXMgPSBPYmplY3Qua2V5cyh0aGlzLmdldElkZW50aXRpZXMoKSk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nID0gT2JqZWN0LmtleXMoYWNjb3VudHMpO1xuICAgICAgICBjb25zdCBuZXdBZGRyZXNzZXMgPSBhZGRyZXNzZXMuZmlsdGVyKChhZGRyZXNzKSA9PiBleGlzdGluZy5pbmRleE9mKGFkZHJlc3MpID09PSAtMSk7XG4gICAgICAgIGNvbnN0IG9sZEFkZHJlc3NlcyA9IGV4aXN0aW5nLmZpbHRlcigoYWRkcmVzcykgPT4gYWRkcmVzc2VzLmluZGV4T2YoYWRkcmVzcykgPT09IC0xKTtcbiAgICAgICAgbmV3QWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGFjY291bnRzW2FkZHJlc3NdID0geyBiYWxhbmNlOiAnMHgwJyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgb2xkQWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBhY2NvdW50c1thZGRyZXNzXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgYWNjb3VudHM6IE9iamVjdC5hc3NpZ24oe30sIGFjY291bnRzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBwcm92aWRlci5cbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3dGggYSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXIgLSBQcm92aWRlciB1c2VkIHRvIGNyZWF0ZSBhIG5ldyB1bmRlcmx5aW5nIEV0aFF1ZXJ5IGluc3RhbmNlLlxuICAgICAqL1xuICAgIHNldCBwcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQocHJvdmlkZXIpO1xuICAgIH1cbiAgICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB0cmlnZ2VyIGEgJ3JlZnJlc2gnLlxuICAgICAqL1xuICAgIHBvbGwoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmMgYWNjb3VudHMgYmFsYW5jZXMgd2l0aCBzb21lIGFkZGl0aW9uYWwgYWRkcmVzc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIHRoZSBhZGRpdGlvbmFsIGFkZHJlc3NlcywgbWF5IGJlIGhhcmR3YXJlIHdhbGxldCBhZGRyZXNzZXMuXG4gICAgICogQHJldHVybnMgYWNjb3VudHMgLSBhZGRyZXNzZXMgd2l0aCBzeW5jZWQgYmFsYW5jZVxuICAgICAqL1xuICAgIHN5bmNCYWxhbmNlV2l0aEFkZHJlc3NlcyhhZGRyZXNzZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLmFsbChhZGRyZXNzZXMubWFwKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZVdpdGhUaW1lb3V0KSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhbGFuY2UgPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0QmFsYW5jZScsIFthZGRyZXNzXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYWRkcmVzcywgYmFsYW5jZV07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnJlZHVjZSgob2JqLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbYWRkcmVzcywgYmFsYW5jZV0gPSBpdGVtO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvYmopLCB7IFthZGRyZXNzXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFjY291bnRUcmFja2VyQ29udHJvbGxlciA9IEFjY291bnRUcmFja2VyQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFjY291bnRUcmFja2VyQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjY291bnRUcmFja2VyQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Bc3NldHNDb250cmFjdENvbnRyb2xsZXIgPSBleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IgPSBleHBvcnRzLlNJTkdMRV9DQUxMX0JBTEFOQ0VTX0FERFJFU1NfQllfQ0hBSU5JRCA9IHZvaWQgMDtcbmNvbnN0IHdlYjNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2ViM1wiKSk7XG5jb25zdCBzaW5nbGVfY2FsbF9iYWxhbmNlX2NoZWNrZXJfYWJpXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInNpbmdsZS1jYWxsLWJhbGFuY2UtY2hlY2tlci1hYmlcIikpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgRVJDNzIxU3RhbmRhcmRfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYXJkcy9Db2xsZWN0aWJsZVN0YW5kYXJkcy9FUkM3MjEvRVJDNzIxU3RhbmRhcmRcIik7XG5jb25zdCBFUkMxMTU1U3RhbmRhcmRfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYXJkcy9Db2xsZWN0aWJsZVN0YW5kYXJkcy9FUkMxMTU1L0VSQzExNTVTdGFuZGFyZFwiKTtcbmNvbnN0IEVSQzIwU3RhbmRhcmRfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYXJkcy9FUkMyMFN0YW5kYXJkXCIpO1xuLyoqXG4gKiBDaGVjayBpZiB0b2tlbiBkZXRlY3Rpb24gaXMgZW5hYmxlZCBmb3IgY2VydGFpbiBuZXR3b3Jrc1xuICpcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW5JRCBvZiBuZXR3b3JrXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBjdXJyZW50IG5ldHdvcmsgc3VwcG9ydHMgdG9rZW4gZGV0ZWN0aW9uXG4gKi9cbmV4cG9ydHMuU0lOR0xFX0NBTExfQkFMQU5DRVNfQUREUkVTU19CWV9DSEFJTklEID0ge1xuICAgIFt1dGlsXzEuU3VwcG9ydGVkVG9rZW5EZXRlY3Rpb25OZXR3b3Jrcy5tYWlubmV0XTogJzB4YjFmOGU1NWM3ZjY0ZDIwM2MxNDAwYjlkODU1NWQwNTBmOTRhZGYzOScsXG4gICAgW3V0aWxfMS5TdXBwb3J0ZWRUb2tlbkRldGVjdGlvbk5ldHdvcmtzLmJzY106ICcweDIzNTJjNjNBODNmOUZkMTI2YWY4Njc2MTQ2NzIxRmEwMDkyNGQ3ZTQnLFxuICAgIFt1dGlsXzEuU3VwcG9ydGVkVG9rZW5EZXRlY3Rpb25OZXR3b3Jrcy5wb2x5Z29uXTogJzB4MjM1MmM2M0E4M2Y5RmQxMjZhZjg2NzYxNDY3MjFGYTAwOTI0ZDdlNCcsXG4gICAgW3V0aWxfMS5TdXBwb3J0ZWRUb2tlbkRldGVjdGlvbk5ldHdvcmtzLmF2YXhdOiAnMHhEMDIzRDE1M2EwREZhNDg1MTMwRUNGZEUyRkFBN2U2MTJFRjk0ODE4Jyxcbn07XG5leHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IgPSAnQXNzZXRzQ29udHJhY3RDb250cm9sbGVyIGZhaWxlZCB0byBzZXQgdGhlIHByb3ZpZGVyIGNvcnJlY3RseS4gQSBwcm92aWRlciBtdXN0IGJlIHNldCBmb3IgdGhpcyBtZXRob2QgdG8gYmUgYXZhaWxhYmxlJztcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IGludGVyYWN0cyB3aXRoIGNvbnRyYWN0cyBvbiBtYWlubmV0IHRocm91Z2ggd2ViM1xuICovXG5jbGFzcyBBc3NldHNDb250cmFjdENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlcl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQXNzZXRzQ29udHJhY3RDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBwcmVmZXJlbmNlIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBc3NldHNDb250cmFjdENvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBwcm92aWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXBmc0dhdGV3YXk6IGNvbnN0YW50c18xLklQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCxcbiAgICAgICAgICAgIGNoYWluSWQ6IHV0aWxfMS5TdXBwb3J0ZWRUb2tlbkRldGVjdGlvbk5ldHdvcmtzLm1haW5uZXQsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHsgaXBmc0dhdGV3YXkgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBpcGZzR2F0ZXdheSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKChuZXR3b3JrU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmZpZy5jaGFpbklkICE9PSBuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogbmV0d29ya1N0YXRlLnByb3ZpZGVyLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IHByb3ZpZGVyLlxuICAgICAqXG4gICAgICogVE9ETzogUmVwbGFjZSB0aGlzIHd0aCBhIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSBwcm92aWRlciAtIFByb3ZpZGVyIHVzZWQgdG8gY3JlYXRlIGEgbmV3IHVuZGVybHlpbmcgV2ViMyBpbnN0YW5jZVxuICAgICAqL1xuICAgIHNldCBwcm92aWRlcihwcm92aWRlcikge1xuICAgICAgICB0aGlzLndlYjMgPSBuZXcgd2ViM18xLmRlZmF1bHQocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLmVyYzcyMVN0YW5kYXJkID0gbmV3IEVSQzcyMVN0YW5kYXJkXzEuRVJDNzIxU3RhbmRhcmQodGhpcy53ZWIzKTtcbiAgICAgICAgdGhpcy5lcmMxMTU1U3RhbmRhcmQgPSBuZXcgRVJDMTE1NVN0YW5kYXJkXzEuRVJDMTE1NVN0YW5kYXJkKHRoaXMud2ViMyk7XG4gICAgICAgIHRoaXMuZXJjMjBTdGFuZGFyZCA9IG5ldyBFUkMyMFN0YW5kYXJkXzEuRVJDMjBTdGFuZGFyZCh0aGlzLndlYjMpO1xuICAgIH1cbiAgICBnZXQgcHJvdmlkZXIoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBiYWxhbmNlIG9yIGNvdW50IGZvciBjdXJyZW50IGFjY291bnQgb24gc3BlY2lmaWMgYXNzZXQgY29udHJhY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFzc2V0IEVSQzIwIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIEN1cnJlbnQgYWNjb3VudCBwdWJsaWMgYWRkcmVzcy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBCTiBvYmplY3QgY29udGFpbmluZyBiYWxhbmNlIGZvciBjdXJyZW50IGFjY291bnQgb24gc3BlY2lmaWMgYXNzZXQgY29udHJhY3QuXG4gICAgICovXG4gICAgZ2V0RVJDMjBCYWxhbmNlT2YoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXJjMjBTdGFuZGFyZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJjMjBTdGFuZGFyZC5nZXRCYWxhbmNlT2YoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciB0aGUgZGVjaW1hbHMgZm9yIGEgZ2l2ZW4gRVJDMjAgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdkZWNpbWFscycuXG4gICAgICovXG4gICAgZ2V0RVJDMjBUb2tlbkRlY2ltYWxzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVyYzIwU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZXJjMjBTdGFuZGFyZC5nZXRUb2tlbkRlY2ltYWxzKGFkZHJlc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW51bWVyYXRlIGFzc2V0cyBhc3NpZ25lZCB0byBhbiBvd25lci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIEN1cnJlbnQgYWNjb3VudCBwdWJsaWMgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gaW5kZXggLSBBIGNvbGxlY3RpYmxlIGNvdW50ZXIgbGVzcyB0aGFuIGBiYWxhbmNlT2Yoc2VsZWN0ZWRBZGRyZXNzKWAuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdG9rZW4gaWRlbnRpZmllciBmb3IgdGhlICdpbmRleCd0aCBhc3NldCBhc3NpZ25lZCB0byAnc2VsZWN0ZWRBZGRyZXNzJy5cbiAgICAgKi9cbiAgICBnZXRFUkM3MjFDb2xsZWN0aWJsZVRva2VuSWQoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzLCBpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5lcmM3MjFTdGFuZGFyZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5NSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lcmM3MjFTdGFuZGFyZC5nZXRDb2xsZWN0aWJsZVRva2VuSWQoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzLCBpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudW1lcmF0ZSBhc3NldHMgYXNzaWduZWQgdG8gYW4gb3duZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHVzZXJBZGRyZXNzIC0gQ3VycmVudCBhY2NvdW50IHB1YmxpYyBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gRVJDNzIxIGFzc2V0IGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VuIHN0YW5kYXJkIGFuZCBhIHNldCBvZiBkZXRhaWxzIHdoaWNoIGRlcGVuZCBvbiB3aGljaCBzdGFuZGFyZCB0aGUgdG9rZW4gc3VwcG9ydHMuXG4gICAgICovXG4gICAgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHModG9rZW5BZGRyZXNzLCB1c2VyQWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjNzIxU3RhbmRhcmQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZXJjMTE1NVN0YW5kYXJkID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmVyYzIwU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBpcGZzR2F0ZXdheSB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAvLyBFUkM3MjFcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sICh5aWVsZCB0aGlzLmVyYzcyMVN0YW5kYXJkLmdldERldGFpbHModG9rZW5BZGRyZXNzLCBpcGZzR2F0ZXdheSwgdG9rZW5JZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRVJDMTE1NVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKHlpZWxkIHRoaXMuZXJjMTE1NVN0YW5kYXJkLmdldERldGFpbHModG9rZW5BZGRyZXNzLCBpcGZzR2F0ZXdheSwgdG9rZW5JZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgIC8vIElnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRVJDMjBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sICh5aWVsZCB0aGlzLmVyYzIwU3RhbmRhcmQuZ2V0RGV0YWlscyh0b2tlbkFkZHJlc3MsIHVzZXJBZGRyZXNzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9jKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlcm1pbmUgY29udHJhY3Qgc3RhbmRhcmQnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciB0b2tlblVSSSBmb3IgYSBnaXZlbiBFUkM3MjEgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gRVJDNzIxIGFzc2V0IGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICd0b2tlblVSSScuXG4gICAgICovXG4gICAgZ2V0RVJDNzIxVG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjNzIxU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJjNzIxU3RhbmRhcmQuZ2V0VG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgbmFtZSBmb3IgYSBnaXZlbiBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIG9yIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICduYW1lJy5cbiAgICAgKi9cbiAgICBnZXRFUkM3MjFBc3NldE5hbWUoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjNzIxU3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJjNzIxU3RhbmRhcmQuZ2V0QXNzZXROYW1lKGFkZHJlc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIHN5bWJvbCBmb3IgYSBnaXZlbiBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIG9yIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdzeW1ib2wnLlxuICAgICAqL1xuICAgIGdldEVSQzcyMUFzc2V0U3ltYm9sKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVyYzcyMVN0YW5kYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5NSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYzcyMVN0YW5kYXJkLmdldEFzc2V0U3ltYm9sKGFkZHJlc3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgZm9yIG93bmVyIGZvciBhIGdpdmVuIEVSQzcyMSBhc3NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBFUkM3MjEgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgb3duZXIgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXRFUkM3MjFPd25lck9mKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmVyYzcyMVN0YW5kYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5NSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYzcyMVN0YW5kYXJkLmdldE93bmVyT2YoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgdG9rZW5VUkkgZm9yIGEgZ2l2ZW4gYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzExNTUgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIEVSQzExNTUgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3Rva2VuVVJJJy5cbiAgICAgKi9cbiAgICBnZXRFUkMxMTU1VG9rZW5VUkkoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjMTE1NVN0YW5kYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5NSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVyYzExNTVTdGFuZGFyZC5nZXRUb2tlblVSSShhZGRyZXNzLCB0b2tlbklkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBiYWxhbmNlIG9mIGEgZ2l2ZW4gRVJDIDExNTUgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlckFkZHJlc3MgLSBXYWxsZXQgcHVibGljIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlQWRkcmVzcyAtIEVSQzExNTUgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVJZCAtIEVSQzExNTUgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ2JhbGFuY2VPZicuXG4gICAgICovXG4gICAgZ2V0RVJDMTE1NUJhbGFuY2VPZih1c2VyQWRkcmVzcywgY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lcmMxMTU1U3RhbmRhcmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihleHBvcnRzLk1JU1NJTkdfUFJPVklERVJfRVJST1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuZXJjMTE1NVN0YW5kYXJkLmdldEJhbGFuY2VPZihjb2xsZWN0aWJsZUFkZHJlc3MsIHVzZXJBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZmVyIHNpbmdsZSBFUkMxMTU1IHRva2VuLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlQWRkcmVzcyAtIEVSQzExNTUgdG9rZW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gc2VuZGVyQWRkcmVzcyAtIEVSQzExNTUgdG9rZW4gc2VuZGVyLlxuICAgICAqIEBwYXJhbSByZWNpcGllbnRBZGRyZXNzIC0gRVJDMTE1NSB0b2tlbiByZWNpcGllbnQuXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlSWQgLSBFUkMxMTU1IHRva2VuIGlkLlxuICAgICAqIEBwYXJhbSBxdHkgLSBRdWFudGl0eSBvZiB0b2tlbnMgdG8gYmUgc2VudC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3RyYW5zZmVyU2luZ2xlJyBFUkMxMTU1IHRva2VuLlxuICAgICAqL1xuICAgIHRyYW5zZmVyU2luZ2xlRVJDMTE1NShjb2xsZWN0aWJsZUFkZHJlc3MsIHNlbmRlckFkZHJlc3MsIHJlY2lwaWVudEFkZHJlc3MsIGNvbGxlY3RpYmxlSWQsIHF0eSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJjMTE1NVN0YW5kYXJkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXhwb3J0cy5NSVNTSU5HX1BST1ZJREVSX0VSUk9SKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmVyYzExNTVTdGFuZGFyZC50cmFuc2ZlclNpbmdsZShjb2xsZWN0aWJsZUFkZHJlc3MsIHNlbmRlckFkZHJlc3MsIHJlY2lwaWVudEFkZHJlc3MsIGNvbGxlY3RpYmxlSWQsIHF0eSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRva2VuIGJhbGFuY2UgZm9yIGEgbGlzdCBvZiB0b2tlbiBhZGRyZXNzZXMgaW4gYSBzaW5nbGUgY2FsbC4gT25seSBub24temVybyBiYWxhbmNlc1xuICAgICAqIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBUaGUgYWRkcmVzcyB0byBjaGVjayB0b2tlbiBiYWxhbmNlcyBmb3IuXG4gICAgICogQHBhcmFtIHRva2Vuc1RvRGV0ZWN0IC0gVGhlIHRva2VuIGFkZHJlc3NlcyB0byBkZXRlY3QgYmFsYW5jZXMgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBsaXN0IG9mIG5vbi16ZXJvIHRva2VuIGJhbGFuY2VzLlxuICAgICAqL1xuICAgIGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsKHNlbGVjdGVkQWRkcmVzcywgdG9rZW5zVG9EZXRlY3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghKHRoaXMuY29uZmlnLmNoYWluSWQgaW4gZXhwb3J0cy5TSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTX0JZX0NIQUlOSUQpKSB7XG4gICAgICAgICAgICAgICAgLy8gT25seSBmZXRjaCBiYWxhbmNlIGlmIGNvbnRyYWN0IGFkZHJlc3MgZXhpc3RzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gZXhwb3J0cy5TSU5HTEVfQ0FMTF9CQUxBTkNFU19BRERSRVNTX0JZX0NIQUlOSURbdGhpcy5jb25maWcuY2hhaW5JZF07XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGhcbiAgICAgICAgICAgICAgICAuY29udHJhY3Qoc2luZ2xlX2NhbGxfYmFsYW5jZV9jaGVja2VyX2FiaV8xLmRlZmF1bHQpXG4gICAgICAgICAgICAgICAgLmF0KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmJhbGFuY2VzKFtzZWxlY3RlZEFkZHJlc3NdLCB0b2tlbnNUb0RldGVjdCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub25aZXJvQmFsYW5jZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNUb0RldGVjdC5mb3JFYWNoKCh0b2tlbkFkZHJlc3MsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHJlc3VsdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoU3RyaW5nKGJhbGFuY2UpICE9PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uWmVyb0JhbGFuY2VzW3Rva2VuQWRkcmVzc10gPSBiYWxhbmNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobm9uWmVyb0JhbGFuY2VzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkFzc2V0c0NvbnRyYWN0Q29udHJvbGxlciA9IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEFzc2V0c0NvbnRyYWN0Q29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFzc2V0c0NvbnRyYWN0Q29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xsZWN0aWJsZURldGVjdGlvbkNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMTgwMDAwO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBDb2xsZWN0aWJsZXMgYXV0byBkZXRlY3Rpb25cbiAqL1xuY2xhc3MgQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbkNvbGxlY3RpYmxlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGFzc2V0cyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRPcGVuU2VhQXBpS2V5IC0gR2V0cyB0aGUgT3BlblNlYSBBUEkga2V5LCBpZiBvbmUgaXMgc2V0LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFkZENvbGxlY3RpYmxlIC0gQWRkIGEgY29sbGVjdGlibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q29sbGVjdGlibGVzU3RhdGUgLSBHZXRzIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBBc3NldHMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRPcGVuU2VhQXBpS2V5LCBhZGRDb2xsZWN0aWJsZSwgZ2V0Q29sbGVjdGlibGVzU3RhdGUsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcic7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDaGVja3Mgd2hldGhlciBuZXR3b3JrIGlzIG1haW5uZXQgb3Igbm90LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyBXaGV0aGVyIGN1cnJlbnQgbmV0d29yayBpcyBtYWlubmV0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc01haW5uZXQgPSAoKSA9PiB0aGlzLmNvbmZpZy5uZXR3b3JrVHlwZSA9PT0gY29uc3RhbnRzXzEuTUFJTk5FVDtcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUwsXG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIGNoYWluSWQ6ICcxJyxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZ2V0Q29sbGVjdGlibGVzU3RhdGUgPSBnZXRDb2xsZWN0aWJsZXNTdGF0ZTtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCh7IHNlbGVjdGVkQWRkcmVzcywgdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZEFkZHJlc3M6IHByZXZpb3VzbHlTZWxlY3RlZEFkZHJlc3MsIGRpc2FibGVkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZEFkZHJlc3MgIT09IHByZXZpb3VzbHlTZWxlY3RlZEFkZHJlc3MgfHxcbiAgICAgICAgICAgICAgICAhdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gIT09IGRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBzZWxlY3RlZEFkZHJlc3MsIGRpc2FibGVkOiAhdXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXNlQ29sbGVjdGlibGVEZXRlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh1c2VDb2xsZWN0aWJsZURldGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoeyBwcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgbmV0d29ya1R5cGU6IHByb3ZpZGVyLnR5cGUsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogcHJvdmlkZXIuY2hhaW5JZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRPcGVuU2VhQXBpS2V5ID0gZ2V0T3BlblNlYUFwaUtleTtcbiAgICAgICAgdGhpcy5hZGRDb2xsZWN0aWJsZSA9IGFkZENvbGxlY3RpYmxlO1xuICAgIH1cbiAgICBnZXRPd25lckNvbGxlY3RpYmxlc0FwaSh7IGFkZHJlc3MsIG9mZnNldCwgdXNlUHJveHksIH0pIHtcbiAgICAgICAgcmV0dXJuIHVzZVByb3h5XG4gICAgICAgICAgICA/IGAke2NvbnN0YW50c18xLk9QRU5TRUFfUFJPWFlfVVJMfS9hc3NldHM/b3duZXI9JHthZGRyZXNzfSZvZmZzZXQ9JHtvZmZzZXR9JmxpbWl0PTUwYFxuICAgICAgICAgICAgOiBgJHtjb25zdGFudHNfMS5PUEVOU0VBX0FQSV9VUkx9L2Fzc2V0cz9vd25lcj0ke2FkZHJlc3N9Jm9mZnNldD0ke29mZnNldH0mbGltaXQ9NTBgO1xuICAgIH1cbiAgICBnZXRPd25lckNvbGxlY3RpYmxlcyhhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBjb2xsZWN0aWJsZXNBcGlSZXNwb25zZTtcbiAgICAgICAgICAgIGxldCBjb2xsZWN0aWJsZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG9wZW5TZWFBcGlLZXkgPSB0aGlzLmdldE9wZW5TZWFBcGlLZXkoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgbGV0IHBhZ2luZ0ZpbmlzaCA9IGZhbHNlO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlibGVzQXBpUmVzcG9uc2UgPSB5aWVsZCAoMCwgdXRpbF8xLmZldGNoV2l0aEVycm9ySGFuZGxpbmcpKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmdldE93bmVyQ29sbGVjdGlibGVzQXBpKHsgYWRkcmVzcywgb2Zmc2V0LCB1c2VQcm94eTogdHJ1ZSB9KSxcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dDogMTUwMDAsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZW5TZWFBcGlLZXkgJiYgIWNvbGxlY3RpYmxlc0FwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlc0FwaVJlc3BvbnNlID0geWllbGQgKDAsIHV0aWxfMS5mZXRjaFdpdGhFcnJvckhhbmRsaW5nKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMuZ2V0T3duZXJDb2xsZWN0aWJsZXNBcGkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZVByb3h5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogeyBoZWFkZXJzOiB7ICdYLUFQSS1LRVknOiBvcGVuU2VhQXBpS2V5IH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggNDAzIGVycm9ycyAoaW4gY2FzZSBBUEkga2V5IGlzIGRvd24gd2UgZG9uJ3Qgd2FudCB0byBibG93IHVwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb2Rlc1RvQ2F0Y2g6IFs0MDNdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb2xsZWN0aWJsZXNBcGlSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlibGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAoKF9hID0gY29sbGVjdGlibGVzQXBpUmVzcG9uc2UgPT09IG51bGwgfHwgY29sbGVjdGlibGVzQXBpUmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxlY3RpYmxlc0FwaVJlc3BvbnNlLmFzc2V0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyAoY29sbGVjdGlibGVzID0gWy4uLmNvbGxlY3RpYmxlcywgLi4uY29sbGVjdGlibGVzQXBpUmVzcG9uc2UuYXNzZXRzXSlcbiAgICAgICAgICAgICAgICAgICAgOiAocGFnaW5nRmluaXNoID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IDUwO1xuICAgICAgICAgICAgfSB3aGlsZSAoIXBhZ2luZ0ZpbmlzaCk7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlibGVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9sbGluZyBmb3IgdGhlIGN1cnJlbmN5IHJhdGUuXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHBvbGxpbmcgZm9yIHRoZSBjdXJyZW5jeSByYXRlLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgc3RvcFBvbGxpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLmludGVydmFsSWQpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbElkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgYSBuZXcgcG9sbGluZyBpbnRlcnZhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpbnRlcnZhbCAtIEFuIGludGVydmFsIG9uIHdoaWNoIHRvIHBvbGwuXG4gICAgICovXG4gICAgc3RhcnRQb2xsaW5nKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmRldGVjdENvbGxlY3RpYmxlcygpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZGV0ZWN0Q29sbGVjdGlibGVzKCk7XG4gICAgICAgICAgICB9KSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpZ2dlcnMgYXNzZXQgRVJDNzIxIHRva2VuIGF1dG8gZGV0ZWN0aW9uIG9uIG1haW5uZXQuIEFueSBuZXdseSBkZXRlY3RlZCBjb2xsZWN0aWJsZXMgYXJlXG4gICAgICogYWRkZWQuXG4gICAgICovXG4gICAgZGV0ZWN0Q29sbGVjdGlibGVzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNNYWlubmV0KCkgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzLCBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoIXNlbGVjdGVkQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaUNvbGxlY3RpYmxlcyA9IHlpZWxkIHRoaXMuZ2V0T3duZXJDb2xsZWN0aWJsZXMoc2VsZWN0ZWRBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZENvbGxlY3RpYmxlc1Byb21pc2VzID0gYXBpQ29sbGVjdGlibGVzLm1hcCgoY29sbGVjdGlibGUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRva2VuX2lkLCBudW1fc2FsZXMsIGJhY2tncm91bmRfY29sb3IsIGltYWdlX3VybCwgaW1hZ2VfcHJldmlld191cmwsIGltYWdlX3RodW1ibmFpbF91cmwsIGltYWdlX29yaWdpbmFsX3VybCwgYW5pbWF0aW9uX3VybCwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCwgbmFtZSwgZGVzY3JpcHRpb24sIGV4dGVybmFsX2xpbmssIGNyZWF0b3IsIGFzc2V0X2NvbnRyYWN0OiB7IGFkZHJlc3MsIHNjaGVtYV9uYW1lIH0sIGxhc3Rfc2FsZSwgfSA9IGNvbGxlY3RpYmxlO1xuICAgICAgICAgICAgICAgIGxldCBpZ25vcmVkO1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZ25vcmVkQ29sbGVjdGlibGVzIH0gPSB0aGlzLmdldENvbGxlY3RpYmxlc1N0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZWRDb2xsZWN0aWJsZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgPSBpZ25vcmVkQ29sbGVjdGlibGVzLmZpbmQoKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGMuYWRkcmVzcyA9PT0gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnRva2VuSWQgPT09IHRva2VuX2lkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlTWV0YWRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCB7IG5hbWUgfSwgY3JlYXRvciAmJiB7IGNyZWF0b3IgfSwgZGVzY3JpcHRpb24gJiYgeyBkZXNjcmlwdGlvbiB9LCBpbWFnZV91cmwgJiYgeyBpbWFnZTogaW1hZ2VfdXJsIH0sIG51bV9zYWxlcyAmJiB7IG51bWJlck9mU2FsZXM6IG51bV9zYWxlcyB9LCBiYWNrZ3JvdW5kX2NvbG9yICYmIHsgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kX2NvbG9yIH0sIGltYWdlX3ByZXZpZXdfdXJsICYmIHsgaW1hZ2VQcmV2aWV3OiBpbWFnZV9wcmV2aWV3X3VybCB9LCBpbWFnZV90aHVtYm5haWxfdXJsICYmIHsgaW1hZ2VUaHVtYm5haWw6IGltYWdlX3RodW1ibmFpbF91cmwgfSwgaW1hZ2Vfb3JpZ2luYWxfdXJsICYmIHsgaW1hZ2VPcmlnaW5hbDogaW1hZ2Vfb3JpZ2luYWxfdXJsIH0sIGFuaW1hdGlvbl91cmwgJiYgeyBhbmltYXRpb246IGFuaW1hdGlvbl91cmwgfSwgYW5pbWF0aW9uX29yaWdpbmFsX3VybCAmJiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcmlnaW5hbDogYW5pbWF0aW9uX29yaWdpbmFsX3VybCxcbiAgICAgICAgICAgICAgICAgICAgfSwgc2NoZW1hX25hbWUgJiYgeyBzdGFuZGFyZDogc2NoZW1hX25hbWUgfSwgZXh0ZXJuYWxfbGluayAmJiB7IGV4dGVybmFsTGluazogZXh0ZXJuYWxfbGluayB9LCBsYXN0X3NhbGUgJiYgeyBsYXN0U2FsZTogbGFzdF9zYWxlIH0pO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuX2lkLCBjb2xsZWN0aWJsZU1ldGFkYXRhLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyQWRkcmVzczogc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoYWRkQ29sbGVjdGlibGVzUHJvbWlzZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlciA9IENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbGxlY3RpYmxlRGV0ZWN0aW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2xsZWN0aWJsZXNDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGFzc2V0c1V0aWxfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0c1V0aWxcIik7XG5jb25zdCBBTExfQ09MTEVDVElCTEVTX1NUQVRFX0tFWSA9ICdhbGxDb2xsZWN0aWJsZXMnO1xuY29uc3QgQUxMX0NPTExFQ1RJQkxFU19DT05UUkFDVFNfU1RBVEVfS0VZID0gJ2FsbENvbGxlY3RpYmxlQ29udHJhY3RzJztcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHN0b3JlcyBhc3NldHMgYW5kIGV4cG9zZXMgY29udmVuaWVuY2UgbWV0aG9kc1xuICovXG5jbGFzcyBDb2xsZWN0aWJsZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIENvbGxlY3RpYmxlc0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2UgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uTmV0d29ya1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIG5ldHdvcmsgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzcyMUFzc2V0TmFtZSAtIEdldHMgdGhlIG5hbWUgb2YgdGhlIGFzc2V0IGF0IHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzcyMUFzc2V0U3ltYm9sIC0gR2V0cyB0aGUgc3ltYm9sIG9mIHRoZSBhc3NldCBhdCB0aGUgZ2l2ZW4gYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRFUkM3MjFUb2tlblVSSSAtIEdldHMgdGhlIFVSSSBvZiB0aGUgRVJDNzIxIHRva2VuIGF0IHRoZSBnaXZlbiBhZGRyZXNzLCB3aXRoIHRoZSBnaXZlbiBJRC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRFUkM3MjFPd25lck9mIC0gR2V0IHRoZSBvd25lciBvZiBhIEVSQy03MjEgY29sbGVjdGlibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0RVJDMTE1NUJhbGFuY2VPZiAtIEdldHMgYmFsYW5jZSBvZiBhIEVSQy0xMTU1IGNvbGxlY3RpYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzExNTVUb2tlblVSSSAtIEdldHMgdGhlIFVSSSBvZiB0aGUgRVJDMTE1NSB0b2tlbiBhdCB0aGUgZ2l2ZW4gYWRkcmVzcywgd2l0aCB0aGUgZ2l2ZW4gSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25Db2xsZWN0aWJsZUFkZGVkIC0gQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIGNvbGxlY3RpYmxlIGlzIGFkZGVkLiBDdXJyZW50bHkgdXNlZCBwYXNzIGRhdGFcbiAgICAgKiBmb3IgdHJhY2tpbmcgdGhlIGNvbGxlY3RpYmxlIGFkZGVkIGV2ZW50LlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSwgb25OZXR3b3JrU3RhdGVDaGFuZ2UsIGdldEVSQzcyMUFzc2V0TmFtZSwgZ2V0RVJDNzIxQXNzZXRTeW1ib2wsIGdldEVSQzcyMVRva2VuVVJJLCBnZXRFUkM3MjFPd25lck9mLCBnZXRFUkMxMTU1QmFsYW5jZU9mLCBnZXRFUkMxMTU1VG9rZW5VUkksIG9uQ29sbGVjdGlibGVBZGRlZCwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgRUlQNzQ3IGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbGxlY3RpYmxlc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSB7XG4gICAgICAgICAgICBuZXR3b3JrVHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCxcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogJycsXG4gICAgICAgICAgICBjaGFpbklkOiAnJyxcbiAgICAgICAgICAgIGlwZnNHYXRld2F5OiBjb25zdGFudHNfMS5JUEZTX0RFRkFVTFRfR0FURVdBWV9VUkwsXG4gICAgICAgICAgICBvcGVuU2VhRW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgICB1c2VJUEZTU3ViZG9tYWluczogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0czoge30sXG4gICAgICAgICAgICBhbGxDb2xsZWN0aWJsZXM6IHt9LFxuICAgICAgICAgICAgaWdub3JlZENvbGxlY3RpYmxlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmdldEVSQzcyMUFzc2V0TmFtZSA9IGdldEVSQzcyMUFzc2V0TmFtZTtcbiAgICAgICAgdGhpcy5nZXRFUkM3MjFBc3NldFN5bWJvbCA9IGdldEVSQzcyMUFzc2V0U3ltYm9sO1xuICAgICAgICB0aGlzLmdldEVSQzcyMVRva2VuVVJJID0gZ2V0RVJDNzIxVG9rZW5VUkk7XG4gICAgICAgIHRoaXMuZ2V0RVJDNzIxT3duZXJPZiA9IGdldEVSQzcyMU93bmVyT2Y7XG4gICAgICAgIHRoaXMuZ2V0RVJDMTE1NUJhbGFuY2VPZiA9IGdldEVSQzExNTVCYWxhbmNlT2Y7XG4gICAgICAgIHRoaXMuZ2V0RVJDMTE1NVRva2VuVVJJID0gZ2V0RVJDMTE1NVRva2VuVVJJO1xuICAgICAgICB0aGlzLm9uQ29sbGVjdGlibGVBZGRlZCA9IG9uQ29sbGVjdGlibGVBZGRlZDtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCh7IHNlbGVjdGVkQWRkcmVzcywgaXBmc0dhdGV3YXksIG9wZW5TZWFFbmFibGVkIH0pID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgc2VsZWN0ZWRBZGRyZXNzLCBpcGZzR2F0ZXdheSwgb3BlblNlYUVuYWJsZWQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoeyBwcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBjaGFpbklkIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlibGVBcGkoeyBjb250cmFjdEFkZHJlc3MsIHRva2VuSWQsIHVzZVByb3h5LCB9KSB7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGlmIChjaGFpbklkID09PSBjb25zdGFudHNfMS5SSU5LRUJZX0NIQUlOX0lEKSB7XG4gICAgICAgICAgICByZXR1cm4gYCR7Y29uc3RhbnRzXzEuT1BFTlNFQV9URVNUX0FQSV9VUkx9L2Fzc2V0LyR7Y29udHJhY3RBZGRyZXNzfS8ke3Rva2VuSWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXNlUHJveHlcbiAgICAgICAgICAgID8gYCR7Y29uc3RhbnRzXzEuT1BFTlNFQV9QUk9YWV9VUkx9L2Fzc2V0LyR7Y29udHJhY3RBZGRyZXNzfS8ke3Rva2VuSWR9YFxuICAgICAgICAgICAgOiBgJHtjb25zdGFudHNfMS5PUEVOU0VBX0FQSV9VUkx9L2Fzc2V0LyR7Y29udHJhY3RBZGRyZXNzfS8ke3Rva2VuSWR9YDtcbiAgICB9XG4gICAgZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uQXBpKHsgY29udHJhY3RBZGRyZXNzLCB1c2VQcm94eSwgfSkge1xuICAgICAgICBjb25zdCB7IGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBpZiAoY2hhaW5JZCA9PT0gY29uc3RhbnRzXzEuUklOS0VCWV9DSEFJTl9JRCkge1xuICAgICAgICAgICAgcmV0dXJuIGAke2NvbnN0YW50c18xLk9QRU5TRUFfVEVTVF9BUElfVVJMfS9hc3NldF9jb250cmFjdC8ke2NvbnRyYWN0QWRkcmVzc31gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2VQcm94eVxuICAgICAgICAgICAgPyBgJHtjb25zdGFudHNfMS5PUEVOU0VBX1BST1hZX1VSTH0vYXNzZXRfY29udHJhY3QvJHtjb250cmFjdEFkZHJlc3N9YFxuICAgICAgICAgICAgOiBgJHtjb25zdGFudHNfMS5PUEVOU0VBX0FQSV9VUkx9L2Fzc2V0X2NvbnRyYWN0LyR7Y29udHJhY3RBZGRyZXNzfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdG8gdXBkYXRlIG5lc3RlZCBzdGF0ZSBmb3IgYWxsQ29sbGVjdGlibGVzIGFuZCBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdDb2xsZWN0aW9uIC0gdGhlIG1vZGlmaWVkIHBpZWNlIG9mIHN0YXRlIHRvIHVwZGF0ZSBpbiB0aGUgY29udHJvbGxlcidzIHN0b3JlXG4gICAgICogQHBhcmFtIGJhc2VTdGF0ZUtleSAtIFRoZSByb290IGtleSBpbiB0aGUgc3RvcmUgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBwYXNzZWRDb25maWcgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgc2VsZWN0ZWRBZGRyZXNzIGFuZCBjaGFpbklkIHRoYXQgYXJlIHBhc3NlZCB0aHJvdWdoIHRoZSBhdXRvLWRldGVjdGlvbiBmbG93LlxuICAgICAqIEBwYXJhbSBwYXNzZWRDb25maWcudXNlckFkZHJlc3MgLSB0aGUgYWRkcmVzcyBwYXNzZWQgdGhyb3VnaCB0aGUgY29sbGVjdGlibGUgZGV0ZWN0aW9uIGZsb3cgdG8gZW5zdXJlIGRldGVjdGVkIGFzc2V0cyBhcmUgc3RvcmVkIHRvIHRoZSBjb3JyZWN0IGFjY291bnRcbiAgICAgKiBAcGFyYW0gcGFzc2VkQ29uZmlnLmNoYWluSWQgLSB0aGUgY2hhaW5JZCBwYXNzZWQgdGhyb3VnaCB0aGUgY29sbGVjdGlibGUgZGV0ZWN0aW9uIGZsb3cgdG8gZW5zdXJlIGRldGVjdGVkIGFzc2V0cyBhcmUgc3RvcmVkIHRvIHRoZSBjb3JyZWN0IGFjY291bnRcbiAgICAgKi9cbiAgICB1cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKG5ld0NvbGxlY3Rpb24sIGJhc2VTdGF0ZUtleSwgeyB1c2VyQWRkcmVzcywgY2hhaW5JZCB9ID0ge1xuICAgICAgICB1c2VyQWRkcmVzczogdGhpcy5jb25maWcuc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiB0aGlzLmNvbmZpZy5jaGFpbklkLFxuICAgIH0pIHtcbiAgICAgICAgY29uc3QgeyBbYmFzZVN0YXRlS2V5XTogb2xkU3RhdGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NTdGF0ZSA9IG9sZFN0YXRlW3VzZXJBZGRyZXNzXTtcbiAgICAgICAgY29uc3QgbmV3QWRkcmVzc1N0YXRlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhZGRyZXNzU3RhdGUpLCB7IFtjaGFpbklkXTogbmV3Q29sbGVjdGlvbiB9KTtcbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZFN0YXRlKSwgeyBbdXNlckFkZHJlc3NdOiBuZXdBZGRyZXNzU3RhdGUgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIFtiYXNlU3RhdGVLZXldOiBuZXdTdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSBpbmZvcm1hdGlvbiBmcm9tIE9wZW5TZWEgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSBjb2xsZWN0aWJsZSBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIG5hbWUgYW5kIGltYWdlLlxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlSW5mb3JtYXRpb25Gcm9tQXBpKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBmZXRjaCB0aGUgZGF0YSB3aXRoIHRoZSBwcm94eVxuICAgICAgICAgICAgbGV0IGNvbGxlY3RpYmxlSW5mb3JtYXRpb24gPSB5aWVsZCAoMCwgdXRpbF8xLmZldGNoV2l0aEVycm9ySGFuZGxpbmcpKHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuZ2V0Q29sbGVjdGlibGVBcGkoe1xuICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuSWQsXG4gICAgICAgICAgICAgICAgICAgIHVzZVByb3h5OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiBhbiBvcGVuU2VhQXBpS2V5IGlzIHNldCB3ZSBzaG91bGQgYXR0ZW1wdCB0byByZWZldGNoIGNhbGxpbmcgZGlyZWN0bHkgdG8gT3BlblNlYVxuICAgICAgICAgICAgaWYgKCFjb2xsZWN0aWJsZUluZm9ybWF0aW9uICYmIHRoaXMub3BlblNlYUFwaUtleSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlSW5mb3JtYXRpb24gPSB5aWVsZCAoMCwgdXRpbF8xLmZldGNoV2l0aEVycm9ySGFuZGxpbmcpKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmdldENvbGxlY3RpYmxlQXBpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VQcm94eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdYLUFQSS1LRVknOiB0aGlzLm9wZW5TZWFBcGlLZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggNDAzIGVycm9ycyAoaW4gY2FzZSBBUEkga2V5IGlzIGRvd24gd2UgZG9uJ3Qgd2FudCB0byBibG93IHVwKVxuICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGVzVG9DYXRjaDogWzQwM10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSB3ZXJlIHN0aWxsIHVuYWJsZSB0byBmZXRjaCB0aGUgZGF0YSB3ZSByZXR1cm4gb3V0IHRoZSBkZWZhdWx0L251bGwgb2YgYENvbGxlY3RpYmxlTWV0YWRhdGFgXG4gICAgICAgICAgICBpZiAoIWNvbGxlY3RpYmxlSW5mb3JtYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkOiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiB3ZSd2ZSByZWFjaGVkIHRoaXMgcG9pbnQsIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGZldGNoZWQgc29tZSBkYXRhIGZvciBjb2xsZWN0aWJsZUluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBub3cgd2UgcmVjb25maWd1cmUgdGhlIGRhdGEgdG8gY29uZm9ybSB0byB0aGUgYENvbGxlY3RpYmxlTWV0YWRhdGFgIHR5cGUgZm9yIHN0b3JhZ2UuXG4gICAgICAgICAgICBjb25zdCB7IG51bV9zYWxlcywgYmFja2dyb3VuZF9jb2xvciwgaW1hZ2VfdXJsLCBpbWFnZV9wcmV2aWV3X3VybCwgaW1hZ2VfdGh1bWJuYWlsX3VybCwgaW1hZ2Vfb3JpZ2luYWxfdXJsLCBhbmltYXRpb25fdXJsLCBhbmltYXRpb25fb3JpZ2luYWxfdXJsLCBuYW1lLCBkZXNjcmlwdGlvbiwgZXh0ZXJuYWxfbGluaywgY3JlYXRvciwgbGFzdF9zYWxlLCBhc3NldF9jb250cmFjdDogeyBzY2hlbWFfbmFtZSB9LCB9ID0gY29sbGVjdGlibGVJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZU1ldGFkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgeyBuYW1lOiBuYW1lIHx8IG51bGwgfSwgeyBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfHwgbnVsbCB9LCB7IGltYWdlOiBpbWFnZV91cmwgfHwgbnVsbCB9LCBjcmVhdG9yICYmIHsgY3JlYXRvciB9LCBudW1fc2FsZXMgJiYgeyBudW1iZXJPZlNhbGVzOiBudW1fc2FsZXMgfSwgYmFja2dyb3VuZF9jb2xvciAmJiB7IGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZF9jb2xvciB9LCBpbWFnZV9wcmV2aWV3X3VybCAmJiB7IGltYWdlUHJldmlldzogaW1hZ2VfcHJldmlld191cmwgfSwgaW1hZ2VfdGh1bWJuYWlsX3VybCAmJiB7IGltYWdlVGh1bWJuYWlsOiBpbWFnZV90aHVtYm5haWxfdXJsIH0sIGltYWdlX29yaWdpbmFsX3VybCAmJiB7IGltYWdlT3JpZ2luYWw6IGltYWdlX29yaWdpbmFsX3VybCB9LCBhbmltYXRpb25fdXJsICYmIHsgYW5pbWF0aW9uOiBhbmltYXRpb25fdXJsIH0sIGFuaW1hdGlvbl9vcmlnaW5hbF91cmwgJiYge1xuICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9yaWdpbmFsOiBhbmltYXRpb25fb3JpZ2luYWxfdXJsLFxuICAgICAgICAgICAgfSwgZXh0ZXJuYWxfbGluayAmJiB7IGV4dGVybmFsTGluazogZXh0ZXJuYWxfbGluayB9LCBsYXN0X3NhbGUgJiYgeyBsYXN0U2FsZTogbGFzdF9zYWxlIH0sIHNjaGVtYV9uYW1lICYmIHsgc3RhbmRhcmQ6IHNjaGVtYV9uYW1lIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlTWV0YWRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGluZGl2aWR1YWwgY29sbGVjdGlibGUgaW5mb3JtYXRpb24gZnJvbSBjb250cmFjdHMgdGhhdCBmb2xsb3dzIE1ldGFkYXRhIEludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250cmFjdEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllci5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZS5cbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBpcGZzR2F0ZXdheSwgdXNlSVBGU1N1YmRvbWFpbnMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZVVSSUFuZFN0YW5kYXJkKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICBsZXQgdG9rZW5VUkkgPSByZXN1bHRbMF07XG4gICAgICAgICAgICBjb25zdCBzdGFuZGFyZCA9IHJlc3VsdFsxXTtcbiAgICAgICAgICAgIGlmICh0b2tlblVSSS5zdGFydHNXaXRoKCdpcGZzOi8vJykpIHtcbiAgICAgICAgICAgICAgICB0b2tlblVSSSA9ICgwLCB1dGlsXzEuZ2V0Rm9ybWF0dGVkSXBmc1VybCkoaXBmc0dhdGV3YXksIHRva2VuVVJJLCB1c2VJUEZTU3ViZG9tYWlucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHlpZWxkICgwLCB1dGlsXzEuaGFuZGxlRmV0Y2gpKHRva2VuVVJJKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDaGVjayBpbWFnZV91cmwgZXhpc3RlbmNlLiBUaGlzIGlzIG5vdCBwYXJ0IG9mIEVJUDcyMSBub3IgRUlQMTE1NVxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ2ltYWdlJylcbiAgICAgICAgICAgICAgICAgICAgPyAnaW1hZ2UnXG4gICAgICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gJ2ltYWdlX3VybCc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IG9iamVjdFtpbWFnZV0sXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG9iamVjdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogb2JqZWN0LmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGFuZGFyZCxcbiAgICAgICAgICAgICAgICAgICAgZmF2b3JpdGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkOiBzdGFuZGFyZCB8fCBudWxsLFxuICAgICAgICAgICAgICAgICAgICBmYXZvcml0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIGNvbGxlY3RpYmxlIHVyaSB3aXRoICBtZXRhZGF0YS4gVE9ETyBVcGRhdGUgbWV0aG9kIHRvIHVzZSBJUEZTLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIENvbGxlY3RpYmxlIGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBDb2xsZWN0aWJsZSB0b2tlbiBpZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBjb2xsZWN0aWJsZSB1cmkgYW5kIHRva2VuIHN0YW5kYXJkLlxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlVVJJQW5kU3RhbmRhcmQoY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyB0cnkgRVJDNzIxIHVyaVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cmkgPSB5aWVsZCB0aGlzLmdldEVSQzcyMVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt1cmksIGNvbnN0YW50c18xLkVSQzcyMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRyeSBFUkMxMTU1IHVyaVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlblVSSSA9IHlpZWxkIHRoaXMuZ2V0RVJDMTE1NVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQWNjb3JkaW5nIHRvIEVJUDExNTUgdGhlIFVSSSB2YWx1ZSBhbGxvd3MgZm9yIElEIHN1YnN0aXR1dGlvblxuICAgICAgICAgICAgICAgICAqIGluIGNhc2UgdGhlIHN0cmluZyBge2lkfWAgZXhpc3RzLlxuICAgICAgICAgICAgICAgICAqIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtMTE1NSNtZXRhZGF0YVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5VUkkuaW5jbHVkZXMoJ3tpZH0nKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuVVJJLCBjb25zdGFudHNfMS5FUkMxMTU1XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaGV4VG9rZW5JZCA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5zdHJpcEhleFByZWZpeCkoKDAsIHV0aWxfMS5CTlRvSGV4KShuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odG9rZW5JZCkpKVxuICAgICAgICAgICAgICAgICAgICAucGFkU3RhcnQoNjQsICcwJylcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFt0b2tlblVSSS5yZXBsYWNlKCd7aWR9JywgaGV4VG9rZW5JZCksIGNvbnN0YW50c18xLkVSQzExNTVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9iKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWycnLCAnJ107XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGluZGl2aWR1YWwgY29sbGVjdGlibGUgaW5mb3JtYXRpb24gKG5hbWUsIGltYWdlIHVybCBhbmQgZGVzY3JpcHRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSBjb2xsZWN0aWJsZSBpZGVudGlmaWVyLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIG5hbWUgYW5kIGltYWdlLlxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlSW5mb3JtYXRpb24oY29udHJhY3RBZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBibG9ja2NoYWluTWV0YWRhdGEgPSB5aWVsZCAoMCwgdXRpbF8xLnNhZmVseUV4ZWN1dGUpKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRDb2xsZWN0aWJsZUluZm9ybWF0aW9uRnJvbVRva2VuVVJJKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBsZXQgb3BlblNlYU1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm9wZW5TZWFFbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgb3BlblNlYU1ldGFkYXRhID0geWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlSW5mb3JtYXRpb25Gcm9tQXBpKGNvbnRyYWN0QWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3BlblNlYU1ldGFkYXRhKSwgeyBuYW1lOiAoX2IgPSAoX2EgPSBibG9ja2NoYWluTWV0YWRhdGEubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3BlblNlYU1ldGFkYXRhID09PSBudWxsIHx8IG9wZW5TZWFNZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlblNlYU1ldGFkYXRhLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsIGRlc2NyaXB0aW9uOiAoX2QgPSAoX2MgPSBibG9ja2NoYWluTWV0YWRhdGEuZGVzY3JpcHRpb24pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG9wZW5TZWFNZXRhZGF0YSA9PT0gbnVsbCB8fCBvcGVuU2VhTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wZW5TZWFNZXRhZGF0YS5kZXNjcmlwdGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbnVsbCwgaW1hZ2U6IChfZiA9IChfZSA9IGJsb2NrY2hhaW5NZXRhZGF0YS5pbWFnZSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogb3BlblNlYU1ldGFkYXRhID09PSBudWxsIHx8IG9wZW5TZWFNZXRhZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlblNlYU1ldGFkYXRhLmltYWdlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsLCBzdGFuZGFyZDogKF9oID0gKF9nID0gYmxvY2tjaGFpbk1ldGFkYXRhLnN0YW5kYXJkKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiBvcGVuU2VhTWV0YWRhdGEgPT09IG51bGwgfHwgb3BlblNlYU1ldGFkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcGVuU2VhTWV0YWRhdGEuc3RhbmRhcmQpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IG51bGwgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uIGZyb20gT3BlblNlYSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIG5hbWUgYW5kIGltYWdlLlxuICAgICAqL1xuICAgIGdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkZyb21BcGkoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGxldCBhcGlDb2xsZWN0aWJsZUNvbnRyYWN0T2JqZWN0ID0geWllbGQgKDAsIHV0aWxfMS5mZXRjaFdpdGhFcnJvckhhbmRsaW5nKSh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkFwaSh7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdXNlUHJveHk6IHRydWUsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGlmIHdlIHN1Y2Nlc3NmdWxseSBmZXRjaGVkIHJldHVybiB0aGUgZmV0Y2hlZCBkYXRhIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICBpZiAoYXBpQ29sbGVjdGlibGVDb250cmFjdE9iamVjdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcGlDb2xsZWN0aWJsZUNvbnRyYWN0T2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgd2Ugd2VyZSB1bnN1Y2Nlc3NmdWwgaW4gZmV0Y2hpbmcgZnJvbSB0aGUgQVBJIGFuZCBhbiBPcGVuU2VhIEFQSSBrZXkgaXMgcHJlc2VudFxuICAgICAgICAgICAgLy8gYXR0ZW1wdCB0byByZWZldGNoIGRpcmVjdGx5IGFnYWluc3QgdGhlIE9wZW5TZWEgQVBJIGFuZCBpZiBzdWNjZXNzZnVsIHJldHVybiB0aGUgZGF0YSBpbW1lZGlhdGVseVxuICAgICAgICAgICAgaWYgKHRoaXMub3BlblNlYUFwaUtleSkge1xuICAgICAgICAgICAgICAgIGFwaUNvbGxlY3RpYmxlQ29udHJhY3RPYmplY3QgPSB5aWVsZCAoMCwgdXRpbF8xLmZldGNoV2l0aEVycm9ySGFuZGxpbmcpKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkFwaSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VQcm94eTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7ICdYLUFQSS1LRVknOiB0aGlzLm9wZW5TZWFBcGlLZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gY2F0Y2ggNDAzIGVycm9ycyAoaW4gY2FzZSBBUEkga2V5IGlzIGRvd24gd2UgZG9uJ3Qgd2FudCB0byBibG93IHVwKVxuICAgICAgICAgICAgICAgICAgICBlcnJvckNvZGVzVG9DYXRjaDogWzQwM10sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaUNvbGxlY3RpYmxlQ29udHJhY3RPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwaUNvbGxlY3RpYmxlQ29udHJhY3RPYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UndmUgcmVhY2hlZCB0aGlzIHBvaW50IHdlIHdlcmUgdW5hYmxlIHRvIGZldGNoIGRhdGEgZnJvbSBlaXRoZXIgdGhlIHByb3h5IG9yIG9wZW5zZWEgc28gd2UgcmV0dXJuXG4gICAgICAgICAgICAvLyB0aGUgZGVmYXVsdC9udWxsIG9mIEFwaUNvbGxlY3RpYmxlQ29udHJhY3RcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFzc2V0X2NvbnRyYWN0X3R5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9kYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjaGVtYV9uYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogbnVsbCxcbiAgICAgICAgICAgICAgICB0b3RhbF9zdXBwbHk6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxfbGluazogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGltYWdlX3VybDogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcXVlc3QgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24gZnJvbSB0aGUgY29udHJhY3QgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBuYW1lIGFuZCBpbWFnZS5cbiAgICAgKi9cbiAgICBnZXRDb2xsZWN0aWJsZUNvbnRyYWN0SW5mb3JtYXRpb25Gcm9tQ29udHJhY3QoY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0geWllbGQgdGhpcy5nZXRFUkM3MjFBc3NldE5hbWUoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHN5bWJvbCA9IHlpZWxkIHRoaXMuZ2V0RVJDNzIxQXNzZXRTeW1ib2woY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbjogeyBuYW1lIH0sXG4gICAgICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGNvbGxlY3RpYmxlIGNvbnRyYWN0IGluZm9ybWF0aW9uIGZyb20gT3BlblNlYSBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3RBZGRyZXNzIC0gSGV4IGFkZHJlc3Mgb2YgdGhlIGNvbGxlY3RpYmxlIGNvbnRyYWN0LlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdCBuYW1lLCBpbWFnZSBhbmQgZGVzY3JpcHRpb24uXG4gICAgICovXG4gICAgZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uKGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tjaGFpbkNvbnRyYWN0RGF0YSA9IHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkZyb21Db250cmFjdChjb250cmFjdEFkZHJlc3MpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGV0IG9wZW5TZWFDb250cmFjdERhdGE7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25maWcub3BlblNlYUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBvcGVuU2VhQ29udHJhY3REYXRhID0geWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmdldENvbGxlY3RpYmxlQ29udHJhY3RJbmZvcm1hdGlvbkZyb21BcGkoY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYmxvY2tjaGFpbkNvbnRyYWN0RGF0YSB8fCBvcGVuU2VhQ29udHJhY3REYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcGVuU2VhQ29udHJhY3REYXRhKSwgYmxvY2tjaGFpbkNvbnRyYWN0RGF0YSksIHsgY29sbGVjdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaW1hZ2VfdXJsOiBudWxsIH0sIG9wZW5TZWFDb250cmFjdERhdGEgPT09IG51bGwgfHwgb3BlblNlYUNvbnRyYWN0RGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3BlblNlYUNvbnRyYWN0RGF0YS5jb2xsZWN0aW9uKSwgYmxvY2tjaGFpbkNvbnRyYWN0RGF0YSA9PT0gbnVsbCB8fCBibG9ja2NoYWluQ29udHJhY3REYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBibG9ja2NoYWluQ29udHJhY3REYXRhLmNvbGxlY3Rpb24pIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGFzc2V0X2NvbnRyYWN0X3R5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgY3JlYXRlZF9kYXRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHNjaGVtYV9uYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHN5bWJvbDogbnVsbCxcbiAgICAgICAgICAgICAgICB0b3RhbF9zdXBwbHk6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG51bGwsXG4gICAgICAgICAgICAgICAgZXh0ZXJuYWxfbGluazogbnVsbCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uOiB7IG5hbWU6IG51bGwsIGltYWdlX3VybDogbnVsbCB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gaW5kaXZpZHVhbCBjb2xsZWN0aWJsZSB0byB0aGUgc3RvcmVkIGNvbGxlY3RpYmxlIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRoZSBjb2xsZWN0aWJsZSBpZGVudGlmaWVyLlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aWJsZU1ldGFkYXRhIC0gQ29sbGVjdGlibGUgb3B0aW9uYWwgaW5mb3JtYXRpb24gKG5hbWUsIGltYWdlIGFuZCBkZXNjcmlwdGlvbikuXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlQ29udHJhY3QgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb250cmFjdCBkYXRhIG9mIHRoZSBjb2xsZWN0aWJsZSBiZWluZyBhZGRlZC5cbiAgICAgKiBAcGFyYW0gZGV0ZWN0aW9uIC0gVGhlIGNoYWluIElEIGFuZCBhZGRyZXNzIG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbmV0d29yayBhbmQgYWNjb3VudCBhdCB0aGUgbW9tZW50IHRoZSBjb2xsZWN0aWJsZSB3YXMgZGV0ZWN0ZWQuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgbGlzdC5cbiAgICAgKi9cbiAgICBhZGRJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCwgY29sbGVjdGlibGVNZXRhZGF0YSwgY29sbGVjdGlibGVDb250cmFjdCwgZGV0ZWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB1bnVzZWQgcmV0dXJuXG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzID0gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgbGV0IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICBpZiAoZGV0ZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBkZXRlY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWRBZGRyZXNzID0gZGV0ZWN0aW9uLnVzZXJBZGRyZXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IHRoaXMuY29uZmlnLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IHRoaXMuY29uZmlnLnNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRW50cnkgPSBjb2xsZWN0aWJsZXMuZmluZCgoY29sbGVjdGlibGUpID0+IGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlLnRva2VuSWQgPT09IHRva2VuSWQpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpZmZlcmVudE1ldGFkYXRhID0gKDAsIGFzc2V0c1V0aWxfMS5jb21wYXJlQ29sbGVjdGlibGVzTWV0YWRhdGEpKGNvbGxlY3RpYmxlTWV0YWRhdGEsIGV4aXN0aW5nRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZmVyZW50TWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFN3aXRjaCB0byBpbmRleFRvVXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFRvUmVtb3ZlID0gY29sbGVjdGlibGVzLmZpbmRJbmRleCgoY29sbGVjdGlibGUpID0+IGNvbGxlY3RpYmxlLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlibGVzLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RW50cnkgPSBPYmplY3QuYXNzaWduKHsgYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5JZCwgZmF2b3JpdGU6IChleGlzdGluZ0VudHJ5ID09PSBudWxsIHx8IGV4aXN0aW5nRW50cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4aXN0aW5nRW50cnkuZmF2b3JpdGUpIHx8IGZhbHNlLCBpc0N1cnJlbnRseU93bmVkOiB0cnVlIH0sIGNvbGxlY3RpYmxlTWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlcyA9IFsuLi5jb2xsZWN0aWJsZXMsIG5ld0VudHJ5XTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlibGVzLCBBTExfQ09MTEVDVElCTEVTX1NUQVRFX0tFWSwgeyBjaGFpbklkLCB1c2VyQWRkcmVzczogc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uQ29sbGVjdGlibGVBZGRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGVjdGlibGVBZGRlZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sOiBjb2xsZWN0aWJsZUNvbnRyYWN0LnN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuSWQ6IHRva2VuSWQudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YW5kYXJkOiBjb2xsZWN0aWJsZU1ldGFkYXRhLnN0YW5kYXJkLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBkZXRlY3Rpb24gPyAnZGV0ZWN0ZWQnIDogJ2N1c3RvbScsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3Q29sbGVjdGlibGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBjb2xsZWN0aWJsZSBjb250cmFjdCB0byB0aGUgc3RvcmVkIGNvbGxlY3RpYmxlIGNvbnRyYWN0cyBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIGRldGVjdGlvbiAtIFRoZSBjaGFpbiBJRCBhbmQgYWRkcmVzcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5ldHdvcmsgYW5kIGFjY291bnQgYXQgdGhlIG1vbWVudCB0aGUgY29sbGVjdGlibGUgd2FzIGRldGVjdGVkLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBjdXJyZW50IGNvbGxlY3RpYmxlIGNvbnRyYWN0cyBsaXN0LlxuICAgICAqL1xuICAgIGFkZENvbGxlY3RpYmxlQ29udHJhY3QoYWRkcmVzcywgZGV0ZWN0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgICAgIGxldCBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgaWYgKGRldGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gZGV0ZWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IGRldGVjdGlvbi51c2VyQWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSB0aGlzLmNvbmZpZy5jaGFpbklkO1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3MgPSB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlQ29udHJhY3RzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFbnRyeSA9IGNvbGxlY3RpYmxlQ29udHJhY3RzLmZpbmQoKGNvbGxlY3RpYmxlQ29udHJhY3QpID0+IGNvbGxlY3RpYmxlQ29udHJhY3QuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY29udHJhY3RJbmZvcm1hdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVDb250cmFjdEluZm9ybWF0aW9uKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXNzZXRfY29udHJhY3RfdHlwZSwgY3JlYXRlZF9kYXRlLCBzY2hlbWFfbmFtZSwgc3ltYm9sLCB0b3RhbF9zdXBwbHksIGRlc2NyaXB0aW9uLCBleHRlcm5hbF9saW5rLCBjb2xsZWN0aW9uOiB7IG5hbWUsIGltYWdlX3VybCB9LCB9ID0gY29udHJhY3RJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgICAgICAvLyBJZiBiZWluZyBhdXRvLWRldGVjdGVkIG9wZW5zZWEgaW5mb3JtYXRpb24gaXMgZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UgYXQgbGVhc3QgbmFtZSBmcm9tIHRoZSBjb250cmFjdCBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoKGRldGVjdGlvbiAmJiAhbmFtZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoY29udHJhY3RJbmZvcm1hdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IE9iamVjdC5hc3NpZ24oe30sIHsgYWRkcmVzcyB9LCBkZXNjcmlwdGlvbiAmJiB7IGRlc2NyaXB0aW9uIH0sIG5hbWUgJiYgeyBuYW1lIH0sIGltYWdlX3VybCAmJiB7IGxvZ286IGltYWdlX3VybCB9LCBzeW1ib2wgJiYgeyBzeW1ib2wgfSwgdG90YWxfc3VwcGx5ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b3RhbF9zdXBwbHkgIT09ICd1bmRlZmluZWQnICYmIHsgdG90YWxTdXBwbHk6IHRvdGFsX3N1cHBseSB9LCBhc3NldF9jb250cmFjdF90eXBlICYmIHsgYXNzZXRDb250cmFjdFR5cGU6IGFzc2V0X2NvbnRyYWN0X3R5cGUgfSwgY3JlYXRlZF9kYXRlICYmIHsgY3JlYXRlZERhdGU6IGNyZWF0ZWRfZGF0ZSB9LCBzY2hlbWFfbmFtZSAmJiB7IHNjaGVtYU5hbWU6IHNjaGVtYV9uYW1lIH0sIGV4dGVybmFsX2xpbmsgJiYgeyBleHRlcm5hbExpbms6IGV4dGVybmFsX2xpbmsgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVDb250cmFjdHMgPSBbLi4uY29sbGVjdGlibGVDb250cmFjdHMsIG5ld0VudHJ5XTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlibGVDb250cmFjdHMsIEFMTF9DT0xMRUNUSUJMRVNfQ09OVFJBQ1RTX1NUQVRFX0tFWSwgeyBjaGFpbklkLCB1c2VyQWRkcmVzczogc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGluZGl2aWR1YWwgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QgYW5kIHNhdmVzIGl0IGluIGlnbm9yZWQgY29sbGVjdGlibGVzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZUFuZElnbm9yZUluZGl2aWR1YWxDb2xsZWN0aWJsZShhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcywgaWdub3JlZENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBuZXdJZ25vcmVkQ29sbGVjdGlibGVzID0gWy4uLmlnbm9yZWRDb2xsZWN0aWJsZXNdO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlcyA9IGNvbGxlY3RpYmxlcy5maWx0ZXIoKGNvbGxlY3RpYmxlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY29sbGVjdGlibGUuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZS50b2tlbklkID09PSB0b2tlbklkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxyZWFkeUlnbm9yZWQgPSBuZXdJZ25vcmVkQ29sbGVjdGlibGVzLmZpbmQoKGMpID0+IGMuYWRkcmVzcyA9PT0gYWRkcmVzcyAmJiBjLnRva2VuSWQgPT09IHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICFhbHJlYWR5SWdub3JlZCAmJiBuZXdJZ25vcmVkQ29sbGVjdGlibGVzLnB1c2goY29sbGVjdGlibGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKG5ld0NvbGxlY3RpYmxlcywgQUxMX0NPTExFQ1RJQkxFU19TVEFURV9LRVkpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBpZ25vcmVkQ29sbGVjdGlibGVzOiBuZXdJZ25vcmVkQ29sbGVjdGlibGVzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlIGZyb20gdGhlIHN0b3JlZCB0b2tlbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUb2tlbiBpZGVudGlmaWVyIG9mIHRoZSBjb2xsZWN0aWJsZS5cbiAgICAgKi9cbiAgICByZW1vdmVJbmRpdmlkdWFsQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZCwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgY29uc3QgY29sbGVjdGlibGVzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdDb2xsZWN0aWJsZXMgPSBjb2xsZWN0aWJsZXMuZmlsdGVyKChjb2xsZWN0aWJsZSkgPT4gIShjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCkpO1xuICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlibGVzLCBBTExfQ09MTEVDVElCTEVTX1NUQVRFX0tFWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjb2xsZWN0aWJsZSBjb250cmFjdCB0byB0aGUgc3RvcmVkIGNvbGxlY3RpYmxlIGNvbnRyYWN0cyBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIGN1cnJlbnQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3QuXG4gICAgICovXG4gICAgcmVtb3ZlQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGNoYWluSWQsIHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlQ29udHJhY3RzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlQ29udHJhY3RzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzID0gY29sbGVjdGlibGVDb250cmFjdHMuZmlsdGVyKChjb2xsZWN0aWJsZUNvbnRyYWN0KSA9PiAhKGNvbGxlY3RpYmxlQ29udHJhY3QuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpKTtcbiAgICAgICAgdGhpcy51cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKG5ld0NvbGxlY3RpYmxlQ29udHJhY3RzLCBBTExfQ09MTEVDVElCTEVTX0NPTlRSQUNUU19TVEFURV9LRVkpO1xuICAgICAgICByZXR1cm4gbmV3Q29sbGVjdGlibGVDb250cmFjdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gT3BlblNlYSBBUEkga2V5IHRvIHJldHJpZXZlIGNvbGxlY3RpYmxlIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wZW5TZWFBcGlLZXkgLSBPcGVuU2VhIEFQSSBrZXkuXG4gICAgICovXG4gICAgc2V0QXBpS2V5KG9wZW5TZWFBcGlLZXkpIHtcbiAgICAgICAgdGhpcy5vcGVuU2VhQXBpS2V5ID0gb3BlblNlYUFwaUtleTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHRoZSBvd25lcnNoaXAgb2YgYSBFUkMtNzIxIG9yIEVSQy0xMTU1IGNvbGxlY3RpYmxlIGZvciBhIGdpdmVuIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3duZXJBZGRyZXNzIC0gVXNlciBwdWJsaWMgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVBZGRyZXNzIC0gQ29sbGVjdGlibGUgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVJZCAtIENvbGxlY3RpYmxlIHRva2VuIElELlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRoZSBjb2xsZWN0aWJsZSBvd25lcnNoaXAuXG4gICAgICovXG4gICAgaXNDb2xsZWN0aWJsZU93bmVyKG93bmVyQWRkcmVzcywgY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBDaGVja3MgdGhlIG93bmVyc2hpcCBmb3IgRVJDLTcyMS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3duZXIgPSB5aWVsZCB0aGlzLmdldEVSQzcyMU93bmVyT2YoY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3duZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IG93bmVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRVJDLTcyMSBjb250cmFjdCBlcnJvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tzIHRoZSBvd25lcnNoaXAgZm9yIEVSQy0xMTU1LlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlID0geWllbGQgdGhpcy5nZXRFUkMxMTU1QmFsYW5jZU9mKG93bmVyQWRkcmVzcywgY29sbGVjdGlibGVBZGRyZXNzLCBjb2xsZWN0aWJsZUlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFsYW5jZSA+IDA7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgRVJDLTExNTUgY29udHJhY3QgZXJyb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHZlcmlmeSBvd25lcnNoaXAuIFByb2JhYmx5IGJlY2F1c2UgdGhlIHN0YW5kYXJkIGlzIG5vdCBzdXBwb3J0ZWQgb3IgdGhlIGNoYWluIGlzIGluY29ycmVjdC4nKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGN1cnJlbnRseSBzZWxlY3RlZCBhZGRyZXNzIG93bnMgZW50ZXJlZCBjb2xsZWN0aWJsZSBhZGRyZXNzL3Rva2VuSWQgY29tYm8gYW5kXG4gICAgICogYWRkcyB0aGUgY29sbGVjdGlibGUgYW5kIHJlc3BlY3RpdmUgY29sbGVjdGlibGUgY29udHJhY3QgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBhbmQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllci5cbiAgICAgKi9cbiAgICBhZGRDb2xsZWN0aWJsZVZlcmlmeU93bmVyc2hpcChhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGVkQWRkcmVzcyB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBpZiAoISh5aWVsZCB0aGlzLmlzQ29sbGVjdGlibGVPd25lcihzZWxlY3RlZEFkZHJlc3MsIGFkZHJlc3MsIHRva2VuSWQpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBjb2xsZWN0aWJsZSBpcyBub3Qgb3duZWQgYnkgdGhlIHVzZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIHRoaXMuYWRkQ29sbGVjdGlibGUoYWRkcmVzcywgdG9rZW5JZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgY29sbGVjdGlibGUgYW5kIHJlc3BlY3RpdmUgY29sbGVjdGlibGUgY29udHJhY3QgdG8gdGhlIHN0b3JlZCBjb2xsZWN0aWJsZSBhbmQgY29sbGVjdGlibGUgY29udHJhY3RzIGxpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBUaGUgY29sbGVjdGlibGUgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gY29sbGVjdGlibGVNZXRhZGF0YSAtIENvbGxlY3RpYmxlIG9wdGlvbmFsIG1ldGFkYXRhLlxuICAgICAqIEBwYXJhbSBkZXRlY3Rpb24gLSBUaGUgY2hhaW4gSUQgYW5kIGFkZHJlc3Mgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBuZXR3b3JrIGFuZCBhY2NvdW50IGF0IHRoZSBtb21lbnQgdGhlIGNvbGxlY3RpYmxlIHdhcyBkZXRlY3RlZC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBjb2xsZWN0aWJsZSBsaXN0LlxuICAgICAqL1xuICAgIGFkZENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQsIGNvbGxlY3RpYmxlTWV0YWRhdGEsIGRldGVjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgYWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVDb250cmFjdHMgPSB5aWVsZCB0aGlzLmFkZENvbGxlY3RpYmxlQ29udHJhY3QoYWRkcmVzcywgZGV0ZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbGxlY3RpYmxlTWV0YWRhdGEgPVxuICAgICAgICAgICAgICAgIGNvbGxlY3RpYmxlTWV0YWRhdGEgfHxcbiAgICAgICAgICAgICAgICAgICAgKHlpZWxkIHRoaXMuZ2V0Q29sbGVjdGlibGVJbmZvcm1hdGlvbihhZGRyZXNzLCB0b2tlbklkKSk7XG4gICAgICAgICAgICAvLyBJZiBjb2xsZWN0aWJsZSBjb250cmFjdCB3YXMgbm90IGFkZGVkLCBkbyBub3QgYWRkIGluZGl2aWR1YWwgY29sbGVjdGlibGVcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlQ29udHJhY3QgPSBuZXdDb2xsZWN0aWJsZUNvbnRyYWN0cy5maW5kKChjb250cmFjdCkgPT4gY29udHJhY3QuYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgLy8gSWYgY29sbGVjdGlibGUgY29udHJhY3QgaW5mb3JtYXRpb24sIGFkZCBpbmRpdmlkdWFsIGNvbGxlY3RpYmxlXG4gICAgICAgICAgICBpZiAoY29sbGVjdGlibGVDb250cmFjdCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuYWRkSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQsIGNvbGxlY3RpYmxlTWV0YWRhdGEsIGNvbGxlY3RpYmxlQ29udHJhY3QsIGRldGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZUNvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhZGRyZXNzID0gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0NvbGxlY3RpYmxlID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghcmVtYWluaW5nQ29sbGVjdGlibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgY29sbGVjdGlibGUgZnJvbSB0aGUgc3RvcmVkIHRva2VuIGxpc3QgYW5kIHNhdmVzIGl0IGluIGlnbm9yZWQgY29sbGVjdGlibGVzIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIFRva2VuIGlkZW50aWZpZXIgb2YgdGhlIGNvbGxlY3RpYmxlLlxuICAgICAqL1xuICAgIHJlbW92ZUFuZElnbm9yZUNvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhZGRyZXNzID0gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQW5kSWdub3JlSW5kaXZpZHVhbENvbGxlY3RpYmxlKGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0NvbGxlY3RpYmxlID0gY29sbGVjdGlibGVzLmZpbmQoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghcmVtYWluaW5nQ29sbGVjdGlibGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29sbGVjdGlibGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBjb2xsZWN0aWJsZXMgZnJvbSB0aGUgaWdub3JlZCBsaXN0LlxuICAgICAqL1xuICAgIGNsZWFySWdub3JlZENvbGxlY3RpYmxlcygpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZ25vcmVkQ29sbGVjdGlibGVzOiBbXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgaW5wdXQgY29sbGVjdGlibGUgaXMgc3RpbGwgb3duZWQgYnkgdGhlIHVzZXJcbiAgICAgKiBBbmQgdXBkYXRlcyB0aGUgaXNDdXJyZW50bHlPd25lZCB2YWx1ZSBvbiB0aGUgY29sbGVjdGlibGUgb2JqZWN0IGFjY29yZGluZ2x5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbGxlY3RpYmxlIC0gVGhlIGNvbGxlY3RpYmxlIG9iamVjdCB0byBjaGVjayBhbmQgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBiYXRjaCAtIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIHBhcnQgb2YgYSBiYXRjaCBvciBzaW5nbGUgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBhY2NvdW50UGFyYW1zIC0gVGhlIHVzZXJBZGRyZXNzIGFuZCBjaGFpbklkIHRvIGNoZWNrIG93bmVyc2hpcCBhZ2FpbnN0XG4gICAgICogQHBhcmFtIGFjY291bnRQYXJhbXMudXNlckFkZHJlc3MgLSB0aGUgYWRkcmVzcyBwYXNzZWQgdGhyb3VnaCB0aGUgY29uZmlybWVkIHRyYW5zYWN0aW9uIGZsb3cgdG8gZW5zdXJlIGRldGVjdGVkIGFzc2V0cyBhcmUgc3RvcmVkIHRvIHRoZSBjb3JyZWN0IGFjY291bnRcbiAgICAgKiBAcGFyYW0gYWNjb3VudFBhcmFtcy5jaGFpbklkIC0gdGhlIGNoYWluSWQgcGFzc2VkIHRocm91Z2ggdGhlIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBmbG93IHRvIGVuc3VyZSBkZXRlY3RlZCBhc3NldHMgYXJlIHN0b3JlZCB0byB0aGUgY29ycmVjdCBhY2NvdW50XG4gICAgICogQHJldHVybnMgdGhlIGNvbGxlY3RpYmxlIHdpdGggdGhlIHVwZGF0ZWQgaXNDdXJyZW50bHlPd25lZCB2YWx1ZVxuICAgICAqL1xuICAgIGNoZWNrQW5kVXBkYXRlU2luZ2xlQ29sbGVjdGlibGVPd25lcnNoaXBTdGF0dXMoY29sbGVjdGlibGUsIGJhdGNoLCB7IHVzZXJBZGRyZXNzLCBjaGFpbklkIH0gPSB7XG4gICAgICAgIHVzZXJBZGRyZXNzOiB0aGlzLmNvbmZpZy5zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IHRoaXMuY29uZmlnLmNoYWluSWQsXG4gICAgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHRva2VuSWQgfSA9IGNvbGxlY3RpYmxlO1xuICAgICAgICAgICAgbGV0IGlzT3duZWQgPSBjb2xsZWN0aWJsZS5pc0N1cnJlbnRseU93bmVkO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpc093bmVkID0geWllbGQgdGhpcy5pc0NvbGxlY3RpYmxlT3duZXIodXNlckFkZHJlc3MsIGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdVbmFibGUgdG8gdmVyaWZ5IG93bmVyc2hpcCcpKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb2xsZWN0aWJsZS5pc0N1cnJlbnRseU93bmVkID0gaXNPd25lZDtcbiAgICAgICAgICAgIGlmIChiYXRjaCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aWJsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaXMgbm90IHBhcnQgb2YgYSBiYXRjaGVkIHVwZGF0ZSB3ZSB1cGRhdGUgdGhpcyBvbmUgY29sbGVjdGlibGUgaW4gc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlc1t1c2VyQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgICAgICBjb25zdCBjb2xsZWN0aWJsZVRvVXBkYXRlID0gY29sbGVjdGlibGVzLmZpbmQoKGl0ZW0pID0+IGl0ZW0udG9rZW5JZCA9PT0gdG9rZW5JZCAmJlxuICAgICAgICAgICAgICAgIGl0ZW0uYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgaWYgKGNvbGxlY3RpYmxlVG9VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aWJsZVRvVXBkYXRlLmlzQ3VycmVudGx5T3duZWQgPSBpc093bmVkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTmVzdGVkQ29sbGVjdGlibGVTdGF0ZShjb2xsZWN0aWJsZXMsIEFMTF9DT0xMRUNUSUJMRVNfU1RBVEVfS0VZLCB7IHVzZXJBZGRyZXNzLCBjaGFpbklkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3RpYmxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgQ29sbGVjdGlibGVzIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHNlbGVjdGVkQWRkcmVzcy9jaGFpbklkIGNvbWJpbmF0aW9uIGFyZSBzdGlsbCBvd25lZCBieSB0aGUgdXNlclxuICAgICAqIEFuZCB1cGRhdGVzIHRoZSBpc0N1cnJlbnRseU93bmVkIHZhbHVlIG9uIGVhY2ggYWNjb3JkaW5nbHkuXG4gICAgICovXG4gICAgY2hlY2tBbmRVcGRhdGVBbGxDb2xsZWN0aWJsZXNPd25lcnNoaXBTdGF0dXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgY29sbGVjdGlibGVzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbGxlY3RpYmxlcyA9IHlpZWxkIFByb21pc2UuYWxsKGNvbGxlY3RpYmxlcy5tYXAoKGNvbGxlY3RpYmxlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKF9iID0gKHlpZWxkIHRoaXMuY2hlY2tBbmRVcGRhdGVTaW5nbGVDb2xsZWN0aWJsZU93bmVyc2hpcFN0YXR1cyhjb2xsZWN0aWJsZSwgdHJ1ZSkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjb2xsZWN0aWJsZSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVOZXN0ZWRDb2xsZWN0aWJsZVN0YXRlKHVwZGF0ZWRDb2xsZWN0aWJsZXMsIEFMTF9DT0xMRUNUSUJMRVNfU1RBVEVfS0VZKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBjb2xsZWN0aWJsZSBmYXZvcml0ZSBzdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gdG9rZW5JZCAtIEhleCBhZGRyZXNzIG9mIHRoZSBjb2xsZWN0aWJsZSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gZmF2b3JpdGUgLSBDb2xsZWN0aWJsZSBuZXcgZmF2b3JpdGUgc3RhdHVzLlxuICAgICAqL1xuICAgIHVwZGF0ZUNvbGxlY3RpYmxlRmF2b3JpdGVTdGF0dXMoYWRkcmVzcywgdG9rZW5JZCwgZmF2b3JpdGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29sbGVjdGlibGVzLmZpbmRJbmRleCgoY29sbGVjdGlibGUpID0+IGNvbGxlY3RpYmxlLmFkZHJlc3MgPT09IGFkZHJlc3MgJiYgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGRhdGVkQ29sbGVjdGlibGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbGxlY3RpYmxlc1tpbmRleF0pLCB7IGZhdm9yaXRlIH0pO1xuICAgICAgICAvLyBVcGRhdGUgQ29sbGVjdGlibGVzIGFycmF5XG4gICAgICAgIGNvbGxlY3RpYmxlc1tpbmRleF0gPSB1cGRhdGVkQ29sbGVjdGlibGU7XG4gICAgICAgIHRoaXMudXBkYXRlTmVzdGVkQ29sbGVjdGlibGVTdGF0ZShjb2xsZWN0aWJsZXMsIEFMTF9DT0xMRUNUSUJMRVNfU1RBVEVfS0VZKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlibGUgYnkgdGhlIGFkZHJlc3MgYW5kIHRva2VuIGlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgY29sbGVjdGlibGUgY29udHJhY3QuXG4gICAgICogQHBhcmFtIHRva2VuSWQgLSBOdW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBpZCBvZiB0aGUgdG9rZW4uXG4gICAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSB1c2VyIGFjY291bnQuXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBJZCBvZiB0aGUgY3VycmVudCBuZXR3b3JrLlxuICAgICAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIHRoZSBDb2xsZWN0aWJsZSBhbmQgdGhlaXIgcG9zaXRpb24gaW4gdGhlIGFycmF5XG4gICAgICovXG4gICAgZmluZENvbGxlY3RpYmxlQnlBZGRyZXNzQW5kVG9rZW5JZChhZGRyZXNzLCB0b2tlbklkLCBzZWxlY3RlZEFkZHJlc3MsIGNoYWluSWQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IGFsbENvbGxlY3RpYmxlcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlibGVzID0gKChfYSA9IGFsbENvbGxlY3RpYmxlc1tzZWxlY3RlZEFkZHJlc3NdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbY2hhaW5JZF0pIHx8IFtdO1xuICAgICAgICBjb25zdCBpbmRleCA9IGNvbGxlY3RpYmxlcy5maW5kSW5kZXgoKGNvbGxlY3RpYmxlKSA9PiBjb2xsZWN0aWJsZS5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSAmJlxuICAgICAgICAgICAgY29sbGVjdGlibGUudG9rZW5JZCA9PT0gdG9rZW5JZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvbGxlY3RpYmxlOiBjb2xsZWN0aWJsZXNbaW5kZXhdLCBpbmRleCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgY29sbGVjdGlibGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xsZWN0aWJsZSAtIENvbGxlY3RpYmxlIG9iamVjdCB0byBmaW5kIHRoZSByaWdodCBjb2xsZWN0aWJsZSB0byB1cGRhdGVzLlxuICAgICAqIEBwYXJhbSB1cGRhdGVzIC0gQ29sbGVjdGlibGUgcGFydGlhbCBvYmplY3QgdG8gdXBkYXRlIHByb3BlcnRpZXMgb2YgdGhlIGNvbGxlY3RpYmxlLlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgdXNlciBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gSWQgb2YgdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKi9cbiAgICB1cGRhdGVDb2xsZWN0aWJsZShjb2xsZWN0aWJsZSwgdXBkYXRlcywgc2VsZWN0ZWRBZGRyZXNzLCBjaGFpbklkKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBhbGxDb2xsZWN0aWJsZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGNvbGxlY3RpYmxlcyA9ICgoX2EgPSBhbGxDb2xsZWN0aWJsZXNbc2VsZWN0ZWRBZGRyZXNzXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2NoYWluSWRdKSB8fCBbXTtcbiAgICAgICAgY29uc3QgY29sbGVjdGlibGVJbmZvID0gdGhpcy5maW5kQ29sbGVjdGlibGVCeUFkZHJlc3NBbmRUb2tlbklkKGNvbGxlY3RpYmxlLmFkZHJlc3MsIGNvbGxlY3RpYmxlLnRva2VuSWQsIHNlbGVjdGVkQWRkcmVzcywgY2hhaW5JZCk7XG4gICAgICAgIGlmICghY29sbGVjdGlibGVJbmZvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZENvbGxlY3RpYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb2xsZWN0aWJsZSksIHVwZGF0ZXMpO1xuICAgICAgICAvLyBVcGRhdGUgQ29sbGVjdGlibGVzIGFycmF5XG4gICAgICAgIGNvbnN0IG5ld0NvbGxlY3RpYmxlcyA9IFtcbiAgICAgICAgICAgIC4uLmNvbGxlY3RpYmxlcy5zbGljZSgwLCBjb2xsZWN0aWJsZUluZm8uaW5kZXgpLFxuICAgICAgICAgICAgdXBkYXRlZENvbGxlY3RpYmxlLFxuICAgICAgICAgICAgLi4uY29sbGVjdGlibGVzLnNsaWNlKGNvbGxlY3RpYmxlSW5mby5pbmRleCArIDEpLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlibGVzLCBBTExfQ09MTEVDVElCTEVTX1NUQVRFX0tFWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgdHJhbnNhY3Rpb24gc3RhdHVzIG9mIGEgY29sbGVjdGlibGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JZCAtIENvbGxlY3RpYmxlIHRyYW5zYWN0aW9uIGlkLlxuICAgICAqIEBwYXJhbSBzZWxlY3RlZEFkZHJlc3MgLSBIZXggYWRkcmVzcyBvZiB0aGUgdXNlciBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gSWQgb2YgdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKiBAcmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgcmVzZXQgd2FzIHdlbGwgc3VjY2VkZWQgb3Igbm90XG4gICAgICovXG4gICAgcmVzZXRDb2xsZWN0aWJsZVRyYW5zYWN0aW9uU3RhdHVzQnlUcmFuc2FjdGlvbklkKHRyYW5zYWN0aW9uSWQsIHNlbGVjdGVkQWRkcmVzcywgY2hhaW5JZCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgYWxsQ29sbGVjdGlibGVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBjb2xsZWN0aWJsZXMgPSAoKF9hID0gYWxsQ29sbGVjdGlibGVzW3NlbGVjdGVkQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtjaGFpbklkXSkgfHwgW107XG4gICAgICAgIGNvbnN0IGluZGV4ID0gY29sbGVjdGlibGVzLmZpbmRJbmRleCgoY29sbGVjdGlibGUpID0+IGNvbGxlY3RpYmxlLnRyYW5zYWN0aW9uSWQgPT09IHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXBkYXRlZENvbGxlY3RpYmxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb2xsZWN0aWJsZXNbaW5kZXhdKSwgeyB0cmFuc2FjdGlvbklkOiB1bmRlZmluZWQgfSk7XG4gICAgICAgIC8vIFVwZGF0ZSBDb2xsZWN0aWJsZXMgYXJyYXlcbiAgICAgICAgY29uc3QgbmV3Q29sbGVjdGlibGVzID0gW1xuICAgICAgICAgICAgLi4uY29sbGVjdGlibGVzLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgICAgIHVwZGF0ZWRDb2xsZWN0aWJsZSxcbiAgICAgICAgICAgIC4uLmNvbGxlY3RpYmxlcy5zbGljZShpbmRleCArIDEpLFxuICAgICAgICBdO1xuICAgICAgICB0aGlzLnVwZGF0ZU5lc3RlZENvbGxlY3RpYmxlU3RhdGUobmV3Q29sbGVjdGlibGVzLCBBTExfQ09MTEVDVElCTEVTX1NUQVRFX0tFWSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29sbGVjdGlibGVzQ29udHJvbGxlciA9IENvbGxlY3RpYmxlc0NvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDb2xsZWN0aWJsZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGVjdGlibGVzQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DdXJyZW5jeVJhdGVDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBjcnlwdG9fY29tcGFyZV8xID0gcmVxdWlyZShcIi4uL2FwaXMvY3J5cHRvLWNvbXBhcmVcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBuYW1lID0gJ0N1cnJlbmN5UmF0ZUNvbnRyb2xsZXInO1xuY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgY29udmVyc2lvbkRhdGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgY29udmVyc2lvblJhdGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgY3VycmVudEN1cnJlbmN5OiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxuICAgIG5hdGl2ZUN1cnJlbmN5OiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHBlbmRpbmdDdXJyZW50Q3VycmVuY3k6IHsgcGVyc2lzdDogZmFsc2UsIGFub255bW91czogdHJ1ZSB9LFxuICAgIHBlbmRpbmdOYXRpdmVDdXJyZW5jeTogeyBwZXJzaXN0OiBmYWxzZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgdXNkQ29udmVyc2lvblJhdGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG59O1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGNvbnZlcnNpb25EYXRlOiAwLFxuICAgIGNvbnZlcnNpb25SYXRlOiAwLFxuICAgIGN1cnJlbnRDdXJyZW5jeTogJ3VzZCcsXG4gICAgbmF0aXZlQ3VycmVuY3k6ICdFVEgnLFxuICAgIHBlbmRpbmdDdXJyZW50Q3VycmVuY3k6IG51bGwsXG4gICAgcGVuZGluZ05hdGl2ZUN1cnJlbmN5OiBudWxsLFxuICAgIHVzZENvbnZlcnNpb25SYXRlOiBudWxsLFxufTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgYW4gZXhjaGFuZ2UgcmF0ZSBmcm9tIHRoZSBjdXJyZW50IGJhc2VcbiAqIGFzc2V0IHRvIHRoZSBjdXJyZW50IGN1cnJlbmN5XG4gKi9cbmNsYXNzIEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBDdXJyZW5jeVJhdGVDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVVc2RSYXRlIC0gS2VlcCB0cmFjayBvZiB0aGUgVVNEIHJhdGUgaW4gYWRkaXRpb24gdG8gdGhlIGN1cnJlbnQgY3VycmVuY3kgcmF0ZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSBwb2xsaW5nIGludGVydmFsLCBpbiBtaWxsaXNlY29uZHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMubWVzc2VuZ2VyIC0gQSByZWZlcmVuY2UgdG8gdGhlIG1lc3NhZ2luZyBzeXN0ZW0uXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZmV0Y2hFeGNoYW5nZVJhdGUgLSBGZXRjaGVzIHRoZSBleGNoYW5nZSByYXRlIGZyb20gYW4gZXh0ZXJuYWwgQVBJLiBUaGlzIG9wdGlvbiBpcyBwcmltYXJpbHkgbWVhbnQgZm9yIHVzZSBpbiB1bml0IHRlc3RzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaW5jbHVkZVVzZFJhdGUgPSBmYWxzZSwgaW50ZXJ2YWwgPSAxODAwMDAsIG1lc3Nlbmdlciwgc3RhdGUsIGZldGNoRXhjaGFuZ2VSYXRlID0gY3J5cHRvX2NvbXBhcmVfMS5mZXRjaEV4Y2hhbmdlUmF0ZSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm11dGV4ID0gbmV3IGFzeW5jX211dGV4XzEuTXV0ZXgoKTtcbiAgICAgICAgdGhpcy5pbmNsdWRlVXNkUmF0ZSA9IGluY2x1ZGVVc2RSYXRlO1xuICAgICAgICB0aGlzLmludGVydmFsRGVsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5mZXRjaEV4Y2hhbmdlUmF0ZSA9IGZldGNoRXhjaGFuZ2VSYXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nIGZvciB0aGUgY3VycmVuY3kgcmF0ZS5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc3RhcnRQb2xsaW5nKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHBvbGxpbmcgZm9yIHRoZSBjdXJyZW5jeSByYXRlLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0byBkaXNjYXJkIHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RvcHMgYW55IGFjdGl2ZSBwb2xsaW5nLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VycmVuY3kgdG8gdHJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3VycmVudEN1cnJlbmN5IC0gSVNPIDQyMTcgY3VycmVuY3kgY29kZS5cbiAgICAgKi9cbiAgICBzZXRDdXJyZW50Q3VycmVuY3koY3VycmVudEN1cnJlbmN5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wZW5kaW5nQ3VycmVudEN1cnJlbmN5ID0gY3VycmVudEN1cnJlbmN5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBuYXRpdmUgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3ltYm9sIC0gU3ltYm9sIGZvciB0aGUgYmFzZSBhc3NldC5cbiAgICAgKi9cbiAgICBzZXROYXRpdmVDdXJyZW5jeShzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnBlbmRpbmdOYXRpdmVDdXJyZW5jeSA9IHN5bWJvbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgeWllbGQgdGhpcy51cGRhdGVFeGNoYW5nZVJhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3BQb2xsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgc3RhcnRQb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAgICAgLy8gVE9ETzogRXhwb3NlIHBvbGxpbmcgY3VycmVuY3kgcmF0ZSB1cGRhdGUgZXJyb3JzXG4gICAgICAgICAgICB5aWVsZCAoMCwgdXRpbF8xLnNhZmVseUV4ZWN1dGUpKCgpID0+IHRoaXMudXBkYXRlRXhjaGFuZ2VSYXRlKCkpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gdGhpcy51cGRhdGVFeGNoYW5nZVJhdGUoKSk7XG4gICAgICAgICAgICB9KSwgdGhpcy5pbnRlcnZhbERlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZXhjaGFuZ2UgcmF0ZSBmb3IgdGhlIGN1cnJlbnQgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY29udHJvbGxlciBzdGF0ZS5cbiAgICAgKi9cbiAgICB1cGRhdGVFeGNoYW5nZVJhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50Q3VycmVuY3k6IHN0YXRlQ3VycmVudEN1cnJlbmN5LCBuYXRpdmVDdXJyZW5jeTogc3RhdGVOYXRpdmVDdXJyZW5jeSwgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeSwgcGVuZGluZ05hdGl2ZUN1cnJlbmN5LCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGxldCBjb252ZXJzaW9uRGF0ZSA9IG51bGw7XG4gICAgICAgICAgICBsZXQgY29udmVyc2lvblJhdGUgPSBudWxsO1xuICAgICAgICAgICAgbGV0IHVzZENvbnZlcnNpb25SYXRlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDdXJyZW5jeSA9IHBlbmRpbmdDdXJyZW50Q3VycmVuY3kgIT09IG51bGwgJiYgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeSAhPT0gdm9pZCAwID8gcGVuZGluZ0N1cnJlbnRDdXJyZW5jeSA6IHN0YXRlQ3VycmVudEN1cnJlbmN5O1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlQ3VycmVuY3kgPSBwZW5kaW5nTmF0aXZlQ3VycmVuY3kgIT09IG51bGwgJiYgcGVuZGluZ05hdGl2ZUN1cnJlbmN5ICE9PSB2b2lkIDAgPyBwZW5kaW5nTmF0aXZlQ3VycmVuY3kgOiBzdGF0ZU5hdGl2ZUN1cnJlbmN5O1xuICAgICAgICAgICAgLy8gRm9yIHByZWxvYWRlZCB0ZXN0bmV0cyAoUmlua2VieSwgUm9wc3RlbiwgR29lcmxpLCBLb3Zhbikgd2Ugd2FudCB0byBmZXRjaCBleGNoYW5nZSByYXRlIGZvciByZWFsIEVUSC5cbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUN1cnJlbmN5Rm9yRXhjaGFuZ2VSYXRlID0gT2JqZWN0LnZhbHVlcyhjb25zdGFudHNfMS5URVNUTkVUX1RJQ0tFUl9TWU1CT0xTKS5pbmNsdWRlcyhuYXRpdmVDdXJyZW5jeSlcbiAgICAgICAgICAgICAgICA/IGNvbnN0YW50c18xLkZBTExfQkFDS19WU19DVVJSRU5DWSAvLyBFVEhcbiAgICAgICAgICAgICAgICA6IG5hdGl2ZUN1cnJlbmN5O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEN1cnJlbmN5ICYmXG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5ICYmXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGVpdGhlciBjdXJyZW5jeSBpcyBhbiBlbXB0eSBzdHJpbmcgd2UgY2FuIHNraXAgdGhlIGNvbXBhcmlzb25cbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpdCB3aWxsIHJlc3VsdCBpbiBhbiBlcnJvciBmcm9tIHRoZSBhcGkgYW5kIHVsdGltYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYSBudWxsIGNvbnZlcnNpb25SYXRlIGVpdGhlciB3YXkuXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDdXJyZW5jeSAhPT0gJycgJiZcbiAgICAgICAgICAgICAgICAgICAgbmF0aXZlQ3VycmVuY3kgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICh7IGNvbnZlcnNpb25SYXRlLCB1c2RDb252ZXJzaW9uUmF0ZSB9ID0geWllbGQgdGhpcy5mZXRjaEV4Y2hhbmdlUmF0ZShjdXJyZW50Q3VycmVuY3ksIG5hdGl2ZUN1cnJlbmN5Rm9yRXhjaGFuZ2VSYXRlLCB0aGlzLmluY2x1ZGVVc2RSYXRlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25EYXRlID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKCdtYXJrZXQgZG9lcyBub3QgZXhpc3QgZm9yIHRoaXMgY29pbiBwYWlyJykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvbkRhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvblJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY3VycmVudGx5IGFsbG93IGFuZCBoYW5kbGUgYW4gZW1wdHkgc3RyaW5nIGFzIGEgdmFsaWQgbmF0aXZlQ3VycmVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBjYXNlcyB3aGVyZSBhIHVzZXIgaGFzIG5vdCBlbnRlcmVkIGEgbmF0aXZlIHRpY2tlciBzeW1ib2wgZm9yIGEgY3VzdG9tIG5ldHdvcmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50Q3VycmVuY3kgaXMgbm90IGZyb20gdXNlciBpbnB1dCBidXQgdGhpcyBwcm90ZWN0cyB1cyBmcm9tIHVuZXhwZWN0ZWQgY2hhbmdlcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXRpdmVDdXJyZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q3VycmVuY3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0N1cnJlbnRDdXJyZW5jeTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nTmF0aXZlQ3VycmVuY3k6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXNkQ29udmVyc2lvblJhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ3VycmVuY3lSYXRlQ29udHJvbGxlciA9IEN1cnJlbmN5UmF0ZUNvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBDdXJyZW5jeVJhdGVDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VycmVuY3lSYXRlQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FUkMxMTU1U3RhbmRhcmQgPSB2b2lkIDA7XG5jb25zdCBtZXRhbWFza19ldGhfYWJpc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlsXCIpO1xuY2xhc3MgRVJDMTE1NVN0YW5kYXJkIHtcbiAgICBjb25zdHJ1Y3Rvcih3ZWIzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSBpZiBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzExNTUgVVJJIE1ldGFkYXRhIGludGVyZmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkMxMTU1IGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgdGhlIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDMTE1NSBVUkkgTWV0YWRhdGEgaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250cmFjdFN1cHBvcnRzVVJJTWV0YWRhdGFJbnRlcmZhY2UgPSAoYWRkcmVzcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJhY3RTdXBwb3J0c0ludGVyZmFjZShhZGRyZXNzLCBjb25zdGFudHNfMS5FUkMxMTU1X01FVEFEQVRBX1VSSV9JTlRFUkZBQ0VfSUQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IGlmIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDMTE1NSBUb2tlbiBSZWNlaXZlciBpbnRlcmZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDMTE1NSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzExNTUgVG9rZW4gUmVjZWl2ZXIgaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250cmFjdFN1cHBvcnRzVG9rZW5SZWNlaXZlckludGVyZmFjZSA9IChhZGRyZXNzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cmFjdFN1cHBvcnRzSW50ZXJmYWNlKGFkZHJlc3MsIGNvbnN0YW50c18xLkVSQzExNTVfVE9LRU5fUkVDRUlWRVJfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSBpZiBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzExNTUgaW50ZXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzExNTUgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gd2hldGhlciB0aGUgY29udHJhY3QgaW1wbGVtZW50cyB0aGUgYmFzZSBFUkMxMTU1IGludGVyZmFjZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udHJhY3RTdXBwb3J0c0Jhc2UxMTU1SW50ZXJmYWNlID0gKGFkZHJlc3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0U3VwcG9ydHNJbnRlcmZhY2UoYWRkcmVzcywgY29uc3RhbnRzXzEuRVJDMTE1NV9JTlRFUkZBQ0VfSUQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IGZvciB0b2tlblVSSSBmb3IgYSBnaXZlbiBhc3NldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkMxMTU1IGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB0b2tlbklkIC0gRVJDMTE1NSBhc3NldCBpZGVudGlmaWVyLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3Rva2VuVVJJJy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0VG9rZW5VUkkgPSAoYWRkcmVzcywgdG9rZW5JZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KG1ldGFtYXNrX2V0aF9hYmlzXzEuYWJpRVJDMTE1NSkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LnVyaSh0b2tlbklkLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IGZvciBiYWxhbmNlIG9mIGEgZ2l2ZW4gRVJDMTE1NSB0b2tlbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyAtIEVSQzExNTUgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBXYWxsZXQgcHVibGljIGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSB0b2tlbklkIC0gRVJDMTE1NSBhc3NldCBpZGVudGlmaWVyLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ2JhbGFuY2VPZicuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEJhbGFuY2VPZiA9IChjb250cmFjdEFkZHJlc3MsIGFkZHJlc3MsIHRva2VuSWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChtZXRhbWFza19ldGhfYWJpc18xLmFiaUVSQzExNTUpLmF0KGNvbnRyYWN0QWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmJhbGFuY2VPZihhZGRyZXNzLCB0b2tlbklkLCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYW5zZmVyIHNpbmdsZSBFUkMxMTU1IHRva2VuLlxuICAgICAgICAgKiBXaGVuIG1pbnRpbmcvY3JlYXRpbmcgdG9rZW5zLCB0aGUgZnJvbSBhcmcgTVVTVCBiZSBzZXQgdG8gMHgwIChpLmUuIHplcm8gYWRkcmVzcykuXG4gICAgICAgICAqIFdoZW4gYnVybmluZy9kZXN0cm95aW5nIHRva2VucywgdGhlIHRvIGFyZyBNVVNUIGJlIHNldCB0byAweDAgKGkuZS4gemVybyBhZGRyZXNzKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9wZXJhdG9yIC0gRVJDMTE1NSB0b2tlbiBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0gZnJvbSAtIEVSQzExNTUgdG9rZW4gaG9sZGVyLlxuICAgICAgICAgKiBAcGFyYW0gdG8gLSBFUkMxMTU1IHRva2VuIHJlY2lwaWVudC5cbiAgICAgICAgICogQHBhcmFtIGlkIC0gRVJDMTE1NSB0b2tlbiBpZC5cbiAgICAgICAgICogQHBhcmFtIHZhbHVlIC0gTnVtYmVyIG9mIHRva2VucyB0byBiZSBzZW50LlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3RyYW5zZmVyU2luZ2xlJy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudHJhbnNmZXJTaW5nbGUgPSAob3BlcmF0b3IsIGZyb20sIHRvLCBpZCwgdmFsdWUpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChtZXRhbWFza19ldGhfYWJpc18xLmFiaUVSQzExNTUpLmF0KG9wZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QudHJhbnNmZXJTaW5nbGUob3BlcmF0b3IsIGZyb20sIHRvLCBpZCwgdmFsdWUsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgaWYgYSBjb250cmFjdCBpbXBsZW1lbnRzIGFuIGludGVyZmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkMxMTU1IGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSBpbnRlcmZhY2VJZCAtIEludGVyZmFjZSBpZGVudGlmaWVyLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIGBpbnRlcmZhY2VJRGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRyYWN0U3VwcG9ydHNJbnRlcmZhY2UgPSAoYWRkcmVzcywgaW50ZXJmYWNlSWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChtZXRhbWFza19ldGhfYWJpc18xLmFiaUVSQzExNTUpLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdC5zdXBwb3J0c0ludGVyZmFjZShpbnRlcmZhY2VJZCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSBpZiBhIGNvbnRyYWN0IGltcGxlbWVudHMgYW4gaW50ZXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICAgICAqIEBwYXJhbSBpcGZzR2F0ZXdheSAtIFRoZSB1c2VyJ3MgcHJlZmVycmVkIElQRlMgZ2F0ZXdheS5cbiAgICAgICAgICogQHBhcmFtIHRva2VuSWQgLSB0b2tlbklkIG9mIGEgZ2l2ZW4gdG9rZW4gaW4gdGhlIGNvbnRyYWN0LlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgc3RhbmRhcmQsIHRva2VuVVJJLCBzeW1ib2wgYW5kIG5hbWUgb2YgdGhlIGdpdmVuIGNvbnRyYWN0L3Rva2VuSWQgcGFpci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0RGV0YWlscyA9IChhZGRyZXNzLCBpcGZzR2F0ZXdheSwgdG9rZW5JZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaXNFUkMxMTU1ID0geWllbGQgdGhpcy5jb250cmFjdFN1cHBvcnRzQmFzZTExNTVJbnRlcmZhY2UoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoIWlzRVJDMTE1NSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgaXNuJ3QgYSB2YWxpZCBFUkMxMTU1IGNvbnRyYWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRva2VuVVJJLCBpbWFnZTtcbiAgICAgICAgICAgIGlmICh0b2tlbklkKSB7XG4gICAgICAgICAgICAgICAgdG9rZW5VUkkgPSB5aWVsZCB0aGlzLmdldFRva2VuVVJJKGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblVSSS5zdGFydHNXaXRoKCdpcGZzOi8vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5VUkkgPSAoMCwgdXRpbF8xLmdldEZvcm1hdHRlZElwZnNVcmwpKGlwZnNHYXRld2F5LCB0b2tlblVSSSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgKDAsIHV0aWxfMS50aW1lb3V0RmV0Y2gpKHRva2VuVVJJKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZSA9IG9iamVjdCA9PT0gbnVsbCB8fCBvYmplY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9iamVjdC5pbWFnZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5zdGFydHNXaXRoKCdpcGZzOi8vJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gKDAsIHV0aWxfMS5nZXRGb3JtYXR0ZWRJcGZzVXJsKShpcGZzR2F0ZXdheSwgaW1hZ2UsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIGNvbnNpZGVyIHF1ZXJ5aW5nIHRvIHRoZSBtZXRhZGF0YSB0byBnZXQgbmFtZS5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmQ6IGNvbnN0YW50c18xLkVSQzExNTUsXG4gICAgICAgICAgICAgICAgdG9rZW5VUkksXG4gICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53ZWIzID0gd2ViMztcbiAgICB9XG59XG5leHBvcnRzLkVSQzExNTVTdGFuZGFyZCA9IEVSQzExNTVTdGFuZGFyZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVSQzExNTVTdGFuZGFyZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FUkM3MjFTdGFuZGFyZCA9IHZvaWQgMDtcbmNvbnN0IG1ldGFtYXNrX2V0aF9hYmlzXzEgPSByZXF1aXJlKFwiQG1ldGFtYXNrL21ldGFtYXNrLWV0aC1hYmlzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3V0aWxcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi9jb25zdGFudHNcIik7XG5jbGFzcyBFUkM3MjFTdGFuZGFyZCB7XG4gICAgY29uc3RydWN0b3Iod2ViMykge1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgaWYgY29udHJhY3QgaW1wbGVtZW50cyBFUkM3MjFNZXRhZGF0YSBpbnRlcmZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gRVJDNzIxIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgdGhlIGNvbnRyYWN0IGltcGxlbWVudHMgRVJDNzIxTWV0YWRhdGEgaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250cmFjdFN1cHBvcnRzTWV0YWRhdGFJbnRlcmZhY2UgPSAoYWRkcmVzcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJhY3RTdXBwb3J0c0ludGVyZmFjZShhZGRyZXNzLCBjb25zdGFudHNfMS5FUkM3MjFfTUVUQURBVEFfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSBpZiBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzcyMUVudW1lcmFibGUgaW50ZXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzcyMUVudW1lcmFibGUgaW50ZXJmYWNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250cmFjdFN1cHBvcnRzRW51bWVyYWJsZUludGVyZmFjZSA9IChhZGRyZXNzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cmFjdFN1cHBvcnRzSW50ZXJmYWNlKGFkZHJlc3MsIGNvbnN0YW50c18xLkVSQzcyMV9FTlVNRVJBQkxFX0lOVEVSRkFDRV9JRCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgaWYgY29udHJhY3QgaW1wbGVtZW50cyBFUkM3MjEgaW50ZXJmYWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB3aGV0aGVyIHRoZSBjb250cmFjdCBpbXBsZW1lbnRzIEVSQzcyMSBpbnRlcmZhY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRyYWN0U3VwcG9ydHNCYXNlNzIxSW50ZXJmYWNlID0gKGFkZHJlc3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyYWN0U3VwcG9ydHNJbnRlcmZhY2UoYWRkcmVzcywgY29uc3RhbnRzXzEuRVJDNzIxX0lOVEVSRkFDRV9JRCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRW51bWVyYXRlIGFzc2V0cyBhc3NpZ25lZCB0byBhbiBvd25lci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkM3MjEgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHNlbGVjdGVkQWRkcmVzcyAtIEN1cnJlbnQgYWNjb3VudCBwdWJsaWMgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gQSBjb2xsZWN0aWJsZSBjb3VudGVyIGxlc3MgdGhhbiBgYmFsYW5jZU9mKHNlbGVjdGVkQWRkcmVzcylgLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0b2tlbiBpZGVudGlmaWVyIGZvciB0aGUgJ2luZGV4J3RoIGFzc2V0IGFzc2lnbmVkIHRvICdzZWxlY3RlZEFkZHJlc3MnLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRDb2xsZWN0aWJsZVRva2VuSWQgPSAoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzLCBpbmRleCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KG1ldGFtYXNrX2V0aF9hYmlzXzEuYWJpRVJDNzIxKS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QudG9rZW5PZk93bmVyQnlJbmRleChzZWxlY3RlZEFkZHJlc3MsIGluZGV4LCAoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IGZvciB0b2tlblVSSSBmb3IgYSBnaXZlbiBhc3NldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkM3MjEgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIHRva2VuSWQgLSBFUkM3MjEgYXNzZXQgaWRlbnRpZmllci5cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICd0b2tlblVSSScuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFRva2VuVVJJID0gKGFkZHJlc3MsIHRva2VuSWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChtZXRhbWFza19ldGhfYWJpc18xLmFiaUVSQzcyMSkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0c01ldGFkYXRhID0geWllbGQgdGhpcy5jb250cmFjdFN1cHBvcnRzTWV0YWRhdGFJbnRlcmZhY2UoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRzTWV0YWRhdGEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGRvZXMgbm90IHN1cHBvcnQgRVJDNzIxIG1ldGFkYXRhIGludGVyZmFjZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3QudG9rZW5VUkkodG9rZW5JZCwgKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSBmb3IgbmFtZSBmb3IgYSBnaXZlbiBhc3NldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkM3MjEgYXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICduYW1lJy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QXNzZXROYW1lID0gKGFkZHJlc3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChtZXRhbWFza19ldGhfYWJpc18xLmFiaUVSQzcyMSkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0Lm5hbWUoKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBRdWVyeSBmb3Igc3ltYm9sIGZvciBhIGdpdmVuIGFzc2V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgJ3N5bWJvbCcuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEFzc2V0U3ltYm9sID0gKGFkZHJlc3MpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gdGhpcy53ZWIzLmV0aC5jb250cmFjdChtZXRhbWFza19ldGhfYWJpc18xLmFiaUVSQzcyMSkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LnN5bWJvbCgoZXJyb3IsIHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXJ5IGlmIGEgY29udHJhY3QgaW1wbGVtZW50cyBhbiBpbnRlcmZhY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgICAgICogQHBhcmFtIGludGVyZmFjZUlkIC0gSW50ZXJmYWNlIGlkZW50aWZpZXIuXG4gICAgICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHdoZXRoZXIgdGhlIGNvbnRyYWN0IGltcGxlbWVudHMgYGludGVyZmFjZUlEYC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29udHJhY3RTdXBwb3J0c0ludGVyZmFjZSA9IChhZGRyZXNzLCBpbnRlcmZhY2VJZCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3QgPSB0aGlzLndlYjMuZXRoLmNvbnRyYWN0KG1ldGFtYXNrX2V0aF9hYmlzXzEuYWJpRVJDNzIxKS5hdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJhY3Quc3VwcG9ydHNJbnRlcmZhY2UoaW50ZXJmYWNlSWQsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogUXVlcnkgaWYgYSBjb250cmFjdCBpbXBsZW1lbnRzIGFuIGludGVyZmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGFkZHJlc3MgLSBBc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAgICAgKiBAcGFyYW0gaXBmc0dhdGV3YXkgLSBUaGUgdXNlcidzIHByZWZlcnJlZCBJUEZTIGdhdGV3YXkuXG4gICAgICAgICAqIEBwYXJhbSB0b2tlbklkIC0gdG9rZW5JZCBvZiBhIGdpdmVuIHRva2VuIGluIHRoZSBjb250cmFjdC5cbiAgICAgICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHN0YW5kYXJkLCB0b2tlblVSSSwgc3ltYm9sIGFuZCBuYW1lIG9mIHRoZSBnaXZlbiBjb250cmFjdC90b2tlbklkIHBhaXIuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldERldGFpbHMgPSAoYWRkcmVzcywgaXBmc0dhdGV3YXksIHRva2VuSWQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRVJDNzIxID0geWllbGQgdGhpcy5jb250cmFjdFN1cHBvcnRzQmFzZTcyMUludGVyZmFjZShhZGRyZXNzKTtcbiAgICAgICAgICAgIGlmICghaXNFUkM3MjEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGlzbid0IGEgdmFsaWQgRVJDNzIxIGNvbnRyYWN0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRva2VuVVJJLCBpbWFnZSwgc3ltYm9sLCBuYW1lO1xuICAgICAgICAgICAgLy8gVE9ETyB1cGdyYWRlIHRvIHVzZSBQcm9taXNlLmFsbFNldHRsZWQgZm9yIG5hbWUvc3ltYm9sIHdoZW4gd2UgY2FuIHJlZmFjdG9yIHRvIHVzZSBlczIwMjAgaW4gdHNjb25maWdcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0geWllbGQgdGhpcy5nZXRBc3NldFN5bWJvbChhZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBuYW1lID0geWllbGQgdGhpcy5nZXRBc3NldE5hbWUoYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2tlbklkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5VUkkgPSB5aWVsZCB0aGlzLmdldFRva2VuVVJJKGFkZHJlc3MsIHRva2VuSWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5VUkkuc3RhcnRzV2l0aCgnaXBmczovLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblVSSSA9ICgwLCB1dGlsXzEuZ2V0Rm9ybWF0dGVkSXBmc1VybCkoaXBmc0dhdGV3YXksIHRva2VuVVJJLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkICgwLCB1dGlsXzEudGltZW91dEZldGNoKSh0b2tlblVSSSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdCA9IHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBvYmplY3QgPT09IG51bGwgfHwgb2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYmplY3QuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2Uuc3RhcnRzV2l0aCgnaXBmczovLycpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSA9ICgwLCB1dGlsXzEuZ2V0Rm9ybWF0dGVkSXBmc1VybCkoaXBmc0dhdGV3YXksIGltYWdlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFuZGFyZDogY29uc3RhbnRzXzEuRVJDNzIxLFxuICAgICAgICAgICAgICAgIHRva2VuVVJJLFxuICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMud2ViMyA9IHdlYjM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBvd25lciBmb3IgYSBnaXZlbiBFUkM3MjEgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzcyMSBhc3NldCBjb250cmFjdCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB0b2tlbklkIC0gRVJDNzIxIGFzc2V0IGlkZW50aWZpZXIuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG93bmVyIGFkZHJlc3MuXG4gICAgICovXG4gICAgZ2V0T3duZXJPZihhZGRyZXNzLCB0b2tlbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QobWV0YW1hc2tfZXRoX2FiaXNfMS5hYmlFUkM3MjEpLmF0KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb250cmFjdC5vd25lck9mKHRva2VuSWQsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRVJDNzIxU3RhbmRhcmQgPSBFUkM3MjFTdGFuZGFyZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVSQzcyMVN0YW5kYXJkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVSQzIwU3RhbmRhcmQgPSB2b2lkIDA7XG5jb25zdCBtZXRhbWFza19ldGhfYWJpc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpc1wiKTtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiZXRoZXJzL2xpYi91dGlsc1wiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uLy4uL2NvbnN0YW50c1wiKTtcbmNsYXNzIEVSQzIwU3RhbmRhcmQge1xuICAgIGNvbnN0cnVjdG9yKHdlYjMpIHtcbiAgICAgICAgdGhpcy53ZWIzID0gd2ViMztcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGJhbGFuY2Ugb3IgY291bnQgZm9yIGN1cnJlbnQgYWNjb3VudCBvbiBzcGVjaWZpYyBhc3NldCBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQXNzZXQgRVJDMjAgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gQ3VycmVudCBhY2NvdW50IHB1YmxpYyBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIEJOIG9iamVjdCBjb250YWluaW5nIGJhbGFuY2UgZm9yIGN1cnJlbnQgYWNjb3VudCBvbiBzcGVjaWZpYyBhc3NldCBjb250cmFjdC5cbiAgICAgKi9cbiAgICBnZXRCYWxhbmNlT2YoYWRkcmVzcywgc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QobWV0YW1hc2tfZXRoX2FiaXNfMS5hYmlFUkMyMCkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmJhbGFuY2VPZihzZWxlY3RlZEFkZHJlc3MsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWVyeSBmb3IgdGhlIGRlY2ltYWxzIGZvciBhIGdpdmVuIEVSQzIwIGFzc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBFUkMyMCBhc3NldCBjb250cmFjdCBzdHJpbmcuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdkZWNpbWFscycuXG4gICAgICovXG4gICAgZ2V0VG9rZW5EZWNpbWFscyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHRoaXMud2ViMy5ldGguY29udHJhY3QobWV0YW1hc2tfZXRoX2FiaXNfMS5hYmlFUkMyMCkuYXQoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0LmRlY2ltYWxzKChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1ZXJ5IGZvciBzeW1ib2wgZm9yIGEgZ2l2ZW4gRVJDMjAgYXNzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEVSQzIwIGFzc2V0IGNvbnRyYWN0IGFkZHJlc3MuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlICdzeW1ib2wnLlxuICAgICAqL1xuICAgIGdldFRva2VuU3ltYm9sKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFNpZ25hdHVyZSBmb3IgY2FsbGluZyBgc3ltYm9sKClgXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyB0bzogYWRkcmVzcywgZGF0YTogJzB4OTVkODliNDEnIH07XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud2ViMy5ldGguY2FsbChwYXlsb2FkLCB1bmRlZmluZWQsIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWJpQ29kZXIgPSBuZXcgdXRpbHNfMS5BYmlDb2RlcigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlY29kZWQgPSBhYmlDb2Rlci5kZWNvZGUoWydzdHJpbmcnXSwgcmVzdWx0KVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShkZWNvZGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhcyBieXRlc1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXRmOCA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS50b1V0ZjgpKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHV0ZjgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHRva2VuIHN5bWJvbCcpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVlcnkgaWYgYSBjb250cmFjdCBpbXBsZW1lbnRzIGFuIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gQXNzZXQgY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gdXNlckFkZHJlc3MgLSBUaGUgcHVibGljIGFkZHJlc3MgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIHVzZXIncyBhY2NvdW50LlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBzdGFuZGFyZCwgZGVjaW1hbHMsIHN5bWJvbCBhbmQgYmFsYW5jZSBvZiB0aGUgZ2l2ZW4gY29udHJhY3QvdXNlckFkZHJlc3MgcGFpci5cbiAgICAgKi9cbiAgICBnZXREZXRhaWxzKGFkZHJlc3MsIHVzZXJBZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBbZGVjaW1hbHMsIHN5bWJvbF0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRUb2tlbkRlY2ltYWxzKGFkZHJlc3MpLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0VG9rZW5TeW1ib2woYWRkcmVzcyksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGxldCBiYWxhbmNlO1xuICAgICAgICAgICAgaWYgKHVzZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgYmFsYW5jZSA9IHlpZWxkIHRoaXMuZ2V0QmFsYW5jZU9mKGFkZHJlc3MsIHVzZXJBZGRyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgICAgIGJhbGFuY2UsXG4gICAgICAgICAgICAgICAgc3RhbmRhcmQ6IGNvbnN0YW50c18xLkVSQzIwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5FUkMyMFN0YW5kYXJkID0gRVJDMjBTdGFuZGFyZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVSQzIwU3RhbmRhcmQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIgPSBleHBvcnRzLkJOID0gdm9pZCAwO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQk5cIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGV0aGVyZXVtanNfdXRpbF8xLkJOOyB9IH0pO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIHRva2VuIGJhbGFuY2VzXG4gKiBmb3IgdG9rZW5zIHN0b3JlZCBpbiB0aGUgVG9rZW5zQ29udHJvbGxlclxuICovXG5jbGFzcyBUb2tlbkJhbGFuY2VzQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlbkJhbGFuY2VzQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblRva2Vuc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIGFzc2V0cyBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0U2VsZWN0ZWRBZGRyZXNzIC0gR2V0cyB0aGUgY3VycmVudCBzZWxlY3RlZCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEVSQzIwQmFsYW5jZU9mIC0gR2V0cyB0aGUgYmFsYW5jZSBvZiB0aGUgZ2l2ZW4gYWNjb3VudCBhdCB0aGUgZ2l2ZW4gY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBvblRva2Vuc1N0YXRlQ2hhbmdlLCBnZXRTZWxlY3RlZEFkZHJlc3MsIGdldEVSQzIwQmFsYW5jZU9mLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUb2tlbkJhbGFuY2VzQ29udHJvbGxlcic7XG4gICAgICAgIHRoaXMuZGVmYXVsdENvbmZpZyA9IHtcbiAgICAgICAgICAgIGludGVydmFsOiAxODAwMDAsXG4gICAgICAgICAgICB0b2tlbnM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHsgY29udHJhY3RCYWxhbmNlczoge30gfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIG9uVG9rZW5zU3RhdGVDaGFuZ2UoKHsgdG9rZW5zLCBkZXRlY3RlZFRva2VucyB9KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IHRva2VuczogWy4uLnRva2VucywgLi4uZGV0ZWN0ZWRUb2tlbnNdIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCYWxhbmNlcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEFkZHJlc3MgPSBnZXRTZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgIHRoaXMuZ2V0RVJDMjBCYWxhbmNlT2YgPSBnZXRFUkMyMEJhbGFuY2VPZjtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyB0b2tlbiBiYWxhbmNlcy5cbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLnVwZGF0ZUJhbGFuY2VzKCkpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvbGwodGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICAgICAgfSwgdGhpcy5jb25maWcuaW50ZXJ2YWwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBiYWxhbmNlcyBmb3IgYWxsIHRva2Vucy5cbiAgICAgKi9cbiAgICB1cGRhdGVCYWxhbmNlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgbmV3Q29udHJhY3RCYWxhbmNlcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIGluIHRva2Vucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYWRkcmVzcyB9ID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyYWN0QmFsYW5jZXNbYWRkcmVzc10gPSB5aWVsZCB0aGlzLmdldEVSQzIwQmFsYW5jZU9mKGFkZHJlc3MsIHRoaXMuZ2V0U2VsZWN0ZWRBZGRyZXNzKCkpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaV0uYmFsYW5jZUVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbnRyYWN0QmFsYW5jZXNbYWRkcmVzc10gPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oMCk7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXS5iYWxhbmNlRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGNvbnRyYWN0QmFsYW5jZXM6IG5ld0NvbnRyYWN0QmFsYW5jZXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIgPSBUb2tlbkJhbGFuY2VzQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRva2VuQmFsYW5jZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5CYWxhbmNlc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgREVGQVVMVF9JTlRFUlZBTCA9IDE4MDAwMDtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgVG9rZW5zIGF1dG8gZGV0ZWN0aW9uXG4gKi9cbmNsYXNzIFRva2VuRGV0ZWN0aW9uQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlbkRldGVjdGlvbkNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vblRva2VuTGlzdFN0YXRlQ2hhbmdlIC0gQWxsb3dzIHN1YnNjcmliaW5nIHRvIHRva2VuIGxpc3QgY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEJhbGFuY2VzSW5TaW5nbGVDYWxsIC0gR2V0cyB0aGUgYmFsYW5jZXMgb2YgYSBsaXN0IG9mIHRva2VucyBmb3IgdGhlIGdpdmVuIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYWRkRGV0ZWN0ZWRUb2tlbnMgLSBBZGQgYSBsaXN0IG9mIGRldGVjdGVkIHRva2Vucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRUb2tlbkxpc3RTdGF0ZSAtIEdldHMgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIFRva2VuTGlzdCBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldFRva2Vuc1N0YXRlIC0gR2V0cyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgVG9rZW5zIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0TmV0d29ya1N0YXRlIC0gR2V0cyB0aGUgc3RhdGUgb2YgdGhlIG5ldHdvcmsgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRQcmVmZXJlbmNlc1N0YXRlIC0gR2V0cyB0aGUgc3RhdGUgb2YgdGhlIHByZWZlcmVuY2VzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgb25Ub2tlbkxpc3RTdGF0ZUNoYW5nZSwgZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwsIGFkZERldGVjdGVkVG9rZW5zLCBnZXRUb2tlbkxpc3RTdGF0ZSwgZ2V0VG9rZW5zU3RhdGUsIGdldE5ldHdvcmtTdGF0ZSwgZ2V0UHJlZmVyZW5jZXNTdGF0ZSwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBjb25zdCB7IHByb3ZpZGVyOiB7IGNoYWluSWQ6IGRlZmF1bHRDaGFpbklkIH0sIH0gPSBnZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgY29uc3QgeyB1c2VUb2tlbkRldGVjdGlvbjogZGVmYXVsdFVzZVRva2VuRGV0ZWN0aW9uIH0gPSBnZXRQcmVmZXJlbmNlc1N0YXRlKCk7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUb2tlbkRldGVjdGlvbkNvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSBPYmplY3QuYXNzaWduKHsgaW50ZXJ2YWw6IERFRkFVTFRfSU5URVJWQUwsIHNlbGVjdGVkQWRkcmVzczogJycsIGRpc2FibGVkOiB0cnVlLCBjaGFpbklkOiBkZWZhdWx0Q2hhaW5JZCwgaXNEZXRlY3Rpb25FbmFibGVkRnJvbVByZWZlcmVuY2VzOiBkZWZhdWx0VXNlVG9rZW5EZXRlY3Rpb24sIGlzRGV0ZWN0aW9uRW5hYmxlZEZvck5ldHdvcms6ICgwLCB1dGlsXzEuaXNUb2tlbkRldGVjdGlvblN1cHBvcnRlZEZvck5ldHdvcmspKGRlZmF1bHRDaGFpbklkKSB9LCBjb25maWcpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5nZXRUb2tlbnNTdGF0ZSA9IGdldFRva2Vuc1N0YXRlO1xuICAgICAgICB0aGlzLmdldFRva2VuTGlzdFN0YXRlID0gZ2V0VG9rZW5MaXN0U3RhdGU7XG4gICAgICAgIHRoaXMuYWRkRGV0ZWN0ZWRUb2tlbnMgPSBhZGREZXRlY3RlZFRva2VucztcbiAgICAgICAgdGhpcy5nZXRCYWxhbmNlc0luU2luZ2xlQ2FsbCA9IGdldEJhbGFuY2VzSW5TaW5nbGVDYWxsO1xuICAgICAgICBvblRva2VuTGlzdFN0YXRlQ2hhbmdlKCh7IHRva2VuTGlzdCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoYXNUb2tlbnMgPSBPYmplY3Qua2V5cyh0b2tlbkxpc3QpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChoYXNUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVjdFRva2VucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlKCh7IHNlbGVjdGVkQWRkcmVzcywgdXNlVG9rZW5EZXRlY3Rpb24gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZEFkZHJlc3M6IGN1cnJlbnRTZWxlY3RlZEFkZHJlc3MsIGlzRGV0ZWN0aW9uRW5hYmxlZEZyb21QcmVmZXJlbmNlcywgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgaXNTZWxlY3RlZEFkZHJlc3NDaGFuZ2VkID0gc2VsZWN0ZWRBZGRyZXNzICE9PSBjdXJyZW50U2VsZWN0ZWRBZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgaXNEZXRlY3Rpb25DaGFuZ2VkRnJvbVByZWZlcmVuY2VzID0gaXNEZXRlY3Rpb25FbmFibGVkRnJvbVByZWZlcmVuY2VzICE9PSB1c2VUb2tlbkRldGVjdGlvbjtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICBpc0RldGVjdGlvbkVuYWJsZWRGcm9tUHJlZmVyZW5jZXM6IHVzZVRva2VuRGV0ZWN0aW9uLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHVzZVRva2VuRGV0ZWN0aW9uICYmXG4gICAgICAgICAgICAgICAgKGlzU2VsZWN0ZWRBZGRyZXNzQ2hhbmdlZCB8fCBpc0RldGVjdGlvbkNoYW5nZWRGcm9tUHJlZmVyZW5jZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RUb2tlbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyOiB7IGNoYWluSWQgfSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IGlzRGV0ZWN0aW9uRW5hYmxlZEZvck5ldHdvcmsgPSAoMCwgdXRpbF8xLmlzVG9rZW5EZXRlY3Rpb25TdXBwb3J0ZWRGb3JOZXR3b3JrKShjaGFpbklkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQ2hhaW5JZENoYW5nZWQgPSBjdXJyZW50Q2hhaW5JZCAhPT0gY2hhaW5JZDtcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIGlzRGV0ZWN0aW9uRW5hYmxlZEZvck5ldHdvcmssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpc0RldGVjdGlvbkVuYWJsZWRGb3JOZXR3b3JrICYmIGlzQ2hhaW5JZENoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRldGVjdFRva2VucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgcG9sbGluZyBmb3IgZGV0ZWN0ZWQgdG9rZW5zLlxuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBkaXNhYmxlZDogZmFsc2UgfSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCBwb2xsaW5nIGZvciBkZXRlY3RlZCB0b2tlbnMuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmUoeyBkaXNhYmxlZDogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICBzdG9wUG9sbGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gQW4gaW50ZXJ2YWwgb24gd2hpY2ggdG8gcG9sbC5cbiAgICAgKi9cbiAgICBzdGFydFBvbGxpbmcoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGludGVydmFsICYmIHRoaXMuY29uZmlndXJlKHsgaW50ZXJ2YWwgfSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZGV0ZWN0VG9rZW5zKCk7XG4gICAgICAgICAgICB0aGlzLmludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5kZXRlY3RUb2tlbnMoKTtcbiAgICAgICAgICAgIH0pLCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmlnZ2VycyBhc3NldCBFUkMyMCB0b2tlbiBhdXRvIGRldGVjdGlvbiBmb3IgZWFjaCBjb250cmFjdCBhZGRyZXNzIGluIGNvbnRyYWN0IG1ldGFkYXRhIG9uIG1haW5uZXQuXG4gICAgICovXG4gICAgZGV0ZWN0VG9rZW5zKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBkaXNhYmxlZCwgaXNEZXRlY3Rpb25FbmFibGVkRm9yTmV0d29yaywgaXNEZXRlY3Rpb25FbmFibGVkRnJvbVByZWZlcmVuY2VzLCB9ID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICBpZiAoZGlzYWJsZWQgfHxcbiAgICAgICAgICAgICAgICAhaXNEZXRlY3Rpb25FbmFibGVkRm9yTmV0d29yayB8fFxuICAgICAgICAgICAgICAgICFpc0RldGVjdGlvbkVuYWJsZWRGcm9tUHJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRva2VucyB9ID0gdGhpcy5nZXRUb2tlbnNTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5zQWRkcmVzc2VzID0gdG9rZW5zLm1hcChcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0Ki8gKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbkxpc3QgfSA9IHRoaXMuZ2V0VG9rZW5MaXN0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRva2Vuc1RvRGV0ZWN0ID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFkZHJlc3MgaW4gdG9rZW5MaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNBZGRyZXNzZXMuaW5jbHVkZXMoYWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9EZXRlY3QucHVzaChhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzbGljZU9mVG9rZW5zVG9EZXRlY3QgPSBbXTtcbiAgICAgICAgICAgIHNsaWNlT2ZUb2tlbnNUb0RldGVjdFswXSA9IHRva2Vuc1RvRGV0ZWN0LnNsaWNlKDAsIDEwMDApO1xuICAgICAgICAgICAgc2xpY2VPZlRva2Vuc1RvRGV0ZWN0WzFdID0gdG9rZW5zVG9EZXRlY3Quc2xpY2UoMTAwMCwgdG9rZW5zVG9EZXRlY3QubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRva2Vuc1NsaWNlIG9mIHNsaWNlT2ZUb2tlbnNUb0RldGVjdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbnNTbGljZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWxhbmNlcyA9IHlpZWxkIHRoaXMuZ2V0QmFsYW5jZXNJblNpbmdsZUNhbGwoc2VsZWN0ZWRBZGRyZXNzLCB0b2tlbnNTbGljZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2Vuc1RvQWRkID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdG9rZW5BZGRyZXNzIGluIGJhbGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaWdub3JlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGlnbm9yZWRUb2tlbnMgfSA9IHRoaXMuZ2V0VG9rZW5zU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkVG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlnbm9yZWQgPSBpZ25vcmVkVG9rZW5zLmZpbmQoKGlnbm9yZWRUb2tlbkFkZHJlc3MpID0+IGlnbm9yZWRUb2tlbkFkZHJlc3MgPT09ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKHRva2VuQWRkcmVzcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzZUluc2Vuc2l0aXZlVG9rZW5LZXkgPSBPYmplY3Qua2V5cyh0b2tlbkxpc3QpLmZpbmQoKGkpID0+IGkudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlnbm9yZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZGVjaW1hbHMsIHN5bWJvbCwgYWdncmVnYXRvcnMsIGljb25VcmwgfSA9IHRva2VuTGlzdFtjYXNlSW5zZW5zaXRpdmVUb2tlbktleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zVG9BZGQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRva2VuQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWdncmVnYXRvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpY29uVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0VSQzcyMTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1RvQWRkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5hZGREZXRlY3RlZFRva2Vucyh0b2tlbnNUb0FkZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyID0gVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5EZXRlY3Rpb25Db250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRva2VuTGlzdENvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgYWJvcnRfY29udHJvbGxlcl8xID0gcmVxdWlyZShcImFib3J0LWNvbnRyb2xsZXJcIik7XG5jb25zdCBCYXNlQ29udHJvbGxlclYyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJWMlwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgdG9rZW5fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2FwaXMvdG9rZW4tc2VydmljZVwiKTtcbmNvbnN0IGFzc2V0c1V0aWxfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0c1V0aWxcIik7XG5jb25zdCBERUZBVUxUX0lOVEVSVkFMID0gMjQgKiA2MCAqIDYwICogMTAwMDtcbmNvbnN0IERFRkFVTFRfVEhSRVNIT0xEID0gMjQgKiA2MCAqIDYwICogMTAwMDtcbmNvbnN0IG5hbWUgPSAnVG9rZW5MaXN0Q29udHJvbGxlcic7XG5jb25zdCBtZXRhZGF0YSA9IHtcbiAgICB0b2tlbkxpc3Q6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgdG9rZW5zQ2hhaW5zQ2FjaGU6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiB0cnVlIH0sXG4gICAgcHJldmVudFBvbGxpbmdPbk5ldHdvcmtSZXN0YXJ0OiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogdHJ1ZSB9LFxufTtcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICB0b2tlbkxpc3Q6IHt9LFxuICAgIHRva2Vuc0NoYWluc0NhY2hlOiB7fSxcbiAgICBwcmV2ZW50UG9sbGluZ09uTmV0d29ya1Jlc3RhcnQ6IGZhbHNlLFxufTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHBhc3NpdmVseSBwb2xscyBvbiBhIHNldCBpbnRlcnZhbCBmb3IgdGhlIGxpc3Qgb2YgdG9rZW5zIGZyb20gbWV0YXN3YXBzIGFwaVxuICovXG5jbGFzcyBUb2tlbkxpc3RDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJWMl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgVG9rZW5MaXN0Q29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIGNvbnRyb2xsZXIgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jaGFpbklkIC0gVGhlIGNoYWluIElEIG9mIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBIGZ1bmN0aW9uIGZvciByZWdpc3RlcmluZyBhbiBldmVudCBoYW5kbGVyIGZvciBuZXR3b3JrIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWwgLSBUaGUgcG9sbGluZyBpbnRlcnZhbCwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmNhY2hlUmVmcmVzaFRocmVzaG9sZCAtIFRoZSB0b2tlbiBjYWNoZSBleHBpcnkgdGltZSwgaW4gbWlsbGlzZWNvbmRzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIEEgcmVzdHJpY3RlZCBjb250cm9sbGVyIG1lc3Nlbmdlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmV2ZW50UG9sbGluZ09uTmV0d29ya1Jlc3RhcnQgLSBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gcHJldmVudCBwb2lsbGluZyBvbiBuZXR3b3JrIHJlc3RhcnQgaW4gZXh0ZW5zaW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCwgcHJldmVudFBvbGxpbmdPbk5ldHdvcmtSZXN0YXJ0ID0gZmFsc2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBpbnRlcnZhbCA9IERFRkFVTFRfSU5URVJWQUwsIGNhY2hlUmVmcmVzaFRocmVzaG9sZCA9IERFRkFVTFRfVEhSRVNIT0xELCBtZXNzZW5nZXIsIHN0YXRlLCB9KSB7XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICB0aGlzLmludGVydmFsRGVsYXkgPSBpbnRlcnZhbDtcbiAgICAgICAgdGhpcy5jYWNoZVJlZnJlc2hUaHJlc2hvbGQgPSBjYWNoZVJlZnJlc2hUaHJlc2hvbGQ7XG4gICAgICAgIHRoaXMuY2hhaW5JZCA9IGNoYWluSWQ7XG4gICAgICAgIHRoaXMudXBkYXRlUHJldmVudFBvbGxpbmdPbk5ldHdvcmtSZXN0YXJ0KHByZXZlbnRQb2xsaW5nT25OZXR3b3JrUmVzdGFydCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0X2NvbnRyb2xsZXJfMS5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKG5ldHdvcmtTdGF0ZSkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhaW5JZCAhPT0gbmV0d29ya1N0YXRlLnByb3ZpZGVyLmNoYWluSWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IGFib3J0X2NvbnRyb2xsZXJfMS5BYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoYWluSWQgPSBuZXR3b3JrU3RhdGUucHJvdmlkZXIuY2hhaW5JZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5wcmV2ZW50UG9sbGluZ09uTmV0d29ya1Jlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcmluZ1Rva2VuTGlzdERhdGEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB0b2tlbkxpc3QgaXMgcmVmZXJlbmNpbmcgZGF0YSBmcm9tIGNvcnJlY3QgbmV0d29ya1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlKSwgeyB0b2tlbkxpc3Q6ICgoX2EgPSB0aGlzLnN0YXRlLnRva2Vuc0NoYWluc0NhY2hlW3RoaXMuY2hhaW5JZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKSB8fCB7fSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdC5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxfMS5pc1Rva2VuTGlzdFN1cHBvcnRlZEZvck5ldHdvcmspKHRoaXMuY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN0YXJ0UG9sbGluZygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdGFydCBwb2xsaW5nIGZvciB0aGUgdG9rZW4gbGlzdC5cbiAgICAgKi9cbiAgICByZXN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zdGFydFBvbGxpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgcG9sbGluZyBmb3IgdGhlIHRva2VuIGxpc3QuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlIHRvIGRpc2NhcmQgdGhpcyBjb250cm9sbGVyLlxuICAgICAqXG4gICAgICogVGhpcyBzdG9wcyBhbnkgYWN0aXZlIHBvbGxpbmcuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgc3VwZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLnN0b3BQb2xsaW5nKCk7XG4gICAgfVxuICAgIHN0b3BQb2xsaW5nKCkge1xuICAgICAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICovXG4gICAgc3RhcnRQb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLmZldGNoVG9rZW5MaXN0KCkpO1xuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gdGhpcy5mZXRjaFRva2VuTGlzdCgpKTtcbiAgICAgICAgICAgIH0pLCB0aGlzLmludGVydmFsRGVsYXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hpbmcgdG9rZW4gbGlzdCBmcm9tIHRoZSBUb2tlbiBTZXJ2aWNlIEFQSS5cbiAgICAgKi9cbiAgICBmZXRjaFRva2VuTGlzdCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0b2tlbnNDaGFpbnNDYWNoZSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBsZXQgdG9rZW5MaXN0ID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkVG9rZW5zID0geWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLmZldGNoRnJvbUNhY2hlKCkpO1xuICAgICAgICAgICAgICAgIGlmIChjYWNoZWRUb2tlbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIG5vbi1leHBpcmVkIGNhY2hlZCB0b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5MaXN0ID0gT2JqZWN0LmFzc2lnbih7fSwgY2FjaGVkVG9rZW5zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIGZyZXNoIHRva2VuIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zRnJvbUFQSSA9IHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gKDAsIHRva2VuX3NlcnZpY2VfMS5mZXRjaFRva2VuTGlzdCkodGhpcy5jaGFpbklkLCB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWwpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2tlbnNGcm9tQVBJKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBleHBpcmVkIGNhY2hlZCB0b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuTGlzdCA9IE9iamVjdC5hc3NpZ24oe30sICgoKF9hID0gdG9rZW5zQ2hhaW5zQ2FjaGVbdGhpcy5jaGFpbklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpIHx8IHt9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZSksIHsgdG9rZW5MaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnNDaGFpbnNDYWNoZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpbHRlcmluZyBvdXQgdG9rZW5zIHdpdGggbGVzcyB0aGFuIDMgb2NjdXJyZW5jZXMgYW5kIG5hdGl2ZSB0b2tlbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRUb2tlbkxpc3QgPSB0b2tlbnNGcm9tQVBJLmZpbHRlcigodG9rZW4pID0+IHRva2VuLm9jY3VycmVuY2VzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5vY2N1cnJlbmNlcyA+PSAzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5hZGRyZXNzICE9PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92aW5nIHRoZSB0b2tlbnMgd2l0aCBzeW1ib2wgY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbHNMaXN0ID0gZmlsdGVyZWRUb2tlbkxpc3QubWFwKCh0b2tlbikgPT4gdG9rZW4uc3ltYm9sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHVwbGljYXRlU3ltYm9scyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5ldyBTZXQoc3ltYm9sc0xpc3QuZmlsdGVyKChzeW1ib2wsIGluZGV4KSA9PiBzeW1ib2xzTGlzdC5pbmRleE9mKHN5bWJvbCkgIT09IGluZGV4KSksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVuaXF1ZVRva2VuTGlzdCA9IGZpbHRlcmVkVG9rZW5MaXN0LmZpbHRlcigodG9rZW4pID0+ICFkdXBsaWNhdGVTeW1ib2xzLmluY2x1ZGVzKHRva2VuLnN5bWJvbCkpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRva2VuIG9mIHVuaXF1ZVRva2VuTGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkVG9rZW4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRva2VuKSwgeyBhZ2dyZWdhdG9yczogKDAsIGFzc2V0c1V0aWxfMS5mb3JtYXRBZ2dyZWdhdG9yTmFtZXMpKHRva2VuLmFnZ3JlZ2F0b3JzKSwgaWNvblVybDogKDAsIGFzc2V0c1V0aWxfMS5mb3JtYXRJY29uVXJsV2l0aFByb3h5KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY2hhaW5JZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiB0b2tlbi5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5MaXN0W3Rva2VuLmFkZHJlc3NdID0gZm9ybWF0dGVkVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRva2Vuc0NoYWluc0NhY2hlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0b2tlbnNDaGFpbnNDYWNoZSksIHsgW3RoaXMuY2hhaW5JZF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHRva2VuTGlzdCxcbiAgICAgICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCB7IHRva2VuTGlzdCwgdG9rZW5zQ2hhaW5zQ2FjaGU6IHVwZGF0ZWRUb2tlbnNDaGFpbnNDYWNoZSB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIENhY2hlIHRpbWVzdGFtcCBpcyB2YWxpZCxcbiAgICAgKiBpZiB5ZXMgZGF0YSBpbiBjYWNoZSB3aWxsIGJlIHJldHVybmVkXG4gICAgICogb3RoZXJ3aXNlIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjYWNoZWQgZGF0YSwgb3IgYG51bGxgIGlmIHRoZSBjYWNoZSB3YXMgZXhwaXJlZC5cbiAgICAgKi9cbiAgICBmZXRjaEZyb21DYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zQ2hhaW5zQ2FjaGUgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ2FjaGUgPSB0b2tlbnNDaGFpbnNDYWNoZVt0aGlzLmNoYWluSWRdO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmICgoZGF0YUNhY2hlID09PSBudWxsIHx8IGRhdGFDYWNoZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YUNhY2hlLmRhdGEpICYmXG4gICAgICAgICAgICAgICAgbm93IC0gKGRhdGFDYWNoZSA9PT0gbnVsbCB8fCBkYXRhQ2FjaGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGFDYWNoZS50aW1lc3RhbXApIDwgdGhpcy5jYWNoZVJlZnJlc2hUaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YUNhY2hlLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyaW5nIHRva2VuTGlzdCBhbmQgdG9rZW5zQ2hhaW5zQ2FjaGUgZXhwbGljaXRseS5cbiAgICAgKi9cbiAgICBjbGVhcmluZ1Rva2VuTGlzdERhdGEoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCB7IHRva2VuTGlzdDoge30sIHRva2Vuc0NoYWluc0NhY2hlOiB7fSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgcHJldmVudFBvbGxpbmdPbk5ldHdvcmtSZXN0YXJ0IGZyb20gZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNob3VsZFByZXZlbnRQb2xsaW5nIC0gRGV0ZXJtaW5lIHdoZXRoZXIgdG8gcHJldmVudCBwb2xsaW5nIG9uIG5ldHdvcmsgY2hhbmdlXG4gICAgICovXG4gICAgdXBkYXRlUHJldmVudFBvbGxpbmdPbk5ldHdvcmtSZXN0YXJ0KHNob3VsZFByZXZlbnRQb2xsaW5nKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCB7IHByZXZlbnRQb2xsaW5nT25OZXR3b3JrUmVzdGFydDogc2hvdWxkUHJldmVudFBvbGxpbmcgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5MaXN0Q29udHJvbGxlciA9IFRva2VuTGlzdENvbnRyb2xsZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBUb2tlbkxpc3RDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5MaXN0Q29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Ub2tlblJhdGVzQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbmNvbnN0IGNyeXB0b19jb21wYXJlXzEgPSByZXF1aXJlKFwiLi4vYXBpcy9jcnlwdG8tY29tcGFyZVwiKTtcbmNvbnN0IENvaW5HZWNrb0FwaSA9IHtcbiAgICBCQVNFX1VSTDogJ2h0dHBzOi8vYXBpLmNvaW5nZWNrby5jb20vYXBpL3YzJyxcbiAgICBnZXRUb2tlblByaWNlVVJMKGNoYWluU2x1ZywgcXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuQkFTRV9VUkx9L3NpbXBsZS90b2tlbl9wcmljZS8ke2NoYWluU2x1Z30/JHtxdWVyeX1gO1xuICAgIH0sXG4gICAgZ2V0UGxhdGZvcm1zVVJMKCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5CQVNFX1VSTH0vYXNzZXRfcGxhdGZvcm1zYDtcbiAgICB9LFxuICAgIGdldFN1cHBvcnRlZFZzQ3VycmVuY2llcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuQkFTRV9VUkx9L3NpbXBsZS9zdXBwb3J0ZWRfdnNfY3VycmVuY2llc2A7XG4gICAgfSxcbn07XG4vKipcbiAqIEZpbmRzIHRoZSBjaGFpbiBzbHVnIGluIHRoZSBkYXRhIGFycmF5IGdpdmVuIGEgY2hhaW5JZC5cbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIFRoZSBjdXJyZW50IGNoYWluIElELlxuICogQHBhcmFtIGRhdGEgLSBBIGxpc3QgcGxhdGZvcm1zIHN1cHBvcnRlZCBieSB0aGUgQ29pbkdlY2tvIEFQSS5cbiAqIEByZXR1cm5zIFRoZSBDb2luR2Vja28gc2x1ZyBmb3IgdGhlIGdpdmVuIGNoYWluIElELCBvciBgbnVsbGAgaWYgdGhlIHNsdWcgd2FzIG5vdCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gZmluZENoYWluU2x1ZyhjaGFpbklkLCBkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY2hhaW4gPSAoX2EgPSBkYXRhLmZpbmQoKHsgY2hhaW5faWRlbnRpZmllciB9KSA9PiBjaGFpbl9pZGVudGlmaWVyICE9PSBudWxsICYmIFN0cmluZyhjaGFpbl9pZGVudGlmaWVyKSA9PT0gY2hhaW5JZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgcmV0dXJuIChjaGFpbiA9PT0gbnVsbCB8fCBjaGFpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hhaW4uaWQpIHx8IG51bGw7XG59XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBwYXNzaXZlbHkgcG9sbHMgb24gYSBzZXQgaW50ZXJ2YWwgZm9yIHRva2VuLXRvLWZpYXQgZXhjaGFuZ2UgcmF0ZXNcbiAqIGZvciB0b2tlbnMgc3RvcmVkIGluIHRoZSBUb2tlbnNDb250cm9sbGVyXG4gKi9cbmNsYXNzIFRva2VuUmF0ZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFRva2VuUmF0ZXNDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uVG9rZW5zU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gdG9rZW4gY29udHJvbGxlciBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gY3VycmVuY3kgcmF0ZSBjb250cm9sbGVyIHN0YXRlIGNoYW5nZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMub25OZXR3b3JrU3RhdGVDaGFuZ2UgLSBBbGxvd3Mgc3Vic2NyaWJpbmcgdG8gbmV0d29yayBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IG9uVG9rZW5zU3RhdGVDaGFuZ2UsIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCB9LCBjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLnRva2VuTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLnN1cHBvcnRlZENoYWlucyA9IHtcbiAgICAgICAgICAgIHRpbWVzdGFtcDogMCxcbiAgICAgICAgICAgIGRhdGE6IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVnNDdXJyZW5jaWVzID0ge1xuICAgICAgICAgICAgdGltZXN0YW1wOiAwLFxuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuUmF0ZXNDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgZGlzYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICBpbnRlcnZhbDogMyAqIDYwICogMTAwMCxcbiAgICAgICAgICAgIG5hdGl2ZUN1cnJlbmN5OiAnZXRoJyxcbiAgICAgICAgICAgIGNoYWluSWQ6ICcnLFxuICAgICAgICAgICAgdG9rZW5zOiBbXSxcbiAgICAgICAgICAgIHRocmVzaG9sZDogNiAqIDYwICogNjAgKiAxMDAwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGRpc2FibGVkOiBmYWxzZSB9LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBvblRva2Vuc1N0YXRlQ2hhbmdlKCh7IHRva2VucywgZGV0ZWN0ZWRUb2tlbnMgfSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyB0b2tlbnM6IFsuLi50b2tlbnMsIC4uLmRldGVjdGVkVG9rZW5zXSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uQ3VycmVuY3lSYXRlU3RhdGVDaGFuZ2UoKGN1cnJlbmN5UmF0ZVN0YXRlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IG5hdGl2ZUN1cnJlbmN5OiBjdXJyZW5jeVJhdGVTdGF0ZS5uYXRpdmVDdXJyZW5jeSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCh7IHByb3ZpZGVyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30gfSk7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3VyZSh7IGNoYWluSWQgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyB0b2tlbiByYXRlcy5cbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IGNoYWluSWQuXG4gICAgICpcbiAgICAgKiBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCBhIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBfY2hhaW5JZCAtIFRoZSBjdXJyZW50IGNoYWluIElELlxuICAgICAqL1xuICAgIHNldCBjaGFpbklkKF9jaGFpbklkKSB7XG4gICAgICAgICF0aGlzLmRpc2FibGVkICYmICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gdGhpcy51cGRhdGVFeGNoYW5nZVJhdGVzKCkpO1xuICAgIH1cbiAgICBnZXQgY2hhaW5JZCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyB0b2tlbiBsaXN0IHRvIHRyYWNrIHByaWNlcy5cbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3aXRoIGEgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VucyAtIExpc3Qgb2YgdG9rZW5zIHRvIHRyYWNrIGV4Y2hhbmdlIHJhdGVzIGZvci5cbiAgICAgKi9cbiAgICBzZXQgdG9rZW5zKHRva2Vucykge1xuICAgICAgICB0aGlzLnRva2VuTGlzdCA9IHRva2VucztcbiAgICAgICAgIXRoaXMuZGlzYWJsZWQgJiYgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLnVwZGF0ZUV4Y2hhbmdlUmF0ZXMoKSk7XG4gICAgfVxuICAgIGdldCB0b2tlbnMoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvcGVydHkgb25seSB1c2VkIGZvciBzZXR0aW5nJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgYSBwYWlycyBvZiB0b2tlbiBhZGRyZXNzIGFuZCBuYXRpdmUgY3VycmVuY3kuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhaW5TbHVnIC0gQ2hhaW4gc3RyaW5nIGlkZW50aWZpZXIuXG4gICAgICogQHBhcmFtIHZzQ3VycmVuY3kgLSBRdWVyeSBhY2NvcmRpbmcgdG8gdG9rZW5zIGluIHRva2VuTGlzdCBhbmQgbmF0aXZlIGN1cnJlbmN5LlxuICAgICAqIEByZXR1cm5zIFRoZSBleGNoYW5nZSByYXRlcyBmb3IgdGhlIGdpdmVuIHBhaXJzLlxuICAgICAqL1xuICAgIGZldGNoRXhjaGFuZ2VSYXRlKGNoYWluU2x1ZywgdnNDdXJyZW5jeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdG9rZW5QYWlycyA9IHRoaXMudG9rZW5MaXN0Lm1hcCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MpLmpvaW4oJywnKTtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5ID0gYGNvbnRyYWN0X2FkZHJlc3Nlcz0ke3Rva2VuUGFpcnN9JnZzX2N1cnJlbmNpZXM9JHt2c0N1cnJlbmN5LnRvTG93ZXJDYXNlKCl9YDtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbF8xLmhhbmRsZUZldGNoKShDb2luR2Vja29BcGkuZ2V0VG9rZW5QcmljZVVSTChjaGFpblNsdWcsIHF1ZXJ5KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbmF0aXZlIGN1cnJlbmN5IGlzIGEgc3VwcG9ydGVkIHZzIGN1cnJlbmN5IHRvIHVzZVxuICAgICAqIHRvIHF1ZXJ5IGZvciB0b2tlbiBleGNoYW5nZSByYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYXRpdmVDdXJyZW5jeSAtIFRoZSBuYXRpdmUgY3VycmVuY3kgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgbmV0d29yay5cbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGl0J3MgYSBzdXBwb3J0ZWQgdnNDdXJyZW5jeS5cbiAgICAgKi9cbiAgICBjaGVja0lzU3VwcG9ydGVkVnNDdXJyZW5jeShuYXRpdmVDdXJyZW5jeSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0aHJlc2hvbGQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyB0aW1lc3RhbXAsIGRhdGEgfSA9IHRoaXMuc3VwcG9ydGVkVnNDdXJyZW5jaWVzO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aW1lc3RhbXAgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jaWVzID0geWllbGQgKDAsIHV0aWxfMS5oYW5kbGVGZXRjaCkoQ29pbkdlY2tvQXBpLmdldFN1cHBvcnRlZFZzQ3VycmVuY2llcygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRlZFZzQ3VycmVuY2llcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3VycmVuY2llcyxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbmNpZXMuaW5jbHVkZXMobmF0aXZlQ3VycmVuY3kudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YS5pbmNsdWRlcyhuYXRpdmVDdXJyZW5jeS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY3VycmVudCBjaGFpbiBJRCBzbHVnIGZyb20gY2FjaGVkIHN1cHBvcnRlZCBwbGF0Zm9ybXMgQ29pbkdlY2tvIEFQSSByZXNwb25zZS5cbiAgICAgKiBJZiBjYWNoZWQgc3VwcG9ydGVkIHBsYXRmb3JtcyByZXNwb25zZSBpcyBzdGFsZSwgZmV0Y2hlcyBhbmQgdXBkYXRlcyBpdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBDb2luR2Vja28gc2x1ZyBmb3IgdGhlIGN1cnJlbnQgY2hhaW4gSUQuXG4gICAgICovXG4gICAgZ2V0Q2hhaW5TbHVnKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0aHJlc2hvbGQsIGNoYWluSWQgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCB0aW1lc3RhbXAgfSA9IHRoaXMuc3VwcG9ydGVkQ2hhaW5zO1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgIGlmIChub3cgLSB0aW1lc3RhbXAgPiB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGF0Zm9ybXMgPSB5aWVsZCAoMCwgdXRpbF8xLmhhbmRsZUZldGNoKShDb2luR2Vja29BcGkuZ2V0UGxhdGZvcm1zVVJMKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3VwcG9ydGVkQ2hhaW5zID0ge1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwbGF0Zm9ybXMsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBmaW5kQ2hhaW5TbHVnKGNoYWluSWQsIHBsYXRmb3Jtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmluZENoYWluU2x1ZyhjaGFpbklkLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgZXhjaGFuZ2UgcmF0ZXMgZm9yIGFsbCB0b2tlbnMuXG4gICAgICovXG4gICAgdXBkYXRlRXhjaGFuZ2VSYXRlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRva2VuTGlzdC5sZW5ndGggPT09IDAgfHwgdGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNsdWcgPSB5aWVsZCB0aGlzLmdldENoYWluU2x1ZygpO1xuICAgICAgICAgICAgbGV0IG5ld0NvbnRyYWN0RXhjaGFuZ2VSYXRlcyA9IHt9O1xuICAgICAgICAgICAgaWYgKCFzbHVnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbkxpc3QuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKHRva2VuLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBuZXdDb250cmFjdEV4Y2hhbmdlUmF0ZXNbYWRkcmVzc10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5hdGl2ZUN1cnJlbmN5IH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgICAgICBuZXdDb250cmFjdEV4Y2hhbmdlUmF0ZXMgPSB5aWVsZCB0aGlzLmZldGNoQW5kTWFwRXhjaGFuZ2VSYXRlcyhuYXRpdmVDdXJyZW5jeSwgc2x1Zyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGNvbnRyYWN0RXhjaGFuZ2VSYXRlczogbmV3Q29udHJhY3RFeGNoYW5nZVJhdGVzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBhY3RpdmUgbmV0d29yaydzIG5hdGl2ZSBjdXJyZW5jeSBpcyBzdXBwb3J0ZWQgYnkgdGhlIGNvaW5nZWNrbyBBUEkuXG4gICAgICogSWYgc3VwcG9ydGVkLCBpdCBmZXRjaGVzIGFuZCBtYXBzIGNvbnRyYWN0RXhjaGFuZ2UgcmF0ZXMgdG8gYSBmb3JtYXQgdG8gYmUgY29uc3VtZWQgYnkgdGhlIFVJLlxuICAgICAqIElmIG5vdCBzdXBwb3J0ZWQsIGl0IGZldGNoZXMgY29udHJhY3RFeGNoYW5nZSByYXRlcyBhbmQgbWFwcyB0aGVtIGZyb20gdG9rZW4vZmFsbGJhY2stY3VycmVuY3lcbiAgICAgKiB0byB0b2tlbi9uYXRpdmVDdXJyZW5jeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYXRpdmVDdXJyZW5jeSAtIFRoZSBuYXRpdmUgY3VycmVuY3kgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gc2x1ZyAtIFRoZSB1bmlxdWUgc2x1ZyB1c2VkIHRvIGlkIHRoZSBjaGFpbiBieSB0aGUgY29pbmdlY2tvIGFwaVxuICAgICAqIHNob3VsZCBiZSB1c2VkIHRvIHF1ZXJ5IHRva2VuIGV4Y2hhbmdlIHJhdGVzLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGNvbnZlcnNpb24gcmF0ZXMgZm9yIGVhY2ggdG9rZW5cbiAgICAgKiByZWxhdGVkIHRvIHRoZSBuZXR3b3JrJ3MgbmF0aXZlIGN1cnJlbmN5LlxuICAgICAqL1xuICAgIGZldGNoQW5kTWFwRXhjaGFuZ2VSYXRlcyhuYXRpdmVDdXJyZW5jeSwgc2x1Zykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RFeGNoYW5nZVJhdGVzID0ge307XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBuYXRpdmUgY3VycmVuY3kgaXMgc3VwcG9ydGVkIGFzIGEgdnNfY3VycmVuY3kgYnkgdGhlIEFQSVxuICAgICAgICAgICAgY29uc3QgbmF0aXZlQ3VycmVuY3lTdXBwb3J0ZWQgPSB5aWVsZCB0aGlzLmNoZWNrSXNTdXBwb3J0ZWRWc0N1cnJlbmN5KG5hdGl2ZUN1cnJlbmN5KTtcbiAgICAgICAgICAgIGlmIChuYXRpdmVDdXJyZW5jeVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIHdlIGNhbiBkbyBhIHNpbXBsZSBmZXRjaCBhZ2FpbnN0IHRoZSBDb2luR2Vja28gQVBJXG4gICAgICAgICAgICAgICAgY29uc3QgcHJpY2VzID0geWllbGQgdGhpcy5mZXRjaEV4Y2hhbmdlUmF0ZShzbHVnLCBuYXRpdmVDdXJyZW5jeSk7XG4gICAgICAgICAgICAgICAgdGhpcy50b2tlbkxpc3QuZm9yRWFjaCgodG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJpY2UgPSBwcmljZXNbdG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RFeGNoYW5nZVJhdGVzWygwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKHRva2VuLmFkZHJlc3MpXSA9IHByaWNlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHByaWNlW25hdGl2ZUN1cnJlbmN5LnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBuYXRpdmUgY3VycmVuY3kgaXMgbm90IHN1cHBvcnRlZCB3ZSBuZWVkIHRvIHVzZSBhIGZhbGxiYWNrIHZzQ3VycmVuY3ksIGdldCB0aGUgZXhjaGFuZ2UgcmF0ZXNcbiAgICAgICAgICAgICAgICAvLyBpbiB0b2tlbi9mYWxsYmFjay1jdXJyZW5jeSBmb3JtYXQgYW5kIGNvbnZlcnQgdGhlbSB0byBleHBlY3RlZCB0b2tlbi9uYXRpdmVDdXJyZW5jeSBmb3JtYXQuXG4gICAgICAgICAgICAgICAgbGV0IHRva2VuRXhjaGFuZ2VSYXRlcztcbiAgICAgICAgICAgICAgICBsZXQgdnNDdXJyZW5jeVRvTmF0aXZlQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSA9IDA7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5FeGNoYW5nZVJhdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBjb252ZXJzaW9uUmF0ZTogdnNDdXJyZW5jeVRvTmF0aXZlQ3VycmVuY3lDb252ZXJzaW9uUmF0ZSB9LFxuICAgICAgICAgICAgICAgICAgICBdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaEV4Y2hhbmdlUmF0ZShzbHVnLCBjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kpLFxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIGNyeXB0b19jb21wYXJlXzEuZmV0Y2hFeGNoYW5nZVJhdGUpKG5hdGl2ZUN1cnJlbmN5LCBjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1ksIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnbWFya2V0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIGNvaW4gcGFpcicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW3Rva2VuQWRkcmVzcywgY29udmVyc2lvbl0gb2YgT2JqZWN0LmVudHJpZXModG9rZW5FeGNoYW5nZVJhdGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlblRvVnNDdXJyZW5jeUNvbnZlcnNpb25SYXRlID0gY29udmVyc2lvbltjb25zdGFudHNfMS5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kudG9Mb3dlckNhc2UoKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlc1soMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKSh0b2tlbkFkZHJlc3MpXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlblRvVnNDdXJyZW5jeUNvbnZlcnNpb25SYXRlICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2c0N1cnJlbmN5VG9OYXRpdmVDdXJyZW5jeUNvbnZlcnNpb25SYXRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdEV4Y2hhbmdlUmF0ZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuVG9rZW5SYXRlc0NvbnRyb2xsZXIgPSBUb2tlblJhdGVzQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFRva2VuUmF0ZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VG9rZW5SYXRlc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVG9rZW5zQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGNvbnRyYWN0X21ldGFkYXRhXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBtZXRhbWFzay9jb250cmFjdC1tZXRhZGF0YVwiKSk7XG5jb25zdCBtZXRhbWFza19ldGhfYWJpc18xID0gcmVxdWlyZShcIkBtZXRhbWFzay9tZXRhbWFzay1ldGgtYWJpc1wiKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgYXN5bmNfbXV0ZXhfMSA9IHJlcXVpcmUoXCJhc3luYy1tdXRleFwiKTtcbmNvbnN0IGV0aGVyc18xID0gcmVxdWlyZShcImV0aGVyc1wiKTtcbmNvbnN0IGFib3J0X2NvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCJhYm9ydC1jb250cm9sbGVyXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgdG9rZW5fc2VydmljZV8xID0gcmVxdWlyZShcIi4uL2FwaXMvdG9rZW4tc2VydmljZVwiKTtcbmNvbnN0IGFzc2V0c1V0aWxfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0c1V0aWxcIik7XG52YXIgU3VnZ2VzdGVkQXNzZXRTdGF0dXM7XG4oZnVuY3Rpb24gKFN1Z2dlc3RlZEFzc2V0U3RhdHVzKSB7XG4gICAgU3VnZ2VzdGVkQXNzZXRTdGF0dXNbXCJhY2NlcHRlZFwiXSA9IFwiYWNjZXB0ZWRcIjtcbiAgICBTdWdnZXN0ZWRBc3NldFN0YXR1c1tcImZhaWxlZFwiXSA9IFwiZmFpbGVkXCI7XG4gICAgU3VnZ2VzdGVkQXNzZXRTdGF0dXNbXCJwZW5kaW5nXCJdID0gXCJwZW5kaW5nXCI7XG4gICAgU3VnZ2VzdGVkQXNzZXRTdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbn0pKFN1Z2dlc3RlZEFzc2V0U3RhdHVzIHx8IChTdWdnZXN0ZWRBc3NldFN0YXR1cyA9IHt9KSk7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBzdG9yZXMgYXNzZXRzIGFuZCBleHBvc2VzIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqL1xuY2xhc3MgVG9rZW5zQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUb2tlbnNDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm9uUHJlZmVyZW5jZXNTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBwcmVmZXJlbmNlIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgb25QcmVmZXJlbmNlc1N0YXRlQ2hhbmdlLCBvbk5ldHdvcmtTdGF0ZUNoYW5nZSwgY29uZmlnLCBzdGF0ZSwgfSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgRUlQNzQ3IGV2ZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5odWIgPSBuZXcgZXZlbnRzXzEuRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2Vuc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRDb25maWcgPSBPYmplY3QuYXNzaWduKHsgbmV0d29ya1R5cGU6IGNvbnN0YW50c18xLk1BSU5ORVQsIHNlbGVjdGVkQWRkcmVzczogJycsIGNoYWluSWQ6ICcnLCBwcm92aWRlcjogdW5kZWZpbmVkIH0sIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdFN0YXRlID0gT2JqZWN0LmFzc2lnbih7IHRva2VuczogW10sIGlnbm9yZWRUb2tlbnM6IFtdLCBkZXRlY3RlZFRva2VuczogW10sIGFsbFRva2Vuczoge30sIGFsbElnbm9yZWRUb2tlbnM6IHt9LCBhbGxEZXRlY3RlZFRva2Vuczoge30sIHN1Z2dlc3RlZEFzc2V0czogW10gfSwgc3RhdGUpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRfY29udHJvbGxlcl8xLkFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBvblByZWZlcmVuY2VzU3RhdGVDaGFuZ2UoKHsgc2VsZWN0ZWRBZGRyZXNzIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgY29uc3QgeyBhbGxUb2tlbnMsIGFsbElnbm9yZWRUb2tlbnMsIGFsbERldGVjdGVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIHRoaXMuY29uZmlndXJlKHsgc2VsZWN0ZWRBZGRyZXNzIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHRva2VuczogKChfYSA9IGFsbFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6ICgoX2IgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Jbc2VsZWN0ZWRBZGRyZXNzXSkgfHwgW10sXG4gICAgICAgICAgICAgICAgZGV0ZWN0ZWRUb2tlbnM6ICgoX2MgPSBhbGxEZXRlY3RlZFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbk5ldHdvcmtTdGF0ZUNoYW5nZSgoeyBwcm92aWRlciB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHsgYWxsVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zLCBhbGxEZXRlY3RlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZCB9ID0gcHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgYWJvcnRfY29udHJvbGxlcl8xLkFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgdGhpcy5jb25maWd1cmUoeyBjaGFpbklkIH0pO1xuICAgICAgICAgICAgdGhpcy5ldGhlcnNQcm92aWRlciA9IHRoaXMuX2luc3RhbnRpYXRlTmV3RXRoZXJzUHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICB0b2tlbnM6ICgoX2EgPSBhbGxUb2tlbnNbY2hhaW5JZF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtzZWxlY3RlZEFkZHJlc3NdKSB8fCBbXSxcbiAgICAgICAgICAgICAgICBpZ25vcmVkVG9rZW5zOiAoKF9iID0gYWxsSWdub3JlZFRva2Vuc1tjaGFpbklkXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3NlbGVjdGVkQWRkcmVzc10pIHx8IFtdLFxuICAgICAgICAgICAgICAgIGRldGVjdGVkVG9rZW5zOiAoKF9jID0gYWxsRGV0ZWN0ZWRUb2tlbnNbY2hhaW5JZF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tzZWxlY3RlZEFkZHJlc3NdKSB8fCBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmFpbFN1Z2dlc3RlZEFzc2V0KHN1Z2dlc3RlZEFzc2V0TWV0YSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZmFpbGVkU3VnZ2VzdGVkQXNzZXRNZXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdWdnZXN0ZWRBc3NldE1ldGEpLCB7IHN0YXR1czogU3VnZ2VzdGVkQXNzZXRTdGF0dXMuZmFpbGVkLCBlcnJvciB9KTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHtzdWdnZXN0ZWRBc3NldE1ldGEuaWR9OmZpbmlzaGVkYCwgZmFpbGVkU3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2ggbWV0YWRhdGEgZm9yIGEgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdG9rZW5BZGRyZXNzIC0gVGhlIGFkZHJlc3Mgb2YgdGhlIHRva2VuLlxuICAgICAqIEByZXR1cm5zIFRoZSB0b2tlbiBtZXRhZGF0YS5cbiAgICAgKi9cbiAgICBmZXRjaFRva2VuTWV0YWRhdGEodG9rZW5BZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuID0geWllbGQgKDAsIHRva2VuX3NlcnZpY2VfMS5mZXRjaFRva2VuTWV0YWRhdGEpKHRoaXMuY29uZmlnLmNoYWluSWQsIHRva2VuQWRkcmVzcywgdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKHRva2VuX3NlcnZpY2VfMS5UT0tFTl9NRVRBREFUQV9OT19TVVBQT1JUX0VSUk9SKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9pbnN0YW50aWF0ZU5ld0V0aGVyc1Byb3ZpZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBuZXcgZXRoZXJzXzEuZXRoZXJzLnByb3ZpZGVycy5XZWIzUHJvdmlkZXIoKF9hID0gdGhpcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm92aWRlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSB0b2tlbiB0byB0aGUgc3RvcmVkIHRva2VuIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEhleCBhZGRyZXNzIG9mIHRoZSB0b2tlbiBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gc3ltYm9sIC0gU3ltYm9sIG9mIHRoZSB0b2tlbi5cbiAgICAgKiBAcGFyYW0gZGVjaW1hbHMgLSBOdW1iZXIgb2YgZGVjaW1hbHMgdGhlIHRva2VuIHVzZXMuXG4gICAgICogQHBhcmFtIGltYWdlIC0gSW1hZ2Ugb2YgdGhlIHRva2VuLlxuICAgICAqIEByZXR1cm5zIEN1cnJlbnQgdG9rZW4gbGlzdC5cbiAgICAgKi9cbiAgICBhZGRUb2tlbihhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzLCBpbWFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENoYWluSWQgPSB0aGlzLmNvbmZpZy5jaGFpbklkO1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zLCBpZ25vcmVkVG9rZW5zLCBkZXRlY3RlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUb2tlbnMgPSBbLi4udG9rZW5zXTtcbiAgICAgICAgICAgICAgICBjb25zdCBbaXNFUkM3MjEsIHRva2VuTWV0YWRhdGFdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kZXRlY3RJc0VSQzcyMShhZGRyZXNzKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZXRjaFRva2VuTWV0YWRhdGEoYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDaGFpbklkICE9PSB0aGlzLmNvbmZpZy5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVG9rZW5zQ29udHJvbGxlciBFcnJvcjogU3dpdGNoZWQgbmV0d29ya3Mgd2hpbGUgYWRkaW5nIHRva2VuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBhc3NldHNVdGlsXzEuZm9ybWF0SWNvblVybFdpdGhQcm94eSkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHRoaXMuY29uZmlnLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGlzRVJDNzIxLFxuICAgICAgICAgICAgICAgICAgICBhZ2dyZWdhdG9yczogKDAsIGFzc2V0c1V0aWxfMS5mb3JtYXRBZ2dyZWdhdG9yTmFtZXMpKCh0b2tlbk1ldGFkYXRhID09PSBudWxsIHx8IHRva2VuTWV0YWRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuTWV0YWRhdGEuYWdncmVnYXRvcnMpIHx8IFtdKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRW50cnkgPSBuZXdUb2tlbnMuZmluZCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0luZGV4ID0gbmV3VG9rZW5zLmluZGV4T2YocHJldmlvdXNFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Rva2Vuc1twcmV2aW91c0luZGV4XSA9IG5ld0VudHJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG9rZW5zLnB1c2gobmV3RW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJZ25vcmVkVG9rZW5zID0gaWdub3JlZFRva2Vucy5maWx0ZXIoKHRva2VuQWRkcmVzcykgPT4gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGV0ZWN0ZWRUb2tlbnMgPSBkZXRlY3RlZFRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiB0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgIT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBuZXdBbGxUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMsIG5ld0FsbERldGVjdGVkVG9rZW5zIH0gPSB0aGlzLl9nZXROZXdBbGxUb2tlbnNTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgbmV3RGV0ZWN0ZWRUb2tlbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnM6IG5ld1Rva2VucyxcbiAgICAgICAgICAgICAgICAgICAgaWdub3JlZFRva2VuczogbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRUb2tlbnM6IG5ld0RldGVjdGVkVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgYWxsSWdub3JlZFRva2VuczogbmV3QWxsSWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgYWxsRGV0ZWN0ZWRUb2tlbnM6IG5ld0FsbERldGVjdGVkVG9rZW5zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdUb2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgYmF0Y2ggb2YgdG9rZW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2Vuc1RvSW1wb3J0IC0gQXJyYXkgb2YgdG9rZW5zIHRvIGltcG9ydC5cbiAgICAgKi9cbiAgICBhZGRUb2tlbnModG9rZW5zVG9JbXBvcnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VMb2NrID0geWllbGQgdGhpcy5tdXRleC5hY3F1aXJlKCk7XG4gICAgICAgICAgICBjb25zdCB7IHRva2VucywgZGV0ZWN0ZWRUb2tlbnMsIGlnbm9yZWRUb2tlbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpbXBvcnRlZFRva2Vuc01hcCA9IHt9O1xuICAgICAgICAgICAgLy8gVXNlZCBsYXRlciB0byBkZWR1cGUgaW1wb3J0ZWQgdG9rZW5zXG4gICAgICAgICAgICBjb25zdCBuZXdUb2tlbnNNYXAgPSB0b2tlbnMucmVkdWNlKChvdXRwdXQsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbY3VycmVudC5hZGRyZXNzXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdG9rZW5zVG9JbXBvcnQuZm9yRWFjaCgodG9rZW5Ub0FkZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlLCBhZ2dyZWdhdG9ycyB9ID0gdG9rZW5Ub0FkZDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2tzdW1BZGRyZXNzID0gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFRva2VuID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogY2hlY2tzdW1BZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjaW1hbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0b3JzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBuZXdUb2tlbnNNYXBbYWRkcmVzc10gPSBmb3JtYXR0ZWRUb2tlbjtcbiAgICAgICAgICAgICAgICAgICAgaW1wb3J0ZWRUb2tlbnNNYXBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZWRUb2tlbjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUb2tlbnMgPSBPYmplY3QudmFsdWVzKG5ld1Rva2Vuc01hcCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGV0ZWN0ZWRUb2tlbnMgPSBkZXRlY3RlZFRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiAhaW1wb3J0ZWRUb2tlbnNNYXBbdG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SWdub3JlZFRva2VucyA9IGlnbm9yZWRUb2tlbnMuZmlsdGVyKCh0b2tlbkFkZHJlc3MpID0+ICFuZXdUb2tlbnNNYXBbdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5ld0FsbFRva2VucywgbmV3QWxsRGV0ZWN0ZWRUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMgfSA9IHRoaXMuX2dldE5ld0FsbFRva2Vuc1N0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV3VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBuZXdEZXRlY3RlZFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgbmV3SWdub3JlZFRva2VucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuczogbmV3VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWRUb2tlbnM6IG5ld0RldGVjdGVkVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBhbGxEZXRlY3RlZFRva2VuczogbmV3QWxsRGV0ZWN0ZWRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6IG5ld0lnbm9yZWRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIGFsbElnbm9yZWRUb2tlbnM6IG5ld0FsbElnbm9yZWRUb2tlbnMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWdub3JlIGEgYmF0Y2ggb2YgdG9rZW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuQWRkcmVzc2VzVG9JZ25vcmUgLSBBcnJheSBvZiB0b2tlbiBhZGRyZXNzZXMgdG8gaWdub3JlLlxuICAgICAqL1xuICAgIGlnbm9yZVRva2Vucyh0b2tlbkFkZHJlc3Nlc1RvSWdub3JlKSB7XG4gICAgICAgIGNvbnN0IHsgaWdub3JlZFRva2VucywgZGV0ZWN0ZWRUb2tlbnMsIHRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaWdub3JlZFRva2Vuc01hcCA9IHt9O1xuICAgICAgICBsZXQgbmV3SWdub3JlZFRva2VucyA9IFsuLi5pZ25vcmVkVG9rZW5zXTtcbiAgICAgICAgY29uc3QgY2hlY2tzdW1tZWRUb2tlbkFkZHJlc3NlcyA9IHRva2VuQWRkcmVzc2VzVG9JZ25vcmUubWFwKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bUFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgICAgIGlnbm9yZWRUb2tlbnNNYXBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpXSA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tzdW1BZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICAgICAgbmV3SWdub3JlZFRva2VucyA9IFsuLi5pZ25vcmVkVG9rZW5zLCAuLi5jaGVja3N1bW1lZFRva2VuQWRkcmVzc2VzXTtcbiAgICAgICAgY29uc3QgbmV3RGV0ZWN0ZWRUb2tlbnMgPSBkZXRlY3RlZFRva2Vucy5maWx0ZXIoKHRva2VuKSA9PiAhaWdub3JlZFRva2Vuc01hcFt0b2tlbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCldKTtcbiAgICAgICAgY29uc3QgbmV3VG9rZW5zID0gdG9rZW5zLmZpbHRlcigodG9rZW4pID0+ICFpZ25vcmVkVG9rZW5zTWFwW3Rva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKV0pO1xuICAgICAgICBjb25zdCB7IG5ld0FsbElnbm9yZWRUb2tlbnMsIG5ld0FsbERldGVjdGVkVG9rZW5zLCBuZXdBbGxUb2tlbnMgfSA9IHRoaXMuX2dldE5ld0FsbFRva2Vuc1N0YXRlKHtcbiAgICAgICAgICAgIG5ld0lnbm9yZWRUb2tlbnMsXG4gICAgICAgICAgICBuZXdEZXRlY3RlZFRva2VucyxcbiAgICAgICAgICAgIG5ld1Rva2VucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGlnbm9yZWRUb2tlbnM6IG5ld0lnbm9yZWRUb2tlbnMsXG4gICAgICAgICAgICB0b2tlbnM6IG5ld1Rva2VucyxcbiAgICAgICAgICAgIGRldGVjdGVkVG9rZW5zOiBuZXdEZXRlY3RlZFRva2VucyxcbiAgICAgICAgICAgIGFsbElnbm9yZWRUb2tlbnM6IG5ld0FsbElnbm9yZWRUb2tlbnMsXG4gICAgICAgICAgICBhbGxEZXRlY3RlZFRva2VuczogbmV3QWxsRGV0ZWN0ZWRUb2tlbnMsXG4gICAgICAgICAgICBhbGxUb2tlbnM6IG5ld0FsbFRva2VucyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBiYXRjaCBvZiBkZXRlY3RlZCB0b2tlbnMgdG8gdGhlIHN0b3JlZCB0b2tlbiBsaXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGluY29taW5nRGV0ZWN0ZWRUb2tlbnMgLSBBcnJheSBvZiBkZXRlY3RlZCB0b2tlbnMgdG8gYmUgYWRkZWQgb3IgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBhZGREZXRlY3RlZFRva2VucyhpbmNvbWluZ0RldGVjdGVkVG9rZW5zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgY29uc3QgeyB0b2tlbnMsIGRldGVjdGVkVG9rZW5zLCBpZ25vcmVkVG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgbmV3VG9rZW5zID0gWy4uLnRva2Vuc107XG4gICAgICAgICAgICBjb25zdCBuZXdEZXRlY3RlZFRva2VucyA9IFsuLi5kZXRlY3RlZFRva2Vuc107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGluY29taW5nRGV0ZWN0ZWRUb2tlbnMuZm9yRWFjaCgodG9rZW5Ub0FkZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlLCBhZ2dyZWdhdG9ycywgaXNFUkM3MjEgfSA9IHRva2VuVG9BZGQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtQWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdFbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNoZWNrc3VtQWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY2ltYWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VSQzcyMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFnZ3JlZ2F0b3JzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0ltcG9ydGVkRW50cnkgPSBuZXdUb2tlbnMuZmluZCgodG9rZW4pID0+IHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gY2hlY2tzdW1BZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNJbXBvcnRlZEVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgZGF0YSBvZiBpbXBvcnRlZCB0b2tlblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNJbXBvcnRlZEluZGV4ID0gbmV3VG9rZW5zLmluZGV4T2YocHJldmlvdXNJbXBvcnRlZEVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Rva2Vuc1twcmV2aW91c0ltcG9ydGVkSW5kZXhdID0gbmV3RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVkVG9rZW5JbmRleCA9IGlnbm9yZWRUb2tlbnMuaW5kZXhPZihhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVkVG9rZW5JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZGV0ZWN0ZWQgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0RldGVjdGVkRW50cnkgPSBuZXdEZXRlY3RlZFRva2Vucy5maW5kKCh0b2tlbikgPT4gdG9rZW4uYWRkcmVzcy50b0xvd2VyQ2FzZSgpID09PSBjaGVja3N1bUFkZHJlc3MudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzRGV0ZWN0ZWRFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0RldGVjdGVkSW5kZXggPSBuZXdEZXRlY3RlZFRva2Vucy5pbmRleE9mKHByZXZpb3VzRGV0ZWN0ZWRFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RldGVjdGVkVG9rZW5zW3ByZXZpb3VzRGV0ZWN0ZWRJbmRleF0gPSBuZXdFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0RldGVjdGVkVG9rZW5zLnB1c2gobmV3RW50cnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbmV3QWxsVG9rZW5zLCBuZXdBbGxEZXRlY3RlZFRva2VucyB9ID0gdGhpcy5fZ2V0TmV3QWxsVG9rZW5zU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBuZXdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIG5ld0RldGVjdGVkVG9rZW5zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zOiBuZXdUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIGFsbFRva2VuczogbmV3QWxsVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBkZXRlY3RlZFRva2VuczogbmV3RGV0ZWN0ZWRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIGFsbERldGVjdGVkVG9rZW5zOiBuZXdBbGxEZXRlY3RlZFRva2VucyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGlzRVJDNzIxIGZpZWxkIHRvIHRva2VuIG9iamVjdC4gVGhpcyBpcyBjYWxsZWQgd2hlbiBhIHVzZXIgYXR0ZW1wdHMgdG8gYWRkIHRva2VucyB0aGF0XG4gICAgICogd2VyZSBwcmV2aW91c2x5IGFkZGVkIHdoaWNoIGRvIG5vdCB5ZXQgaGFkIGlzRVJDNzIxIGZpZWxkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuQWRkcmVzcyAtIFRoZSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSB0b2tlbiByZXF1aXJpbmcgdGhlIGlzRVJDNzIxIGZpZWxkIGFkZGVkLlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgdG9rZW4gb2JqZWN0IHdpdGggdGhlIGFkZGVkIGlzRVJDNzIxIGZpZWxkLlxuICAgICAqL1xuICAgIHVwZGF0ZVRva2VuVHlwZSh0b2tlbkFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzRVJDNzIxID0geWllbGQgdGhpcy5fZGV0ZWN0SXNFUkM3MjEodG9rZW5BZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW5zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgdG9rZW5JbmRleCA9IHRva2Vucy5maW5kSW5kZXgoKHRva2VuKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmFkZHJlc3MudG9Mb3dlckNhc2UoKSA9PT0gdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbkluZGV4XS5pc0VSQzcyMSA9IGlzRVJDNzIxO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyB0b2tlbnMgfSk7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zW3Rva2VuSW5kZXhdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZWN0cyB3aGV0aGVyIG9yIG5vdCBhIHRva2VuIGlzIEVSQy03MjEgY29tcGF0aWJsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlbkFkZHJlc3MgLSBUaGUgdG9rZW4gY29udHJhY3QgYWRkcmVzcy5cbiAgICAgKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSB0b2tlbiBhZGRyZXNzIHBhc3NlZCBpbiBzdXBwb3J0cyB0aGUgRUlQLTcyMVxuICAgICAqIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBfZGV0ZWN0SXNFUkM3MjEodG9rZW5BZGRyZXNzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bUFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKSh0b2tlbkFkZHJlc3MpO1xuICAgICAgICAgICAgLy8gaWYgdGhpcyB0b2tlbiBpcyBhbHJlYWR5IGluIG91ciBjb250cmFjdCBtZXRhZGF0YSBtYXAgd2UgZG9uJ3QgbmVlZFxuICAgICAgICAgICAgLy8gdG8gY2hlY2sgYWdhaW5zdCB0aGUgY29udHJhY3RcbiAgICAgICAgICAgIGlmICgoKF9hID0gY29udHJhY3RfbWV0YWRhdGFfMS5kZWZhdWx0W2NoZWNrc3VtQWRkcmVzc10pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcmM3MjEpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCgoX2IgPSBjb250cmFjdF9tZXRhZGF0YV8xLmRlZmF1bHRbY2hlY2tzdW1BZGRyZXNzXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmVyYzIwKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdG9rZW5Db250cmFjdCA9IHlpZWxkIHRoaXMuX2NyZWF0ZUV0aGVyc0NvbnRyYWN0KHRva2VuQWRkcmVzcywgbWV0YW1hc2tfZXRoX2FiaXNfMS5hYmlFUkM3MjEsIHRoaXMuZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdG9rZW5Db250cmFjdC5zdXBwb3J0c0ludGVyZmFjZShjb25zdGFudHNfMS5FUkM3MjFfSU5URVJGQUNFX0lEKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSB3ZSBzZWUgYSB2YXJpZXR5IG9mIGVycm9ycyBhY3Jvc3MgZGlmZmVyZW50IG5ldHdvcmtzIHdoZW5cbiAgICAgICAgICAgICAgICAvLyB0b2tlbiBjb250cmFjdHMgYXJlIG5vdCBFUkM3MjEgY29tcGF0aWJsZS4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGEgYmV0dGVyXG4gICAgICAgICAgICAgICAgLy8gd2F5IG9mIGRpZmZlcmVudGlhdGluZyB0b2tlbiBpbnRlcmZhY2UgdHlwZXMgYnV0IGZvciBub3cgaWYgd2UgZ2V0IGFuIGVycm9yXG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBhc3N1bWUgdGhlIHRva2VuIGlzIG5vdCBFUkM3MjEgY29tcGF0aWJsZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfY3JlYXRlRXRoZXJzQ29udHJhY3QodG9rZW5BZGRyZXNzLCBhYmksIGV0aGVyc1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbkNvbnRyYWN0ID0geWllbGQgbmV3IGV0aGVyc18xLmV0aGVycy5Db250cmFjdCh0b2tlbkFkZHJlc3MsIGFiaSwgZXRoZXJzUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuQ29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2VuZXJhdGVSYW5kb21JZCgpIHtcbiAgICAgICAgcmV0dXJuICgwLCB1dWlkXzEudjEpKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgc3VnZ2VzdGVkQXNzZXQgdG8gc3RhdGUuIFBhcmFtZXRlcnMgd2lsbCBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvXG4gICAgICogYXNzZXQgdHlwZSBiZWluZyB3YXRjaGVkLiBBIGA8c3VnZ2VzdGVkQXNzZXRNZXRhLmlkPjpwZW5kaW5nYCBodWIgZXZlbnQgd2lsbCBiZSBlbWl0dGVkIG9uY2UgYWRkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXNzZXQgLSBUaGUgYXNzZXQgdG8gYmUgd2F0Y2hlZC4gRm9yIG5vdyBvbmx5IEVSQzIwIHRva2VucyBhcmUgYWNjZXB0ZWQuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgYXNzZXQgdHlwZS5cbiAgICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBhIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSBzdWdnZXN0ZWRBc3NldCBhZGRyZXNzIGlmIGFjY2VwdGVkLlxuICAgICAqL1xuICAgIHdhdGNoQXNzZXQoYXNzZXQsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1Z2dlc3RlZEFzc2V0TWV0YSA9IHtcbiAgICAgICAgICAgICAgICBhc3NldCxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5fZ2VuZXJhdGVSYW5kb21JZCgpLFxuICAgICAgICAgICAgICAgIHN0YXR1czogU3VnZ2VzdGVkQXNzZXRTdGF0dXMucGVuZGluZyxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRVJDMjAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZVRva2VuVG9XYXRjaCkoYXNzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzc2V0IG9mIHR5cGUgJHt0eXBlfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsU3VnZ2VzdGVkQXNzZXQoc3VnZ2VzdGVkQXNzZXRNZXRhLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmh1Yi5vbmNlKGAke3N1Z2dlc3RlZEFzc2V0TWV0YS5pZH06ZmluaXNoZWRgLCAobWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1ldGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmFjY2VwdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG1ldGEuYXNzZXQuYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN1Z2dlc3RlZEFzc2V0U3RhdHVzLnJlamVjdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdVc2VyIHJlamVjdGVkIHRvIHdhdGNoIHRoZSBhc3NldC4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFN1Z2dlc3RlZEFzc2V0U3RhdHVzLmZhaWxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihtZXRhLmVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBVbmtub3duIHN0YXR1czogJHttZXRhLnN0YXR1c31gKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBzdWdnZXN0ZWRBc3NldHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBzdWdnZXN0ZWRBc3NldHMucHVzaChzdWdnZXN0ZWRBc3NldE1ldGEpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzdWdnZXN0ZWRBc3NldHM6IFsuLi5zdWdnZXN0ZWRBc3NldHNdIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdCgncGVuZGluZ1N1Z2dlc3RlZEFzc2V0Jywgc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdCwgc3VnZ2VzdGVkQXNzZXRNZXRhIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIHRvIHdhdGNoIGFuIGFzc2V0IGFuZCB1cGRhdGVzIGl0J3Mgc3RhdHVzIGFuZCBkZWxldGVzIHRoZSBzdWdnZXN0ZWRBc3NldCBmcm9tIHN0YXRlLFxuICAgICAqIGFkZGluZyB0aGUgYXNzZXQgdG8gY29ycmVzcG9uZGluZyBhc3NldCBzdGF0ZS4gSW4gdGhpcyBjYXNlIEVSQzIwIHRva2Vucy5cbiAgICAgKiBBIGA8c3VnZ2VzdGVkQXNzZXRNZXRhLmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50IGlzIGZpcmVkIGFmdGVyIGFjY2VwdGVkIG9yIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3VnZ2VzdGVkQXNzZXRJRCAtIFRoZSBJRCBvZiB0aGUgc3VnZ2VzdGVkQXNzZXQgdG8gYWNjZXB0LlxuICAgICAqL1xuICAgIGFjY2VwdFdhdGNoQXNzZXQoc3VnZ2VzdGVkQXNzZXRJRCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBzdWdnZXN0ZWRBc3NldHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHN1Z2dlc3RlZEFzc2V0cy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gc3VnZ2VzdGVkQXNzZXRJRCA9PT0gaWQpO1xuICAgICAgICAgICAgY29uc3Qgc3VnZ2VzdGVkQXNzZXRNZXRhID0gc3VnZ2VzdGVkQXNzZXRzW2luZGV4XTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdWdnZXN0ZWRBc3NldE1ldGEudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdFUkMyMCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlIH0gPSBzdWdnZXN0ZWRBc3NldE1ldGEuYXNzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmFkZFRva2VuKGFkZHJlc3MsIHN5bWJvbCwgZGVjaW1hbHMsIGltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Z2dlc3RlZEFzc2V0TWV0YS5zdGF0dXMgPSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5hY2NlcHRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7c3VnZ2VzdGVkQXNzZXRNZXRhLmlkfTpmaW5pc2hlZGAsIHN1Z2dlc3RlZEFzc2V0TWV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXNzZXQgb2YgdHlwZSAke3N1Z2dlc3RlZEFzc2V0TWV0YS50eXBlfSBub3Qgc3VwcG9ydGVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsU3VnZ2VzdGVkQXNzZXQoc3VnZ2VzdGVkQXNzZXRNZXRhLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdTdWdnZXN0ZWRBc3NldHMgPSBzdWdnZXN0ZWRBc3NldHMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSBzdWdnZXN0ZWRBc3NldElEKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgc3VnZ2VzdGVkQXNzZXRzOiBbLi4ubmV3U3VnZ2VzdGVkQXNzZXRzXSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlamVjdHMgYSB3YXRjaEFzc2V0IHJlcXVlc3QgYmFzZWQgb24gaXRzIElEIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyB0byBcInJlamVjdGVkXCJcbiAgICAgKiBhbmQgZW1pdHRpbmcgYSBgPHN1Z2dlc3RlZEFzc2V0TWV0YS5pZD46ZmluaXNoZWRgIGh1YiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWdnZXN0ZWRBc3NldElEIC0gVGhlIElEIG9mIHRoZSBzdWdnZXN0ZWRBc3NldCB0byBhY2NlcHQuXG4gICAgICovXG4gICAgcmVqZWN0V2F0Y2hBc3NldChzdWdnZXN0ZWRBc3NldElEKSB7XG4gICAgICAgIGNvbnN0IHsgc3VnZ2VzdGVkQXNzZXRzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBpbmRleCA9IHN1Z2dlc3RlZEFzc2V0cy5maW5kSW5kZXgoKHsgaWQgfSkgPT4gc3VnZ2VzdGVkQXNzZXRJRCA9PT0gaWQpO1xuICAgICAgICBjb25zdCBzdWdnZXN0ZWRBc3NldE1ldGEgPSBzdWdnZXN0ZWRBc3NldHNbaW5kZXhdO1xuICAgICAgICBpZiAoIXN1Z2dlc3RlZEFzc2V0TWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1Z2dlc3RlZEFzc2V0TWV0YS5zdGF0dXMgPSBTdWdnZXN0ZWRBc3NldFN0YXR1cy5yZWplY3RlZDtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHtzdWdnZXN0ZWRBc3NldE1ldGEuaWR9OmZpbmlzaGVkYCwgc3VnZ2VzdGVkQXNzZXRNZXRhKTtcbiAgICAgICAgY29uc3QgbmV3U3VnZ2VzdGVkQXNzZXRzID0gc3VnZ2VzdGVkQXNzZXRzLmZpbHRlcigoeyBpZCB9KSA9PiBpZCAhPT0gc3VnZ2VzdGVkQXNzZXRJRCk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgc3VnZ2VzdGVkQXNzZXRzOiBbLi4ubmV3U3VnZ2VzdGVkQXNzZXRzXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBuZXcgdG9rZW5zIGFuZCBpZ25vcmVkVG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBuZXR3b3JrL2FjY291bnQgY29tYmluYXRpb25cbiAgICAgKiBhbmQgcmV0dXJucyBuZXcgYWxsVG9rZW5zIGFuZCBhbGxJZ25vcmVkVG9rZW5zIHN0YXRlIHRvIHVwZGF0ZSB0by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBPYmplY3QgdGhhdCBob2xkcyB0b2tlbiBwYXJhbXMuXG4gICAgICogQHBhcmFtIHBhcmFtcy5uZXdUb2tlbnMgLSBUaGUgbmV3IHRva2VucyB0byBzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmsgYW5kIHNlbGVjdGVkIGFjY291bnQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5uZXdJZ25vcmVkVG9rZW5zIC0gVGhlIG5ldyBpZ25vcmVkIHRva2VucyB0byBzZXQgZm9yIHRoZSBjdXJyZW50IG5ldHdvcmsgYW5kIHNlbGVjdGVkIGFjY291bnQuXG4gICAgICogQHBhcmFtIHBhcmFtcy5uZXdEZXRlY3RlZFRva2VucyAtIFRoZSBuZXcgZGV0ZWN0ZWQgdG9rZW5zIHRvIHNldCBmb3IgdGhlIGN1cnJlbnQgbmV0d29yayBhbmQgc2VsZWN0ZWQgYWNjb3VudC5cbiAgICAgKiBAcmV0dXJucyBUaGUgdXBkYXRlZCBgYWxsVG9rZW5zYCBhbmQgYGFsbElnbm9yZWRUb2tlbnNgIHN0YXRlLlxuICAgICAqL1xuICAgIF9nZXROZXdBbGxUb2tlbnNTdGF0ZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgeyBuZXdUb2tlbnMsIG5ld0lnbm9yZWRUb2tlbnMsIG5ld0RldGVjdGVkVG9rZW5zIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgYWxsVG9rZW5zLCBhbGxJZ25vcmVkVG9rZW5zLCBhbGxEZXRlY3RlZFRva2VucyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgeyBjaGFpbklkLCBzZWxlY3RlZEFkZHJlc3MgfSA9IHRoaXMuY29uZmlnO1xuICAgICAgICBsZXQgbmV3QWxsVG9rZW5zID0gYWxsVG9rZW5zO1xuICAgICAgICBpZiAobmV3VG9rZW5zKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrVG9rZW5zID0gYWxsVG9rZW5zW2NoYWluSWRdO1xuICAgICAgICAgICAgY29uc3QgbmV3TmV0d29ya1Rva2VucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbmV0d29ya1Rva2VucyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld1Rva2VucyB9KTtcbiAgICAgICAgICAgIG5ld0FsbFRva2VucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWxsVG9rZW5zKSwgeyBbY2hhaW5JZF06IG5ld05ldHdvcmtUb2tlbnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0FsbElnbm9yZWRUb2tlbnMgPSBhbGxJZ25vcmVkVG9rZW5zO1xuICAgICAgICBpZiAobmV3SWdub3JlZFRva2Vucykge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0lnbm9yZWRUb2tlbnMgPSBhbGxJZ25vcmVkVG9rZW5zW2NoYWluSWRdO1xuICAgICAgICAgICAgY29uc3QgbmV3SWdub3JlZE5ldHdvcmtUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ldHdvcmtJZ25vcmVkVG9rZW5zKSwgeyBbc2VsZWN0ZWRBZGRyZXNzXTogbmV3SWdub3JlZFRva2VucyB9KTtcbiAgICAgICAgICAgIG5ld0FsbElnbm9yZWRUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbElnbm9yZWRUb2tlbnMpLCB7IFtjaGFpbklkXTogbmV3SWdub3JlZE5ldHdvcmtUb2tlbnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0FsbERldGVjdGVkVG9rZW5zID0gYWxsRGV0ZWN0ZWRUb2tlbnM7XG4gICAgICAgIGlmIChuZXdEZXRlY3RlZFRva2Vucykge1xuICAgICAgICAgICAgY29uc3QgbmV0d29ya0RldGVjdGVkVG9rZW5zID0gYWxsRGV0ZWN0ZWRUb2tlbnNbY2hhaW5JZF07XG4gICAgICAgICAgICBjb25zdCBuZXdEZXRlY3RlZE5ldHdvcmtUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ldHdvcmtEZXRlY3RlZFRva2VucyksIHsgW3NlbGVjdGVkQWRkcmVzc106IG5ld0RldGVjdGVkVG9rZW5zIH0pO1xuICAgICAgICAgICAgbmV3QWxsRGV0ZWN0ZWRUb2tlbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbERldGVjdGVkVG9rZW5zKSwgeyBbY2hhaW5JZF06IG5ld0RldGVjdGVkTmV0d29ya1Rva2VucyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBuZXdBbGxUb2tlbnMsIG5ld0FsbElnbm9yZWRUb2tlbnMsIG5ld0FsbERldGVjdGVkVG9rZW5zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRva2VucyBmcm9tIHRoZSBpZ25vcmVkIGxpc3QuXG4gICAgICovXG4gICAgY2xlYXJJZ25vcmVkVG9rZW5zKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlnbm9yZWRUb2tlbnM6IFtdLCBhbGxJZ25vcmVkVG9rZW5zOiB7fSB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRva2Vuc0NvbnRyb2xsZXIgPSBUb2tlbnNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVG9rZW5zQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRva2Vuc0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdEljb25VcmxXaXRoUHJveHkgPSBleHBvcnRzLmZvcm1hdEFnZ3JlZ2F0b3JOYW1lcyA9IGV4cG9ydHMuY29tcGFyZUNvbGxlY3RpYmxlc01ldGFkYXRhID0gdm9pZCAwO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbXBhcmVzIGNvbGxlY3RpYmxlIG1ldGFkYXRhIGVudHJpZXMgdG8gYW55IGNvbGxlY3RpYmxlIGVudHJ5LlxuICogV2UgbmVlZCB0aGlzIG1ldGhvZCB3aGVuIGNvbXBhcmluZyBhIG5ldyBmZXRjaGVkIGNvbGxlY3RpYmxlIG1ldGFkYXRhLCBpbiBjYXNlIGEgZW50cnkgY2hhbmdlZCB0byBhIGRlZmluZWQgdmFsdWUsXG4gKiB0aGVyZSdzIGEgbmVlZCB0byB1cGRhdGUgdGhlIGNvbGxlY3RpYmxlIGluIHN0YXRlLlxuICpcbiAqIEBwYXJhbSBuZXdDb2xsZWN0aWJsZU1ldGFkYXRhIC0gQ29sbGVjdGlibGUgbWV0YWRhdGEgb2JqZWN0LlxuICogQHBhcmFtIGNvbGxlY3RpYmxlIC0gQ29sbGVjdGlibGUgb2JqZWN0IHRvIGNvbXBhcmUgd2l0aC5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlcmUgYXJlIGRpZmZlcmVuY2VzLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQ29sbGVjdGlibGVzTWV0YWRhdGEobmV3Q29sbGVjdGlibGVNZXRhZGF0YSwgY29sbGVjdGlibGUpIHtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgJ2ltYWdlUHJldmlldycsXG4gICAgICAgICdpbWFnZVRodW1ibmFpbCcsXG4gICAgICAgICdpbWFnZU9yaWdpbmFsJyxcbiAgICAgICAgJ2FuaW1hdGlvbicsXG4gICAgICAgICdhbmltYXRpb25PcmlnaW5hbCcsXG4gICAgICAgICdleHRlcm5hbExpbmsnLFxuICAgIF07XG4gICAgY29uc3QgZGlmZmVyZW50VmFsdWVzID0ga2V5cy5yZWR1Y2UoKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKG5ld0NvbGxlY3RpYmxlTWV0YWRhdGFba2V5XSAmJlxuICAgICAgICAgICAgbmV3Q29sbGVjdGlibGVNZXRhZGF0YVtrZXldICE9PSBjb2xsZWN0aWJsZVtrZXldKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm4gZGlmZmVyZW50VmFsdWVzID4gMDtcbn1cbmV4cG9ydHMuY29tcGFyZUNvbGxlY3RpYmxlc01ldGFkYXRhID0gY29tcGFyZUNvbGxlY3RpYmxlc01ldGFkYXRhO1xuY29uc3QgYWdncmVnYXRvck5hbWVCeUtleSA9IHtcbiAgICBhYXZlOiAnQWF2ZScsXG4gICAgYmFuY29yOiAnQmFuY29yJyxcbiAgICBjbWM6ICdDTUMnLFxuICAgIGNyeXB0b2NvbTogJ0NyeXB0by5jb20nLFxuICAgIGNvaW5HZWNrbzogJ0NvaW5HZWNrbycsXG4gICAgb25lSW5jaDogJzFpbmNoJyxcbiAgICBwYXJhc3dhcDogJ1BhcmFzd2FwJyxcbiAgICBwbW06ICdQTU0nLFxuICAgIHphcHBlcjogJ1phcHBlcicsXG4gICAgemVyaW9uOiAnWmVyaW9uJyxcbiAgICB6ZXJvRXg6ICcweCcsXG4gICAgc3ludGhldGl4OiAnU3ludGhldGl4JyxcbiAgICB5ZWFybjogJ1llYXJuJyxcbiAgICBhcGVzd2FwOiAnQXBlU3dhcCcsXG4gICAgYmluYW5jZURleDogJ0JpbmFuY2VEZXgnLFxuICAgIHBhbmNha2VUb3AxMDA6ICdQYW5jYWtlVG9wMTAwJyxcbiAgICBwYW5jYWtlRXh0ZW5kZWQ6ICdQYW5jYWtlRXh0ZW5kZWQnLFxuICAgIGJhbGFuY2VyOiAnQmFsYW5jZXInLFxuICAgIHF1aWNrc3dhcDogJ1F1aWNrU3dhcCcsXG4gICAgbWF0Y2hhOiAnTWF0Y2hhJyxcbiAgICBwYW5nb2xpbkRleDogJ1BhbmdvbGluRGV4JyxcbiAgICBwYW5nb2xpbkRleFN0YWJsZUNvaW46ICdQYW5nb2xpbkRleFN0YWJsZUNvaW4nLFxuICAgIHBhbmdvbGluRGV4QXZheEJyaWRnZTogJ1BhbmdvbGluRGV4QXZheEJyaWRnZScsXG4gICAgdHJhZGVySm9lOiAnVHJhZGVySm9lJyxcbiAgICBhaXJzd2FwTGlnaHQ6ICdBaXJzd2FwTGlnaHQnLFxuICAgIGtsZXJvczogJ0tsZXJvcycsXG59O1xuLyoqXG4gKiBGb3JtYXRzIGFnZ3JlZ2F0b3IgbmFtZXMgdG8gcHJlc2VudGFibGUgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBhZ2dyZWdhdG9ycyAtIExpc3Qgb2YgdG9rZW4gbGlzdCBuYW1lcyBpbiBjYW1lbGNhc2UuXG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgYWdncmVnYXRvciBuYW1lcy5cbiAqL1xuY29uc3QgZm9ybWF0QWdncmVnYXRvck5hbWVzID0gKGFnZ3JlZ2F0b3JzKSA9PiB7XG4gICAgcmV0dXJuIGFnZ3JlZ2F0b3JzLm1hcCgoa2V5KSA9PiBhZ2dyZWdhdG9yTmFtZUJ5S2V5W2tleV0gfHxcbiAgICAgICAgYCR7a2V5WzBdLnRvVXBwZXJDYXNlKCl9JHtrZXkuc3Vic3RyaW5nKDEsIGtleS5sZW5ndGgpfWApO1xufTtcbmV4cG9ydHMuZm9ybWF0QWdncmVnYXRvck5hbWVzID0gZm9ybWF0QWdncmVnYXRvck5hbWVzO1xuLyoqXG4gKiBGb3JtYXQgdG9rZW4gbGlzdCBhc3NldHMgdG8gdXNlIGltYWdlIHByb3h5IGZyb20gQ29kZWZpLlxuICpcbiAqIEBwYXJhbSBwYXJhbXMgLSBPYmplY3QgdGhhdCBjb250YWlucyBjaGFpbklEIGFuZCB0b2tlbkFkZHJlc3MuXG4gKiBAcGFyYW0gcGFyYW1zLmNoYWluSWQgLSBDaGFpbklEIG9mIG5ldHdvcmsgaW4gZGVjaW1hbCBvciBoZXhhZGVjaW1hbCBmb3JtYXQuXG4gKiBAcGFyYW0gcGFyYW1zLnRva2VuQWRkcmVzcyAtIEFkZHJlc3Mgb2YgdG9rZW4gaW4gbWl4ZWQgb3IgbG93ZXJjYXNlLlxuICogQHJldHVybnMgRm9ybWF0dGVkIGltYWdlIHVybFxuICovXG5jb25zdCBmb3JtYXRJY29uVXJsV2l0aFByb3h5ID0gKHsgY2hhaW5JZCwgdG9rZW5BZGRyZXNzLCB9KSA9PiB7XG4gICAgY29uc3QgY2hhaW5JZERlY2ltYWwgPSAoMCwgdXRpbF8xLmNvbnZlcnRIZXhUb0RlY2ltYWwpKGNoYWluSWQpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGBodHRwczovL3N0YXRpYy5tZXRhc3dhcC5jb2RlZmkubmV0d29yay9hcGkvdjEvdG9rZW5JY29ucy8ke2NoYWluSWREZWNpbWFsfS8ke3Rva2VuQWRkcmVzcy50b0xvd2VyQ2FzZSgpfS5wbmdgO1xufTtcbmV4cG9ydHMuZm9ybWF0SWNvblVybFdpdGhQcm94eSA9IGZvcm1hdEljb25VcmxXaXRoUHJveHk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NldHNVdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PUEVOU0VBX1RFU1RfQVBJX1VSTCA9IGV4cG9ydHMuT1BFTlNFQV9BUElfVVJMID0gZXhwb3J0cy5PUEVOU0VBX1BST1hZX1VSTCA9IGV4cG9ydHMuVEVTVE5FVF9ORVRXT1JLX1RZUEVfVE9fVElDS0VSX1NZTUJPTCA9IGV4cG9ydHMuVEVTVE5FVF9USUNLRVJfU1lNQk9MUyA9IGV4cG9ydHMuQVNTRVRfVFlQRVMgPSBleHBvcnRzLkdXRUkgPSBleHBvcnRzLkVSQzExNTVfVE9LRU5fUkVDRUlWRVJfSU5URVJGQUNFX0lEID0gZXhwb3J0cy5FUkMxMTU1X01FVEFEQVRBX1VSSV9JTlRFUkZBQ0VfSUQgPSBleHBvcnRzLkVSQzExNTVfSU5URVJGQUNFX0lEID0gZXhwb3J0cy5FUkM3MjFfRU5VTUVSQUJMRV9JTlRFUkZBQ0VfSUQgPSBleHBvcnRzLkVSQzcyMV9NRVRBREFUQV9JTlRFUkZBQ0VfSUQgPSBleHBvcnRzLkVSQzcyMV9JTlRFUkZBQ0VfSUQgPSBleHBvcnRzLkVSQzIwID0gZXhwb3J0cy5FUkMxMTU1ID0gZXhwb3J0cy5FUkM3MjEgPSBleHBvcnRzLkdBTkFDSEVfQ0hBSU5fSUQgPSBleHBvcnRzLlJJTktFQllfQ0hBSU5fSUQgPSBleHBvcnRzLklQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCA9IGV4cG9ydHMuRkFMTF9CQUNLX1ZTX0NVUlJFTkNZID0gZXhwb3J0cy5SUEMgPSBleHBvcnRzLk1BSU5ORVQgPSB2b2lkIDA7XG5leHBvcnRzLk1BSU5ORVQgPSAnbWFpbm5ldCc7XG5leHBvcnRzLlJQQyA9ICdycGMnO1xuZXhwb3J0cy5GQUxMX0JBQ0tfVlNfQ1VSUkVOQ1kgPSAnRVRIJztcbmV4cG9ydHMuSVBGU19ERUZBVUxUX0dBVEVXQVlfVVJMID0gJ2h0dHBzOi8vY2xvdWRmbGFyZS1pcGZzLmNvbS9pcGZzLyc7XG4vLyBORVRXT1JLUyBJRFxuZXhwb3J0cy5SSU5LRUJZX0NIQUlOX0lEID0gJzQnO1xuZXhwb3J0cy5HQU5BQ0hFX0NIQUlOX0lEID0gJzEzMzcnO1xuLy8gVE9LRU4gU1RBTkRBUkRTXG5leHBvcnRzLkVSQzcyMSA9ICdFUkM3MjEnO1xuZXhwb3J0cy5FUkMxMTU1ID0gJ0VSQzExNTUnO1xuZXhwb3J0cy5FUkMyMCA9ICdFUkMyMCc7XG4vLyBUT0tFTiBJTlRFUkZBQ0UgSURTXG5leHBvcnRzLkVSQzcyMV9JTlRFUkZBQ0VfSUQgPSAnMHg4MGFjNThjZCc7XG5leHBvcnRzLkVSQzcyMV9NRVRBREFUQV9JTlRFUkZBQ0VfSUQgPSAnMHg1YjVlMTM5Zic7XG5leHBvcnRzLkVSQzcyMV9FTlVNRVJBQkxFX0lOVEVSRkFDRV9JRCA9ICcweDc4MGU5ZDYzJztcbmV4cG9ydHMuRVJDMTE1NV9JTlRFUkZBQ0VfSUQgPSAnMHhkOWI2N2EyNic7XG5leHBvcnRzLkVSQzExNTVfTUVUQURBVEFfVVJJX0lOVEVSRkFDRV9JRCA9ICcweDBlODkzNDFjJztcbmV4cG9ydHMuRVJDMTE1NV9UT0tFTl9SRUNFSVZFUl9JTlRFUkZBQ0VfSUQgPSAnMHg0ZTIzMTJlMCc7XG4vLyBVTklUU1xuZXhwb3J0cy5HV0VJID0gJ2d3ZWknO1xuLy8gQVNTRVQgVFlQRVNcbmV4cG9ydHMuQVNTRVRfVFlQRVMgPSB7XG4gICAgTkFUSVZFOiAnTkFUSVZFJyxcbiAgICBUT0tFTjogJ1RPS0VOJyxcbiAgICBDT0xMRUNUSUJMRTogJ0NPTExFQ1RJQkxFJyxcbiAgICBVTktOT1dOOiAnVU5LTk9XTicsXG59O1xuLy8gVElDS0VSIFNZTUJPTFNcbmV4cG9ydHMuVEVTVE5FVF9USUNLRVJfU1lNQk9MUyA9IHtcbiAgICBSSU5LRUJZOiAnUmlua2VieUVUSCcsXG4gICAgR09FUkxJOiAnR29lcmxpRVRIJyxcbiAgICBST1BTVEVOOiAnUm9wc3RlbkVUSCcsXG4gICAgS09WQU46ICdLb3ZhbkVUSCcsXG59O1xuLy8gVFlQRUQgTmV0d29ya1R5cGUgVElDS0VSIFNZTUJPTFNcbmV4cG9ydHMuVEVTVE5FVF9ORVRXT1JLX1RZUEVfVE9fVElDS0VSX1NZTUJPTCA9IHtcbiAgICByaW5rZWJ5OiAnUmlua2VieUVUSCcsXG4gICAgZ29lcmxpOiAnR29lcmxpRVRIJyxcbiAgICByb3BzdGVuOiAnUm9wc3RlbkVUSCcsXG4gICAga292YW46ICdLb3ZhbkVUSCcsXG4gICAgbWFpbm5ldDogJycsXG4gICAgcnBjOiAnJyxcbiAgICBsb2NhbGhvc3Q6ICcnLFxuICAgIG9wdGltaXNtOiAnJyxcbiAgICBvcHRpbWlzbVRlc3Q6ICcnLFxufTtcbi8vIEFQSXNcbmV4cG9ydHMuT1BFTlNFQV9QUk9YWV9VUkwgPSAnaHR0cHM6Ly9wcm94eS5tZXRhc3dhcC5jb2RlZmkubmV0d29yay9vcGVuc2VhL3YxL2FwaS92MSc7XG5leHBvcnRzLk9QRU5TRUFfQVBJX1VSTCA9ICdodHRwczovL2FwaS5vcGVuc2VhLmlvL2FwaS92MSc7XG5leHBvcnRzLk9QRU5TRUFfVEVTVF9BUElfVVJMID0gJ2h0dHBzOi8vdGVzdG5ldHMtYXBpLm9wZW5zZWEuaW8vYXBpL3YxJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0YW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5HYXNGZWVDb250cm9sbGVyID0gZXhwb3J0cy5HQVNfRVNUSU1BVEVfVFlQRVMgPSBleHBvcnRzLkxFR0FDWV9HQVNfUFJJQ0VTX0FQSV9VUkwgPSB2b2lkIDA7XG5jb25zdCBldGhfcXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXF1ZXJ5XCIpKTtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IGdhc191dGlsXzEgPSByZXF1aXJlKFwiLi9nYXMtdXRpbFwiKTtcbmNvbnN0IGRldGVybWluZUdhc0ZlZUNhbGN1bGF0aW9uc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RldGVybWluZUdhc0ZlZUNhbGN1bGF0aW9uc1wiKSk7XG5jb25zdCBmZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9mZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnlcIikpO1xuY29uc3QgR0FTX0ZFRV9BUEkgPSAnaHR0cHM6Ly9tb2NrLWdhcy1zZXJ2ZXIuaGVyb2t1YXBwLmNvbS8nO1xuZXhwb3J0cy5MRUdBQ1lfR0FTX1BSSUNFU19BUElfVVJMID0gYGh0dHBzOi8vYXBpLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrL2dhc1ByaWNlc2A7XG4vKipcbiAqIEluZGljYXRlcyB3aGljaCB0eXBlIG9mIGdhc0VzdGltYXRlIHRoZSBjb250cm9sbGVyIGlzIGN1cnJlbnRseSByZXR1cm5pbmcuXG4gKiBUaGlzIGlzIHVzZWZ1bCBhcyBhIHdheSBvZiBhc3NlcnRpbmcgdGhhdCB0aGUgc2hhcGUgb2YgZ2FzRXN0aW1hdGVzIG1hdGNoZXNcbiAqIGV4cGVjdGF0aW9ucy4gTk9ORSBpcyBhIHNwZWNpYWwgY2FzZSBpbmRpY2F0aW5nIHRoYXQgbm8gcHJldmlvdXMgZ2FzRXN0aW1hdGVcbiAqIGhhcyBiZWVuIGZldGNoZWQuXG4gKi9cbmV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTID0ge1xuICAgIEZFRV9NQVJLRVQ6ICdmZWUtbWFya2V0JyxcbiAgICBMRUdBQ1k6ICdsZWdhY3knLFxuICAgIEVUSF9HQVNQUklDRTogJ2V0aF9nYXNQcmljZScsXG4gICAgTk9ORTogJ25vbmUnLFxufTtcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIGdhc0ZlZUVzdGltYXRlczogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG4gICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczogeyBwZXJzaXN0OiB0cnVlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG4gICAgZ2FzRXN0aW1hdGVUeXBlOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogZmFsc2UgfSxcbn07XG5jb25zdCBuYW1lID0gJ0dhc0ZlZUNvbnRyb2xsZXInO1xuY29uc3QgZGVmYXVsdFN0YXRlID0ge1xuICAgIGdhc0ZlZUVzdGltYXRlczoge30sXG4gICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kczoge30sXG4gICAgZ2FzRXN0aW1hdGVUeXBlOiBleHBvcnRzLkdBU19FU1RJTUFURV9UWVBFUy5OT05FLFxufTtcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IHJldHJpZXZlcyBnYXMgZmVlIGVzdGltYXRlIGRhdGEgYW5kIHBvbGxzIGZvciB1cGRhdGVkIGRhdGEgb24gYSBzZXQgaW50ZXJ2YWxcbiAqL1xuY2xhc3MgR2FzRmVlQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyVjJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEdhc0ZlZUNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuaW50ZXJ2YWwgLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIHBvbGxzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyIG1lc3Nlbmdlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIFRoZSBpbml0aWFsIHN0YXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHkgLSBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IHRoZSBjdXJyZW50XG4gICAgICogbmV0d29yayBpcyBFSVAtMTU1OSBjb21wYXRpYmxlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAgICogY3VycmVudCBuZXR3b3JrIGlzIGNvbXBhdGlibGUgd2l0aCB0aGUgbGVnYWN5IGdhcyBwcmljZSBBUEkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eSAtIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGN1cnJlbnRcbiAgICAgKiBhY2NvdW50IGlzIEVJUC0xNTU5IGNvbXBhdGlibGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0Q2hhaW5JZCAtIFJldHVybnMgdGhlIGN1cnJlbnQgY2hhaW4gSUQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0UHJvdmlkZXIgLSBSZXR1cm5zIGEgbmV0d29yayBwcm92aWRlciBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEEgZnVuY3Rpb24gZm9yIHJlZ2lzdGVyaW5nIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZVxuICAgICAqIG5ldHdvcmsgc3RhdGUgY2hhbmdlIGV2ZW50LlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmxlZ2FjeUFQSUVuZHBvaW50IC0gVGhlIGxlZ2FjeSBnYXMgcHJpY2UgQVBJIFVSTC4gVGhpcyBvcHRpb24gaXMgcHJpbWFyaWx5IGZvclxuICAgICAqIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuRUlQMTU1OUFQSUVuZHBvaW50IC0gVGhlIEVJUC0xNTU5IGdhcyBwcmljZSBBUEkgVVJMLiBUaGlzIG9wdGlvbiBpcyBwcmltYXJpbHlcbiAgICAgKiBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5jbGllbnRJZCAtIFRoZSBjbGllbnQgSUQgdXNlZCB0byBpZGVudGlmeSB0byB0aGUgZ2FzIGVzdGltYXRpb24gQVBJIHdobyBpc1xuICAgICAqIGFza2luZyBmb3IgZXN0aW1hdGVzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaW50ZXJ2YWwgPSAxNTAwMCwgbWVzc2VuZ2VyLCBzdGF0ZSwgZ2V0Q3VycmVudE5ldHdvcmtFSVAxNTU5Q29tcGF0aWJpbGl0eSwgZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eSwgZ2V0Q2hhaW5JZCwgZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5LCBnZXRQcm92aWRlciwgb25OZXR3b3JrU3RhdGVDaGFuZ2UsIGxlZ2FjeUFQSUVuZHBvaW50ID0gZXhwb3J0cy5MRUdBQ1lfR0FTX1BSSUNFU19BUElfVVJMLCBFSVAxNTU5QVBJRW5kcG9pbnQgPSBHQVNfRkVFX0FQSSwgY2xpZW50SWQsIH0pIHtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlKSwgc3RhdGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbnRlcnZhbERlbGF5ID0gaW50ZXJ2YWw7XG4gICAgICAgIHRoaXMucG9sbFRva2VucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50TmV0d29ya0VJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgICAgICAgIGdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHk7XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudE5ldHdvcmtMZWdhY3lHYXNBUElDb21wYXRpYmlsaXR5ID1cbiAgICAgICAgICAgIGdldEN1cnJlbnROZXR3b3JrTGVnYWN5R2FzQVBJQ29tcGF0aWJpbGl0eTtcbiAgICAgICAgdGhpcy5nZXRDdXJyZW50QWNjb3VudEVJUDE1NTlDb21wYXRpYmlsaXR5ID1cbiAgICAgICAgICAgIGdldEN1cnJlbnRBY2NvdW50RUlQMTU1OUNvbXBhdGliaWxpdHk7XG4gICAgICAgIHRoaXMuRUlQMTU1OUFQSUVuZHBvaW50ID0gRUlQMTU1OUFQSUVuZHBvaW50O1xuICAgICAgICB0aGlzLmxlZ2FjeUFQSUVuZHBvaW50ID0gbGVnYWN5QVBJRW5kcG9pbnQ7XG4gICAgICAgIHRoaXMuZ2V0Q2hhaW5JZCA9IGdldENoYWluSWQ7XG4gICAgICAgIHRoaXMuY3VycmVudENoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICB0aGlzLmV0aFF1ZXJ5ID0gbmV3IGV0aF9xdWVyeV8xLmRlZmF1bHQocHJvdmlkZXIpO1xuICAgICAgICB0aGlzLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIG9uTmV0d29ya1N0YXRlQ2hhbmdlKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChuZXdQcm92aWRlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Q2hhaW5JZCAhPT0gbmV3Q2hhaW5JZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudENoYWluSWQgPSBuZXdDaGFpbklkO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucmVzZXRQb2xsaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmVzZXRQb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9sbFRva2Vucy5zaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9rZW5zID0gQXJyYXkuZnJvbSh0aGlzLnBvbGxUb2tlbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmdldEdhc0ZlZUVzdGltYXRlc0FuZFN0YXJ0UG9sbGluZyh0b2tlbnNbMF0pO1xuICAgICAgICAgICAgICAgIHRva2Vucy5zbGljZSgxKS5mb3JFYWNoKCh0b2tlbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvbGxUb2tlbnMuYWRkKHRva2VuKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZldGNoR2FzRmVlRXN0aW1hdGVzKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLl9mZXRjaEdhc0ZlZUVzdGltYXRlRGF0YShvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEdhc0ZlZUVzdGltYXRlc0FuZFN0YXJ0UG9sbGluZyhwb2xsVG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9wb2xsVG9rZW4gPSBwb2xsVG9rZW4gfHwgKDAsIHV1aWRfMS52MSkoKTtcbiAgICAgICAgICAgIHRoaXMucG9sbFRva2Vucy5hZGQoX3BvbGxUb2tlbik7XG4gICAgICAgICAgICBpZiAodGhpcy5wb2xsVG9rZW5zLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLl9mZXRjaEdhc0ZlZUVzdGltYXRlRGF0YSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcG9sbFRva2VuO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbmQgc2V0cyBnYXNGZWVFc3RpbWF0ZXMgaW4gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBnYXMgZmVlIGVzdGltYXRlIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2hvdWxkVXBkYXRlU3RhdGUgLSBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHN0YXRlIHNob3VsZCBiZSB1cGRhdGVkIHdpdGggdGhlXG4gICAgICogdXBkYXRlZCBnYXMgZXN0aW1hdGVzLlxuICAgICAqIEByZXR1cm5zIFRoZSBnYXMgZmVlIGVzdGltYXRlcy5cbiAgICAgKi9cbiAgICBfZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNob3VsZFVwZGF0ZVN0YXRlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgIGxldCBpc0VJUDE1NTlDb21wYXRpYmxlO1xuICAgICAgICAgICAgY29uc3QgaXNMZWdhY3lHYXNBUElDb21wYXRpYmxlID0gdGhpcy5nZXRDdXJyZW50TmV0d29ya0xlZ2FjeUdhc0FQSUNvbXBhdGliaWxpdHkoKTtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gdGhpcy5nZXRDaGFpbklkKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYWluSWQgPT09ICdzdHJpbmcnICYmICgwLCBldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZykoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpc0VJUDE1NTlDb21wYXRpYmxlID0geWllbGQgdGhpcy5nZXRFSVAxNTU5Q29tcGF0aWJpbGl0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGdhc0ZlZUNhbGN1bGF0aW9ucyA9IHlpZWxkICgwLCBkZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnNfMS5kZWZhdWx0KSh7XG4gICAgICAgICAgICAgICAgaXNFSVAxNTU5Q29tcGF0aWJsZSxcbiAgICAgICAgICAgICAgICBpc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUsXG4gICAgICAgICAgICAgICAgZmV0Y2hHYXNFc3RpbWF0ZXM6IGdhc191dGlsXzEuZmV0Y2hHYXNFc3RpbWF0ZXMsXG4gICAgICAgICAgICAgICAgZmV0Y2hHYXNFc3RpbWF0ZXNVcmw6IHRoaXMuRUlQMTU1OUFQSUVuZHBvaW50LnJlcGxhY2UoJzxjaGFpbl9pZD4nLCBgJHtjaGFpbklkfWApLFxuICAgICAgICAgICAgICAgIGZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeTogZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5XzEuZGVmYXVsdCxcbiAgICAgICAgICAgICAgICBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzOiBnYXNfdXRpbF8xLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMsXG4gICAgICAgICAgICAgICAgZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlc1VybDogdGhpcy5sZWdhY3lBUElFbmRwb2ludC5yZXBsYWNlKCc8Y2hhaW5faWQ+JywgYCR7Y2hhaW5JZH1gKSxcbiAgICAgICAgICAgICAgICBmZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGU6IGdhc191dGlsXzEuZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlLFxuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZVRpbWVFc3RpbWF0ZTogZ2FzX3V0aWxfMS5jYWxjdWxhdGVUaW1lRXN0aW1hdGUsXG4gICAgICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgZXRoUXVlcnk6IHRoaXMuZXRoUXVlcnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nYXNGZWVFc3RpbWF0ZXMgPSBnYXNGZWVDYWxjdWxhdGlvbnMuZ2FzRmVlRXN0aW1hdGVzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdhc0ZlZUNhbGN1bGF0aW9ucy5lc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5nYXNFc3RpbWF0ZVR5cGUgPSBnYXNGZWVDYWxjdWxhdGlvbnMuZ2FzRXN0aW1hdGVUeXBlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdhc0ZlZUNhbGN1bGF0aW9ucztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgcG9sbCB0b2tlbiwgYW5kIHN0b3AgcG9sbGluZyBpZiB0aGUgc2V0IG9mIHBvbGwgdG9rZW5zIGlzIGVtcHR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvbGxUb2tlbiAtIFRoZSBwb2xsIHRva2VuIHRvIGRpc2Nvbm5lY3QuXG4gICAgICovXG4gICAgZGlzY29ubmVjdFBvbGxlcihwb2xsVG9rZW4pIHtcbiAgICAgICAgdGhpcy5wb2xsVG9rZW5zLmRlbGV0ZShwb2xsVG9rZW4pO1xuICAgICAgICBpZiAodGhpcy5wb2xsVG9rZW5zLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBvbGxpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdG9wUG9sbGluZygpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9sbFRva2Vucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZSB0byBkaXNjYXJkIHRoaXMgY29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIFRoaXMgc3RvcHMgYW55IGFjdGl2ZSBwb2xsaW5nLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5zdG9wUG9sbGluZygpO1xuICAgIH1cbiAgICBfcG9sbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW50ZXJ2YWxJZCkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gdGhpcy5fZmV0Y2hHYXNGZWVFc3RpbWF0ZURhdGEoKSk7XG4gICAgICAgIH0pLCB0aGlzLmludGVydmFsRGVsYXkpO1xuICAgIH1cbiAgICByZXNldFN0YXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFN0YXRlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TmV0d29ya0lzRUlQMTU1OUNvbXBhdGlibGUgPSB5aWVsZCB0aGlzLmdldEN1cnJlbnROZXR3b3JrRUlQMTU1OUNvbXBhdGliaWxpdHkoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRBY2NvdW50SXNFSVAxNTU5Q29tcGF0aWJsZSA9IChfYiA9IChfYSA9IHRoaXMuZ2V0Q3VycmVudEFjY291bnRFSVAxNTU5Q29tcGF0aWJpbGl0eSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gKGN1cnJlbnROZXR3b3JrSXNFSVAxNTU5Q29tcGF0aWJsZSAmJiBjdXJyZW50QWNjb3VudElzRUlQMTU1OUNvbXBhdGlibGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGltZUVzdGltYXRlKG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmdhc0ZlZUVzdGltYXRlcyB8fFxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5nYXNFc3RpbWF0ZVR5cGUgIT09IGV4cG9ydHMuR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIGdhc191dGlsXzEuY2FsY3VsYXRlVGltZUVzdGltYXRlKShtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCB0aGlzLnN0YXRlLmdhc0ZlZUVzdGltYXRlcyk7XG4gICAgfVxufVxuZXhwb3J0cy5HYXNGZWVDb250cm9sbGVyID0gR2FzRmVlQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IEdhc0ZlZUNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1HYXNGZWVDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBHYXNGZWVDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi9HYXNGZWVDb250cm9sbGVyXCIpO1xuLyoqXG4gKiBPYnRhaW5zIGEgc2V0IG9mIG1heCBiYXNlIGFuZCBwcmlvcml0eSBmZWUgZXN0aW1hdGVzIGFsb25nIHdpdGggdGltZSBlc3RpbWF0ZXMgc28gdGhhdCB3ZVxuICogY2FuIHByZXNlbnQgdGhlbSB0byB1c2VycyB3aGVuIHRoZXkgYXJlIHNlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIG1ha2luZyBzd2Fwcy5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMuXG4gKiBAcGFyYW0gYXJncy5pc0VJUDE1NTlDb21wYXRpYmxlIC0gR292ZXJucyB3aGV0aGVyIG9yIG5vdCB3ZSBjYW4gdXNlIGFuIEVJUC0xNTU5LW9ubHkgbWV0aG9kIHRvXG4gKiBwcm9kdWNlIGVzdGltYXRlcy5cbiAqIEBwYXJhbSBhcmdzLmlzTGVnYWN5R2FzQVBJQ29tcGF0aWJsZSAtIEdvdmVybnMgd2hldGhlciBvciBub3Qgd2UgY2FuIHVzZSBhIG5vbi1FSVAtMTU1OSBtZXRob2QgdG9cbiAqIHByb2R1Y2UgZXN0aW1hdGVzIChmb3IgaW5zdGFuY2UsIHRlc3RuZXRzIGRvIG5vdCBzdXBwb3J0IGVzdGltYXRlcyBhbHRvZ2V0aGVyKS5cbiAqIEBwYXJhbSBhcmdzLmZldGNoR2FzRXN0aW1hdGVzIC0gQSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgZ2FzIGVzdGltYXRlcyB1c2luZyBhbiBFSVAtMTU1OS1zcGVjaWZpY1xuICogQVBJLlxuICogQHBhcmFtIGFyZ3MuZmV0Y2hHYXNFc3RpbWF0ZXNVcmwgLSBUaGUgVVJMIGZvciB0aGUgQVBJIHdlIGNhbiB1c2UgdG8gb2J0YWluIEVJUC0xNTU5LXNwZWNpZmljXG4gKiBlc3RpbWF0ZXMuXG4gKiBAcGFyYW0gYXJncy5mZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnkgLSBBIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBnYXMgZXN0aW1hdGVzIHVzaW5nXG4gKiBgZXRoX2ZlZUhpc3RvcnlgIChhbiBFSVAtMTU1OSBmZWF0dXJlKS5cbiAqIEBwYXJhbSBhcmdzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMgLSBBIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBnYXMgZXN0aW1hdGVzIHVzaW5nIGFuXG4gKiBub24tRUlQLTE1NTktc3BlY2lmaWMgQVBJLlxuICogQHBhcmFtIGFyZ3MuZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlc1VybCAtIFRoZSBVUkwgZm9yIHRoZSBBUEkgd2UgY2FuIHVzZSB0byBvYnRhaW5cbiAqIG5vbi1FSVAtMTU1OS1zcGVjaWZpYyBlc3RpbWF0ZXMuXG4gKiBAcGFyYW0gYXJncy5mZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUgLSBBIGZ1bmN0aW9uIHRoYXQgZmV0Y2hlcyBnYXMgZXN0aW1hdGVzIHVzaW5nXG4gKiBgZXRoX2dhc1ByaWNlYC5cbiAqIEBwYXJhbSBhcmdzLmNhbGN1bGF0ZVRpbWVFc3RpbWF0ZSAtIEEgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmUgdGltZSBlc3RpbWF0ZSBib3VuZHMuXG4gKiBAcGFyYW0gYXJncy5jbGllbnRJZCAtIEFuIGlkZW50aWZpZXIgdGhhdCBhbiBBUEkgY2FuIHVzZSB0byBrbm93IHdobyBpcyBhc2tpbmcgZm9yIGVzdGltYXRlcy5cbiAqIEBwYXJhbSBhcmdzLmV0aFF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2Ugd2UgY2FuIHVzZSB0byB0YWxrIHRvIEV0aGVyZXVtIGRpcmVjdGx5LlxuICogQHJldHVybnMgVGhlIGdhcyBmZWUgY2FsY3VsYXRpb25zLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnMoeyBpc0VJUDE1NTlDb21wYXRpYmxlLCBpc0xlZ2FjeUdhc0FQSUNvbXBhdGlibGUsIGZldGNoR2FzRXN0aW1hdGVzLCBmZXRjaEdhc0VzdGltYXRlc1VybCwgZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5LCBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzLCBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzVXJsLCBmZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUsIGNhbGN1bGF0ZVRpbWVFc3RpbWF0ZSwgY2xpZW50SWQsIGV0aFF1ZXJ5LCB9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc0VJUDE1NTlDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVzdGltYXRlcztcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZXMgPSB5aWVsZCBmZXRjaEdhc0VzdGltYXRlcyhmZXRjaEdhc0VzdGltYXRlc1VybCwgY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVzID0geWllbGQgZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5KGV0aFF1ZXJ5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcywgc3VnZ2VzdGVkTWF4RmVlUGVyR2FzIH0gPSBlc3RpbWF0ZXMubWVkaXVtO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlZEdhc0ZlZVRpbWVCb3VuZHMgPSBjYWxjdWxhdGVUaW1lRXN0aW1hdGUoc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMsIHN1Z2dlc3RlZE1heEZlZVBlckdhcywgZXN0aW1hdGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGVzdGltYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcyxcbiAgICAgICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVUeXBlOiBHYXNGZWVDb250cm9sbGVyXzEuR0FTX0VTVElNQVRFX1RZUEVTLkZFRV9NQVJLRVQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzTGVnYWN5R2FzQVBJQ29tcGF0aWJsZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlcyA9IHlpZWxkIGZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMoZmV0Y2hMZWdhY3lHYXNQcmljZUVzdGltYXRlc1VybCwgY2xpZW50SWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdhc0ZlZUVzdGltYXRlczogZXN0aW1hdGVzLFxuICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVUeXBlOiBHYXNGZWVDb250cm9sbGVyXzEuR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWluIGdhcyBmZWUvcHJpY2UgZXN0aW1hdGlvbiBmYWlsZWQuIFVzZSBmYWxsYmFjaycpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZXMgPSB5aWVsZCBmZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUoZXRoUXVlcnkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGdhc0ZlZUVzdGltYXRlczogZXN0aW1hdGVzLFxuICAgICAgICAgICAgICAgICAgICBlc3RpbWF0ZWRHYXNGZWVUaW1lQm91bmRzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzRXN0aW1hdGVUeXBlOiBHYXNGZWVDb250cm9sbGVyXzEuR0FTX0VTVElNQVRFX1RZUEVTLkVUSF9HQVNQUklDRSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHYXMgZmVlL3ByaWNlIGVzdGltYXRpb24gZmFpbGVkLiBNZXNzYWdlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZXRlcm1pbmVHYXNGZWVDYWxjdWxhdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgTUFYX05VTUJFUl9PRl9CTE9DS1NfUEVSX0VUSF9GRUVfSElTVE9SWV9DQUxMID0gMTAyNDtcbi8qKlxuICogVXNlcyBgZXRoX2ZlZUhpc3RvcnlgIChhbiBFSVAtMTU1OSBmZWF0dXJlKSB0byBvYnRhaW4gaW5mb3JtYXRpb24gYWJvdXQgZ2FzIGZlZXMgZnJvbSBhIHJhbmdlIG9mXG4gKiBibG9ja3MgdGhhdCBoYXZlIG9jY3VycmVkIHJlY2VudGx5IG9uIGEgbmV0d29yay5cbiAqXG4gKiBUbyBsZWFybiBtb3JlLCBzZWUgdGhlc2UgcmVzb3VyY2VzOlxuICpcbiAqIC0gPGh0dHBzOi8vaW5mdXJhLmlvL2RvY3MvZXRoZXJldW0jb3BlcmF0aW9uL2V0aF9mZWVIaXN0b3J5PlxuICogLSA8aHR0cHM6Ly9naXRodWIuY29tL3pzZmVsZm9sZGkvZmVlaGlzdG9yeS9ibG9iL21haW4vZG9jcy9mZWVIaXN0b3J5Lm1kPlxuICogLSA8aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2Jsb2IvNTdhM2ZhYjhhNzVlZWI5YzJmNGZhYjc3MGI3M2I1MWI5ZmU2NzJjNS9ldGgvZ2FzcHJpY2UvZmVlaGlzdG9yeS5nbyNMMTgwPlxuICogLSA8aHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL0VJUHMvYmxvYi9tYXN0ZXIvRUlQUy9laXAtMTU1OS5tZD5cbiAqIC0gPGh0dHBzOi8vZ2FzLWFwaS5tZXRhc3dhcC5jb2RlZmkubmV0d29yay90ZXN0RmVlSGlzdG9yeT5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHMgdG8gdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSBhcmdzLmV0aFF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2UgdGhhdCB3cmFwcyBhIHByb3ZpZGVyIGZvciB0aGUgbmV0d29yayBpbiBxdWVzdGlvbi5cbiAqIEBwYXJhbSBhcmdzLmVuZEJsb2NrIC0gVGhlIGRlc2lyZWQgZW5kIG9mIHRoZSByZXF1ZXN0ZWQgYmxvY2sgcmFuZ2UuIENhbiBiZSBcImxhdGVzdFwiIGlmIHlvdSB3YW50XG4gKiB0byBzdGFydCBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCBibG9jayBvciB0aGUgbnVtYmVyIG9mIGEga25vd24gcGFzdCBibG9jay5cbiAqIEBwYXJhbSBhcmdzLm51bWJlck9mQmxvY2tzIC0gSG93IG1hbnkgdG90YWwgYmxvY2tzIHRvIGZldGNoLiBOb3RlIHRoYXQgaWYgdGhpcyBpcyBtb3JlIHRoYW4gMTAyNCxcbiAqIG11bHRpcGxlIGNhbGxzIHRvIGBldGhfZmVlSGlzdG9yeWAgd2lsbCBiZSBtYWRlLlxuICogQHBhcmFtIGFyZ3MucGVyY2VudGlsZXMgLSBBIHNldCBvZiBudW1iZXJzIGJldHdlZW4gMSBhbmQgMTAwIHdoaWNoIHdpbGwgZGljdGF0ZSBob3dcbiAqIGBwcmlvcml0eUZlZXNCeVBlcmNlbnRpbGVgIGluIGVhY2ggcmV0dXJuZWQgYmxvY2sgd2lsbCBiZSBmb3JtZWQuIFdoZW4gRXRoZXJldW0gcnVucyB0aGVcbiAqIGBldGhfZmVlSGlzdG9yeWAgbWV0aG9kLCBmb3IgZWFjaCBibG9jayBpdCBpcyBjb25zaWRlcmluZywgaXQgd2lsbCBmaXJzdCBzb3J0IGFsbCB0cmFuc2FjdGlvbnMgYnlcbiAqIHRoZSBwcmlvcml0eSBmZWUuIEl0IHdpbGwgdGhlbiBnbyB0aHJvdWdoIGVhY2ggdHJhbnNhY3Rpb24gYW5kIGFkZCB0aGUgdG90YWwgYW1vdW50IG9mIGdhcyBwYWlkXG4gKiBmb3IgdGhhdCB0cmFuc2FjdGlvbiB0byBhIGJ1Y2tldCB3aGljaCBtYXhlcyBvdXQgYXQgdGhlIHRvdGFsIGdhcyB1c2VkIGZvciB0aGUgd2hvbGUgYmxvY2suIEFzXG4gKiB0aGUgYnVja2V0IGZpbGxzLCBpdCB3aWxsIGNyb3NzIHBlcmNlbnRhZ2VzIHdoaWNoIGNvcnJlc3BvbmQgdG8gdGhlIHBlcmNlbnRpbGVzIHNwZWNpZmllZCBoZXJlLFxuICogYW5kIHRoZSBwcmlvcml0eSBmZWVzIG9mIHRoZSBmaXJzdCB0cmFuc2FjdGlvbnMgd2hpY2ggY2F1c2UgaXQgdG8gcmVhY2ggdGhvc2UgcGVyY2VudGFnZXMgd2lsbCBiZVxuICogcmVjb3JkZWQuIEhlbmNlLCBgcHJpb3JpdHlGZWVzQnlQZXJjZW50aWxlYCByZXByZXNlbnRzIHRoZSBwcmlvcml0eSBmZWVzIG9mIHRyYW5zYWN0aW9ucyBhdCBrZXlcbiAqIGdhcyB1c2VkIGNvbnRyaWJ1dGlvbiBsZXZlbHMsIHdoZXJlIGVhcmxpZXIgbGV2ZWxzIGhhdmUgc21hbGxlciBjb250cmlidXRpb25zIGFuZCBsYXRlciBsZXZlbHNcbiAqIGhhdmUgaGlnaGVyIGNvbnRyaWJ1dGlvbnMuXG4gKiBAcGFyYW0gYXJncy5pbmNsdWRlTmV4dEJsb2NrIC0gV2hldGhlciB0byBpbmNsdWRlIGFuIGV4dHJhIGJsb2NrIHRoYXQgcmVwcmVzZW50cyB0aGUgbmV4dFxuICogYmxvY2sgYWZ0ZXIgdGhlIGxhdGVzdCBvbmUuIE9ubHkgdGhlIGBiYXNlRmVlUGVyR2FzYCB3aWxsIGJlIGZpbGxlZCBpbiBmb3IgdGhpcyBibG9jayAod2hpY2ggaXNcbiAqIGVzdGltYXRlZCkuXG4gKiBAcmV0dXJucyBUaGUgbGlzdCBvZiBibG9ja3MgYW5kIHRoZWlyIGZlZSBkYXRhLCBzb3J0ZWQgZnJvbSBvbGRlc3QgdG8gbmV3ZXN0LlxuICovXG5mdW5jdGlvbiBmZXRjaEJsb2NrRmVlSGlzdG9yeSh7IGV0aFF1ZXJ5LCBudW1iZXJPZkJsb2NrczogdG90YWxOdW1iZXJPZkJsb2NrcywgZW5kQmxvY2s6IGdpdmVuRW5kQmxvY2sgPSAnbGF0ZXN0JywgcGVyY2VudGlsZXM6IGdpdmVuUGVyY2VudGlsZXMgPSBbXSwgaW5jbHVkZU5leHRCbG9jayA9IGZhbHNlLCB9KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcGVyY2VudGlsZXMgPSBnaXZlblBlcmNlbnRpbGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gQXJyYXkuZnJvbShuZXcgU2V0KGdpdmVuUGVyY2VudGlsZXMpKS5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IGZpbmFsRW5kQmxvY2tOdW1iZXIgPSBnaXZlbkVuZEJsb2NrID09PSAnbGF0ZXN0J1xuICAgICAgICAgICAgPyAoMCwgdXRpbF8xLmZyb21IZXgpKHlpZWxkICgwLCB1dGlsXzEucXVlcnkpKGV0aFF1ZXJ5LCAnYmxvY2tOdW1iZXInKSlcbiAgICAgICAgICAgIDogZ2l2ZW5FbmRCbG9jaztcbiAgICAgICAgY29uc3QgcmVxdWVzdENodW5rU3BlY2lmaWVycyA9IGRldGVybWluZVJlcXVlc3RDaHVua1NwZWNpZmllcnMoZmluYWxFbmRCbG9ja051bWJlciwgdG90YWxOdW1iZXJPZkJsb2Nrcyk7XG4gICAgICAgIGNvbnN0IGJsb2NrQ2h1bmtzID0geWllbGQgUHJvbWlzZS5hbGwocmVxdWVzdENodW5rU3BlY2lmaWVycy5tYXAoKHsgbnVtYmVyT2ZCbG9ja3MsIGVuZEJsb2NrTnVtYmVyIH0sIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpID09PSByZXF1ZXN0Q2h1bmtTcGVjaWZpZXJzLmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICA/IG1ha2VSZXF1ZXN0Rm9yQ2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICBldGhRdWVyeSxcbiAgICAgICAgICAgICAgICAgICAgbnVtYmVyT2ZCbG9ja3MsXG4gICAgICAgICAgICAgICAgICAgIGVuZEJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICBwZXJjZW50aWxlcyxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZU5leHRCbG9jayxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIDogbWFrZVJlcXVlc3RGb3JDaHVuayh7XG4gICAgICAgICAgICAgICAgICAgIGV0aFF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICBudW1iZXJPZkJsb2NrcyxcbiAgICAgICAgICAgICAgICAgICAgZW5kQmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIHBlcmNlbnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlTmV4dEJsb2NrOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gYmxvY2tDaHVua3MucmVkdWNlKChhcnJheSwgYmxvY2tzKSA9PiBbLi4uYXJyYXksIC4uLmJsb2Nrc10sIFtdKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoQmxvY2tGZWVIaXN0b3J5O1xuLyoqXG4gKiBCdWlsZHMgYW4gRXhpc3RpbmdGZWVIaXN0b3J5QmxvY2suXG4gKlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJncyB0byB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIGFyZ3MubnVtYmVyIC0gVGhlIG51bWJlciBvZiB0aGUgYmxvY2suXG4gKiBAcGFyYW0gYXJncy5iYXNlRmVlUGVyR2FzIC0gVGhlIGJhc2UgZmVlIHBlciBnYXMgb2YgdGhlIGJsb2NrLlxuICogQHBhcmFtIGFyZ3MuYmxvY2tJbmRleCAtIFRoZSBpbmRleCBvZiB0aGUgYmxvY2sgaW4gdGhlIHNvdXJjZSBjaHVuay5cbiAqIEBwYXJhbSBhcmdzLmdhc1VzZWRSYXRpb3MgLSBUaGUgZ2FzIHVzZWQgcmF0aW9zIGZvciB0aGUgYmxvY2suXG4gKiBAcGFyYW0gYXJncy5wcmlvcml0eUZlZVBlcmNlbnRpbGVHcm91cHMgLSBUaGUgcHJpb3JpdHkgZmVlIHBlcmNlbnRpbGUgZ3JvdXBzIGZvciB0aGUgYmxvY2suXG4gKiBAcGFyYW0gYXJncy5wZXJjZW50aWxlcyAtIFRoZSBwZXJjZW50aWxlcyB1c2VkIHRvIGZldGNoIHRoZSBzb3VyY2UgY2h1bmsuXG4gKiBAcmV0dXJucyBUaGUgRXhpc3RpbmdGZWVIaXN0b3J5QmxvY2suXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkRXhpc3RpbmdGZWVIaXN0b3J5QmxvY2soeyBiYXNlRmVlUGVyR2FzLCBudW1iZXIsIGJsb2NrSW5kZXgsIGdhc1VzZWRSYXRpb3MsIHByaW9yaXR5RmVlUGVyY2VudGlsZUdyb3VwcywgcGVyY2VudGlsZXMsIH0pIHtcbiAgICBjb25zdCBnYXNVc2VkUmF0aW8gPSBnYXNVc2VkUmF0aW9zW2Jsb2NrSW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5RmVlc0ZvckVhY2hQZXJjZW50aWxlID0gcHJpb3JpdHlGZWVQZXJjZW50aWxlR3JvdXBzW2Jsb2NrSW5kZXhdO1xuICAgIGNvbnN0IHByaW9yaXR5RmVlc0J5UGVyY2VudGlsZSA9IHBlcmNlbnRpbGVzLnJlZHVjZSgob2JqLCBwZXJjZW50aWxlLCBwZXJjZW50aWxlSW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcHJpb3JpdHlGZWUgPSBwcmlvcml0eUZlZXNGb3JFYWNoUGVyY2VudGlsZVtwZXJjZW50aWxlSW5kZXhdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvYmopLCB7IFtwZXJjZW50aWxlXTogKDAsIHV0aWxfMS5mcm9tSGV4KShwcmlvcml0eUZlZSkgfSk7XG4gICAgfSwge30pO1xuICAgIHJldHVybiB7XG4gICAgICAgIG51bWJlcixcbiAgICAgICAgYmFzZUZlZVBlckdhcyxcbiAgICAgICAgZ2FzVXNlZFJhdGlvLFxuICAgICAgICBwcmlvcml0eUZlZXNCeVBlcmNlbnRpbGUsXG4gICAgfTtcbn1cbi8qKlxuICogQnVpbGRzIGEgTmV4dEZlZUhpc3RvcnlCbG9jay5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmdzIHRvIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0gYXJncy5iYXNlRmVlUGVyR2FzIC0gVGhlIGJhc2UgZmVlIHBlciBnYXMgb2YgdGhlIGJsb2NrLlxuICogQHBhcmFtIGFyZ3MubnVtYmVyIC0gVGhlIG51bWJlciBvZiB0aGUgYmxvY2suXG4gKiBAcmV0dXJucyBUaGUgTmV4dEZlZUhpc3RvcnlCbG9jay5cbiAqL1xuZnVuY3Rpb24gYnVpbGROZXh0RmVlSGlzdG9yeUJsb2NrKHsgYmFzZUZlZVBlckdhcywgbnVtYmVyLCB9KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbnVtYmVyLFxuICAgICAgICBiYXNlRmVlUGVyR2FzLFxuICAgICAgICBnYXNVc2VkUmF0aW86IG51bGwsXG4gICAgICAgIHByaW9yaXR5RmVlc0J5UGVyY2VudGlsZTogbnVsbCxcbiAgICB9O1xufVxuLyoqXG4gKiBVc2VzIGV0aF9mZWVIaXN0b3J5IHRvIHJlcXVlc3QgaGlzdG9yaWNhbCBkYXRhIGFib3V0IGEgZ3JvdXAgb2YgYmxvY2tzIChtYXggc2l6ZSAxMDI0KS5cbiAqXG4gKiBAcGFyYW0gYXJncyAtIFRoZSBhcmd1bWVudHNcbiAqIEBwYXJhbSBhcmdzLmV0aFF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2UuXG4gKiBAcGFyYW0gYXJncy5udW1iZXJPZkJsb2NrcyAtIFRoZSBudW1iZXIgb2YgYmxvY2tzIGluIHRoZSBjaHVuay4gTXVzdCBiZSBhdCBtb3N0IDEwMjQsIGFzIHRoaXMgaXNcbiAqIHRoZSBtYXhpbXVtIHRoYXQgYGV0aF9mZWVIaXN0b3J5YCBjYW4gcmV0dXJuIGluIG9uZSBjYWxsLlxuICogQHBhcmFtIGFyZ3MuZW5kQmxvY2tOdW1iZXIgLSBUaGUgZW5kIG9mIHRoZSByZXF1ZXN0ZWQgYmxvY2sgcmFuZ2UuXG4gKiBAcGFyYW0gYXJncy5wZXJjZW50aWxlcyAtIEEgc2V0IG9mIG51bWJlcnMgYmV0d2VlbiAxIGFuZCAxMDAgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcHVsbCBwcmlvcml0eVxuICogZmVlcyBmb3IgZWFjaCBibG9jay5cbiAqIEBwYXJhbSBhcmdzLmluY2x1ZGVOZXh0QmxvY2sgLSBXaGV0aGVyIHRvIGluY2x1ZGUgYW4gZXh0cmEgYmxvY2sgdGhhdCByZXByZXNlbnRzIHRoZSBuZXh0XG4gKiBibG9jayBhZnRlciB0aGUgbGF0ZXN0IG9uZS4gT25seSB0aGUgYGJhc2VGZWVQZXJHYXNgIHdpbGwgYmUgZmlsbGVkIGluIGZvciB0aGlzIGJsb2NrICh3aGljaCBpc1xuICogZXN0aW1hdGVkKS5cbiAqIEByZXR1cm5zIEEgbGlzdCBvZiBibG9jayBkYXRhLlxuICovXG5mdW5jdGlvbiBtYWtlUmVxdWVzdEZvckNodW5rKHsgZXRoUXVlcnksIG51bWJlck9mQmxvY2tzLCBlbmRCbG9ja051bWJlciwgcGVyY2VudGlsZXMsIGluY2x1ZGVOZXh0QmxvY2ssIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KShldGhRdWVyeSwgJ2V0aF9mZWVIaXN0b3J5JywgWygwLCB1dGlsXzEudG9IZXgpKG51bWJlck9mQmxvY2tzKSwgKDAsIHV0aWxfMS50b0hleCkoZW5kQmxvY2tOdW1iZXIpLCBwZXJjZW50aWxlc10pO1xuICAgICAgICBjb25zdCBzdGFydEJsb2NrTnVtYmVyID0gKDAsIHV0aWxfMS5mcm9tSGV4KShyZXNwb25zZS5vbGRlc3RCbG9jayk7XG4gICAgICAgIGlmIChyZXNwb25zZS5iYXNlRmVlUGVyR2FzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHJlc3BvbnNlLmJhc2VGZWVQZXJHYXMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgcmVzcG9uc2UuZ2FzVXNlZFJhdGlvLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIChyZXNwb25zZS5yZXdhcmQgPT09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5yZXdhcmQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIC8vIFBlclxuICAgICAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9ibG9iLzU3YTNmYWI4YTc1ZWViOWMyZjRmYWI3NzBiNzNiNTFiOWZlNjcyYzUvZXRoL2dhc3ByaWNlL2ZlZWhpc3RvcnkuZ28jTDE5MS1MMTkyPixcbiAgICAgICAgICAgIC8vIGJhc2VGZWVQZXJHYXMgd2lsbCBhbHdheXMgaW5jbHVkZSBhbiBleHRyYSBpdGVtIHdoaWNoIGlzIHRoZSBjYWxjdWxhdGVkIGJhc2UgZmVlIGZvciB0aGVcbiAgICAgICAgICAgIC8vIG5leHQgKGZ1dHVyZSkgYmxvY2suIFdlIG1heSBvciBtYXkgbm90IGNhcmUgYWJvdXQgdGhpczsgaWYgd2UgZG9uJ3QsIGNob3AgaXQgb2ZmLlxuICAgICAgICAgICAgY29uc3QgYmFzZUZlZXNQZXJHYXNBc0hleCA9IGluY2x1ZGVOZXh0QmxvY2tcbiAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmJhc2VGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlLmJhc2VGZWVQZXJHYXMuc2xpY2UoMCwgbnVtYmVyT2ZCbG9ja3MpO1xuICAgICAgICAgICAgY29uc3QgZ2FzVXNlZFJhdGlvcyA9IHJlc3BvbnNlLmdhc1VzZWRSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5RmVlUGVyY2VudGlsZUdyb3VwcyA9IChfYSA9IHJlc3BvbnNlLnJld2FyZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgICAgICAvLyBDaGFpbiBpcyBhbGxvd2VkIHRvIHJldHVybiBmZXdlciBudW1iZXIgb2YgYmxvY2sgcmVzdWx0c1xuICAgICAgICAgICAgY29uc3QgbnVtYmVyT2ZFeGlzdGluZ1Jlc3VsdHMgPSBnYXNVc2VkUmF0aW9zLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBiYXNlRmVlc1Blckdhc0FzSGV4Lm1hcCgoYmFzZUZlZVBlckdhc0FzSGV4LCBibG9ja0luZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUZlZVBlckdhcyA9ICgwLCB1dGlsXzEuZnJvbUhleCkoYmFzZUZlZVBlckdhc0FzSGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBudW1iZXIgPSBzdGFydEJsb2NrTnVtYmVyLmFkZG4oYmxvY2tJbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJsb2NrSW5kZXggPj0gbnVtYmVyT2ZFeGlzdGluZ1Jlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgPyBidWlsZE5leHRGZWVIaXN0b3J5QmxvY2soeyBiYXNlRmVlUGVyR2FzLCBudW1iZXIgfSlcbiAgICAgICAgICAgICAgICAgICAgOiBidWlsZEV4aXN0aW5nRmVlSGlzdG9yeUJsb2NrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9ja0luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FzVXNlZFJhdGlvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5RmVlUGVyY2VudGlsZUdyb3VwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlcmNlbnRpbGVzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9KTtcbn1cbi8qKlxuICogRGl2aWRlcyBhIGJsb2NrIHJhbmdlIChzcGVjaWZpZWQgYnkgYSByYW5nZSBzaXplIGFuZCB0aGUgZW5kIG9mIHRoZSByYW5nZSkgaW50byBjaHVua3MgYmFzZWQgb25cbiAqIHRoZSBtYXhpbXVtIG51bWJlciBvZiBibG9ja3MgdGhhdCBgZXRoX2ZlZUhpc3RvcnlgIGNhbiByZXR1cm4gaW4gYSBzaW5nbGUgY2FsbC5cbiAqXG4gKiBJZiB0aGUgcmVxdWVzdGVkIHRvdGFsTnVtYmVyT2ZCbG9ja3MgZXhjZWVkIGVuZEJsb2NrTnVtYmVyLCB0b3RhbE51bWJlck9mQmxvY2tzIGlzXG4gKiB0cnVuY2F0ZWQgdG8gYXZvaWQgcmVxdWVzdGluZyBjaHVua3Mgd2l0aCBuZWdhdGl2ZSBlbmRCbG9ja051bWJlci5cbiAqXG4gKiBAcGFyYW0gZW5kQmxvY2tOdW1iZXIgLSBUaGUgZmluYWwgYmxvY2sgaW4gdGhlIGNvbXBsZXRlIGRlc2lyZWQgYmxvY2sgcmFuZ2UgYWZ0ZXIgYWxsXG4gKiBgZXRoX2ZlZUhpc3RvcnlgIHJlcXVlc3RzIGhhdmUgYmVlbiBtYWRlLlxuICogQHBhcmFtIHRvdGFsTnVtYmVyT2ZCbG9ja3MgLSBUaGUgdG90YWwgbnVtYmVyIG9mIGRlc2lyZWQgYmxvY2tzIGFmdGVyIGFsbCBgZXRoX2ZlZUhpc3RvcnlgXG4gKiByZXF1ZXN0cyBoYXZlIGJlZW4gbWFkZS5cbiAqIEByZXR1cm5zIEEgc2V0IG9mIGFyZ3VtZW50cyB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgcmVxdWVzdHMgdG8gYGV0aF9mZWVIaXN0b3J5YCBpbiBvcmRlciB0b1xuICogcmV0cmlldmUgYWxsIG9mIHRoZSByZXF1ZXN0ZWQgYmxvY2tzLCBzb3J0ZWQgZnJvbSBvbGRlc3QgYmxvY2sgdG8gbmV3ZXN0IGJsb2NrLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVSZXF1ZXN0Q2h1bmtTcGVjaWZpZXJzKGVuZEJsb2NrTnVtYmVyLCB0b3RhbE51bWJlck9mQmxvY2tzKSB7XG4gICAgaWYgKGVuZEJsb2NrTnVtYmVyLmx0KG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih0b3RhbE51bWJlck9mQmxvY2tzKSkpIHtcbiAgICAgICAgdG90YWxOdW1iZXJPZkJsb2NrcyA9IGVuZEJsb2NrTnVtYmVyLnRvTnVtYmVyKCk7XG4gICAgfVxuICAgIGNvbnN0IHNwZWNpZmllcnMgPSBbXTtcbiAgICBmb3IgKGxldCBjaHVua1N0YXJ0QmxvY2tOdW1iZXIgPSBlbmRCbG9ja051bWJlci5zdWJuKHRvdGFsTnVtYmVyT2ZCbG9ja3MpOyBjaHVua1N0YXJ0QmxvY2tOdW1iZXIubHQoZW5kQmxvY2tOdW1iZXIpOyBjaHVua1N0YXJ0QmxvY2tOdW1iZXIgPSBjaHVua1N0YXJ0QmxvY2tOdW1iZXIuYWRkbihNQVhfTlVNQkVSX09GX0JMT0NLU19QRVJfRVRIX0ZFRV9ISVNUT1JZX0NBTEwpKSB7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVG9FbmQgPSBlbmRCbG9ja051bWJlci5zdWIoY2h1bmtTdGFydEJsb2NrTnVtYmVyKS50b051bWJlcigpO1xuICAgICAgICBjb25zdCBudW1iZXJPZkJsb2NrcyA9IGRpc3RhbmNlVG9FbmQgPCBNQVhfTlVNQkVSX09GX0JMT0NLU19QRVJfRVRIX0ZFRV9ISVNUT1JZX0NBTExcbiAgICAgICAgICAgID8gZGlzdGFuY2VUb0VuZFxuICAgICAgICAgICAgOiBNQVhfTlVNQkVSX09GX0JMT0NLU19QRVJfRVRIX0ZFRV9ISVNUT1JZX0NBTEw7XG4gICAgICAgIGNvbnN0IGNodW5rRW5kQmxvY2tOdW1iZXIgPSBjaHVua1N0YXJ0QmxvY2tOdW1iZXIuYWRkbihudW1iZXJPZkJsb2Nrcyk7XG4gICAgICAgIHNwZWNpZmllcnMucHVzaCh7IG51bWJlck9mQmxvY2tzLCBlbmRCbG9ja051bWJlcjogY2h1bmtFbmRCbG9ja051bWJlciB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHNwZWNpZmllcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaEJsb2NrRmVlSGlzdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXRoanNfdW5pdF8xID0gcmVxdWlyZShcImV0aGpzLXVuaXRcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi9jb25zdGFudHNcIik7XG5jb25zdCBmZXRjaEJsb2NrRmVlSGlzdG9yeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZldGNoQmxvY2tGZWVIaXN0b3J5XCIpKTtcbmNvbnN0IGZldGNoTGF0ZXN0QmxvY2tfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9mZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnkvZmV0Y2hMYXRlc3RCbG9ja1wiKSk7XG5jb25zdCBjYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVsc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2ZldGNoR2FzRXN0aW1hdGVzVmlhRXRoRmVlSGlzdG9yeS9jYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVsc1wiKSk7XG4vKipcbiAqIEdlbmVyYXRlcyBnYXMgZmVlIGVzdGltYXRlcyBiYXNlZCBvbiBnYXMgZmVlcyB0aGF0IGhhdmUgYmVlbiB1c2VkIGluIHRoZSByZWNlbnQgcGFzdCBzbyB0aGF0XG4gKiB0aG9zZSBlc3RpbWF0ZXMgY2FuIGJlIGRpc3BsYXllZCB0byB1c2Vycy5cbiAqXG4gKiBUbyBwcm9kdWNlIHRoZSBlc3RpbWF0ZXMsIHRoZSBsYXN0IDUgYmxvY2tzIGFyZSByZWFkIGZyb20gdGhlIG5ldHdvcmssIGFuZCBmb3IgZWFjaCBibG9jaywgdGhlXG4gKiBwcmlvcml0eSBmZWVzIGZvciB0cmFuc2FjdGlvbnMgYXQgdGhlIDEwdGgsIDIwdGgsIGFuZCAzMHRoIHBlcmNlbnRpbGVzIGFyZSBhbHNvIHJlYWQgKGhlcmVcbiAqIFwicGVyY2VudGlsZVwiIHNpZ25pZmllcyB0aGUgbGV2ZWwgYXQgd2hpY2ggdGhvc2UgdHJhbnNhY3Rpb25zIGNvbnRyaWJ1dGUgdG8gdGhlIG92ZXJhbGwgZ2FzIHVzZWRcbiAqIGZvciB0aGUgYmxvY2ssIHdoZXJlIGhpZ2hlciBwZXJjZW50aWxlcyBjb3JyZXNwb25kIHRvIGhpZ2hlciBmZWVzKS4gVGhpcyBpbmZvcm1hdGlvbiBpcyB1c2VkIHRvXG4gKiBjYWxjdWxhdGUgcmVhc29uYWJsZSBtYXggcHJpb3JpdHkgYW5kIG1heCBmZWVzIGZvciB0aHJlZSBkaWZmZXJlbnQgcHJpb3JpdHkgbGV2ZWxzIChoaWdoZXJcbiAqIHByaW9yaXR5ID0gaGlnaGVyIGZlZSkuXG4gKlxuICogTm90ZSB0aGF0IHByb3BlcnRpZXMgYXJlIHJldHVybmVkIGZvciBvdGhlciBkYXRhIHRoYXQgYXJlIG5vcm1hbGx5IG9idGFpbmVkIHZpYSB0aGUgQVBJOyBob3dldmVyLFxuICogdG8gcHJldmVudCBleHRyYSByZXF1ZXN0cyB0byBJbmZ1cmEsIHRoZXNlIHByb3BlcnRpZXMgYXJlIGVtcHR5LlxuICpcbiAqIEBwYXJhbSBldGhRdWVyeSAtIEFuIEV0aFF1ZXJ5IGluc3RhbmNlLlxuICogQHJldHVybnMgQmFzZSBhbmQgcHJpb3JpdHkgZmVlIGVzdGltYXRlcywgY2F0ZWdvcml6ZWQgYnkgcHJpb3JpdHkgbGV2ZWwsIGFzIHdlbGwgYXMgYW4gZXN0aW1hdGVcbiAqIGZvciB0aGUgbmV4dCBibG9jaydzIGJhc2UgZmVlLlxuICovXG5mdW5jdGlvbiBmZXRjaEdhc0VzdGltYXRlc1ZpYUV0aEZlZUhpc3RvcnkoZXRoUXVlcnkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9jayA9IHlpZWxkICgwLCBmZXRjaExhdGVzdEJsb2NrXzEuZGVmYXVsdCkoZXRoUXVlcnkpO1xuICAgICAgICBjb25zdCBibG9ja3MgPSB5aWVsZCAoMCwgZmV0Y2hCbG9ja0ZlZUhpc3RvcnlfMS5kZWZhdWx0KSh7XG4gICAgICAgICAgICBldGhRdWVyeSxcbiAgICAgICAgICAgIGVuZEJsb2NrOiBsYXRlc3RCbG9jay5udW1iZXIsXG4gICAgICAgICAgICBudW1iZXJPZkJsb2NrczogNSxcbiAgICAgICAgICAgIHBlcmNlbnRpbGVzOiBbMTAsIDIwLCAzMF0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlc3RpbWF0ZWRCYXNlRmVlID0gKDAsIGV0aGpzX3VuaXRfMS5mcm9tV2VpKShsYXRlc3RCbG9jay5iYXNlRmVlUGVyR2FzLCBjb25zdGFudHNfMS5HV0VJKTtcbiAgICAgICAgY29uc3QgbGV2ZWxTcGVjaWZpY0VzdGltYXRlcyA9ICgwLCBjYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVsc18xLmRlZmF1bHQpKGJsb2Nrcyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxldmVsU3BlY2lmaWNFc3RpbWF0ZXMpLCB7IGVzdGltYXRlZEJhc2VGZWUsIGhpc3RvcmljYWxCYXNlRmVlUmFuZ2U6IG51bGwsIGJhc2VGZWVUcmVuZDogbnVsbCwgbGF0ZXN0UHJpb3JpdHlGZWVSYW5nZTogbnVsbCwgaGlzdG9yaWNhbFByaW9yaXR5RmVlUmFuZ2U6IG51bGwsIHByaW9yaXR5RmVlVHJlbmQ6IG51bGwsIG5ldHdvcmtDb25nZXN0aW9uOiBudWxsIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmV0Y2hHYXNFc3RpbWF0ZXNWaWFFdGhGZWVIaXN0b3J5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXRoZXJldW1qc191dGlsXzEgPSByZXF1aXJlKFwiZXRoZXJldW1qcy11dGlsXCIpO1xuY29uc3QgZXRoanNfdW5pdF8xID0gcmVxdWlyZShcImV0aGpzLXVuaXRcIik7XG5jb25zdCBjb25zdGFudHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb25zdGFudHNcIik7XG5jb25zdCBtZWRpYW5PZl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL21lZGlhbk9mXCIpKTtcbmNvbnN0IFBSSU9SSVRZX0xFVkVMUyA9IFsnbG93JywgJ21lZGl1bScsICdoaWdoJ107XG5jb25zdCBQUklPUklUWV9MRVZFTF9QRVJDRU5USUxFUyA9IFsxMCwgMjAsIDMwXTtcbmNvbnN0IFNFVFRJTkdTX0JZX1BSSU9SSVRZX0xFVkVMID0ge1xuICAgIGxvdzoge1xuICAgICAgICBwZXJjZW50aWxlOiAxMCxcbiAgICAgICAgYmFzZUZlZVBlcmNlbnRhZ2VNdWx0aXBsaWVyOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oMTEwKSxcbiAgICAgICAgcHJpb3JpdHlGZWVQZXJjZW50YWdlTXVsdGlwbGllcjogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDk0KSxcbiAgICAgICAgbWluU3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxMDAwMDAwMDAwKSxcbiAgICAgICAgZXN0aW1hdGVkV2FpdFRpbWVzOiB7XG4gICAgICAgICAgICBtaW5XYWl0VGltZUVzdGltYXRlOiAxNTAwMCxcbiAgICAgICAgICAgIG1heFdhaXRUaW1lRXN0aW1hdGU6IDMwMDAwLFxuICAgICAgICB9LFxuICAgIH0sXG4gICAgbWVkaXVtOiB7XG4gICAgICAgIHBlcmNlbnRpbGU6IDIwLFxuICAgICAgICBiYXNlRmVlUGVyY2VudGFnZU11bHRpcGxpZXI6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxMjApLFxuICAgICAgICBwcmlvcml0eUZlZVBlcmNlbnRhZ2VNdWx0aXBsaWVyOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oOTcpLFxuICAgICAgICBtaW5TdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDE1MDAwMDAwMDApLFxuICAgICAgICBlc3RpbWF0ZWRXYWl0VGltZXM6IHtcbiAgICAgICAgICAgIG1pbldhaXRUaW1lRXN0aW1hdGU6IDE1MDAwLFxuICAgICAgICAgICAgbWF4V2FpdFRpbWVFc3RpbWF0ZTogNDUwMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBoaWdoOiB7XG4gICAgICAgIHBlcmNlbnRpbGU6IDMwLFxuICAgICAgICBiYXNlRmVlUGVyY2VudGFnZU11bHRpcGxpZXI6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigxMjUpLFxuICAgICAgICBwcmlvcml0eUZlZVBlcmNlbnRhZ2VNdWx0aXBsaWVyOiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oOTgpLFxuICAgICAgICBtaW5TdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKDIwMDAwMDAwMDApLFxuICAgICAgICBlc3RpbWF0ZWRXYWl0VGltZXM6IHtcbiAgICAgICAgICAgIG1pbldhaXRUaW1lRXN0aW1hdGU6IDE1MDAwLFxuICAgICAgICAgICAgbWF4V2FpdFRpbWVFc3RpbWF0ZTogNjAwMDAsXG4gICAgICAgIH0sXG4gICAgfSxcbn07XG4vKipcbiAqIENhbGN1bGF0ZXMgYSBzZXQgb2YgZXN0aW1hdGVzIGFzc2lnbmVkIHRvIGEgcGFydGljdWxhciBwcmlvcml0eSBsZXZlbCBiYXNlZCBvbiB0aGUgZGF0YSByZXR1cm5lZFxuICogYnkgYGV0aF9mZWVIaXN0b3J5YC5cbiAqXG4gKiBAcGFyYW0gcHJpb3JpdHlMZXZlbCAtIFRoZSBsZXZlbCBvZiBmZWVzIHRoYXQgZGljdGF0ZXMgaG93IHNvb24gYSB0cmFuc2FjdGlvbiBtYXkgZ28gdGhyb3VnaFxuICogKFwibG93XCIsIFwibWVkaXVtXCIsIG9yIFwiaGlnaFwiKS5cbiAqIEBwYXJhbSBibG9ja3MgLSBBIHNldCBvZiBibG9ja3MgYXMgb2J0YWluZWQgZnJvbSB7QGxpbmsgZmV0Y2hCbG9ja0ZlZUhpc3Rvcnl9LlxuICogQHJldHVybnMgVGhlIGVzdGltYXRlcy5cbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsLCBibG9ja3MpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IFNFVFRJTkdTX0JZX1BSSU9SSVRZX0xFVkVMW3ByaW9yaXR5TGV2ZWxdO1xuICAgIGNvbnN0IGxhdGVzdEJhc2VGZWVQZXJHYXMgPSBibG9ja3NbYmxvY2tzLmxlbmd0aCAtIDFdLmJhc2VGZWVQZXJHYXM7XG4gICAgY29uc3QgYWRqdXN0ZWRCYXNlRmVlID0gbGF0ZXN0QmFzZUZlZVBlckdhc1xuICAgICAgICAubXVsKHNldHRpbmdzLmJhc2VGZWVQZXJjZW50YWdlTXVsdGlwbGllcilcbiAgICAgICAgLmRpdm4oMTAwKTtcbiAgICBjb25zdCBwcmlvcml0eUZlZXMgPSBibG9ja3NcbiAgICAgICAgLm1hcCgoYmxvY2spID0+IHtcbiAgICAgICAgcmV0dXJuICdwcmlvcml0eUZlZXNCeVBlcmNlbnRpbGUnIGluIGJsb2NrXG4gICAgICAgICAgICA/IGJsb2NrLnByaW9yaXR5RmVlc0J5UGVyY2VudGlsZVtzZXR0aW5ncy5wZXJjZW50aWxlXVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH0pXG4gICAgICAgIC5maWx0ZXIoZXRoZXJldW1qc191dGlsXzEuQk4uaXNCTik7XG4gICAgY29uc3QgbWVkaWFuUHJpb3JpdHlGZWUgPSAoMCwgbWVkaWFuT2ZfMS5kZWZhdWx0KShwcmlvcml0eUZlZXMpO1xuICAgIGNvbnN0IGFkanVzdGVkUHJpb3JpdHlGZWUgPSBtZWRpYW5Qcmlvcml0eUZlZVxuICAgICAgICAubXVsKHNldHRpbmdzLnByaW9yaXR5RmVlUGVyY2VudGFnZU11bHRpcGxpZXIpXG4gICAgICAgIC5kaXZuKDEwMCk7XG4gICAgY29uc3Qgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBldGhlcmV1bWpzX3V0aWxfMS5CTi5tYXgoYWRqdXN0ZWRQcmlvcml0eUZlZSwgc2V0dGluZ3MubWluU3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGNvbnN0IHN1Z2dlc3RlZE1heEZlZVBlckdhcyA9IGFkanVzdGVkQmFzZUZlZS5hZGQoc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNldHRpbmdzLmVzdGltYXRlZFdhaXRUaW1lcyksIHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6ICgwLCBldGhqc191bml0XzEuZnJvbVdlaSkoc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMsIGNvbnN0YW50c18xLkdXRUkpLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXM6ICgwLCBldGhqc191bml0XzEuZnJvbVdlaSkoc3VnZ2VzdGVkTWF4RmVlUGVyR2FzLCBjb25zdGFudHNfMS5HV0VJKSB9KTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBhIHNldCBvZiBlc3RpbWF0ZXMgc3VpdGFibGUgZm9yIGRpZmZlcmVudCBwcmlvcml0eSBsZXZlbHMgYmFzZWQgb24gdGhlIGRhdGEgcmV0dXJuZWRcbiAqIGJ5IGBldGhfZmVlSGlzdG9yeWAuXG4gKlxuICogQHBhcmFtIGJsb2NrcyAtIEEgc2V0IG9mIGJsb2NrcyBwb3B1bGF0ZWQgd2l0aCBkYXRhIGZvciBwcmlvcml0eSBmZWUgcGVyY2VudGlsZXMgMTAsIDIwLCBhbmQgMzAsXG4gKiBvYnRhaW5lZCB2aWEge0BsaW5rIEJsb2NrRmVlSGlzdG9yeURhdGFzZXRGZXRjaGVyfS5cbiAqIEByZXR1cm5zIFRoZSBlc3RpbWF0ZXMuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUdhc0ZlZUVzdGltYXRlc0ZvclByaW9yaXR5TGV2ZWxzKGJsb2Nrcykge1xuICAgIHJldHVybiBQUklPUklUWV9MRVZFTFMucmVkdWNlKChvYmosIHByaW9yaXR5TGV2ZWwpID0+IHtcbiAgICAgICAgY29uc3QgZ2FzRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbCA9IGNhbGN1bGF0ZUVzdGltYXRlc0ZvclByaW9yaXR5TGV2ZWwocHJpb3JpdHlMZXZlbCwgYmxvY2tzKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2JqKSwgeyBbcHJpb3JpdHlMZXZlbF06IGdhc0VzdGltYXRlc0ZvclByaW9yaXR5TGV2ZWwgfSk7XG4gICAgfSwge30pO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gY2FsY3VsYXRlR2FzRmVlRXN0aW1hdGVzRm9yUHJpb3JpdHlMZXZlbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jYWxjdWxhdGVHYXNGZWVFc3RpbWF0ZXNGb3JQcmlvcml0eUxldmVscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG4vKipcbiAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBjb21wbGV0ZWQgYmxvY2suXG4gKlxuICogQHBhcmFtIGV0aFF1ZXJ5IC0gQW4gRXRoUXVlcnkgaW5zdGFuY2VcbiAqIEBwYXJhbSBpbmNsdWRlRnVsbFRyYW5zYWN0aW9uRGF0YSAtIFdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgYWxsIGRhdGEgZm9yIHRyYW5zYWN0aW9ucyBhc1xuICogb3Bwb3NlZCB0byBtZXJlbHkgaGFzaGVzLiBGYWxzZSBieSBkZWZhdWx0LlxuICogQHJldHVybnMgVGhlIGJsb2NrLlxuICovXG5mdW5jdGlvbiBmZXRjaExhdGVzdEJsb2NrKGV0aFF1ZXJ5LCBpbmNsdWRlRnVsbFRyYW5zYWN0aW9uRGF0YSA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KShldGhRdWVyeSwgJ2Jsb2NrTnVtYmVyJyk7XG4gICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgKDAsIHV0aWxfMS5xdWVyeSkoZXRoUXVlcnksICdnZXRCbG9ja0J5TnVtYmVyJywgW1xuICAgICAgICAgICAgYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICBpbmNsdWRlRnVsbFRyYW5zYWN0aW9uRGF0YSxcbiAgICAgICAgXSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJsb2NrKSwgeyBudW1iZXI6ICgwLCB1dGlsXzEuZnJvbUhleCkoYmxvY2subnVtYmVyKSwgYmFzZUZlZVBlckdhczogKDAsIHV0aWxfMS5mcm9tSGV4KShibG9jay5iYXNlRmVlUGVyR2FzKSB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoTGF0ZXN0QmxvY2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZXRjaExhdGVzdEJsb2NrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBGaW5kcyB0aGUgbWVkaWFuIGFtb25nIGEgbGlzdCBvZiBudW1iZXJzLiBOb3RlIHRoYXQgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIGluIHRoZSBNZXRhU3dhcCBBUEksIGFzIHdlIHdhbnQgdG8gaG9sZCB0byB1c2luZyBCTiBhcyBtdWNoIGFzIHBvc3NpYmxlLlxuICpcbiAqIEBwYXJhbSBudW1iZXJzIC0gQSBsaXN0IG9mIG51bWJlcnMsIGFzIEJOcy4gV2lsbCBiZSBzb3J0ZWQgYXV0b21hdGljYWxseSBpZiB1bnNvcnRlZC5cbiAqIEByZXR1cm5zIFRoZSBtZWRpYW4gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBtZWRpYW5PZihudW1iZXJzKSB7XG4gICAgY29uc3Qgc29ydGVkTnVtYmVycyA9IG51bWJlcnMuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhLmNtcChiKSk7XG4gICAgY29uc3QgbGVuID0gc29ydGVkTnVtYmVycy5sZW5ndGg7XG4gICAgY29uc3QgaW5kZXggPSBNYXRoLmZsb29yKChsZW4gLSAxKSAvIDIpO1xuICAgIHJldHVybiBzb3J0ZWROdW1iZXJzW2luZGV4XTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG1lZGlhbk9mO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWFuT2YuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2FsY3VsYXRlVGltZUVzdGltYXRlID0gZXhwb3J0cy5mZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUgPSBleHBvcnRzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMgPSBleHBvcnRzLmZldGNoR2FzRXN0aW1hdGVzID0gZXhwb3J0cy5ub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMgPSB2b2lkIDA7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IG1ha2VDbGllbnRJZEhlYWRlciA9IChjbGllbnRJZCkgPT4gKHsgJ1gtQ2xpZW50LUlkJzogY2xpZW50SWQgfSk7XG4vKipcbiAqIENvbnZlcnQgYSBkZWNpbWFsIEdXRUkgdmFsdWUgdG8gYSBkZWNpbWFsIHN0cmluZyByb3VuZGVkIHRvIHRoZSBuZWFyZXN0IFdFSS5cbiAqXG4gKiBAcGFyYW0gbiAtIFRoZSBpbnB1dCBHV0VJIGFtb3VudCwgYXMgYSBkZWNpbWFsIHN0cmluZyBvciBhIG51bWJlci5cbiAqIEByZXR1cm5zIFRoZSBkZWNpbWFsIHN0cmluZyBHV0VJIGFtb3VudC5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKG4pIHtcbiAgICBjb25zdCBudW1iZXJBc1dFSUhleCA9ICgwLCB1dGlsXzEuZ3dlaURlY1RvV0VJQk4pKG4pLnRvU3RyaW5nKDE2KTtcbiAgICBjb25zdCBudW1iZXJBc0dXRUkgPSAoMCwgdXRpbF8xLndlaUhleFRvR3dlaURlYykobnVtYmVyQXNXRUlIZXgpLnRvU3RyaW5nKDEwKTtcbiAgICByZXR1cm4gbnVtYmVyQXNHV0VJO1xufVxuZXhwb3J0cy5ub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMgPSBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnM7XG4vKipcbiAqIEZldGNoIGdhcyBlc3RpbWF0ZXMgZnJvbSB0aGUgZ2l2ZW4gVVJMLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgZ2FzIGVzdGltYXRlIFVSTC5cbiAqIEBwYXJhbSBjbGllbnRJZCAtIFRoZSBjbGllbnQgSUQgdXNlZCB0byBpZGVudGlmeSB0byB0aGUgQVBJIHdobyBpcyBhc2tpbmcgZm9yIGVzdGltYXRlcy5cbiAqIEByZXR1cm5zIFRoZSBnYXMgZXN0aW1hdGVzLlxuICovXG5mdW5jdGlvbiBmZXRjaEdhc0VzdGltYXRlcyh1cmwsIGNsaWVudElkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZXN0aW1hdGVzID0geWllbGQgKDAsIHV0aWxfMS5oYW5kbGVGZXRjaCkodXJsLCBjbGllbnRJZCA/IHsgaGVhZGVyczogbWFrZUNsaWVudElkSGVhZGVyKGNsaWVudElkKSB9IDogdW5kZWZpbmVkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvdzogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlc3RpbWF0ZXMubG93KSwgeyBzdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhczogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5sb3cuc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpLCBzdWdnZXN0ZWRNYXhGZWVQZXJHYXM6IG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhlc3RpbWF0ZXMubG93LnN1Z2dlc3RlZE1heEZlZVBlckdhcykgfSksXG4gICAgICAgICAgICBtZWRpdW06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXN0aW1hdGVzLm1lZGl1bSksIHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhlc3RpbWF0ZXMubWVkaXVtLnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKSwgc3VnZ2VzdGVkTWF4RmVlUGVyR2FzOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLm1lZGl1bS5zdWdnZXN0ZWRNYXhGZWVQZXJHYXMpIH0pLFxuICAgICAgICAgICAgaGlnaDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlc3RpbWF0ZXMuaGlnaCksIHsgc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXM6IG5vcm1hbGl6ZUdXRUlEZWNpbWFsTnVtYmVycyhlc3RpbWF0ZXMuaGlnaC5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyksIHN1Z2dlc3RlZE1heEZlZVBlckdhczogbm9ybWFsaXplR1dFSURlY2ltYWxOdW1iZXJzKGVzdGltYXRlcy5oaWdoLnN1Z2dlc3RlZE1heEZlZVBlckdhcykgfSksXG4gICAgICAgICAgICBlc3RpbWF0ZWRCYXNlRmVlOiBub3JtYWxpemVHV0VJRGVjaW1hbE51bWJlcnMoZXN0aW1hdGVzLmVzdGltYXRlZEJhc2VGZWUpLFxuICAgICAgICAgICAgaGlzdG9yaWNhbEJhc2VGZWVSYW5nZTogZXN0aW1hdGVzLmhpc3RvcmljYWxCYXNlRmVlUmFuZ2UsXG4gICAgICAgICAgICBiYXNlRmVlVHJlbmQ6IGVzdGltYXRlcy5iYXNlRmVlVHJlbmQsXG4gICAgICAgICAgICBsYXRlc3RQcmlvcml0eUZlZVJhbmdlOiBlc3RpbWF0ZXMubGF0ZXN0UHJpb3JpdHlGZWVSYW5nZSxcbiAgICAgICAgICAgIGhpc3RvcmljYWxQcmlvcml0eUZlZVJhbmdlOiBlc3RpbWF0ZXMuaGlzdG9yaWNhbFByaW9yaXR5RmVlUmFuZ2UsXG4gICAgICAgICAgICBwcmlvcml0eUZlZVRyZW5kOiBlc3RpbWF0ZXMucHJpb3JpdHlGZWVUcmVuZCxcbiAgICAgICAgICAgIG5ldHdvcmtDb25nZXN0aW9uOiBlc3RpbWF0ZXMubmV0d29ya0Nvbmdlc3Rpb24sXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoR2FzRXN0aW1hdGVzID0gZmV0Y2hHYXNFc3RpbWF0ZXM7XG4vKipcbiAqIEhpdCB0aGUgbGVnYWN5IE1ldGFTd2FwcyBnYXNQcmljZXMgZXN0aW1hdGUgYXBpIGFuZCByZXR1cm4gdGhlIGxvdywgbWVkaXVtXG4gKiBoaWdoIHZhbHVlcyBmcm9tIHRoYXQgQVBJLlxuICpcbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIGZldGNoIGdhcyBwcmljZSBlc3RpbWF0ZXMgZnJvbS5cbiAqIEBwYXJhbSBjbGllbnRJZCAtIFRoZSBjbGllbnQgSUQgdXNlZCB0byBpZGVudGlmeSB0byB0aGUgQVBJIHdobyBpcyBhc2tpbmcgZm9yIGVzdGltYXRlcy5cbiAqIEByZXR1cm5zIFRoZSBnYXMgcHJpY2UgZXN0aW1hdGVzLlxuICovXG5mdW5jdGlvbiBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzKHVybCwgY2xpZW50SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCAoMCwgdXRpbF8xLmhhbmRsZUZldGNoKSh1cmwsIHtcbiAgICAgICAgICAgIHJlZmVycmVyOiB1cmwsXG4gICAgICAgICAgICByZWZlcnJlclBvbGljeTogJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBtb2RlOiAnY29ycycsXG4gICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyB9LCAoY2xpZW50SWQgJiYgbWFrZUNsaWVudElkSGVhZGVyKGNsaWVudElkKSkpLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvdzogcmVzdWx0LlNhZmVHYXNQcmljZSxcbiAgICAgICAgICAgIG1lZGl1bTogcmVzdWx0LlByb3Bvc2VHYXNQcmljZSxcbiAgICAgICAgICAgIGhpZ2g6IHJlc3VsdC5GYXN0R2FzUHJpY2UsXG4gICAgICAgIH07XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoTGVnYWN5R2FzUHJpY2VFc3RpbWF0ZXMgPSBmZXRjaExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVzO1xuLyoqXG4gKiBHZXQgYSBnYXMgcHJpY2UgZXN0aW1hdGUgZnJvbSB0aGUgbmV0d29yayB1c2luZyB0aGUgYGV0aF9nYXNQcmljZWAgbWV0aG9kLlxuICpcbiAqIEBwYXJhbSBldGhRdWVyeSAtIFRoZSBFdGhRdWVyeSBpbnN0YW5jZSB0byBjYWxsIHRoZSBuZXR3b3JrIHdpdGguXG4gKiBAcmV0dXJucyBBIGdhcyBwcmljZSBlc3RpbWF0ZS5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hFdGhHYXNQcmljZUVzdGltYXRlKGV0aFF1ZXJ5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KShldGhRdWVyeSwgJ2dhc1ByaWNlJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnYXNQcmljZTogKDAsIHV0aWxfMS53ZWlIZXhUb0d3ZWlEZWMpKGdhc1ByaWNlKS50b1N0cmluZygpLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuZXhwb3J0cy5mZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGUgPSBmZXRjaEV0aEdhc1ByaWNlRXN0aW1hdGU7XG4vKipcbiAqIEVzdGltYXRlIHRoZSB0aW1lIGl0IHdpbGwgdGFrZSBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBjb25maXJtZWQuXG4gKlxuICogQHBhcmFtIG1heFByaW9yaXR5RmVlUGVyR2FzIC0gVGhlIG1heCBwcmlvcml0eSBmZWUgcGVyIGdhcy5cbiAqIEBwYXJhbSBtYXhGZWVQZXJHYXMgLSBUaGUgbWF4IGZlZSBwZXIgZ2FzLlxuICogQHBhcmFtIGdhc0ZlZUVzdGltYXRlcyAtIFRoZSBnYXMgZmVlIGVzdGltYXRlcy5cbiAqIEByZXR1cm5zIFRoZSBlc3RpbWF0ZWQgbG93ZXIgYW5kIHVwcGVyIGJvdW5kcyBmb3Igd2hlbiB0aGlzIHRyYW5zYWN0aW9uIHdpbGwgYmUgY29uZmlybWVkLlxuICovXG5mdW5jdGlvbiBjYWxjdWxhdGVUaW1lRXN0aW1hdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzRmVlRXN0aW1hdGVzKSB7XG4gICAgY29uc3QgeyBsb3csIG1lZGl1bSwgaGlnaCwgZXN0aW1hdGVkQmFzZUZlZSB9ID0gZ2FzRmVlRXN0aW1hdGVzO1xuICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzSW5XRUkgPSAoMCwgdXRpbF8xLmd3ZWlEZWNUb1dFSUJOKShtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgY29uc3QgbWF4RmVlUGVyR2FzSW5XRUkgPSAoMCwgdXRpbF8xLmd3ZWlEZWNUb1dFSUJOKShtYXhGZWVQZXJHYXMpO1xuICAgIGNvbnN0IGVzdGltYXRlZEJhc2VGZWVJbldFSSA9ICgwLCB1dGlsXzEuZ3dlaURlY1RvV0VJQk4pKGVzdGltYXRlZEJhc2VGZWUpO1xuICAgIGNvbnN0IGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlID0gZXRoZXJldW1qc191dGlsXzEuQk4ubWluKG1heFByaW9yaXR5RmVlUGVyR2FzSW5XRUksIG1heEZlZVBlckdhc0luV0VJLnN1Yihlc3RpbWF0ZWRCYXNlRmVlSW5XRUkpKTtcbiAgICBjb25zdCBsb3dNYXhQcmlvcml0eUZlZUluV0VJID0gKDAsIHV0aWxfMS5nd2VpRGVjVG9XRUlCTikobG93LnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBjb25zdCBtZWRpdW1NYXhQcmlvcml0eUZlZUluV0VJID0gKDAsIHV0aWxfMS5nd2VpRGVjVG9XRUlCTikobWVkaXVtLnN1Z2dlc3RlZE1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICBjb25zdCBoaWdoTWF4UHJpb3JpdHlGZWVJbldFSSA9ICgwLCB1dGlsXzEuZ3dlaURlY1RvV0VJQk4pKGhpZ2guc3VnZ2VzdGVkTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGxldCBsb3dlclRpbWVCb3VuZDtcbiAgICBsZXQgdXBwZXJUaW1lQm91bmQ7XG4gICAgaWYgKGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmx0KGxvd01heFByaW9yaXR5RmVlSW5XRUkpKSB7XG4gICAgICAgIGxvd2VyVGltZUJvdW5kID0gbnVsbDtcbiAgICAgICAgdXBwZXJUaW1lQm91bmQgPSAndW5rbm93bic7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmd0ZShsb3dNYXhQcmlvcml0eUZlZUluV0VJKSAmJlxuICAgICAgICBlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5sdChtZWRpdW1NYXhQcmlvcml0eUZlZUluV0VJKSkge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IGxvdy5taW5XYWl0VGltZUVzdGltYXRlO1xuICAgICAgICB1cHBlclRpbWVCb3VuZCA9IGxvdy5tYXhXYWl0VGltZUVzdGltYXRlO1xuICAgIH1cbiAgICBlbHNlIGlmIChlZmZlY3RpdmVNYXhQcmlvcml0eUZlZS5ndGUobWVkaXVtTWF4UHJpb3JpdHlGZWVJbldFSSkgJiZcbiAgICAgICAgZWZmZWN0aXZlTWF4UHJpb3JpdHlGZWUubHQoaGlnaE1heFByaW9yaXR5RmVlSW5XRUkpKSB7XG4gICAgICAgIGxvd2VyVGltZUJvdW5kID0gbWVkaXVtLm1pbldhaXRUaW1lRXN0aW1hdGU7XG4gICAgICAgIHVwcGVyVGltZUJvdW5kID0gbWVkaXVtLm1heFdhaXRUaW1lRXN0aW1hdGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVmZmVjdGl2ZU1heFByaW9yaXR5RmVlLmVxKGhpZ2hNYXhQcmlvcml0eUZlZUluV0VJKSkge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IGhpZ2gubWluV2FpdFRpbWVFc3RpbWF0ZTtcbiAgICAgICAgdXBwZXJUaW1lQm91bmQgPSBoaWdoLm1heFdhaXRUaW1lRXN0aW1hdGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCA9IDA7XG4gICAgICAgIHVwcGVyVGltZUJvdW5kID0gaGlnaC5tYXhXYWl0VGltZUVzdGltYXRlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsb3dlclRpbWVCb3VuZCxcbiAgICAgICAgdXBwZXJUaW1lQm91bmQsXG4gICAgfTtcbn1cbmV4cG9ydHMuY2FsY3VsYXRlVGltZUVzdGltYXRlID0gY2FsY3VsYXRlVGltZUVzdGltYXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FzLXV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZvcm1hdEljb25VcmxXaXRoUHJveHkgPSBleHBvcnRzLnV0aWwgPSBleHBvcnRzLmdldEFub255bWl6ZWRTdGF0ZSA9IGV4cG9ydHMuZ2V0UGVyc2lzdGVudFN0YXRlID0gZXhwb3J0cy5CYXNlQ29udHJvbGxlclYyID0gdm9pZCAwO1xucmVxdWlyZShcImlzb21vcnBoaWMtZmV0Y2hcIik7XG5jb25zdCB1dGlsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxcIikpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbmNvbnN0IGFzc2V0c1V0aWxfMSA9IHJlcXVpcmUoXCIuL2Fzc2V0cy9hc3NldHNVdGlsXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZm9ybWF0SWNvblVybFdpdGhQcm94eVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYXNzZXRzVXRpbF8xLmZvcm1hdEljb25VcmxXaXRoUHJveHk7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL0FjY291bnRUcmFja2VyQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXNlci9BZGRyZXNzQm9va0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2FwcHJvdmFsL0FwcHJvdmFsQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL0Fzc2V0c0NvbnRyYWN0Q29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQmFzZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xudmFyIEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuL0Jhc2VDb250cm9sbGVyVjJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJCYXNlQ29udHJvbGxlclYyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXI7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRQZXJzaXN0ZW50U3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2VDb250cm9sbGVyVjJfMS5nZXRQZXJzaXN0ZW50U3RhdGU7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRBbm9ueW1pemVkU3RhdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJhc2VDb250cm9sbGVyVjJfMS5nZXRBbm9ueW1pemVkU3RhdGU7IH0gfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tcG9zYWJsZUNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbnRyb2xsZXJNZXNzZW5nZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9DdXJyZW5jeVJhdGVDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9rZXlyaW5nL0tleXJpbmdDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXNzYWdlLW1hbmFnZXIvTWVzc2FnZU1hbmFnZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25ldHdvcmsvTmV0d29ya0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3RoaXJkLXBhcnR5L1BoaXNoaW5nQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vdXNlci9QcmVmZXJlbmNlc0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Ub2tlbkJhbGFuY2VzQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL1Rva2VuUmF0ZXNDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi90cmFuc2FjdGlvbi9UcmFuc2FjdGlvbkNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21lc3NhZ2UtbWFuYWdlci9QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXNzYWdlLW1hbmFnZXIvVHlwZWRNZXNzYWdlTWFuYWdlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYW5ub3VuY2VtZW50L0Fubm91bmNlbWVudENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Ub2tlbkxpc3RDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9nYXMvR2FzRmVlQ29udHJvbGxlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXNzZXRzL1Rva2Vuc0NvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2V0cy9Db2xsZWN0aWJsZXNDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvVG9rZW5EZXRlY3Rpb25Db250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hc3NldHMvQ29sbGVjdGlibGVEZXRlY3Rpb25Db250cm9sbGVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wZXJtaXNzaW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3ViamVjdC1tZXRhZGF0YVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmF0ZWxpbWl0L1JhdGVMaW1pdENvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL25vdGlmaWNhdGlvbi9Ob3RpZmljYXRpb25Db250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuS2V5cmluZ0NvbnRyb2xsZXIgPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0gZXhwb3J0cy5BY2NvdW50SW1wb3J0U3RyYXRlZ3kgPSBleHBvcnRzLktleXJpbmdUeXBlcyA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IGV0aF9zaWdfdXRpbF8xID0gcmVxdWlyZShcImV0aC1zaWctdXRpbFwiKTtcbmNvbnN0IGV0aGVyZXVtanNfd2FsbGV0XzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcImV0aGVyZXVtanMtd2FsbGV0XCIpKTtcbmNvbnN0IGV0aF9rZXlyaW5nX2NvbnRyb2xsZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLWtleXJpbmctY29udHJvbGxlclwiKSk7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBBdmFpbGFibGUga2V5cmluZyB0eXBlc1xuICovXG52YXIgS2V5cmluZ1R5cGVzO1xuKGZ1bmN0aW9uIChLZXlyaW5nVHlwZXMpIHtcbiAgICBLZXlyaW5nVHlwZXNbXCJzaW1wbGVcIl0gPSBcIlNpbXBsZSBLZXkgUGFpclwiO1xuICAgIEtleXJpbmdUeXBlc1tcImhkXCJdID0gXCJIRCBLZXkgVHJlZVwiO1xuICAgIEtleXJpbmdUeXBlc1tcInFyXCJdID0gXCJRUiBIYXJkd2FyZSBXYWxsZXQgRGV2aWNlXCI7XG59KShLZXlyaW5nVHlwZXMgPSBleHBvcnRzLktleXJpbmdUeXBlcyB8fCAoZXhwb3J0cy5LZXlyaW5nVHlwZXMgPSB7fSkpO1xuLyoqXG4gKiBBIHN0cmF0ZWd5IGZvciBpbXBvcnRpbmcgYW4gYWNjb3VudFxuICovXG52YXIgQWNjb3VudEltcG9ydFN0cmF0ZWd5O1xuKGZ1bmN0aW9uIChBY2NvdW50SW1wb3J0U3RyYXRlZ3kpIHtcbiAgICBBY2NvdW50SW1wb3J0U3RyYXRlZ3lbXCJwcml2YXRlS2V5XCJdID0gXCJwcml2YXRlS2V5XCI7XG4gICAgQWNjb3VudEltcG9ydFN0cmF0ZWd5W1wianNvblwiXSA9IFwianNvblwiO1xufSkoQWNjb3VudEltcG9ydFN0cmF0ZWd5ID0gZXhwb3J0cy5BY2NvdW50SW1wb3J0U3RyYXRlZ3kgfHwgKGV4cG9ydHMuQWNjb3VudEltcG9ydFN0cmF0ZWd5ID0ge30pKTtcbi8qKlxuICogVGhlIGBzaWduVHlwZWRNZXNzYWdlYCB2ZXJzaW9uXG4gKlxuICogQHNlZSBodHRwczovL2RvY3MubWV0YW1hc2suaW8vZ3VpZGUvc2lnbmluZy1kYXRhLmh0bWxcbiAqL1xudmFyIFNpZ25UeXBlZERhdGFWZXJzaW9uO1xuKGZ1bmN0aW9uIChTaWduVHlwZWREYXRhVmVyc2lvbikge1xuICAgIFNpZ25UeXBlZERhdGFWZXJzaW9uW1wiVjFcIl0gPSBcIlYxXCI7XG4gICAgU2lnblR5cGVkRGF0YVZlcnNpb25bXCJWM1wiXSA9IFwiVjNcIjtcbiAgICBTaWduVHlwZWREYXRhVmVyc2lvbltcIlY0XCJdID0gXCJWNFwiO1xufSkoU2lnblR5cGVkRGF0YVZlcnNpb24gPSBleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uIHx8IChleHBvcnRzLlNpZ25UeXBlZERhdGFWZXJzaW9uID0ge30pKTtcbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3IgZXN0YWJsaXNoaW5nIGFuZCBtYW5hZ2luZyB1c2VyIGlkZW50aXR5XG4gKi9cbmNsYXNzIEtleXJpbmdDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIEtleXJpbmdDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgY29udHJvbGxlciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnJlbW92ZUlkZW50aXR5IC0gUmVtb3ZlIHRoZSBpZGVudGl0eSB3aXRoIHRoZSBnaXZlbiBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN5bmNJZGVudGl0aWVzIC0gU3luYyBpZGVudGl0aWVzIHdpdGggdGhlIGdpdmVuIGxpc3Qgb2YgYWRkcmVzc2VzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnVwZGF0ZUlkZW50aXRpZXMgLSBHZW5lcmF0ZSBhbiBpZGVudGl0eSBmb3IgZWFjaCBhZGRyZXNzIGdpdmVuIHRoYXQgZG9lc24ndCBhbHJlYWR5IGhhdmUgYW4gaWRlbnRpdHkuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuc2V0U2VsZWN0ZWRBZGRyZXNzIC0gU2V0IHRoZSBzZWxlY3RlZCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnNldEFjY291bnRMYWJlbCAtIFNldCBhIG5ldyBuYW1lIGZvciBhY2NvdW50LlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHJlbW92ZUlkZW50aXR5LCBzeW5jSWRlbnRpdGllcywgdXBkYXRlSWRlbnRpdGllcywgc2V0U2VsZWN0ZWRBZGRyZXNzLCBzZXRBY2NvdW50TGFiZWwsIH0sIGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIHRoaXMubXV0ZXggPSBuZXcgYXN5bmNfbXV0ZXhfMS5NdXRleCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdLZXlyaW5nQ29udHJvbGxlcic7XG4gICAgICAgIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBuZXcgZXRoX2tleXJpbmdfY29udHJvbGxlcl8xLmRlZmF1bHQoT2JqZWN0LmFzc2lnbih7IGluaXRTdGF0ZTogc3RhdGUgfSwgY29uZmlnKSksIFwiZlwiKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5zdG9yZS5nZXRTdGF0ZSgpKSwgeyBrZXlyaW5nczogW10gfSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSWRlbnRpdHkgPSByZW1vdmVJZGVudGl0eTtcbiAgICAgICAgdGhpcy5zeW5jSWRlbnRpdGllcyA9IHN5bmNJZGVudGl0aWVzO1xuICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMgPSB1cGRhdGVJZGVudGl0aWVzO1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyA9IHNldFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgdGhpcy5zZXRBY2NvdW50TGFiZWwgPSBzZXRBY2NvdW50TGFiZWw7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBhY2NvdW50IHRvIHRoZSBkZWZhdWx0IChmaXJzdCkgSEQgc2VlZCBwaHJhc2Uga2V5cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGUgd2hlbiB0aGUgYWNjb3VudCBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICBhZGROZXdBY2NvdW50KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuZ2V0S2V5cmluZ3NCeVR5cGUoJ0hEIEtleSBUcmVlJylbMF07XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICghcHJpbWFyeUtleXJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEhEIGtleXJpbmcgZm91bmQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZEFjY291bnRzID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICAgICAgICBjb25zdCBuZXdBY2NvdW50cyA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgeWllbGQgdGhpcy52ZXJpZnlTZWVkUGhyYXNlKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMobmV3QWNjb3VudHMpO1xuICAgICAgICAgICAgbmV3QWNjb3VudHMuZm9yRWFjaCgoc2VsZWN0ZWRBZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRBY2NvdW50cy5pbmNsdWRlcyhzZWxlY3RlZEFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRBZGRyZXNzKHNlbGVjdGVkQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGFjY291bnQgdG8gdGhlIGRlZmF1bHQgKGZpcnN0KSBIRCBzZWVkIHBocmFzZSBrZXlyaW5nIHdpdGhvdXQgdXBkYXRpbmcgaWRlbnRpdGllcyBpbiBwcmVmZXJlbmNlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGN1cnJlbnQgc3RhdGUgd2hlbiB0aGUgYWNjb3VudCBpcyBhZGRlZC5cbiAgICAgKi9cbiAgICBhZGROZXdBY2NvdW50V2l0aG91dFVwZGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByaW1hcnlLZXlyaW5nID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmdldEtleXJpbmdzQnlUeXBlKCdIRCBLZXkgVHJlZScpWzBdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXByaW1hcnlLZXlyaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBIRCBrZXlyaW5nIGZvdW5kJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuYWRkTmV3QWNjb3VudChwcmltYXJ5S2V5cmluZyk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnZlcmlmeVNlZWRQaHJhc2UoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGNyZWF0aW5nIGEgbmV3IGtleWNoYWluIHRoZW4gcG9wdWxhdGluZyBpdFxuICAgICAqIHVzaW5nIHRoZSBnaXZlbiBzZWVkIHBocmFzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIHRvIHVubG9jayBrZXljaGFpbi5cbiAgICAgKiBAcGFyYW0gc2VlZCAtIEEgQklQMzktY29tcGxpYW50IHNlZWQgcGhyYXNlLFxuICAgICAqIGVpdGhlciBhcyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBVVEYtOCBieXRlcyB0aGF0IHJlcHJlc2VudCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByZXN0b3JlZCBrZXljaGFpbiBvYmplY3QuXG4gICAgICovXG4gICAgY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBzZWVkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgaWYgKCFwYXNzd29yZCB8fCAhcGFzc3dvcmQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhc3N3b3JkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyhbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmF1bHQgPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuY3JlYXRlTmV3VmF1bHRBbmRSZXN0b3JlKHBhc3N3b3JkLCBzZWVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlkZW50aXRpZXMoeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmdldEFjY291bnRzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcHJpbWFyeSBrZXljaGFpbiBhbmQgd2lwZSBhbnkgcHJldmlvdXMga2V5Y2hhaW5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgdG8gdW5sb2NrIHRoZSBuZXcgdmF1bHQuXG4gICAgICogQHJldHVybnMgTmV3bHktY3JlYXRlZCBrZXljaGFpbiBvYmplY3QuXG4gICAgICovXG4gICAgY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmF1bHQgPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuY3JlYXRlTmV3VmF1bHRBbmRLZXljaGFpbihwYXNzd29yZCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5nZXRBY2NvdW50cygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWxlYXNlTG9jaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIHZhbGlkYXRlIGEgcGFzc3dvcmQgYWdhaW5zdCB0aGUgcGFzc3dvcmQgZnJvbSB0aGUga2V5cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAtIFBhc3N3b3JkIG9mIHRoZSBrZXlyaW5nLlxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyBpZiBpbnB1dCBwYXNzd29yZCBpcyB2YWxpZFxuICAgICAqL1xuICAgIHZhbGlkYXRlUGFzc3dvcmQocGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5wYXNzd29yZCA9PT0gcGFzc3dvcmQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0YXR1cyBvZiB0aGUgdmF1bHQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBCb29sZWFuIHJldHVybmluZyB0cnVlIGlmIHRoZSB2YXVsdCBpcyB1bmxvY2tlZC5cbiAgICAgKi9cbiAgICBpc1VubG9ja2VkKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLm1lbVN0b3JlLmdldFN0YXRlKCkuaXNVbmxvY2tlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VlZCBwaHJhc2Ugb2YgdGhlIEhEIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFzc3dvcmQgLSBQYXNzd29yZCBvZiB0aGUga2V5cmluZy5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgc2VlZCBwaHJhc2UuXG4gICAgICovXG4gICAgZXhwb3J0U2VlZFBocmFzZShwYXNzd29yZCkge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5rZXlyaW5nc1swXS5tbmVtb25pYztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFzc3dvcmQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJpdmF0ZSBrZXkgZnJvbSB0aGUga2V5cmluZyBjb250cm9sbGluZyBhbiBhZGRyZXNzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgb2YgdGhlIGtleXJpbmcuXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGV4cG9ydC5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcHJpdmF0ZSBrZXkgZm9yIGFuIGFkZHJlc3MuXG4gICAgICovXG4gICAgZXhwb3J0QWNjb3VudChwYXNzd29yZCwgYWRkcmVzcykge1xuICAgICAgICBpZiAodGhpcy52YWxpZGF0ZVBhc3N3b3JkKHBhc3N3b3JkKSkge1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5leHBvcnRBY2NvdW50KGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwYXNzd29yZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwdWJsaWMgYWRkcmVzc2VzIG9mIGFsbCBhY2NvdW50cyBmb3IgdGhlIGN1cnJlbnQga2V5cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXNvbHZpbmcgdG8gYW4gYXJyYXkgb2YgYWRkcmVzc2VzLlxuICAgICAqL1xuICAgIGdldEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmdldEFjY291bnRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEltcG9ydHMgYW4gYWNjb3VudCB3aXRoIHRoZSBzcGVjaWZpZWQgaW1wb3J0IHN0cmF0ZWd5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0cmF0ZWd5IC0gSW1wb3J0IHN0cmF0ZWd5IG5hbWUuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcnJheSBvZiBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgdW5kZXJseWluZyBzdGF0ZWd5LlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyB3aGVuIHBhc3NlZCBhbiB1bnJlY29nbml6ZWQgc3RyYXRlZ3kuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gY3VycmVudCBzdGF0ZSB3aGVuIHRoZSBpbXBvcnQgaXMgY29tcGxldGUuXG4gICAgICovXG4gICAgaW1wb3J0QWNjb3VudFdpdGhTdHJhdGVneShzdHJhdGVneSwgYXJncykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHByaXZhdGVLZXk7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJpdmF0ZUtleSc6XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtpbXBvcnRlZEtleV0gPSBhcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWltcG9ydGVkS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgYW4gZW1wdHkga2V5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZWZpeGVkID0gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkoaW1wb3J0ZWRLZXkpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYnVmZmVyZWRQcml2YXRlS2V5O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyZWRQcml2YXRlS2V5ID0gKDAsIGV0aGVyZXVtanNfdXRpbF8xLnRvQnVmZmVyKShwcmVmaXhlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpbXBvcnQgaW52YWxpZCBwcml2YXRlIGtleS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoMCwgZXRoZXJldW1qc191dGlsXzEuaXNWYWxpZFByaXZhdGUpKGJ1ZmZlcmVkUHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGltcG9ydCBpbnZhbGlkIHByaXZhdGUga2V5LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSAoMCwgZXRoZXJldW1qc191dGlsXzEuc3RyaXBIZXhQcmVmaXgpKHByZWZpeGVkKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnanNvbic6XG4gICAgICAgICAgICAgICAgICAgIGxldCB3YWxsZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dCwgcGFzc3dvcmRdID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldCA9IGV0aGVyZXVtanNfd2FsbGV0XzEudGhpcmRwYXJ0eS5mcm9tRXRoZXJXYWxsZXQoaW5wdXQsIHBhc3N3b3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0ID0gd2FsbGV0IHx8ICh5aWVsZCBldGhlcmV1bWpzX3dhbGxldF8xLmRlZmF1bHQuZnJvbVYzKGlucHV0LCBwYXNzd29yZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSAoMCwgZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgpKHdhbGxldC5nZXRQcml2YXRlS2V5KCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgaW1wb3J0IHN0cmF0ZWd5OiAnJHtzdHJhdGVneX0nYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdLZXlyaW5nID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmFkZE5ld0tleXJpbmcoS2V5cmluZ1R5cGVzLnNpbXBsZSwgW1xuICAgICAgICAgICAgICAgIHByaXZhdGVLZXksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgbmV3S2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgY29uc3QgYWxsQWNjb3VudHMgPSB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyhhbGxBY2NvdW50cyk7XG4gICAgICAgICAgICB0aGlzLnNldFNlbGVjdGVkQWRkcmVzcyhhY2NvdW50c1swXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGFjY291bnQgZnJvbSBrZXlyaW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBhY2NvdW50IHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyBjdXJyZW50IHN0YXRlIHdoZW4gdGhpcyBhY2NvdW50IHJlbW92YWwgY29tcGxldGVzLlxuICAgICAqL1xuICAgIHJlbW92ZUFjY291bnQoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJZGVudGl0eShhZGRyZXNzKTtcbiAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5yZW1vdmVBY2NvdW50KGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhbGxvY2F0ZXMgYWxsIHNlY3JldHMgYW5kIGxvY2tzIHRoZSB3YWxsZXQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICAgIHNldExvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5zZXRMb2NrZWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFBlcnNvbmFsTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gc2lnbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byBhIHNpZ25lZCBtZXNzYWdlIHN0cmluZy5cbiAgICAgKi9cbiAgICBzaWduTWVzc2FnZShtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuc2lnbk1lc3NhZ2UobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNpZ25zIHBlcnNvbmFsIG1lc3NhZ2UgYnkgY2FsbGluZyBkb3duIGludG8gYSBzcGVjaWZpYyBrZXlyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBQZXJzb25hbE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHNpZ24uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBzaWduZWQgbWVzc2FnZSBzdHJpbmcuXG4gICAgICovXG4gICAgc2lnblBlcnNvbmFsTWVzc2FnZShtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuc2lnblBlcnNvbmFsTWVzc2FnZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgdHlwZWQgbWVzc2FnZSBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gc2lnbi5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTIuXG4gICAgICogQHRocm93cyBXaWxsIHRocm93IHdoZW4gcGFzc2VkIGFuIHVucmVjb2duaXplZCB2ZXJzaW9uLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIGEgc2lnbmVkIG1lc3NhZ2Ugc3RyaW5nIG9yIGFuIGVycm9yIGlmIGFueS5cbiAgICAgKi9cbiAgICBzaWduVHlwZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXMsIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9ICgwLCBldGhfc2lnX3V0aWxfMS5ub3JtYWxpemUpKG1lc3NhZ2VQYXJhbXMuZnJvbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcXJLZXlyaW5nID0geWllbGQgdGhpcy5nZXRPckFkZFFSS2V5cmluZygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHFyQWNjb3VudHMgPSB5aWVsZCBxcktleXJpbmcuZ2V0QWNjb3VudHMoKTtcbiAgICAgICAgICAgICAgICBpZiAocXJBY2NvdW50cy5maW5kSW5kZXgoKHFyQWRkcmVzcykgPT4gcXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VQYXJhbXNDbG9uZSA9IE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gU2lnblR5cGVkRGF0YVZlcnNpb24uVjEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBtZXNzYWdlUGFyYW1zQ2xvbmUuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXNDbG9uZS5kYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlUGFyYW1zQ2xvbmUuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5zaWduVHlwZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXNDbG9uZSwgeyB2ZXJzaW9uIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhc3N3b3JkIH0gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleSA9IHlpZWxkIHRoaXMuZXhwb3J0QWNjb3VudChwYXNzd29yZCwgYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJpdmF0ZUtleUJ1ZmZlciA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS50b0J1ZmZlcikoKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkocHJpdmF0ZUtleSkpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodmVyc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNpZ25UeXBlZERhdGFWZXJzaW9uLlYxOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2lnblR5cGVkRGF0YUxlZ2FjeSB3aWxsIHRocm93IGlmIHRoZSBkYXRhIGlzIGludmFsaWQuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIGV0aF9zaWdfdXRpbF8xLnNpZ25UeXBlZERhdGFMZWdhY3kpKHByaXZhdGVLZXlCdWZmZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlUGFyYW1zLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTaWduVHlwZWREYXRhVmVyc2lvbi5WMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgZXRoX3NpZ191dGlsXzEuc2lnblR5cGVkRGF0YSkocHJpdmF0ZUtleUJ1ZmZlciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IEpTT04ucGFyc2UobWVzc2FnZVBhcmFtcy5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFNpZ25UeXBlZERhdGFWZXJzaW9uLlY0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBldGhfc2lnX3V0aWxfMS5zaWduVHlwZWREYXRhX3Y0KShwcml2YXRlS2V5QnVmZmVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogSlNPTi5wYXJzZShtZXNzYWdlUGFyYW1zLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgc2lnblR5cGVkTWVzc2FnZSB2ZXJzaW9uOiAnJHt2ZXJzaW9ufSdgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleXJpbmcgQ29udHJvbGxlciBzaWduVHlwZWRNZXNzYWdlOiAke2Vycm9yfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2lnbnMgYSB0cmFuc2FjdGlvbiBieSBjYWxsaW5nIGRvd24gaW50byBhIHNwZWNpZmljIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUcmFuc2FjdGlvbiBvYmplY3QgdG8gc2lnbi4gTXVzdCBiZSBhIGBldGhlcmV1bWpzLXR4YCB0cmFuc2FjdGlvbiBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gZnJvbSAtIEFkZHJlc3MgdG8gc2lnbiBmcm9tLCBzaG91bGQgYmUgaW4ga2V5Y2hhaW4uXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBzaWduZWQgdHJhbnNhY3Rpb24gc3RyaW5nLlxuICAgICAqL1xuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgZnJvbSkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgZnJvbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGRlY3J5cHQgdGhlIGN1cnJlbnQgdmF1bHQgYW5kIGxvYWQgaXRzIGtleXJpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhc3N3b3JkIC0gUGFzc3dvcmQgdG8gdW5sb2NrIHRoZSBrZXljaGFpbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgICBzdWJtaXRQYXNzd29yZChwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLnN1Ym1pdFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0geWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN5bmNJZGVudGl0aWVzKGFjY291bnRzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIG9mIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgLSBDYWxsYmFjayB0cmlnZ2VyZWQgd2hlbiBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuc3RvcmUuc3Vic2NyaWJlKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBleGlzdGluZyBsaXN0ZW5lciBmcm9tIHJlY2VpdmluZyBzdGF0ZSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgYSBsaXN0ZW5lciBpcyBmb3VuZCBhbmQgdW5zdWJzY3JpYmVkLlxuICAgICAqL1xuICAgIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuc3RvcmUudW5zdWJzY3JpYmUobGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG5ldyBsaXN0ZW5lciB0byBiZSBub3RpZmllZCB3aGVuIHRoZSB3YWxsZXQgaXMgbG9ja2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyIC0gQ2FsbGJhY2sgdHJpZ2dlcmVkIHdoZW4gd2FsbGV0IGlzIGxvY2tlZC5cbiAgICAgKiBAcmV0dXJucyBFdmVudEVtaXR0ZXIgaWYgbGlzdGVuZXIgYWRkZWQuXG4gICAgICovXG4gICAgb25Mb2NrKGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikub24oJ2xvY2snLCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgbmV3IGxpc3RlbmVyIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHdhbGxldCBpcyB1bmxvY2tlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciAtIENhbGxiYWNrIHRyaWdnZXJlZCB3aGVuIHdhbGxldCBpcyB1bmxvY2tlZC5cbiAgICAgKiBAcmV0dXJucyBFdmVudEVtaXR0ZXIgaWYgbGlzdGVuZXIgYWRkZWQuXG4gICAgICovXG4gICAgb25VbmxvY2sobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5vbigndW5sb2NrJywgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyB0aGUgdGhhdCB0aGUgc2VlZCBwaHJhc2UgcmVzdG9yZXMgdGhlIGN1cnJlbnQga2V5Y2hhaW4ncyBhY2NvdW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZlcmlmaWNhdGlvbiBzdWNjZWVkcy5cbiAgICAgKi9cbiAgICB2ZXJpZnlTZWVkUGhyYXNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJpbWFyeUtleXJpbmcgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuZ2V0S2V5cmluZ3NCeVR5cGUoS2V5cmluZ1R5cGVzLmhkKVswXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgaWYgKCFwcmltYXJ5S2V5cmluZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gSEQga2V5cmluZyBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZWRXb3JkcyA9ICh5aWVsZCBwcmltYXJ5S2V5cmluZy5zZXJpYWxpemUoKSkubW5lbW9uaWM7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9IHlpZWxkIHByaW1hcnlLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB2ZXJpZnkgYW4gZW1wdHkga2V5cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFRlc3RLZXlyaW5nQ2xhc3MgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuZ2V0S2V5cmluZ0NsYXNzRm9yVHlwZShLZXlyaW5nVHlwZXMuaGQpO1xuICAgICAgICAgICAgY29uc3QgdGVzdEtleXJpbmcgPSBuZXcgVGVzdEtleXJpbmdDbGFzcyh7XG4gICAgICAgICAgICAgICAgbW5lbW9uaWM6IHNlZWRXb3JkcyxcbiAgICAgICAgICAgICAgICBudW1iZXJPZkFjY291bnRzOiBhY2NvdW50cy5sZW5ndGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRlc3RBY2NvdW50cyA9IHlpZWxkIHRlc3RLZXlyaW5nLmdldEFjY291bnRzKCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmICh0ZXN0QWNjb3VudHMubGVuZ3RoICE9PSBhY2NvdW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlZWQgcGhyYXNlIGltcG9ydGVkIGluY29ycmVjdCBudW1iZXIgb2YgYWNjb3VudHMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXN0QWNjb3VudHMuZm9yRWFjaCgoYWNjb3VudCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LnRvTG93ZXJDYXNlKCkgIT09IGFjY291bnRzW2ldLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWVkIHBocmFzZSBpbXBvcnRlZCBkaWZmZXJlbnQgYWNjb3VudHMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2VlZFdvcmRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGtleXJpbmdzIGluIHN0YXRlIGFuZCBjYWxscyBLZXlyaW5nQ29udHJvbGxlciBmdWxsVXBkYXRlIG1ldGhvZCByZXR1cm5pbmcgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICAgIGZ1bGxVcGRhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlyaW5ncyA9IHlpZWxkIFByb21pc2UuYWxsKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5rZXlyaW5ncy5tYXAoKGtleXJpbmcsIGluZGV4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cmluZ0FjY291bnRzID0geWllbGQga2V5cmluZy5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjY291bnRzID0gQXJyYXkuaXNBcnJheShrZXlyaW5nQWNjb3VudHMpXG4gICAgICAgICAgICAgICAgICAgID8ga2V5cmluZ0FjY291bnRzLm1hcCgoYWRkcmVzcykgPT4gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcykpXG4gICAgICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gW107XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBrZXlyaW5nLnR5cGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IGtleXJpbmdzOiBbLi4ua2V5cmluZ3NdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5mdWxsVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBRUiBIYXJkd2FyZSByZWxhdGVkIG1ldGhvZHNcbiAgICAvKipcbiAgICAgKiBBZGQgcXIgaGFyZHdhcmUga2V5cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBhZGRlZCBrZXlyaW5nXG4gICAgICovXG4gICAgYWRkUVJLZXlyaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cmluZyA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5hZGROZXdLZXlyaW5nKEtleXJpbmdUeXBlcy5xcik7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiBrZXlyaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHFyIGhhcmR3YXJlIGtleXJpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgYWRkZWQga2V5cmluZ1xuICAgICAqL1xuICAgIGdldE9yQWRkUVJLZXlyaW5nKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cmluZyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5nZXRLZXlyaW5nc0J5VHlwZShLZXlyaW5nVHlwZXMucXIpWzBdO1xuICAgICAgICAgICAgcmV0dXJuIGtleXJpbmcgfHwgKHlpZWxkIHRoaXMuYWRkUVJLZXlyaW5nKCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzdG9yZVFSS2V5cmluZyhzZXJpYWxpemVkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoeWllbGQgdGhpcy5nZXRPckFkZFFSS2V5cmluZygpKS5kZXNlcmlhbGl6ZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWRlbnRpdGllcyh5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc2V0UVJLZXlyaW5nU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoeWllbGQgdGhpcy5nZXRPckFkZFFSS2V5cmluZygpKS5yZXNldFN0b3JlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRRUktleXJpbmdTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoeWllbGQgdGhpcy5nZXRPckFkZFFSS2V5cmluZygpKS5nZXRNZW1TdG9yZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VibWl0UVJDcnlwdG9IREtleShjcnlwdG9IREtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgKHlpZWxkIHRoaXMuZ2V0T3JBZGRRUktleXJpbmcoKSkuc3VibWl0Q3J5cHRvSERLZXkoY3J5cHRvSERLZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VibWl0UVJDcnlwdG9BY2NvdW50KGNyeXB0b0FjY291bnQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICh5aWVsZCB0aGlzLmdldE9yQWRkUVJLZXlyaW5nKCkpLnN1Ym1pdENyeXB0b0FjY291bnQoY3J5cHRvQWNjb3VudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdWJtaXRRUlNpZ25hdHVyZShyZXF1ZXN0SWQsIGV0aFNpZ25hdHVyZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgKHlpZWxkIHRoaXMuZ2V0T3JBZGRRUktleXJpbmcoKSkuc3VibWl0U2lnbmF0dXJlKHJlcXVlc3RJZCwgZXRoU2lnbmF0dXJlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbmNlbFFSU2lnblJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAoeWllbGQgdGhpcy5nZXRPckFkZFFSS2V5cmluZygpKS5jYW5jZWxTaWduUmVxdWVzdCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdFFSSGFyZHdhcmUocGFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlyaW5nID0geWllbGQgdGhpcy5nZXRPckFkZFFSS2V5cmluZygpO1xuICAgICAgICAgICAgICAgIGxldCBhY2NvdW50cztcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAtMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzID0geWllbGQga2V5cmluZy5nZXRQcmV2aW91c1BhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50cyA9IHlpZWxkIGtleXJpbmcuZ2V0TmV4dFBhZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudHMgPSB5aWVsZCBrZXlyaW5nLmdldEZpcnN0UGFnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjY291bnQpLCB7IGJhbGFuY2U6ICcweDAnIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3BlY2lmaWVkIGVycm9yIHdoZW4gY29ubmVjdCBRUiBIYXJkd2FyZSwgJHtlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW5sb2NrUVJIYXJkd2FyZVdhbGxldEFjY291bnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXJpbmcgPSB5aWVsZCB0aGlzLmdldE9yQWRkUVJLZXlyaW5nKCk7XG4gICAgICAgICAgICBrZXlyaW5nLnNldEFjY291bnRUb1VubG9jayhpbmRleCk7XG4gICAgICAgICAgICBjb25zdCBvbGRBY2NvdW50cyA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgeWllbGQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZywgXCJmXCIpLmFkZE5ld0FjY291bnQoa2V5cmluZyk7XG4gICAgICAgICAgICBjb25zdCBuZXdBY2NvdW50cyA9IHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5nZXRBY2NvdW50cygpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVJZGVudGl0aWVzKG5ld0FjY291bnRzKTtcbiAgICAgICAgICAgIG5ld0FjY291bnRzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW9sZEFjY291bnRzLmluY2x1ZGVzKGFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldEFjY291bnRMYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgYCR7a2V5cmluZy5nZXROYW1lKCl9ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikucGVyc2lzdEFsbEtleXJpbmdzKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmZ1bGxVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEFjY291bnRLZXlyaW5nVHlwZShhY2NvdW50KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5nZXRLZXlyaW5nRm9yQWNjb3VudChhY2NvdW50KSkudHlwZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvcmdldFFSRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5cmluZyA9IHlpZWxkIHRoaXMuZ2V0T3JBZGRRUktleXJpbmcoKTtcbiAgICAgICAgICAgIGtleXJpbmcuZm9yZ2V0RGV2aWNlKCk7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50cyA9ICh5aWVsZCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9LZXlyaW5nQ29udHJvbGxlcl9rZXlyaW5nLCBcImZcIikuZ2V0QWNjb3VudHMoKSk7XG4gICAgICAgICAgICBhY2NvdW50cy5mb3JFYWNoKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTZWxlY3RlZEFkZHJlc3MoYWNjb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0tleXJpbmdDb250cm9sbGVyX2tleXJpbmcsIFwiZlwiKS5wZXJzaXN0QWxsS2V5cmluZ3MoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZnVsbFVwZGF0ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLktleXJpbmdDb250cm9sbGVyID0gS2V5cmluZ0NvbnRyb2xsZXI7XG5fS2V5cmluZ0NvbnRyb2xsZXJfa2V5cmluZyA9IG5ldyBXZWFrTWFwKCk7XG5leHBvcnRzLmRlZmF1bHQgPSBLZXlyaW5nQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUtleXJpbmdDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbi8qKlxuICogQ29udHJvbGxlciBpbiBjaGFyZ2Ugb2YgbWFuYWdpbmcgLSBzdG9yaW5nLCBhZGRpbmcsIHJlbW92aW5nLCB1cGRhdGluZyAtIE1lc3NhZ2VzLlxuICovXG5jbGFzcyBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIEluaXRpYWwgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICogQHBhcmFtIHN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgc3RhdGUpIHtcbiAgICAgICAgc3VwZXIoY29uZmlnLCBzdGF0ZSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFdmVudEVtaXR0ZXIgaW5zdGFuY2UgdXNlZCB0byBsaXN0ZW4gdG8gc3BlY2lmaWMgbWVzc2FnZSBldmVudHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaHViID0gbmV3IGV2ZW50c18xLkV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICB1bmFwcHJvdmVkTWVzc2FnZXM6IHt9LFxuICAgICAgICAgICAgdW5hcHByb3ZlZE1lc3NhZ2VzQ291bnQ6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSB1bmFwcHJvdmVkIG1lc3NhZ2VzLCBhbmQgdGhlaXIgY291bnQgdG8gc3RhdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBzYXZlTWVzc2FnZUxpc3QoKSB7XG4gICAgICAgIGNvbnN0IHVuYXBwcm92ZWRNZXNzYWdlcyA9IHRoaXMuZ2V0VW5hcHByb3ZlZE1lc3NhZ2VzKCk7XG4gICAgICAgIGNvbnN0IHVuYXBwcm92ZWRNZXNzYWdlc0NvdW50ID0gdGhpcy5nZXRVbmFwcHJvdmVkTWVzc2FnZXNDb3VudCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IHVuYXBwcm92ZWRNZXNzYWdlcywgdW5hcHByb3ZlZE1lc3NhZ2VzQ291bnQgfSk7XG4gICAgICAgIHRoaXMuaHViLmVtaXQoJ3VwZGF0ZUJhZGdlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHN0YXR1cyBvZiBhIE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gdXBkYXRlLlxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgbmV3IHN0YXR1cyBvZiB0aGUgTWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZXRNZXNzYWdlU3RhdHVzKG1lc3NhZ2VJZCwgc3RhdHVzKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmdldE1lc3NhZ2UobWVzc2FnZUlkKTtcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGhpcy5uYW1lfTogTWVzc2FnZSBub3QgZm91bmQgZm9yIGlkOiAke21lc3NhZ2VJZH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgIHRoaXMudXBkYXRlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHttZXNzYWdlSWR9OiR7c3RhdHVzfWAsIG1lc3NhZ2UpO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAncmVqZWN0ZWQnIHx8IHN0YXR1cyA9PT0gJ3NpZ25lZCcgfHwgc3RhdHVzID09PSAnZXJyb3JlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7bWVzc2FnZUlkfTpmaW5pc2hlZGAsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBNZXNzYWdlIGluIHRoaXMubWVzc2FnZXMgdG8gdGhlIHBhc3NlZCBNZXNzYWdlIGlmIHRoZSBpZHMgYXJlIGVxdWFsLlxuICAgICAqIFRoZW4gc2F2ZXMgdGhlIHVuYXBwcm92ZWRNZXNzYWdlIGxpc3QgdG8gc3RvcmFnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIC0gQSBNZXNzYWdlIHRoYXQgd2lsbCByZXBsYWNlIGFuIGV4aXN0aW5nIE1lc3NhZ2UgKHdpdGggdGhlIGlkKSBpbiB0aGlzLm1lc3NhZ2VzLlxuICAgICAqL1xuICAgIHVwZGF0ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMubWVzc2FnZXMuZmluZEluZGV4KChtc2cpID0+IG1lc3NhZ2UuaWQgPT09IG1zZy5pZCk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZXNbaW5kZXhdID0gbWVzc2FnZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNhdmVNZXNzYWdlTGlzdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGdldHRlciBmb3IgdGhlIG51bWJlciBvZiAndW5hcHByb3ZlZCcgTWVzc2FnZXMgaW4gdGhpcy5tZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXMuXG4gICAgICovXG4gICAgZ2V0VW5hcHByb3ZlZE1lc3NhZ2VzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldFVuYXBwcm92ZWRNZXNzYWdlcygpKS5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciB0aGUgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHN0YXRlIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gaW5kZXggb2YgTWVzc2FnZSBpZHMgdG8gTWVzc2FnZXMsIGZvciBhbGwgJ3VuYXBwcm92ZWQnIE1lc3NhZ2VzIGluIHRoaXMubWVzc2FnZXMuXG4gICAgICovXG4gICAgZ2V0VW5hcHByb3ZlZE1lc3NhZ2VzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlc1xuICAgICAgICAgICAgLmZpbHRlcigobWVzc2FnZSkgPT4gbWVzc2FnZS5zdGF0dXMgPT09ICd1bmFwcHJvdmVkJylcbiAgICAgICAgICAgIC5yZWR1Y2UoKHJlc3VsdCwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgcmVzdWx0W21lc3NhZ2UuaWRdID0gbWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBhc3NlZCBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCBjYWxscyB0aGlzLnNhdmVNZXNzYWdlTGlzdCgpIHRvIHNhdmVcbiAgICAgKiB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcyBmcm9tIHRoYXQgbGlzdCB0byB0aGlzLm1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgTWVzc2FnZSB0byBhZGQgdG8gdGhpcy5tZXNzYWdlcy5cbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnNhdmVNZXNzYWdlTGlzdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3BlY2lmaWVkIE1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgTWVzc2FnZSB3aXRoIHRoZSBpZCB0aGF0IG1hdGNoZXMgdGhlIHBhc3NlZCBtZXNzYWdlSWQsIG9yIHVuZGVmaW5lZFxuICAgICAqIGlmIG5vIE1lc3NhZ2UgaGFzIHRoYXQgaWQuXG4gICAgICovXG4gICAgZ2V0TWVzc2FnZShtZXNzYWdlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuZmluZCgobWVzc2FnZSkgPT4gbWVzc2FnZS5pZCA9PT0gbWVzc2FnZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwcm92ZXMgYSBNZXNzYWdlLiBTZXRzIHRoZSBtZXNzYWdlIHN0YXR1cyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TWVzc2FnZVN0YXR1c0FwcHJvdmVkLFxuICAgICAqIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aXRoIGFueSB0aGUgbWVzc2FnZSBwYXJhbXMgbW9kaWZpZWQgZm9yIHByb3BlciBzaWduaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBiZSB1c2VkIHdoZW4gc2lnbmluZyBtZXRob2QgaXMgY2FsbGVkLFxuICAgICAqIHBsdXMgZGF0YSBhZGRlZCBieSBNZXRhTWFzay5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWVzc2FnZVBhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IHJlbW92ZWQuXG4gICAgICovXG4gICAgYXBwcm92ZU1lc3NhZ2UobWVzc2FnZVBhcmFtcykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5zZXRNZXNzYWdlU3RhdHVzQXBwcm92ZWQobWVzc2FnZVBhcmFtcy5tZXRhbWFza0lkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcE1lc3NhZ2VGb3JTaWduaW5nKG1lc3NhZ2VQYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgTWVzc2FnZSBzdGF0dXMgdG8gJ2FwcHJvdmVkJyB2aWEgYSBjYWxsIHRvIHRoaXMuc2V0TWVzc2FnZVN0YXR1cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gYXBwcm92ZS5cbiAgICAgKi9cbiAgICBzZXRNZXNzYWdlU3RhdHVzQXBwcm92ZWQobWVzc2FnZUlkKSB7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZVN0YXR1cyhtZXNzYWdlSWQsICdhcHByb3ZlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgTWVzc2FnZSBzdGF0dXMgdG8gJ3NpZ25lZCcgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1lc3NhZ2VTdGF0dXMgYW5kIHVwZGF0ZXNcbiAgICAgKiB0aGF0IE1lc3NhZ2UgaW4gdGhpcy5tZXNzYWdlcyBieSBhZGRpbmcgdGhlIHJhdyBzaWduYXR1cmUgZGF0YSBvZiB0aGUgc2lnbmF0dXJlXG4gICAgICogcmVxdWVzdCB0byB0aGUgTWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlSWQgLSBUaGUgaWQgb2YgdGhlIE1lc3NhZ2UgdG8gc2lnbi5cbiAgICAgKiBAcGFyYW0gcmF3U2lnIC0gVGhlIHJhdyBkYXRhIG9mIHRoZSBzaWduYXR1cmUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBzZXRNZXNzYWdlU3RhdHVzU2lnbmVkKG1lc3NhZ2VJZCwgcmF3U2lnKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmdldE1lc3NhZ2UobWVzc2FnZUlkKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UucmF3U2lnID0gcmF3U2lnO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc2V0TWVzc2FnZVN0YXR1cyhtZXNzYWdlSWQsICdzaWduZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIE1lc3NhZ2Ugc3RhdHVzIHRvICdyZWplY3RlZCcgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1lc3NhZ2VTdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBNZXNzYWdlIHRvIHJlamVjdC5cbiAgICAgKi9cbiAgICByZWplY3RNZXNzYWdlKG1lc3NhZ2VJZCkge1xuICAgICAgICB0aGlzLnNldE1lc3NhZ2VTdGF0dXMobWVzc2FnZUlkLCAncmVqZWN0ZWQnKTtcbiAgICB9XG59XG5leHBvcnRzLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIgPSBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWJzdHJhY3RNZXNzYWdlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFic3RyYWN0TWVzc2FnZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBNZXNzYWdlcy5cbiAqL1xuY2xhc3MgTWVzc2FnZU1hbmFnZXIgZXh0ZW5kcyBBYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyXzEuQWJzdHJhY3RNZXNzYWdlTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ01lc3NhZ2VNYW5hZ2VyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZSB1bmFwcHJvdmVkIE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3QuXG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVTaWduTWVzc2FnZURhdGEpKG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5hZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpO1xuICAgICAgICAgICAgdGhpcy5odWIub25jZShgJHttZXNzYWdlSWR9OmZpbmlzaGVkYCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhLnJhd1NpZyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJykpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYE1ldGFNYXNrIE1lc3NhZ2UgU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZVBhcmFtcyl9YCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZVxuICAgICAqIHVuYXBwcm92ZWQgTWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBwYXJhbXMgZm9yIHRoZSBldGhfc2lnbiBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2VcbiAgICAgKiBpcyBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gcmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgaWQgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgbWVzc2FnZS5cbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgaWYgKHJlcSkge1xuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcy5vcmlnaW4gPSByZXEub3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2VQYXJhbXMuZGF0YSA9ICgwLCB1dGlsXzEubm9ybWFsaXplTWVzc2FnZURhdGEpKG1lc3NhZ2VQYXJhbXMuZGF0YSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VJZCA9ICgwLCB1dWlkXzEudjEpKCk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEYXRhID0ge1xuICAgICAgICAgICAgaWQ6IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMsXG4gICAgICAgICAgICBzdGF0dXM6ICd1bmFwcHJvdmVkJyxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICB0eXBlOiAnZXRoX3NpZ24nLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZURhdGEpO1xuICAgICAgICB0aGlzLmh1Yi5lbWl0KGB1bmFwcHJvdmVkTWVzc2FnZWAsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVzc2FnZVBhcmFtcyksIHsgbWV0YW1hc2tJZDogbWVzc2FnZUlkIH0pKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSBmcm9tIHBhc3NlZCBtZXNzYWdlUGFyYW1zIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB3aGljaFxuICAgICAqIHJlc29sdmVzIHRoZSB1cGRhdGVkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBtZXNzYWdlUGFyYW1zIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgbWVzc2FnZVBhcmFtcyB3aXRoIHRoZSBtZXRhbWFza0lkIHByb3BlcnR5IHJlbW92ZWQuXG4gICAgICovXG4gICAgcHJlcE1lc3NhZ2VGb3JTaWduaW5nKG1lc3NhZ2VQYXJhbXMpIHtcbiAgICAgICAgZGVsZXRlIG1lc3NhZ2VQYXJhbXMubWV0YW1hc2tJZDtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VNYW5hZ2VyID0gTWVzc2FnZU1hbmFnZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBNZXNzYWdlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBNZXNzYWdlcy5cbiAqL1xuY2xhc3MgUGVyc29uYWxNZXNzYWdlTWFuYWdlciBleHRlbmRzIEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMS5BYnN0cmFjdE1lc3NhZ2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnUGVyc29uYWxNZXNzYWdlTWFuYWdlcic7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWVzc2FnZSB3aXRoIGFuICd1bmFwcHJvdmVkJyBzdGF0dXMgdXNpbmcgdGhlIHBhc3NlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqIHRoaXMuYWRkTWVzc2FnZSBpcyBjYWxsZWQgdG8gYWRkIHRoZSBuZXcgTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBNZXNzYWdlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXNzYWdlUGFyYW1zIC0gVGhlIHBhcmFtcyBmb3IgdGhlIHBlcnNvbmFsX3NpZ24gY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSByYXcgZGF0YSBvZiB0aGUgc2lnbmF0dXJlIHJlcXVlc3QuXG4gICAgICovXG4gICAgYWRkVW5hcHByb3ZlZE1lc3NhZ2VBc3luYyhtZXNzYWdlUGFyYW1zLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVTaWduTWVzc2FnZURhdGEpKG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5hZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCByZXEpO1xuICAgICAgICAgICAgdGhpcy5odWIub25jZShgJHttZXNzYWdlSWR9OmZpbmlzaGVkYCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhLnJhd1NpZyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBQZXJzb25hbCBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJykpO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoYE1ldGFNYXNrIFBlcnNvbmFsIE1lc3NhZ2UgU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkobWVzc2FnZVBhcmFtcyl9YCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBNZXNzYWdlIHRvIHRoaXMubWVzc2FnZXMsIGFuZCB0byBzYXZlIHRoZVxuICAgICAqIHVuYXBwcm92ZWQgTWVzc2FnZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVBhcmFtcyAtIFRoZSBwYXJhbXMgZm9yIHRoZSBwZXJzb25hbF9zaWduIGNhbGwgdG8gYmUgbWFkZSBhZnRlciB0aGUgbWVzc2FnZVxuICAgICAqIGlzIGFwcHJvdmVkLlxuICAgICAqIEBwYXJhbSByZXEgLSBUaGUgb3JpZ2luYWwgcmVxdWVzdCBvYmplY3QgcG9zc2libHkgY29udGFpbmluZyB0aGUgb3JpZ2luLlxuICAgICAqIEByZXR1cm5zIFRoZSBpZCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBtZXNzYWdlLlxuICAgICAqL1xuICAgIGFkZFVuYXBwcm92ZWRNZXNzYWdlKG1lc3NhZ2VQYXJhbXMsIHJlcSkge1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLm9yaWdpbiA9IHJlcS5vcmlnaW47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZVBhcmFtcy5kYXRhID0gKDAsIHV0aWxfMS5ub3JtYWxpemVNZXNzYWdlRGF0YSkobWVzc2FnZVBhcmFtcy5kYXRhKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gKDAsIHV1aWRfMS52MSkoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICBpZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgbWVzc2FnZVBhcmFtcyxcbiAgICAgICAgICAgIHN0YXR1czogJ3VuYXBwcm92ZWQnLFxuICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHR5cGU6ICdwZXJzb25hbF9zaWduJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZE1lc3NhZ2VgLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lc3NhZ2VQYXJhbXMpLCB7IG1ldGFtYXNrSWQ6IG1lc3NhZ2VJZCB9KSk7XG4gICAgICAgIHJldHVybiBtZXNzYWdlSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIG1ldGFtYXNrSWQgcHJvcGVydHkgZnJvbSBwYXNzZWQgbWVzc2FnZVBhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB0aGUgdXBkYXRlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lc3NhZ2VQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBwcm9wZXJ0eSByZW1vdmVkLlxuICAgICAqL1xuICAgIHByZXBNZXNzYWdlRm9yU2lnbmluZyhtZXNzYWdlUGFyYW1zKSB7XG4gICAgICAgIGRlbGV0ZSBtZXNzYWdlUGFyYW1zLm1ldGFtYXNrSWQ7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobWVzc2FnZVBhcmFtcyk7XG4gICAgfVxufVxuZXhwb3J0cy5QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyID0gUGVyc29uYWxNZXNzYWdlTWFuYWdlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IFBlcnNvbmFsTWVzc2FnZU1hbmFnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJzb25hbE1lc3NhZ2VNYW5hZ2VyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UeXBlZE1lc3NhZ2VNYW5hZ2VyID0gdm9pZCAwO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEFic3RyYWN0TWVzc2FnZU1hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL0Fic3RyYWN0TWVzc2FnZU1hbmFnZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgaW4gY2hhcmdlIG9mIG1hbmFnaW5nIC0gc3RvcmluZywgYWRkaW5nLCByZW1vdmluZywgdXBkYXRpbmcgLSBUeXBlZE1lc3NhZ2VzLlxuICovXG5jbGFzcyBUeXBlZE1lc3NhZ2VNYW5hZ2VyIGV4dGVuZHMgQWJzdHJhY3RNZXNzYWdlTWFuYWdlcl8xLkFic3RyYWN0TWVzc2FnZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdUeXBlZE1lc3NhZ2VNYW5hZ2VyJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUeXBlZE1lc3NhZ2Ugd2l0aCBhbiAndW5hcHByb3ZlZCcgc3RhdHVzIHVzaW5nIHRoZSBwYXNzZWQgbWVzc2FnZVBhcmFtcy5cbiAgICAgKiB0aGlzLmFkZE1lc3NhZ2UgaXMgY2FsbGVkIHRvIGFkZCB0aGUgbmV3IFR5cGVkTWVzc2FnZSB0byB0aGlzLm1lc3NhZ2VzLCBhbmQgdG8gc2F2ZSB0aGUgdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgZXRoX3NpZ25UeXBlZERhdGEgY2FsbCB0byBiZSBtYWRlIGFmdGVyIHRoZSBtZXNzYWdlIGlzIGFwcHJvdmVkLlxuICAgICAqIEBwYXJhbSB2ZXJzaW9uIC0gQ29tcGF0aWJpbGl0eSB2ZXJzaW9uIEVJUDcxMi5cbiAgICAgKiBAcGFyYW0gcmVxIC0gVGhlIG9yaWdpbmFsIHJlcXVlc3Qgb2JqZWN0IHBvc3NpYmx5IGNvbnRhaW5pbmcgdGhlIG9yaWdpbi5cbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJlc29sdmluZyB0byB0aGUgcmF3IGRhdGEgb2YgdGhlIHNpZ25hdHVyZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFkZFVuYXBwcm92ZWRNZXNzYWdlQXN5bmMobWVzc2FnZVBhcmFtcywgdmVyc2lvbiwgcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAodmVyc2lvbiA9PT0gJ1YxJykge1xuICAgICAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYxKShtZXNzYWdlUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAnVjMnKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjMpKG1lc3NhZ2VQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gdGhpcy5hZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpO1xuICAgICAgICAgICAgdGhpcy5odWIub25jZShgJHttZXNzYWdlSWR9OmZpbmlzaGVkYCwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGRhdGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShkYXRhLnJhd1NpZyk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdNZXRhTWFzayBUeXBlZCBNZXNzYWdlIFNpZ25hdHVyZTogVXNlciBkZW5pZWQgbWVzc2FnZSBzaWduYXR1cmUuJykpO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcmVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBUeXBlZCBNZXNzYWdlIFNpZ25hdHVyZTogJHtkYXRhLmVycm9yfWApKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGBNZXRhTWFzayBUeXBlZCBNZXNzYWdlIFNpZ25hdHVyZTogVW5rbm93biBwcm9ibGVtOiAke0pTT04uc3RyaW5naWZ5KG1lc3NhZ2VQYXJhbXMpfWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVHlwZWRNZXNzYWdlIHdpdGggYW4gJ3VuYXBwcm92ZWQnIHN0YXR1cyB1c2luZyB0aGUgcGFzc2VkIG1lc3NhZ2VQYXJhbXMuXG4gICAgICogdGhpcy5hZGRNZXNzYWdlIGlzIGNhbGxlZCB0byBhZGQgdGhlIG5ldyBUeXBlZE1lc3NhZ2UgdG8gdGhpcy5tZXNzYWdlcywgYW5kIHRvIHNhdmUgdGhlXG4gICAgICogdW5hcHByb3ZlZCBUeXBlZE1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgcGFyYW1zIGZvciB0aGUgJ2V0aF9zaWduVHlwZWREYXRhJyBjYWxsIHRvIGJlIG1hZGUgYWZ0ZXIgdGhlIG1lc3NhZ2VcbiAgICAgKiBpcyBhcHByb3ZlZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiAtIENvbXBhdGliaWxpdHkgdmVyc2lvbiBFSVA3MTIuXG4gICAgICogQHBhcmFtIHJlcSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG9iamVjdCBwb3NzaWJseSBjb250YWluaW5nIHRoZSBvcmlnaW4uXG4gICAgICogQHJldHVybnMgVGhlIGlkIG9mIHRoZSBuZXdseSBjcmVhdGVkIFR5cGVkTWVzc2FnZS5cbiAgICAgKi9cbiAgICBhZGRVbmFwcHJvdmVkTWVzc2FnZShtZXNzYWdlUGFyYW1zLCB2ZXJzaW9uLCByZXEpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZUlkID0gKDAsIHV1aWRfMS52MSkoKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZVBhcmFtc01ldGFtYXNrID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXNzYWdlUGFyYW1zKSwgeyBtZXRhbWFza0lkOiBtZXNzYWdlSWQsIHZlcnNpb24gfSk7XG4gICAgICAgIGlmIChyZXEpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VQYXJhbXMub3JpZ2luID0gcmVxLm9yaWdpbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IHtcbiAgICAgICAgICAgIGlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICBtZXNzYWdlUGFyYW1zLFxuICAgICAgICAgICAgc3RhdHVzOiAndW5hcHByb3ZlZCcsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgdHlwZTogJ2V0aF9zaWduVHlwZWREYXRhJyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1lc3NhZ2VEYXRhKTtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgdW5hcHByb3ZlZE1lc3NhZ2VgLCBtZXNzYWdlUGFyYW1zTWV0YW1hc2spO1xuICAgICAgICByZXR1cm4gbWVzc2FnZUlkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgVHlwZWRNZXNzYWdlIHN0YXR1cyB0byAnZXJyb3JlZCcgdmlhIGEgY2FsbCB0byB0aGlzLnNldE1lc3NhZ2VTdGF0dXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbWVzc2FnZUlkIC0gVGhlIGlkIG9mIHRoZSBUeXBlZE1lc3NhZ2UgdG8gZXJyb3IuXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIHRvIGJlIGluY2x1ZGVkIGluIFR5cGVkTWVzc2FnZS5cbiAgICAgKi9cbiAgICBzZXRNZXNzYWdlU3RhdHVzRXJyb3JlZChtZXNzYWdlSWQsIGVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmdldE1lc3NhZ2UobWVzc2FnZUlkKTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghbWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgdGhpcy51cGRhdGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnNldE1lc3NhZ2VTdGF0dXMobWVzc2FnZUlkLCAnZXJyb3JlZCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBtZXRhbWFza0lkIGFuZCB2ZXJzaW9uIHByb3BlcnRpZXMgZnJvbSBwYXNzZWQgbWVzc2FnZVBhcmFtcyBhbmQgcmV0dXJucyBhIHByb21pc2Ugd2hpY2hcbiAgICAgKiByZXNvbHZlcyB0aGUgdXBkYXRlZCBtZXNzYWdlUGFyYW1zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1lc3NhZ2VQYXJhbXMgLSBUaGUgbWVzc2FnZVBhcmFtcyB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIG1lc3NhZ2VQYXJhbXMgd2l0aCB0aGUgbWV0YW1hc2tJZCBhbmQgdmVyc2lvbiBwcm9wZXJ0aWVzIHJlbW92ZWQuXG4gICAgICovXG4gICAgcHJlcE1lc3NhZ2VGb3JTaWduaW5nKG1lc3NhZ2VQYXJhbXMpIHtcbiAgICAgICAgZGVsZXRlIG1lc3NhZ2VQYXJhbXMubWV0YW1hc2tJZDtcbiAgICAgICAgZGVsZXRlIG1lc3NhZ2VQYXJhbXMudmVyc2lvbjtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShtZXNzYWdlUGFyYW1zKTtcbiAgICB9XG59XG5leHBvcnRzLlR5cGVkTWVzc2FnZU1hbmFnZXIgPSBUeXBlZE1lc3NhZ2VNYW5hZ2VyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHlwZWRNZXNzYWdlTWFuYWdlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVR5cGVkTWVzc2FnZU1hbmFnZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmV0d29ya0NvbnRyb2xsZXIgPSBleHBvcnRzLk5ldHdvcmtzQ2hhaW5JZCA9IHZvaWQgMDtcbmNvbnN0IGV0aF9xdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcXVlcnlcIikpO1xuY29uc3QgcHJvdmlkZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL3Byb3ZpZGVyXCIpKTtcbmNvbnN0IGNyZWF0ZVByb3ZpZGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImV0aC1qc29uLXJwYy1pbmZ1cmEvc3JjL2NyZWF0ZVByb3ZpZGVyXCIpKTtcbmNvbnN0IHplcm9fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwid2ViMy1wcm92aWRlci1lbmdpbmUvemVyb1wiKSk7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50c1wiKTtcbnZhciBOZXR3b3Jrc0NoYWluSWQ7XG4oZnVuY3Rpb24gKE5ldHdvcmtzQ2hhaW5JZCkge1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcIm1haW5uZXRcIl0gPSBcIjFcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJrb3ZhblwiXSA9IFwiNDJcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJyaW5rZWJ5XCJdID0gXCI0XCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wiZ29lcmxpXCJdID0gXCI1XCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wicm9wc3RlblwiXSA9IFwiM1wiO1xuICAgIE5ldHdvcmtzQ2hhaW5JZFtcImxvY2FsaG9zdFwiXSA9IFwiXCI7XG4gICAgTmV0d29ya3NDaGFpbklkW1wicnBjXCJdID0gXCJcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJvcHRpbWlzbVwiXSA9IFwiMTBcIjtcbiAgICBOZXR3b3Jrc0NoYWluSWRbXCJvcHRpbWlzbVRlc3RcIl0gPSBcIjY5XCI7XG59KShOZXR3b3Jrc0NoYWluSWQgPSBleHBvcnRzLk5ldHdvcmtzQ2hhaW5JZCB8fCAoZXhwb3J0cy5OZXR3b3Jrc0NoYWluSWQgPSB7fSkpO1xuY29uc3QgTE9DQUxIT1NUX1JQQ19VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1Jztcbi8qKlxuICogQ29udHJvbGxlciB0aGF0IGNyZWF0ZXMgYW5kIG1hbmFnZXMgYW4gRXRoZXJldW0gbmV0d29yayBwcm92aWRlclxuICovXG5jbGFzcyBOZXR3b3JrQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOZXR3b3JrQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBOYW1lIG9mIHRoaXMgY29udHJvbGxlciB1c2VkIGR1cmluZyBjb21wb3NpdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uYW1lID0gJ05ldHdvcmtDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBuZXR3b3JrOiAnbG9hZGluZycsXG4gICAgICAgICAgICBpc0N1c3RvbU5ldHdvcms6IGZhbHNlLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHsgdHlwZTogY29uc3RhbnRzXzEuTUFJTk5FVCwgY2hhaW5JZDogTmV0d29ya3NDaGFpbklkLm1haW5uZXQgfSxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHsgaXNFSVAxNTU5Q29tcGF0aWJsZTogZmFsc2UgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZVByb3ZpZGVyKHR5cGUsIHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlzQ3VzdG9tTmV0d29yazogdGhpcy5nZXRJc0N1c3RvbU5ldHdvcmsoY2hhaW5JZCkgfSk7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAna292YW4nOlxuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5NQUlOTkVUOlxuICAgICAgICAgICAgY2FzZSAncmlua2VieSc6XG4gICAgICAgICAgICBjYXNlICdnb2VybGknOlxuICAgICAgICAgICAgY2FzZSAnb3B0aW1pc20nOlxuICAgICAgICAgICAgY2FzZSAnb3B0aW1pc21UZXN0JzpcbiAgICAgICAgICAgIGNhc2UgJ3JvcHN0ZW4nOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBJbmZ1cmFQcm92aWRlcih0eXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvY2FsaG9zdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR1cFN0YW5kYXJkUHJvdmlkZXIoTE9DQUxIT1NUX1JQQ19VUkwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBjb25zdGFudHNfMS5SUEM6XG4gICAgICAgICAgICAgICAgcnBjVGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0dXBTdGFuZGFyZFByb3ZpZGVyKHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG5ldHdvcmsgdHlwZTogJyR7dHlwZX0nYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaE5ldHdvcmsoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgbmV0d29yazogJ2xvYWRpbmcnLCBwcm9wZXJ0aWVzOiB7fSB9KTtcbiAgICAgICAgY29uc3QgeyBycGNUYXJnZXQsIHR5cGUsIGNoYWluSWQsIHRpY2tlciB9ID0gdGhpcy5zdGF0ZS5wcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplUHJvdmlkZXIodHlwZSwgcnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIpO1xuICAgICAgICB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJQcm92aWRlcigpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlci5vbignZXJyb3InLCB0aGlzLnZlcmlmeU5ldHdvcmsuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdCh0aGlzLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgc2V0dXBJbmZ1cmFQcm92aWRlcih0eXBlKSB7XG4gICAgICAgIGNvbnN0IGluZnVyYVByb3ZpZGVyID0gKDAsIGNyZWF0ZVByb3ZpZGVyXzEuZGVmYXVsdCkoe1xuICAgICAgICAgICAgbmV0d29yazogdHlwZSxcbiAgICAgICAgICAgIHByb2plY3RJZDogdGhpcy5jb25maWcuaW5mdXJhUHJvamVjdElkLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW5mdXJhU3VicHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJfMS5kZWZhdWx0KGluZnVyYVByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcpLCB7XG4gICAgICAgICAgICBkYXRhU3VicHJvdmlkZXI6IGluZnVyYVN1YnByb3ZpZGVyLFxuICAgICAgICAgICAgZW5naW5lUGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgYmxvY2tUcmFja2VyUHJvdmlkZXI6IGluZnVyYVByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbDogMTIwMDAsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVQcm92aWRlcigoMCwgemVyb18xLmRlZmF1bHQpKGNvbmZpZykpO1xuICAgIH1cbiAgICBnZXRJc0N1c3RvbU5ldHdvcmsoY2hhaW5JZCkge1xuICAgICAgICByZXR1cm4gKGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5tYWlubmV0ICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQua292YW4gJiZcbiAgICAgICAgICAgIGNoYWluSWQgIT09IE5ldHdvcmtzQ2hhaW5JZC5yaW5rZWJ5ICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQuZ29lcmxpICYmXG4gICAgICAgICAgICBjaGFpbklkICE9PSBOZXR3b3Jrc0NoYWluSWQucm9wc3RlbiAmJlxuICAgICAgICAgICAgY2hhaW5JZCAhPT0gTmV0d29ya3NDaGFpbklkLmxvY2FsaG9zdCk7XG4gICAgfVxuICAgIHNldHVwU3RhbmRhcmRQcm92aWRlcihycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmludGVybmFsUHJvdmlkZXJDb25maWcpLCB7XG4gICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgZW5naW5lUGFyYW1zOiB7IHBvbGxpbmdJbnRlcnZhbDogMTIwMDAgfSxcbiAgICAgICAgICAgIG5pY2tuYW1lLFxuICAgICAgICAgICAgcnBjVXJsOiBycGNUYXJnZXQsXG4gICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVByb3ZpZGVyKCgwLCB6ZXJvXzEuZGVmYXVsdCkoY29uZmlnKSk7XG4gICAgfVxuICAgIHVwZGF0ZVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuc2FmZWx5U3RvcFByb3ZpZGVyKHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJQcm92aWRlcigpO1xuICAgIH1cbiAgICBzYWZlbHlTdG9wUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBwcm92aWRlciA9PT0gbnVsbCB8fCBwcm92aWRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvdmlkZXIuc3RvcCgpO1xuICAgICAgICB9LCA1MDApO1xuICAgIH1cbiAgICB2ZXJpZnlOZXR3b3JrKCkge1xuICAgICAgICB0aGlzLnN0YXRlLm5ldHdvcmsgPT09ICdsb2FkaW5nJyAmJiB0aGlzLmxvb2t1cE5ldHdvcmsoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBjb25maWd1cmF0aW9uIGZvciB3ZWIzLXByb3ZpZGVyLWVuZ2luZS5cbiAgICAgKlxuICAgICAqIFRPRE86IFJlcGxhY2UgdGhpcyB3dGggYSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvdmlkZXJDb25maWcgLSBUaGUgd2ViMy1wcm92aWRlci1lbmdpbmUgY29uZmlndXJhdGlvbi5cbiAgICAgKi9cbiAgICBzZXQgcHJvdmlkZXJDb25maWcocHJvdmlkZXJDb25maWcpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbFByb3ZpZGVyQ29uZmlnID0gcHJvdmlkZXJDb25maWc7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgcnBjVGFyZ2V0LCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lIH0gPSB0aGlzLnN0YXRlLnByb3ZpZGVyO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVQcm92aWRlcih0eXBlLCBycGNUYXJnZXQsIGNoYWluSWQsIHRpY2tlciwgbmlja25hbWUpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyUHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5sb29rdXBOZXR3b3JrKCk7XG4gICAgfVxuICAgIGdldCBwcm92aWRlckNvbmZpZygpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9wZXJ0eSBvbmx5IHVzZWQgZm9yIHNldHRpbmcnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBjdXJyZW50IG5ldHdvcmsgY29kZS5cbiAgICAgKi9cbiAgICBsb29rdXBOZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuZXRoUXVlcnkgfHwgIXRoaXMuZXRoUXVlcnkuc2VuZEFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVsZWFzZUxvY2sgPSB5aWVsZCB0aGlzLm11dGV4LmFjcXVpcmUoKTtcbiAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkuc2VuZEFzeW5jKHsgbWV0aG9kOiAnbmV0X3ZlcnNpb24nIH0sIChlcnJvciwgbmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yazogZXJyb3IgPyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCovICdsb2FkaW5nJyA6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHVwZGF0ZSBwcm92aWRlciBuZXR3b3JrIHR5cGUgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZSAtIEh1bWFuIHJlYWRhYmxlIG5ldHdvcmsgbmFtZS5cbiAgICAgKi9cbiAgICBzZXRQcm92aWRlclR5cGUodHlwZSkge1xuICAgICAgICBjb25zdCBfYSA9IHRoaXMuc3RhdGUucHJvdmlkZXIsIHsgcnBjVGFyZ2V0LCBjaGFpbklkLCBuaWNrbmFtZSB9ID0gX2EsIHByb3ZpZGVyU3RhdGUgPSBfX3Jlc3QoX2EsIFtcInJwY1RhcmdldFwiLCBcImNoYWluSWRcIiwgXCJuaWNrbmFtZVwiXSk7XG4gICAgICAgIC8vIElmIHRlc3RuZXQgdGhlIHRpY2tlciBzeW1ib2wgc2hvdWxkIHVzZSBhIHRlc3RuZXQgcHJlZml4XG4gICAgICAgIGNvbnN0IHRpY2tlciA9IHR5cGUgaW4gY29uc3RhbnRzXzEuVEVTVE5FVF9ORVRXT1JLX1RZUEVfVE9fVElDS0VSX1NZTUJPTCAmJlxuICAgICAgICAgICAgY29uc3RhbnRzXzEuVEVTVE5FVF9ORVRXT1JLX1RZUEVfVE9fVElDS0VSX1NZTUJPTFt0eXBlXS5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IGNvbnN0YW50c18xLlRFU1RORVRfTkVUV09SS19UWVBFX1RPX1RJQ0tFUl9TWU1CT0xbdHlwZV1cbiAgICAgICAgICAgIDogJ0VUSCc7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb3ZpZGVyU3RhdGUpLCB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICB0aWNrZXIsXG4gICAgICAgICAgICAgICAgY2hhaW5JZDogTmV0d29ya3NDaGFpbklkW3R5cGVdLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2hOZXR3b3JrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byB1cGRhdGUgcHJvdmlkZXIgUlBDIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJwY1RhcmdldCAtIFRoZSBSUEMgZW5kcG9pbnQgVVJMLlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gVGhlIGNoYWluIElEIGFzIHBlciBFSVAtMTU1LlxuICAgICAqIEBwYXJhbSB0aWNrZXIgLSBUaGUgY3VycmVuY3kgdGlja2VyLlxuICAgICAqIEBwYXJhbSBuaWNrbmFtZSAtIFBlcnNvbmFsaXplZCBuZXR3b3JrIG5hbWUuXG4gICAgICovXG4gICAgc2V0UnBjVGFyZ2V0KHJwY1RhcmdldCwgY2hhaW5JZCwgdGlja2VyLCBuaWNrbmFtZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBwcm92aWRlcjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLnByb3ZpZGVyKSwgeyB0eXBlOiBjb25zdGFudHNfMS5SUEMsIHRpY2tlciwgcnBjVGFyZ2V0LCBjaGFpbklkLCBuaWNrbmFtZSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaE5ldHdvcmsoKTtcbiAgICB9XG4gICAgZ2V0RUlQMTU1OUNvbXBhdGliaWxpdHkoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBwcm9wZXJ0aWVzID0ge30gfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmICghcHJvcGVydGllcy5pc0VJUDE1NTlDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mICgoX2EgPSB0aGlzLmV0aFF1ZXJ5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZEFzeW5jKSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZXRoUXVlcnkuc2VuZEFzeW5jKHsgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBwYXJhbXM6IFsnbGF0ZXN0JywgZmFsc2VdIH0sIChlcnJvciwgYmxvY2spID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFSVAxNTU5Q29tcGF0aWJsZSA9IHR5cGVvZiBibG9jay5iYXNlRmVlUGVyR2FzICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmlzRUlQMTU1OUNvbXBhdGlibGUgIT09IGlzRUlQMTU1OUNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRUlQMTU1OUNvbXBhdGlibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGlzRUlQMTU1OUNvbXBhdGlibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuTmV0d29ya0NvbnRyb2xsZXIgPSBOZXR3b3JrQ29udHJvbGxlcjtcbmV4cG9ydHMuZGVmYXVsdCA9IE5ldHdvcmtDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TmV0d29ya0NvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBuYW5vaWRfMSA9IHJlcXVpcmUoXCJuYW5vaWRcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgbmFtZSA9ICdOb3RpZmljYXRpb25Db250cm9sbGVyJztcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIG5vdGlmaWNhdGlvbnM6IHsgcGVyc2lzdDogdHJ1ZSwgYW5vbnltb3VzOiBmYWxzZSB9LFxufTtcbmNvbnN0IGRlZmF1bHRTdGF0ZSA9IHtcbiAgICBub3RpZmljYXRpb25zOiB7fSxcbn07XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBoYW5kbGVzIHN0b3Jpbmcgbm90aWZpY2F0aW9ucyBhbmQgc2hvd2luZyB0aGVtIHRvIHRoZSB1c2VyXG4gKi9cbmNsYXNzIE5vdGlmaWNhdGlvbkNvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBOb3RpZmljYXRpb25Db250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBtZXNzYWdpbmcgc3lzdGVtLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2VuZ2VyLCBzdGF0ZSwgfSkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0U3RhdGUpLCBzdGF0ZSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7bmFtZX06c2hvd2AsIChvcmlnaW4sIG1lc3NhZ2UpID0+IHRoaXMuc2hvdyhvcmlnaW4sIG1lc3NhZ2UpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke25hbWV9OmRpc21pc3NgLCAoaWRzKSA9PiB0aGlzLmRpc21pc3MoaWRzKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtuYW1lfTptYXJrUmVhZGAsIChpZHMpID0+IHRoaXMubWFya1JlYWQoaWRzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgbm90aWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gdHJ5aW5nIHRvIHNlbmQgYSBub3RpZmljYXRpb25cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSAtIEEgbWVzc2FnZSB0byBzaG93IG9uIHRoZSBub3RpZmljYXRpb25cbiAgICAgKi9cbiAgICBzaG93KG9yaWdpbiwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBpZCA9ICgwLCBuYW5vaWRfMS5uYW5vaWQpKCk7XG4gICAgICAgIGNvbnN0IG5vdGlmaWNhdGlvbiA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY3JlYXRlZERhdGU6IERhdGUubm93KCksXG4gICAgICAgICAgICByZWFkRGF0ZTogbnVsbCxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgc3RhdGUubm90aWZpY2F0aW9uc1tpZF0gPSBub3RpZmljYXRpb247XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaW1pc3NlcyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZHMgLSBBIGxpc3Qgb2Ygbm90aWZpY2F0aW9uIElEc1xuICAgICAqL1xuICAgIGRpc21pc3MoaWRzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5oYXNQcm9wZXJ0eSkoc3RhdGUubm90aWZpY2F0aW9ucywgaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5ub3RpZmljYXRpb25zW2lkXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYXJrcyBhIGxpc3Qgb2Ygbm90aWZpY2F0aW9ucyBhcyByZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkcyAtIEEgbGlzdCBvZiBub3RpZmljYXRpb24gSURzXG4gICAgICovXG4gICAgbWFya1JlYWQoaWRzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5oYXNQcm9wZXJ0eSkoc3RhdGUubm90aWZpY2F0aW9ucywgaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5vdGlmaWNhdGlvbnNbaWRdLnJlYWREYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTm90aWZpY2F0aW9uQ29udHJvbGxlciA9IE5vdGlmaWNhdGlvbkNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Ob3RpZmljYXRpb25Db250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29yYXRlV2l0aENhdmVhdHMgPSB2b2lkIDA7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbi8qKlxuICogRGVjb3JhdGUgYSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiB3aXRoIGl0cyBjYXZlYXRzLlxuICpcbiAqIE5vdGUgdGhhdCBhbGwgY2F2ZWF0IGZ1bmN0aW9ucyAoaS5lLiB0aGUgYXJndW1lbnQgYW5kIHJldHVybiB2YWx1ZSBvZiB0aGVcbiAqIGRlY29yYXRvcikgbXVzdCBiZSBhd2FpdGVkLlxuICpcbiAqIEBwYXJhbSBtZXRob2RJbXBsZW1lbnRhdGlvbiAtIFRoZSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICogQHBhcmFtIHBlcm1pc3Npb24gLSBUaGUgb3JpZ2luJ3MgcG90ZW50aWFsIHBlcm1pc3Npb25cbiAqIEBwYXJhbSBjYXZlYXRTcGVjaWZpY2F0aW9ucyAtIEFsbCBjYXZlYXQgaW1wbGVtZW50YXRpb25zXG4gKiBAcmV0dXJucyBUaGUgZGVjb3JhdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICovXG5mdW5jdGlvbiBkZWNvcmF0ZVdpdGhDYXZlYXRzKG1ldGhvZEltcGxlbWVudGF0aW9uLCBwZXJtaXNzaW9uLCAvLyBib3VuZCB0byB0aGUgcmVxdWVzdGluZyBvcmlnaW5cbmNhdmVhdFNwZWNpZmljYXRpb25zKSB7XG4gICAgY29uc3QgeyBjYXZlYXRzIH0gPSBwZXJtaXNzaW9uO1xuICAgIGlmICghY2F2ZWF0cykge1xuICAgICAgICByZXR1cm4gbWV0aG9kSW1wbGVtZW50YXRpb247XG4gICAgfVxuICAgIGxldCBkZWNvcmF0ZWQgPSAoYXJncykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gbWV0aG9kSW1wbGVtZW50YXRpb24oYXJncyk7IH0pO1xuICAgIGZvciAoY29uc3QgY2F2ZWF0IG9mIGNhdmVhdHMpIHtcbiAgICAgICAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IGNhdmVhdFNwZWNpZmljYXRpb25zW2NhdmVhdC50eXBlXTtcbiAgICAgICAgaWYgKCFzcGVjaWZpY2F0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yKGNhdmVhdC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBkZWNvcmF0ZWQgPSBzcGVjaWZpY2F0aW9uLmRlY29yYXRvcihkZWNvcmF0ZWQsIGNhdmVhdCk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvcmF0ZWQ7XG59XG5leHBvcnRzLmRlY29yYXRlV2l0aENhdmVhdHMgPSBkZWNvcmF0ZVdpdGhDYXZlYXRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2F2ZWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNTcGVjaWZpY2F0aW9uVHlwZSA9IGV4cG9ydHMuUGVybWlzc2lvblR5cGUgPSBleHBvcnRzLmZpbmRDYXZlYXQgPSBleHBvcnRzLmNvbnN0cnVjdFBlcm1pc3Npb24gPSB2b2lkIDA7XG5jb25zdCBuYW5vaWRfMSA9IHJlcXVpcmUoXCJuYW5vaWRcIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHBlcm1pc3Npb24gZmFjdG9yeSBmdW5jdGlvbi4gTmFpdmVseSBjb25zdHJ1Y3RzIGEgcGVybWlzc2lvbiBmcm9tXG4gKiB0aGUgaW5wdXRzLiBTZXRzIGEgZGVmYXVsdCwgcmFuZG9tIGBpZGAgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBQZXJtaXNzaW9ufSBGb3IgbW9yZSBkZXRhaWxzLlxuICogQHRlbXBsYXRlIFRhcmdldFBlcm1pc3Npb24tIC0gVGhlIHtAbGluayBQZXJtaXNzaW9ufSB0aGF0IHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgcGVybWlzc2lvbi5cbiAqIEByZXR1cm5zIFRoZSBuZXcgcGVybWlzc2lvbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFBlcm1pc3Npb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2F2ZWF0cyA9IG51bGwsIGludm9rZXIsIHRhcmdldCB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogKDAsIG5hbm9pZF8xLm5hbm9pZCkoKSxcbiAgICAgICAgcGFyZW50Q2FwYWJpbGl0eTogdGFyZ2V0LFxuICAgICAgICBpbnZva2VyLFxuICAgICAgICBjYXZlYXRzLFxuICAgICAgICBkYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICB9O1xufVxuZXhwb3J0cy5jb25zdHJ1Y3RQZXJtaXNzaW9uID0gY29uc3RydWN0UGVybWlzc2lvbjtcbi8qKlxuICogR2V0cyB0aGUgY2F2ZWF0IG9mIHRoZSBzcGVjaWZpZWQgdHlwZSBiZWxvbmdpbmcgdG8gdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uLlxuICpcbiAqIEBwYXJhbSBwZXJtaXNzaW9uIC0gVGhlIHBlcm1pc3Npb24gd2hvc2UgY2F2ZWF0IHRvIHJldHJpZXZlLlxuICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHRvIHJldHJpZXZlLlxuICogQHJldHVybnMgVGhlIGNhdmVhdCwgb3IgdW5kZWZpbmVkIGlmIG5vIHN1Y2ggY2F2ZWF0IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gZmluZENhdmVhdChwZXJtaXNzaW9uLCBjYXZlYXRUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSBwZXJtaXNzaW9uLmNhdmVhdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maW5kKChjYXZlYXQpID0+IGNhdmVhdC50eXBlID09PSBjYXZlYXRUeXBlKTtcbn1cbmV4cG9ydHMuZmluZENhdmVhdCA9IGZpbmRDYXZlYXQ7XG4vKipcbiAqIFRoZSBkaWZmZXJlbnQgcG9zc2libGUgdHlwZXMgb2YgcGVybWlzc2lvbnMuXG4gKi9cbnZhciBQZXJtaXNzaW9uVHlwZTtcbihmdW5jdGlvbiAoUGVybWlzc2lvblR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlc3RyaWN0ZWQgSlNPTi1SUEMgbWV0aG9kLiBBIHN1YmplY3QgbXVzdCBoYXZlIHRoZSByZXF1aXNpdGUgcGVybWlzc2lvblxuICAgICAqIHRvIGNhbGwgYSByZXN0cmljdGVkIEpTT04tUlBDIG1ldGhvZC5cbiAgICAgKi9cbiAgICBQZXJtaXNzaW9uVHlwZVtcIlJlc3RyaWN0ZWRNZXRob2RcIl0gPSBcIlJlc3RyaWN0ZWRNZXRob2RcIjtcbiAgICAvKipcbiAgICAgKiBBbiBcImVuZG93bWVudFwiIGdyYW50ZWQgdG8gc3ViamVjdHMgdGhhdCBwb3NzZXNzIHRoZSByZXF1aXNpdGUgcGVybWlzc2lvbixcbiAgICAgKiBzdWNoIGFzIGEgZ2xvYmFsIGVudmlyb25tZW50IHZhcmlhYmxlIGV4cG9zaW5nIGEgcmVzdHJpY3RlZCBBUEksIGV0Yy5cbiAgICAgKi9cbiAgICBQZXJtaXNzaW9uVHlwZVtcIkVuZG93bWVudFwiXSA9IFwiRW5kb3dtZW50XCI7XG59KShQZXJtaXNzaW9uVHlwZSA9IGV4cG9ydHMuUGVybWlzc2lvblR5cGUgfHwgKGV4cG9ydHMuUGVybWlzc2lvblR5cGUgPSB7fSkpO1xuLyoqXG4gKiBDaGVja3MgdGhhdCB0aGUgc3BlY2lmaWNhdGlvbiBoYXMgdGhlIGV4cGVjdGVkIHBlcm1pc3Npb24gdHlwZS5cbiAqXG4gKiBAcGFyYW0gc3BlY2lmaWNhdGlvbiAtIFRoZSBzcGVjaWZpY2F0aW9uIHRvIGNoZWNrLlxuICogQHBhcmFtIGV4cGVjdGVkVHlwZSAtIFRoZSBleHBlY3RlZCBwZXJtaXNzaW9uIHR5cGUuXG4gKiBAdGVtcGxhdGUgU3BlY2lmaWNhdGlvbiAtIFRoZSBzcGVjaWZpY2F0aW9uIHRvIGNoZWNrLlxuICogQHRlbXBsYXRlIFR5cGUgLSBUaGUgZXhwZWN0ZWQgcGVybWlzc2lvbiB0eXBlLlxuICogQHJldHVybnMgV2hldGhlciBvciBub3QgdGhlIHNwZWNpZmljYXRpb24gaXMgb2YgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGhhc1NwZWNpZmljYXRpb25UeXBlKHNwZWNpZmljYXRpb24sIGV4cGVjdGVkVHlwZSkge1xuICAgIHJldHVybiBzcGVjaWZpY2F0aW9uLnBlcm1pc3Npb25UeXBlID09PSBleHBlY3RlZFR5cGU7XG59XG5leHBvcnRzLmhhc1NwZWNpZmljYXRpb25UeXBlID0gaGFzU3BlY2lmaWNhdGlvblR5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJtaXNzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19yZXN0ID0gKHRoaXMgJiYgdGhpcy5fX3Jlc3QpIHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gICAgdmFyIHQgPSB7fTtcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XG4gICAgICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBlcm1pc3Npb25Db250cm9sbGVyID0gZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0gdm9pZCAwO1xuY29uc3QgZGVlcF9mcmVlemVfc3RyaWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlZXAtZnJlZXplLXN0cmljdFwiKSk7XG5jb25zdCBpbW1lcl8xID0gcmVxdWlyZShcImltbWVyXCIpO1xuY29uc3QgbmFub2lkXzEgPSByZXF1aXJlKFwibmFub2lkXCIpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5jb25zdCBDYXZlYXRfMSA9IHJlcXVpcmUoXCIuL0NhdmVhdFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgUGVybWlzc2lvbl8xID0gcmVxdWlyZShcIi4vUGVybWlzc2lvblwiKTtcbmNvbnN0IHBlcm1pc3Npb25fbWlkZGxld2FyZV8xID0gcmVxdWlyZShcIi4vcGVybWlzc2lvbi1taWRkbGV3YXJlXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyfS5cbiAqL1xuY29uc3QgY29udHJvbGxlck5hbWUgPSAnUGVybWlzc2lvbkNvbnRyb2xsZXInO1xuLyoqXG4gKiBHZXQgdGhlIHN0YXRlIG1ldGFkYXRhIG9mIHRoZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBQZXJtaXNzaW9uIC0gVGhlIGNvbnRyb2xsZXIncyBwZXJtaXNzaW9uIHR5cGUgdW5pb24uXG4gKiBAcmV0dXJucyBUaGUgc3RhdGUgbWV0YWRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhdGVNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4geyBzdWJqZWN0czogeyBhbm9ueW1vdXM6IHRydWUsIHBlcnNpc3Q6IHRydWUgfSB9O1xufVxuLyoqXG4gKiBHZXQgdGhlIGRlZmF1bHQgc3RhdGUgb2YgdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uXG4gKlxuICogQHRlbXBsYXRlIFBlcm1pc3Npb24gLSBUaGUgY29udHJvbGxlcidzIHBlcm1pc3Npb24gdHlwZSB1bmlvbi5cbiAqIEByZXR1cm5zIFRoZSBkZWZhdWx0IHN0YXRlIG9mIHRoZSBjb250cm9sbGVyXG4gKi9cbmZ1bmN0aW9uIGdldERlZmF1bHRTdGF0ZSgpIHtcbiAgICByZXR1cm4geyBzdWJqZWN0czoge30gfTtcbn1cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBwb3NzaWJsZSByZXN1bHRzIG9mIGEge0BsaW5rIENhdmVhdE11dGF0b3J9IGZ1bmN0aW9uLlxuICovXG52YXIgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbjtcbihmdW5jdGlvbiAoQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbikge1xuICAgIENhdmVhdE11dGF0b3JPcGVyYXRpb25bQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltcIm5vb3BcIl0gPSAwXSA9IFwibm9vcFwiO1xuICAgIENhdmVhdE11dGF0b3JPcGVyYXRpb25bQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltcInVwZGF0ZVZhbHVlXCJdID0gMV0gPSBcInVwZGF0ZVZhbHVlXCI7XG4gICAgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltDYXZlYXRNdXRhdG9yT3BlcmF0aW9uW1wiZGVsZXRlQ2F2ZWF0XCJdID0gMl0gPSBcImRlbGV0ZUNhdmVhdFwiO1xuICAgIENhdmVhdE11dGF0b3JPcGVyYXRpb25bQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbltcInJldm9rZVBlcm1pc3Npb25cIl0gPSAzXSA9IFwicmV2b2tlUGVybWlzc2lvblwiO1xufSkoQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiA9IGV4cG9ydHMuQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbiB8fCAoZXhwb3J0cy5DYXZlYXRNdXRhdG9yT3BlcmF0aW9uID0ge30pKTtcbi8qKlxuICogVGhlIHBlcm1pc3Npb24gY29udHJvbGxlci4gU2VlIHRoZSBSRUFETUUgZm9yIGRldGFpbHMuXG4gKlxuICogQXNzdW1lcyB0aGUgZXhpc3RlbmNlIG9mIGFuIHtAbGluayBBcHByb3ZhbENvbnRyb2xsZXJ9IHJlYWNoYWJsZSB2aWEgdGhlXG4gKiB7QGxpbmsgQ29udHJvbGxlck1lc3Nlbmdlcn0uXG4gKlxuICogQHRlbXBsYXRlIENvbnRyb2xsZXJQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbiAtIEEgdW5pb24gb2YgdGhlIHR5cGVzIG9mIGFsbFxuICogcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuIEFueSByZWZlcmVuY2VkIGNhdmVhdHNcbiAqIG11c3QgYmUgaW5jbHVkZWQgaW4gdGhlIGNvbnRyb2xsZXIncyBjYXZlYXQgc3BlY2lmaWNhdGlvbnMuXG4gKiBAdGVtcGxhdGUgQ29udHJvbGxlckNhdmVhdFNwZWNpZmljYXRpb24gLSBBIHVuaW9uIG9mIHRoZSB0eXBlcyBvZiBhbGxcbiAqIGNhdmVhdCBzcGVjaWZpY2F0aW9ucyBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuXG4gKi9cbmNsYXNzIFBlcm1pc3Npb25Db250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJWMl8xLkJhc2VDb250cm9sbGVyIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIHRoZSBQZXJtaXNzaW9uQ29udHJvbGxlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gUGVybWlzc2lvbiBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuY2F2ZWF0U3BlY2lmaWNhdGlvbnMgLSBUaGUgc3BlY2lmaWNhdGlvbnMgb2YgYWxsIGNhdmVhdHNcbiAgICAgKiBhdmFpbGFibGUgdG8gdGhlIGNvbnRyb2xsZXIuIFNlZSB7QGxpbmsgQ2F2ZWF0U3BlY2lmaWNhdGlvbk1hcH0gYW5kIHRoZVxuICAgICAqIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMgLSBUaGUgc3BlY2lmaWNhdGlvbnMgb2YgYWxsXG4gICAgICogcGVybWlzc2lvbnMgYXZhaWxhYmxlIHRvIHRoZSBjb250cm9sbGVyLiBTZWVcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvblNwZWNpZmljYXRpb25NYXB9IGFuZCB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMudW5yZXN0cmljdGVkTWV0aG9kcyAtIFRoZSBjYWxsYWJsZSBuYW1lcyBvZiBhbGwgSlNPTi1SUENcbiAgICAgKiBtZXRob2RzIGlnbm9yZWQgYnkgdGhlIG5ldyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIFRoZSBjb250cm9sbGVyIG1lc3Nlbmdlci4gU2VlXG4gICAgICoge0BsaW5rIEJhc2VDb250cm9sbGVyfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdGF0ZSAtIEV4aXN0aW5nIHN0YXRlIHRvIGh5ZHJhdGUgdGhlIGNvbnRyb2xsZXIgd2l0aCBhdFxuICAgICAqIGluaXRpYWxpemF0aW9uLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjYXZlYXRTcGVjaWZpY2F0aW9ucywgcGVybWlzc2lvblNwZWNpZmljYXRpb25zLCB1bnJlc3RyaWN0ZWRNZXRob2RzLCBtZXNzZW5nZXIsIHN0YXRlID0ge30sIH0gPSBvcHRpb25zO1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBuYW1lOiBjb250cm9sbGVyTmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiBnZXRTdGF0ZU1ldGFkYXRhKCksXG4gICAgICAgICAgICBtZXNzZW5nZXIsXG4gICAgICAgICAgICBzdGF0ZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXREZWZhdWx0U3RhdGUoKSksIHN0YXRlKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3VucmVzdHJpY3RlZE1ldGhvZHMgPSBuZXcgU2V0KHVucmVzdHJpY3RlZE1ldGhvZHMpO1xuICAgICAgICB0aGlzLl9jYXZlYXRTcGVjaWZpY2F0aW9ucyA9ICgwLCBkZWVwX2ZyZWV6ZV9zdHJpY3RfMS5kZWZhdWx0KShPYmplY3QuYXNzaWduKHt9LCBjYXZlYXRTcGVjaWZpY2F0aW9ucykpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvblNwZWNpZmljYXRpb25zKHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgdGhpcy5fY2F2ZWF0U3BlY2lmaWNhdGlvbnMpO1xuICAgICAgICB0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMgPSAoMCwgZGVlcF9mcmVlemVfc3RyaWN0XzEuZGVmYXVsdCkoT2JqZWN0LmFzc2lnbih7fSwgcGVybWlzc2lvblNwZWNpZmljYXRpb25zKSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJNZXNzYWdlSGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVQZXJtaXNzaW9uTWlkZGxld2FyZSA9ICgwLCBwZXJtaXNzaW9uX21pZGRsZXdhcmVfMS5nZXRQZXJtaXNzaW9uTWlkZGxld2FyZUZhY3RvcnkpKHtcbiAgICAgICAgICAgIGV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kOiB0aGlzLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0UmVzdHJpY3RlZE1ldGhvZDogdGhpcy5nZXRSZXN0cmljdGVkTWV0aG9kLmJpbmQodGhpcyksXG4gICAgICAgICAgICBpc1VucmVzdHJpY3RlZE1ldGhvZDogdGhpcy51bnJlc3RyaWN0ZWRNZXRob2RzLmhhcy5iaW5kKHRoaXMudW5yZXN0cmljdGVkTWV0aG9kcyksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZXMgb2YgYWxsIEpTT04tUlBDIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgbmFtZXMgb2YgYWxsIHVucmVzdHJpY3RlZCBKU09OLVJQQyBtZXRob2RzXG4gICAgICovXG4gICAgZ2V0IHVucmVzdHJpY3RlZE1ldGhvZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91bnJlc3RyaWN0ZWRNZXRob2RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRhcmdldEtleSAtIFRoZSB0YXJnZXQga2V5IG9mIHRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHRhcmdldCBrZXkuXG4gICAgICovXG4gICAgZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnNbdGFyZ2V0S2V5XTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNhdmVhdCBzcGVjaWZpY2F0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhdmVhdFR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgY2F2ZWF0IHNwZWNpZmljYXRpb24gdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIFRoZSBjYXZlYXQgc3BlY2lmaWNhdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZS5cbiAgICAgKi9cbiAgICBnZXRDYXZlYXRTcGVjaWZpY2F0aW9uKGNhdmVhdFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhdmVhdFNwZWNpZmljYXRpb25zW2NhdmVhdFR5cGVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBoZWxwZXIgZm9yIHZhbGlkYXRpbmcgcGVybWlzc2lvbiBzcGVjaWZpY2F0aW9ucy4gVGhpcyBpc1xuICAgICAqIGludGVuZGVkIHRvIHByZXZlbnQgdGhlIHVzZSBvZiBpbnZhbGlkIHRhcmdldCBrZXlzIHdoaWNoLCB3aGlsZSBpbXBvc3NpYmxlXG4gICAgICogdG8gYWRkIGluIFR5cGVTY3JpcHQsIGNvdWxkIHJhdGhlciBlYXNpbHkgb2NjdXIgaW4gcGxhaW4gSmF2YVNjcmlwdC5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucyAtIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb25zIHBhc3NlZCB0b1xuICAgICAqIHRoaXMgY29udHJvbGxlcidzIGNvbnN0cnVjdG9yLlxuICAgICAqIEBwYXJhbSBjYXZlYXRTcGVjaWZpY2F0aW9ucyAtIFRoZSBjYXZlYXQgc3BlY2lmaWNhdGlvbnMgcGFzc2VkIHRvIHRoaXNcbiAgICAgKiBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUGVybWlzc2lvblNwZWNpZmljYXRpb25zKHBlcm1pc3Npb25TcGVjaWZpY2F0aW9ucywgY2F2ZWF0U3BlY2lmaWNhdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmVudHJpZXMocGVybWlzc2lvblNwZWNpZmljYXRpb25zKS5mb3JFYWNoKChbdGFyZ2V0S2V5LCB7IHBlcm1pc3Npb25UeXBlLCB0YXJnZXRLZXk6IGlubmVyVGFyZ2V0S2V5LCBhbGxvd2VkQ2F2ZWF0cyB9LF0pID0+IHtcbiAgICAgICAgICAgIGlmICghcGVybWlzc2lvblR5cGUgfHwgISgwLCB1dGlsXzEuaGFzUHJvcGVydHkpKFBlcm1pc3Npb25fMS5QZXJtaXNzaW9uVHlwZSwgcGVybWlzc2lvblR5cGUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBlcm1pc3Npb24gdHlwZTogXCIke3Blcm1pc3Npb25UeXBlfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGtleSBpcyB0aGUgZW1wdHkgc3RyaW5nLCBlbmRzIHdpdGggXCJfXCIsIG9yIGVuZHNcbiAgICAgICAgICAgIC8vIHdpdGggXCIqXCIgYnV0IG5vdCBcIl8qXCJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0S2V5IHx8IC9fJC91LnRlc3QodGFyZ2V0S2V5KSB8fCAvW15fXVxcKiQvdS50ZXN0KHRhcmdldEtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGVybWlzc2lvbiB0YXJnZXQga2V5OiBcIiR7dGFyZ2V0S2V5fVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0S2V5ICE9PSBpbm5lclRhcmdldEtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb246IGtleSBcIiR7dGFyZ2V0S2V5fVwiIG11c3QgbWF0Y2ggc3BlY2lmaWNhdGlvbi50YXJnZXQgdmFsdWUgXCIke2lubmVyVGFyZ2V0S2V5fVwiLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93ZWRDYXZlYXRzKSB7XG4gICAgICAgICAgICAgICAgYWxsb3dlZENhdmVhdHMuZm9yRWFjaCgoY2F2ZWF0VHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsXzEuaGFzUHJvcGVydHkpKGNhdmVhdFNwZWNpZmljYXRpb25zLCBjYXZlYXRUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvcihjYXZlYXRUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3IgaGVscGVyIGZvciByZWdpc3RlcmluZyB0aGUgY29udHJvbGxlcidzIG1lc3NhZ2luZyBzeXN0ZW1cbiAgICAgKiBhY3Rpb25zLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyTWVzc2FnZUhhbmRsZXJzKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmNsZWFyUGVybWlzc2lvbnNgLCAoKSA9PiB0aGlzLmNsZWFyU3RhdGUoKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06Z2V0RW5kb3dtZW50c2AsIChvcmlnaW4sIHRhcmdldE5hbWUsIHJlcXVlc3REYXRhKSA9PiB0aGlzLmdldEVuZG93bWVudHMob3JpZ2luLCB0YXJnZXROYW1lLCByZXF1ZXN0RGF0YSkpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmdldFN1YmplY3ROYW1lc2AsICgpID0+IHRoaXMuZ2V0U3ViamVjdE5hbWVzKCkpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OmdldFBlcm1pc3Npb25zYCwgKG9yaWdpbikgPT4gdGhpcy5nZXRQZXJtaXNzaW9ucyhvcmlnaW4pKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpoYXNQZXJtaXNzaW9uYCwgKG9yaWdpbiwgdGFyZ2V0TmFtZSkgPT4gdGhpcy5oYXNQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0TmFtZSkpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9Omhhc1Blcm1pc3Npb25zYCwgKG9yaWdpbikgPT4gdGhpcy5oYXNQZXJtaXNzaW9ucyhvcmlnaW4pKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpncmFudFBlcm1pc3Npb25zYCwgdGhpcy5ncmFudFBlcm1pc3Npb25zLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5yZWdpc3RlckFjdGlvbkhhbmRsZXIoYCR7Y29udHJvbGxlck5hbWV9OnJlcXVlc3RQZXJtaXNzaW9uc2AsIChzdWJqZWN0LCBwZXJtaXNzaW9ucykgPT4gdGhpcy5yZXF1ZXN0UGVybWlzc2lvbnMoc3ViamVjdCwgcGVybWlzc2lvbnMpKTtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke2NvbnRyb2xsZXJOYW1lfTpyZXZva2VBbGxQZXJtaXNzaW9uc2AsIChvcmlnaW4pID0+IHRoaXMucmV2b2tlQWxsUGVybWlzc2lvbnMob3JpZ2luKSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06cmV2b2tlUGVybWlzc2lvbkZvckFsbFN1YmplY3RzYCwgKHRhcmdldCkgPT4gdGhpcy5yZXZva2VQZXJtaXNzaW9uRm9yQWxsU3ViamVjdHModGFyZ2V0KSk7XG4gICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLnJlZ2lzdGVyQWN0aW9uSGFuZGxlcihgJHtjb250cm9sbGVyTmFtZX06cmV2b2tlUGVybWlzc2lvbnNgLCB0aGlzLnJldm9rZVBlcm1pc3Npb25zLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHN0YXRlIG9mIHRoZSBjb250cm9sbGVyLlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChfZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldERlZmF1bHRTdGF0ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBwZXJtaXNzaW9uXG4gICAgICogdHlwZSBhbmQgdGFyZ2V0IG5hbWUuIFRocm93cyBhbiBlcnJvciBpZiB0aGUgdGFyZ2V0IG5hbWUgZG9lcyBub3RcbiAgICAgKiBjb3JyZXNwb25kIHRvIGEgcGVybWlzc2lvbiwgb3IgaWYgdGhlIHNwZWNpZmljYXRpb24gaXMgbm90IG9mIHRoZVxuICAgICAqIGdpdmVuIHBlcm1pc3Npb24gdHlwZS5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbiB0byBnZXQuXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb25UeXBlIC0gVGhlIHR5cGUgb2YgdGhlIHBlcm1pc3Npb24gc3BlY2lmaWNhdGlvbiB0byBnZXQuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGVybWlzc2lvbiB3aG9zZSBzcGVjaWZpY2F0aW9uIHRvIGdldC5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdGluZ09yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHJlcXVlc3Rpbmcgc3ViamVjdCwgaWYgYW55LlxuICAgICAqIFdpbGwgYmUgYWRkZWQgdG8gYW55IHRocm93biBlcnJvcnMuXG4gICAgICogQHJldHVybnMgVGhlIHNwZWNpZmljYXRpb24gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHR5cGUgYW5kXG4gICAgICogdGFyZ2V0IG5hbWUuXG4gICAgICovXG4gICAgZ2V0VHlwZWRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbihwZXJtaXNzaW9uVHlwZSwgdGFyZ2V0TmFtZSwgcmVxdWVzdGluZ09yaWdpbikge1xuICAgICAgICBjb25zdCBmYWlsdXJlRXJyb3IgPSBwZXJtaXNzaW9uVHlwZSA9PT0gUGVybWlzc2lvbl8xLlBlcm1pc3Npb25UeXBlLlJlc3RyaWN0ZWRNZXRob2RcbiAgICAgICAgICAgID8gKDAsIGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKSh0YXJnZXROYW1lLCByZXF1ZXN0aW5nT3JpZ2luID8geyBvcmlnaW46IHJlcXVlc3RpbmdPcmlnaW4gfSA6IHVuZGVmaW5lZClcbiAgICAgICAgICAgIDogbmV3IGVycm9yc18xLkVuZG93bWVudFBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcih0YXJnZXROYW1lLCByZXF1ZXN0aW5nT3JpZ2luKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkodGFyZ2V0TmFtZSk7XG4gICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBmYWlsdXJlRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3BlY2lmaWNhdGlvbiA9IHRoaXMuZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KTtcbiAgICAgICAgaWYgKCEoMCwgUGVybWlzc2lvbl8xLmhhc1NwZWNpZmljYXRpb25UeXBlKShzcGVjaWZpY2F0aW9uLCBwZXJtaXNzaW9uVHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IGZhaWx1cmVFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BlY2lmaWNhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIHNwZWNpZmllZCByZXN0cmljdGVkIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEEgSlNPTi1SUEMgZXJyb3IgaXMgdGhyb3duIGlmIHRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0gYW5kXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlfSBmb3IgaW50ZXJuYWwgdXNhZ2UuXG4gICAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSByZXN0cmljdGVkIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHJlcXVlc3QgZm9yIHRoZSByZXN0cmljdGVkXG4gICAgICogbWV0aG9kLCBpZiBhbnkuXG4gICAgICogQHJldHVybnMgVGhlIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGdldFJlc3RyaWN0ZWRNZXRob2QobWV0aG9kLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZWRQZXJtaXNzaW9uU3BlY2lmaWNhdGlvbihQZXJtaXNzaW9uXzEuUGVybWlzc2lvblR5cGUuUmVzdHJpY3RlZE1ldGhvZCwgbWV0aG9kLCBvcmlnaW4pLm1ldGhvZEltcGxlbWVudGF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBhbGwgb3JpZ2lucyBvZiBzdWJqZWN0cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvcmlnaW5zIChpLmUuIElEcykgb2YgYWxsIHN1YmplY3RzLlxuICAgICAqL1xuICAgIGdldFN1YmplY3ROYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3ViamVjdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwZXJtaXNzaW9uIGZvciB0aGUgc3BlY2lmaWVkIHRhcmdldCBvZiB0aGUgc3ViamVjdCBjb3JyZXNwb25kaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBvcmlnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAtIFRoZSBtZXRob2QgbmFtZSBhcyBpbnZva2VkIGJ5IGEgdGhpcmQgcGFydHkgKGkuZS4sIG5vdFxuICAgICAqIGEgbWV0aG9kIGtleSkuXG4gICAgICogQHJldHVybnMgVGhlIHBlcm1pc3Npb24gaWYgaXQgZXhpc3RzLCBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGdldFBlcm1pc3Npb24ob3JpZ2luLCB0YXJnZXROYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc3RhdGUuc3ViamVjdHNbb3JpZ2luXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBlcm1pc3Npb25zW3RhcmdldE5hbWVdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBwZXJtaXNzaW9ucyBmb3IgdGhlIHNwZWNpZmllZCBzdWJqZWN0LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcGVybWlzc2lvbnMgb2YgdGhlIHN1YmplY3QsIGlmIGFueS5cbiAgICAgKi9cbiAgICBnZXRQZXJtaXNzaW9ucyhvcmlnaW4pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVybWlzc2lvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBzdWJqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBvcmlnaW4gaGFzIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBwZXJtaXNzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzdWJqZWN0IGhhcyB0aGUgcGVybWlzc2lvbi5cbiAgICAgKi9cbiAgICBoYXNQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0UGVybWlzc2lvbihvcmlnaW4sIHRhcmdldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZ2luIGhhcyBhbnkgcGVybWlzc2lvbnMuXG4gICAgICogVXNlIHRoaXMgaWYgeW91IHdhbnQgdG8ga25vdyBpZiBhIHN1YmplY3QgXCJleGlzdHNcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN1YmplY3QgaGFzIGFueSBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICBoYXNQZXJtaXNzaW9ucyhvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5zdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV2b2tlcyBhbGwgcGVybWlzc2lvbnMgZnJvbSB0aGUgc3BlY2lmaWVkIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBvZiB0aGUgb3JpZ2luIGhhcyBubyBwZXJtaXNzaW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIHdob3NlIHBlcm1pc3Npb25zIHRvIHJldm9rZS5cbiAgICAgKi9cbiAgICByZXZva2VBbGxQZXJtaXNzaW9ucyhvcmlnaW4pIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmICghZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVucmVjb2duaXplZFN1YmplY3RFcnJvcihvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGRyYWZ0U3RhdGUuc3ViamVjdHNbb3JpZ2luXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldm9rZXMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9uIGZyb20gdGhlIHN1YmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkXG4gICAgICogb3JpZ2luLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBzdWJqZWN0IG9yIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3Qgd2hvc2UgcGVybWlzc2lvbiB0byByZXZva2UuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbiB0byByZXZva2UuXG4gICAgICovXG4gICAgcmV2b2tlUGVybWlzc2lvbihvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICB0aGlzLnJldm9rZVBlcm1pc3Npb25zKHsgW29yaWdpbl06IFt0YXJnZXRdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbnMgZnJvbSB0aGUgc3BlY2lmaWVkIHN1YmplY3RzLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGFueSBvZiB0aGUgc3ViamVjdHMgb3IgcGVybWlzc2lvbnMgZG8gbm90IGV4aXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YmplY3RzQW5kUGVybWlzc2lvbnMgLSBBbiBvYmplY3QgbWFwcGluZyBzdWJqZWN0IG9yaWdpbnNcbiAgICAgKiB0byBhcnJheXMgb2YgcGVybWlzc2lvbiB0YXJnZXQgbmFtZXMgdG8gcmV2b2tlLlxuICAgICAqL1xuICAgIHJldm9rZVBlcm1pc3Npb25zKHN1YmplY3RzQW5kUGVybWlzc2lvbnMpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHN1YmplY3RzQW5kUGVybWlzc2lvbnMpLmZvckVhY2goKG9yaWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghKDAsIHV0aWxfMS5oYXNQcm9wZXJ0eSkoZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN1YmplY3RzQW5kUGVybWlzc2lvbnNbb3JpZ2luXS5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgwLCB1dGlsXzEuaGFzUHJvcGVydHkpKHBlcm1pc3Npb25zLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZVBlcm1pc3Npb24oZHJhZnRTdGF0ZS5zdWJqZWN0cywgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXZva2VzIGFsbCBwZXJtaXNzaW9ucyBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWQgdGFyZ2V0IGZvciBhbGwgc3ViamVjdHMuXG4gICAgICogRG9lcyBub3RoaW5nIGlmIG5vIHN1YmplY3RzIG9yIG5vIHN1Y2ggcGVybWlzc2lvbiBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIG5hbWUgb2YgdGhlIHRhcmdldCB0byByZXZva2UgYWxsIHBlcm1pc3Npb25zIGZvci5cbiAgICAgKi9cbiAgICByZXZva2VQZXJtaXNzaW9uRm9yQWxsU3ViamVjdHModGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLmdldFN1YmplY3ROYW1lcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhkcmFmdFN0YXRlLnN1YmplY3RzKS5mb3JFYWNoKChbb3JpZ2luLCBzdWJqZWN0XSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHN1YmplY3Q7XG4gICAgICAgICAgICAgICAgaWYgKCgwLCB1dGlsXzEuaGFzUHJvcGVydHkpKHBlcm1pc3Npb25zLCB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlUGVybWlzc2lvbihkcmFmdFN0YXRlLnN1YmplY3RzLCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSBwZXJtaXNzaW9uIGlkZW50aWZpZWQgYnkgdGhlIGdpdmVuIG9yaWdpbiBhbmQgdGFyZ2V0LiBJZiB0aGVcbiAgICAgKiBwZXJtaXNzaW9uIGlzIHRoZSBzaW5nbGUgcmVtYWluaW5nIHBlcm1pc3Npb24gb2YgaXRzIHN1YmplY3QsIHRoZSBzdWJqZWN0XG4gICAgICogaXMgYWxzbyBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YmplY3RzIC0gVGhlIGRyYWZ0IHBlcm1pc3Npb24gY29udHJvbGxlciBzdWJqZWN0cy5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIHBlcm1pc3Npb25cbiAgICAgKiB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbiB0byBkZWxldGUuXG4gICAgICovXG4gICAgZGVsZXRlUGVybWlzc2lvbihzdWJqZWN0cywgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgeyBwZXJtaXNzaW9ucyB9ID0gc3ViamVjdHNbb3JpZ2luXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHBlcm1pc3Npb25zKS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBkZWxldGUgcGVybWlzc2lvbnNbdGFyZ2V0XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBwZXJtaXNzaW9uIG9mIHRoZSBzdWJqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuXG4gICAgICogb3JpZ2luIGhhcyBhIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHN1YmplY3QgZG9lcyBub3QgaGF2ZSBhIHBlcm1pc3Npb24gd2l0aCB0aGVcbiAgICAgKiBzcGVjaWZpZWQgdGFyZ2V0IG5hbWUuXG4gICAgICpcbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gY2hlY2sgZm9yLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHBlcm1pc3Npb24gaGFzIHRoZSBzcGVjaWZpZWQgY2F2ZWF0LlxuICAgICAqL1xuICAgIGhhc0NhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjYXZlYXQgb2YgdGhlIHNwZWNpZmllZCB0eXBlLCBpZiBhbnksIGZvciB0aGUgcGVybWlzc2lvbiBvZlxuICAgICAqIHRoZSBzdWJqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIG9yaWdpbi5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiB0aGUgc3ViamVjdCBkb2VzIG5vdCBoYXZlIGEgcGVybWlzc2lvbiB3aXRoIHRoZVxuICAgICAqIHNwZWNpZmllZCB0YXJnZXQgbmFtZS5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBnZXQuXG4gICAgICogQHJldHVybnMgVGhlIGNhdmVhdCwgb3IgYHVuZGVmaW5lZGAgaWYgbm8gc3VjaCBjYXZlYXQgZXhpc3RzLlxuICAgICAqL1xuICAgIGdldENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gdGhpcy5nZXRQZXJtaXNzaW9uKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yKG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIFBlcm1pc3Npb25fMS5maW5kQ2F2ZWF0KShwZXJtaXNzaW9uLCBjYXZlYXRUeXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUsIHdpdGggdGhlIHNwZWNpZmllZCBjYXZlYXQgdmFsdWUsIHRvXG4gICAgICogdGhlIHBlcm1pc3Npb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gc3ViamVjdCBvcmlnaW4gYW5kIHBlcm1pc3Npb25cbiAgICAgKiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBGb3IgbW9kaWZ5aW5nIGV4aXN0aW5nIGNhdmVhdHMsIHVzZVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci51cGRhdGVDYXZlYXR9LlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIG5vIHN1Y2ggcGVybWlzc2lvbiBleGlzdHMsIG9yIGlmIHRoZSBjYXZlYXQgYWxyZWFkeVxuICAgICAqIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBhZGQuXG4gICAgICogQHBhcmFtIGNhdmVhdFZhbHVlIC0gVGhlIHZhbHVlIG9mIHRoZSBjYXZlYXQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZENhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUsIGNhdmVhdFZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgYmVsb25naW5nIHRvIHRoZVxuICAgICAqIHBlcm1pc3Npb24gY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gc3ViamVjdCBvcmlnaW4gYW5kIHBlcm1pc3Npb25cbiAgICAgKiB0YXJnZXQuXG4gICAgICpcbiAgICAgKiBGb3IgYWRkaW5nIG5ldyBjYXZlYXRzLCB1c2VcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWRkQ2F2ZWF0fS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIHBlcm1pc3Npb24gb3IgY2F2ZWF0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIGNhdmVhdFZhbHVlIC0gVGhlIG5ldyB2YWx1ZSBvZiB0aGUgY2F2ZWF0LlxuICAgICAqL1xuICAgIHVwZGF0ZUNhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSwgY2F2ZWF0VmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0NhdmVhdChvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXREb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUsIGNhdmVhdFZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3BlY2lmaWVkIGNhdmVhdCBvbiB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24uIE92ZXJ3cml0ZXMgZXhpc3RpbmdcbiAgICAgKiBjYXZlYXRzIG9mIHRoZSBzYW1lIHR5cGUgaW4tcGxhY2UgKHByZXNlcnZpbmcgYXJyYXkgb3JkZXIpLCBhbmQgYWRkcyB0aGVcbiAgICAgKiBjYXZlYXQgdG8gdGhlIGVuZCBvZiB0aGUgYXJyYXkgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGV4aXN0IG9yIGZhaWxzIHRvIHZhbGlkYXRlIGFmdGVyXG4gICAgICogaXRzIGNhdmVhdHMgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWRkQ2F2ZWF0fVxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnVwZGF0ZUNhdmVhdH1cbiAgICAgKiBAdGVtcGxhdGUgVGFyZ2V0TmFtZSAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLiBTaG91bGQgYmUgaW5mZXJyZWQuXG4gICAgICogQHRlbXBsYXRlIENhdmVhdFR5cGUgLSBUaGUgdmFsaWQgY2F2ZWF0IHR5cGVzIGZvciB0aGUgcGVybWlzc2lvbi4gU2hvdWxkXG4gICAgICogYmUgaW5mZXJyZWQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gY2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXQgdG8gc2V0LlxuICAgICAqIEBwYXJhbSBjYXZlYXRWYWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgY2F2ZWF0IHRvIHNldC5cbiAgICAgKi9cbiAgICBzZXRDYXZlYXQob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUsIGNhdmVhdFZhbHVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0ID0gZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dO1xuICAgICAgICAgICAgLy8gVW5yZWFjaGFibGUgYmVjYXVzZSBgaGFzQ2F2ZWF0YCBpcyBhbHdheXMgY2FsbGVkIGJlZm9yZSB0aGlzLCBhbmQgaXRcbiAgICAgICAgICAgIC8vIHRocm93cyBpZiBwZXJtaXNzaW9ucyBhcmUgbWlzc2luZy4gVHlwZVNjcmlwdCBuZWVkcyB0aGlzLCBob3dldmVyLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICBpZiAoIXN1YmplY3QpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yKG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gc3ViamVjdC5wZXJtaXNzaW9uc1t0YXJnZXRdO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmOiBwcmFjdGljYWxseSBpbXBvc3NpYmxlLCBidXQgVHlwZVNjcmlwdCB3YW50cyBpdCAqL1xuICAgICAgICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjYXZlYXQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogY2F2ZWF0VHlwZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogY2F2ZWF0VmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChwZXJtaXNzaW9uLmNhdmVhdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXZlYXRJbmRleCA9IHBlcm1pc3Npb24uY2F2ZWF0cy5maW5kSW5kZXgoKGV4aXN0aW5nQ2F2ZWF0KSA9PiBleGlzdGluZ0NhdmVhdC50eXBlID09PSBjYXZlYXQudHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhdmVhdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMucHVzaChjYXZlYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVybWlzc2lvbi5jYXZlYXRzLnNwbGljZShjYXZlYXRJbmRleCwgMSwgY2F2ZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUeXBlY2FzdDogQXQgdGhpcyBwb2ludCwgd2UgZG9uJ3Qga25vdyBpZiB0aGUgc3BlY2lmaWMgcGVybWlzc2lvblxuICAgICAgICAgICAgICAgIC8vIGlzIGFsbG93ZWQgdG8gaGF2ZSBjYXZlYXRzLCBidXQgaXQgc2hvdWxkIGJlIGltcG9zc2libGUgdG8gY2FsbFxuICAgICAgICAgICAgICAgIC8vIHRoaXMgbWV0aG9kIGZvciBhIHBlcm1pc3Npb24gdGhhdCBtYXkgbm90IGhhdmUgYW55IGNhdmVhdHMuXG4gICAgICAgICAgICAgICAgLy8gSWYgYWxsIGVsc2UgZmFpbHMsIHRoZSBwZXJtaXNzaW9uIHZhbGlkYXRvciBpcyBhbHNvIGNhbGxlZC5cbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMgPSBbY2F2ZWF0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVNb2RpZmllZFBlcm1pc3Npb24ocGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbGwgY2F2ZWF0cyB3aXRoIHRoZSBzcGVjaWZpZWQgdHlwZSBmb3IgYWxsIHN1YmplY3RzIGFuZFxuICAgICAqIHBlcm1pc3Npb25zIGJ5IGFwcGx5aW5nIHRoZSBzcGVjaWZpZWQgbXV0YXRvciBmdW5jdGlvbiB0byB0aGVtLlxuICAgICAqXG4gICAgICogQVRUTjogUGVybWlzc2lvbnMgY2FuIGJlIHJldm9rZWQgZW50aXJlbHkgYnkgdGhlIGFjdGlvbiBvZiB0aGlzIG1ldGhvZCxcbiAgICAgKiByZWFkIG9uIGZvciBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQ2F2ZWF0IG11dGF0b3JzIGFyZSBmdW5jdGlvbnMgdGhhdCByZWNlaXZlIGEgY2F2ZWF0IHZhbHVlIGFuZCByZXR1cm4gYVxuICAgICAqIHR1cGxlIGNvbnNpc3Rpbmcgb2YgYSB7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbn0gYW5kLCBvcHRpb25hbGx5LCBhIG5ld1xuICAgICAqIHZhbHVlIHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgY2F2ZWF0IHdpdGguXG4gICAgICpcbiAgICAgKiBGb3IgZWFjaCBjYXZlYXQsIGRlcGVuZGluZyBvbiB0aGUgbXV0YXRvciByZXN1bHQsIHRoaXMgbWV0aG9kIHdpbGw6XG4gICAgICogLSBEbyBub3RoaW5nICh7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5ub29wfSlcbiAgICAgKiAtIFVwZGF0ZSB0aGUgdmFsdWUgb2YgdGhlIGNhdmVhdCAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24udXBkYXRlVmFsdWV9KS4gVGhlIGNhdmVhdCBzcGVjaWZpY2F0aW9uIHZhbGlkYXRvciwgaWYgYW55LCB3aWxsIGJlIGNhbGxlZCBhZnRlciB1cGRhdGluZyB0aGUgdmFsdWUuXG4gICAgICogLSBEZWxldGUgdGhlIGNhdmVhdCAoe0BsaW5rIENhdmVhdE11dGF0b3JPcGVyYXRpb24uZGVsZXRlQ2F2ZWF0fSkuIFRoZSBwZXJtaXNzaW9uIHNwZWNpZmljYXRpb24gdmFsaWRhdG9yLCBpZiBhbnksIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGRlbGV0aW5nIHRoZSBjYXZlYXQuXG4gICAgICogLSBSZXZva2UgdGhlIHBhcmVudCBwZXJtaXNzaW9uICh7QGxpbmsgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5yZXZva2VQZXJtaXNzaW9ufSlcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiB0aGUgdmFsaWRhdGlvbiBvZiBhbnkgY2F2ZWF0IG9yIHBlcm1pc3Npb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0Q2F2ZWF0VHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBjYXZlYXRzIHRvIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gbXV0YXRvciAtIFRoZSBtdXRhdG9yIGZ1bmN0aW9uIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byBhbGwgY2F2ZWF0XG4gICAgICogdmFsdWVzLlxuICAgICAqL1xuICAgIHVwZGF0ZVBlcm1pc3Npb25zQnlDYXZlYXQodGFyZ2V0Q2F2ZWF0VHlwZSwgbXV0YXRvcikge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5zdGF0ZS5zdWJqZWN0cykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoKGRyYWZ0U3RhdGUpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoZHJhZnRTdGF0ZS5zdWJqZWN0cykuZm9yRWFjaCgoc3ViamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIE9iamVjdC52YWx1ZXMoc3ViamVjdC5wZXJtaXNzaW9ucykuZm9yRWFjaCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNhdmVhdHMgfSA9IHBlcm1pc3Npb247XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENhdmVhdCA9IGNhdmVhdHMgPT09IG51bGwgfHwgY2F2ZWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F2ZWF0cy5maW5kKCh7IHR5cGUgfSkgPT4gdHlwZSA9PT0gdGFyZ2V0Q2F2ZWF0VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0Q2F2ZWF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG11dGF0b3IgbWF5IG1vZGlmeSB0aGUgY2F2ZWF0IHZhbHVlIGluIHBsYWNlLCBhbmQgbXVzdCBhbHdheXNcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuIGEgdmFsaWQgbXV0YXRpb24gcmVzdWx0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtdXRhdG9yUmVzdWx0ID0gbXV0YXRvcih0YXJnZXRDYXZlYXQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG11dGF0b3JSZXN1bHQub3BlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIENhdmVhdE11dGF0b3JPcGVyYXRpb24ubm9vcDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi51cGRhdGVWYWx1ZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUeXBlY2FzdDogYE11dGFibGVgIGlzIHVzZWQgaGVyZSB0byBhc3NpZ24gdG8gYSByZWFkb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5LiBgdGFyZ2V0Q29uc3RyYWludGAgc2hvdWxkIGFscmVhZHkgYmUgbXV0YWJsZSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwYXJ0IG9mIGEgZHJhZnQsIGJ1dCBmb3Igc29tZSByZWFzb24gaXQncyBub3QuIFdlIGNhbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBtb3JlLWNvcnJlY3QgYERyYWZ0YCB0eXBlIGhlcmUgZWl0aGVyIGJlY2F1c2UgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGluIGFuIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldENhdmVhdC52YWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG11dGF0b3JSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdmVhdCh0YXJnZXRDYXZlYXQsIHN1YmplY3Qub3JpZ2luLCBwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDYXZlYXRNdXRhdG9yT3BlcmF0aW9uLmRlbGV0ZUNhdmVhdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGV0ZUNhdmVhdChwZXJtaXNzaW9uLCB0YXJnZXRDYXZlYXRUeXBlLCBzdWJqZWN0Lm9yaWdpbiwgcGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQ2F2ZWF0TXV0YXRvck9wZXJhdGlvbi5yZXZva2VQZXJtaXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVsZXRlUGVybWlzc2lvbihkcmFmdFN0YXRlLnN1YmplY3RzLCBzdWJqZWN0Lm9yaWdpbiwgcGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHR5cGUgY2hlY2sgZW5zdXJlcyB0aGF0IHRoZSBzd2l0Y2ggc3RhdGVtZW50IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhoYXVzdGl2ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbXV0YXRvclJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtdXRhdGlvbiByZXN1bHQ6IFwiJHtfZXhoYXVzdGl2ZUNoZWNrLm9wZXJhdGlvbn1cImApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNhdmVhdCBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgZnJvbSB0aGUgcGVybWlzc2lvbiBjb3JyZXNwb25kaW5nXG4gICAgICogdG8gdGhlIGdpdmVuIHN1YmplY3Qgb3JpZ2luIGFuZCB0YXJnZXQgbmFtZS5cbiAgICAgKlxuICAgICAqIFRocm93cyBhbiBlcnJvciBpZiBubyBzdWNoIHBlcm1pc3Npb24gb3IgY2F2ZWF0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEB0ZW1wbGF0ZSBUYXJnZXROYW1lIC0gVGhlIHBlcm1pc3Npb24gdGFyZ2V0IG5hbWUuIFNob3VsZCBiZSBpbmZlcnJlZC5cbiAgICAgKiBAdGVtcGxhdGUgQ2F2ZWF0VHlwZSAtIFRoZSB2YWxpZCBjYXZlYXQgdHlwZXMgZm9yIHRoZSBwZXJtaXNzaW9uLiBTaG91bGRcbiAgICAgKiBiZSBpbmZlcnJlZC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHRhcmdldCBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlQ2F2ZWF0KG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRUeXBlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gKF9hID0gZHJhZnRTdGF0ZS5zdWJqZWN0c1tvcmlnaW5dKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVybWlzc2lvbnNbdGFyZ2V0XTtcbiAgICAgICAgICAgIGlmICghcGVybWlzc2lvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5QZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwZXJtaXNzaW9uLmNhdmVhdHMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3Iob3JpZ2luLCB0YXJnZXQsIGNhdmVhdFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWxldGVDYXZlYXQocGVybWlzc2lvbiwgY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyB0aGUgc3BlY2lmaWVkIGNhdmVhdCBmcm9tIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbi4gSWYgbm8gY2F2ZWF0c1xuICAgICAqIHJlbWFpbiBhZnRlciBkZWxldGlvbiwgdGhlIHBlcm1pc3Npb24ncyBjYXZlYXQgcHJvcGVydHkgaXMgc2V0IHRvIGBudWxsYC5cbiAgICAgKiBUaGUgcGVybWlzc2lvbiBpcyB2YWxpZGF0ZWQgYWZ0ZXIgYmVpbmcgbW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIHBlcm1pc3Npb24gZG9lcyBub3QgaGF2ZSBhIGNhdmVhdCB3aXRoIHRoZSBzcGVjaWZpZWRcbiAgICAgKiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBlcm1pc3Npb24gLSBUaGUgcGVybWlzc2lvbiB3aG9zZSBjYXZlYXQgdG8gZGVsZXRlLlxuICAgICAqIEBwYXJhbSBjYXZlYXRUeXBlIC0gVGhlIHR5cGUgb2YgdGhlIGNhdmVhdCB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBvcmlnaW4gdGhlIHBlcm1pc3Npb24gc3ViamVjdC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIG5hbWUgb2YgdGhlIHBlcm1pc3Npb24gdGFyZ2V0LlxuICAgICAqL1xuICAgIGRlbGV0ZUNhdmVhdChwZXJtaXNzaW9uLCBjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IG5vdCBwb3NzaWJsZSBpbiBvdXIgdXNhZ2UgKi9cbiAgICAgICAgaWYgKCFwZXJtaXNzaW9uLmNhdmVhdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXREb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2F2ZWF0SW5kZXggPSBwZXJtaXNzaW9uLmNhdmVhdHMuZmluZEluZGV4KChleGlzdGluZ0NhdmVhdCkgPT4gZXhpc3RpbmdDYXZlYXQudHlwZSA9PT0gY2F2ZWF0VHlwZSk7XG4gICAgICAgIGlmIChjYXZlYXRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXREb2VzTm90RXhpc3RFcnJvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBlcm1pc3Npb24uY2F2ZWF0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHBlcm1pc3Npb24uY2F2ZWF0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwZXJtaXNzaW9uLmNhdmVhdHMuc3BsaWNlKGNhdmVhdEluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbGlkYXRlTW9kaWZpZWRQZXJtaXNzaW9uKHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBzcGVjaWZpZWQgbW9kaWZpZWQgcGVybWlzc2lvbi4gU2hvdWxkICoqYWx3YXlzKiogYmUgaW52b2tlZFxuICAgICAqIG9uIGEgcGVybWlzc2lvbiBhZnRlciBpdHMgY2F2ZWF0cyBoYXZlIGJlZW4gbW9kaWZpZWQuXG4gICAgICpcbiAgICAgKiBKdXN0IGxpa2Uge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnZhbGlkYXRlUGVybWlzc2lvbn0sIGV4Y2VwdCB0aGF0IHRoZVxuICAgICAqIGNvcnJlc3BvbmRpbmcgdGFyZ2V0IGtleSBhbmQgc3BlY2lmaWNhdGlvbiBhcmUgcmV0cmlldmVkIGZpcnN0LCBhbmQgYW5cbiAgICAgKiBlcnJvciBpcyB0aHJvd24gaWYgdGhlIHRhcmdldCBrZXkgZG9lcyBub3QgZXhpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbiAtIFRoZSBtb2RpZmllZCBwZXJtaXNzaW9uIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAtIFRoZSB0YXJnZXQgbmFtZSBuYW1lIG9mIHRoZSBwZXJtaXNzaW9uLlxuICAgICAqL1xuICAgIHZhbGlkYXRlTW9kaWZpZWRQZXJtaXNzaW9uKHBlcm1pc3Npb24sIG9yaWdpbiwgdGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCB0YXJnZXRLZXkgPSB0aGlzLmdldFRhcmdldEtleShwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHRoaXMgc2hvdWxkIGJlIGltcG9zc2libGUgKi9cbiAgICAgICAgaWYgKCF0YXJnZXRLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmF0YWw6IEV4aXN0aW5nIHBlcm1pc3Npb24gdGFyZ2V0IGtleSBcIiR7dGFyZ2V0S2V5fVwiIGhhcyBubyBzcGVjaWZpY2F0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsaWRhdGVQZXJtaXNzaW9uKHRoaXMuZ2V0UGVybWlzc2lvblNwZWNpZmljYXRpb24odGFyZ2V0S2V5KSwgcGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUga2V5IGZvciB0aGUgc3BlY2lmaWVkIHBlcm1pc3Npb24gdGFyZ2V0LlxuICAgICAqXG4gICAgICogVXNlZCB0byBzdXBwb3J0IG91ciBuYW1lc3BhY2VkIHBlcm1pc3Npb24gdGFyZ2V0IGZlYXR1cmUsIHdoaWNoIGlzIHVzZWRcbiAgICAgKiB0byBpbXBsZW1lbnQgbmFtZXNwYWNlZCByZXN0cmljdGVkIEpTT04tUlBDIG1ldGhvZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IC0gVGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9uIHRhcmdldC5cbiAgICAgKiBAcmV0dXJucyBUaGUgaW50ZXJuYWwga2V5IG9mIHRoZSBwZXJtaXNzaW9uIHRhcmdldC5cbiAgICAgKi9cbiAgICBnZXRUYXJnZXRLZXkodGFyZ2V0KSB7XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmhhc1Byb3BlcnR5KSh0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZXNwYWNlZFRhcmdldHNXaXRob3V0V2lsZGNhcmQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB0YXJnZXRLZXkgb2YgT2JqZWN0LmtleXModGhpcy5fcGVybWlzc2lvblNwZWNpZmljYXRpb25zKSkge1xuICAgICAgICAgICAgY29uc3Qgd2lsZENhcmRNYXRjaCA9IHRhcmdldEtleS5tYXRjaCgvKC4rKVxcKiQvdSk7XG4gICAgICAgICAgICBpZiAod2lsZENhcmRNYXRjaCkge1xuICAgICAgICAgICAgICAgIG5hbWVzcGFjZWRUYXJnZXRzV2l0aG91dFdpbGRjYXJkW3dpbGRDYXJkTWF0Y2hbMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgcG90ZW50aWFsbHkgbmVzdGVkIG5hbWVzcGFjZXM6XG4gICAgICAgIC8vIEV4OiB3aWxkem9uZV9cbiAgICAgICAgLy8gRXg6IGV0aF9wbHVnaW5fXG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gdGFyZ2V0LnNwbGl0KCdfJyk7XG4gICAgICAgIGxldCB0YXJnZXRLZXkgPSAnJztcbiAgICAgICAgd2hpbGUgKHNlZ21lbnRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICEoMCwgdXRpbF8xLmhhc1Byb3BlcnR5KSh0aGlzLl9wZXJtaXNzaW9uU3BlY2lmaWNhdGlvbnMsIHRhcmdldEtleSkgJiZcbiAgICAgICAgICAgICFuYW1lc3BhY2VkVGFyZ2V0c1dpdGhvdXRXaWxkY2FyZFt0YXJnZXRLZXldKSB7XG4gICAgICAgICAgICB0YXJnZXRLZXkgKz0gYCR7c2VnbWVudHMuc2hpZnQoKX1fYDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlZFRhcmdldHNXaXRob3V0V2lsZGNhcmRbdGFyZ2V0S2V5XSkge1xuICAgICAgICAgICAgcmV0dXJuIGAke3RhcmdldEtleX0qYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgX2FwcHJvdmVkXyBwZXJtaXNzaW9ucyB0byB0aGUgc3BlY2lmaWVkIHN1YmplY3QuIEV2ZXJ5IHBlcm1pc3Npb24gYW5kXG4gICAgICogY2F2ZWF0IGlzIHN0cmluZ2VudGx5IHZhbGlkYXRlZCDigJMgaW5jbHVkaW5nIGJ5IGNhbGxpbmcgZXZlcnkgc3BlY2lmaWNhdGlvblxuICAgICAqIHZhbGlkYXRvciDigJMgYW5kIGFuIGVycm9yIGlzIHRocm93biBpZiBhbnkgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEFUVE46IFRoaXMgbWV0aG9kIGRvZXMgKipub3QqKiBwcm9tcHQgdGhlIHVzZXIgZm9yIGFwcHJvdmFsLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIucmVxdWVzdFBlcm1pc3Npb25zfSBGb3IgaW5pdGlhdGluZyBhXG4gICAgICogcGVybWlzc2lvbnMgcmVxdWVzdCByZXF1aXJpbmcgdXNlciBhcHByb3ZhbC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgYmFnLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmFwcHJvdmVkUGVybWlzc2lvbnMgLSBUaGUgcmVxdWVzdGVkIHBlcm1pc3Npb25zIGFwcHJvdmVkIGJ5XG4gICAgICogdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmVxdWVzdERhdGEgLSBQZXJtaXNzaW9uIHJlcXVlc3QgZGF0YS4gUGFzc2VkIHRvIHBlcm1pc3Npb25cbiAgICAgKiBmYWN0b3J5IGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgLSBXaGV0aGVyIHRvIHByZXNlcnZlIHRoZVxuICAgICAqIHN1YmplY3QncyBleGlzdGluZyBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5zdWJqZWN0IC0gVGhlIHN1YmplY3QgdG8gZ3JhbnQgcGVybWlzc2lvbnMgdG8uXG4gICAgICogQHJldHVybnMgVGhlIGdyYW50ZWQgcGVybWlzc2lvbnMuXG4gICAgICovXG4gICAgZ3JhbnRQZXJtaXNzaW9ucyh7IGFwcHJvdmVkUGVybWlzc2lvbnMsIHJlcXVlc3REYXRhLCBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgPSB0cnVlLCBzdWJqZWN0LCB9KSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBzdWJqZWN0O1xuICAgICAgICBpZiAoIW9yaWdpbiB8fCB0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSAocHJlc2VydmVFeGlzdGluZ1Blcm1pc3Npb25zXG4gICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0UGVybWlzc2lvbnMob3JpZ2luKSkgOiB7fSk7XG4gICAgICAgIGZvciAoY29uc3QgW3JlcXVlc3RlZFRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uXSBvZiBPYmplY3QuZW50cmllcyhhcHByb3ZlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gdGhpcy5nZXRUYXJnZXRLZXkocmVxdWVzdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLm1ldGhvZE5vdEZvdW5kKShyZXF1ZXN0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFwcHJvdmVkUGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICByZXF1ZXN0ZWRUYXJnZXQgIT09IGFwcHJvdmVkUGVybWlzc2lvbi5wYXJlbnRDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRBcHByb3ZlZFBlcm1pc3Npb25FcnJvcihvcmlnaW4sIHJlcXVlc3RlZFRhcmdldCwgYXBwcm92ZWRQZXJtaXNzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSByZXF1ZXN0ZWQgdGFyZ2V0IG11c3QgYmUgYSB2YWxpZCB0YXJnZXQgbmFtZSBpZiB3ZSBmb3VuZCBpdHMga2V5LlxuICAgICAgICAgICAgLy8gV2UgcmVhc3NpZ24gaXQgdG8gY2hhbmdlIGl0cyB0eXBlLlxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHJlcXVlc3RlZFRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSB0aGlzLmdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSk7XG4gICAgICAgICAgICAvLyBUaGUgcmVxdWVzdGVkIGNhdmVhdHMgYXJlIHZhbGlkYXRlZCBoZXJlLlxuICAgICAgICAgICAgY29uc3QgY2F2ZWF0cyA9IHRoaXMuY29uc3RydWN0Q2F2ZWF0cyhvcmlnaW4sIHRhcmdldE5hbWUsIGFwcHJvdmVkUGVybWlzc2lvbi5jYXZlYXRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGNhdmVhdHMsXG4gICAgICAgICAgICAgICAgaW52b2tlcjogb3JpZ2luLFxuICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsZXQgcGVybWlzc2lvbjtcbiAgICAgICAgICAgIGlmIChzcGVjaWZpY2F0aW9uLmZhY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uID0gc3BlY2lmaWNhdGlvbi5mYWN0b3J5KHBlcm1pc3Npb25PcHRpb25zLCByZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgLy8gRnVsbCBjYXZlYXQgYW5kIHBlcm1pc3Npb24gdmFsaWRhdGlvbiBpcyBwZXJmb3JtZWQgaGVyZSBzaW5jZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBmYWN0b3J5IGZ1bmN0aW9uIGNhbiBhcmJpdHJhcmlseSBtb2RpZnkgdGhlIGVudGlyZSBwZXJtaXNzaW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBpbmNsdWRpbmcgaXRzIGNhdmVhdHMuXG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVBlcm1pc3Npb24oc3BlY2lmaWNhdGlvbiwgcGVybWlzc2lvbiwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcm1pc3Npb24gPSAoMCwgUGVybWlzc2lvbl8xLmNvbnN0cnVjdFBlcm1pc3Npb24pKHBlcm1pc3Npb25PcHRpb25zKTtcbiAgICAgICAgICAgICAgICAvLyBXZSBkbyBub3QgbmVlZCB0byB2YWxpZGF0ZSBjYXZlYXRzIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGUgcGxhaW5cbiAgICAgICAgICAgICAgICAvLyBwZXJtaXNzaW9uIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGRvZXMgbm90IG1vZGlmeSB0aGUgY2F2ZWF0cywgd2hpY2hcbiAgICAgICAgICAgICAgICAvLyB3ZXJlIGFscmVhZHkgdmFsaWRhdGVkIGJ5IGBjb25zdHJ1Y3RDYXZlYXRzYCBhYm92ZS5cbiAgICAgICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbihzcGVjaWZpY2F0aW9uLCBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUsIHtcbiAgICAgICAgICAgICAgICAgICAgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVybWlzc2lvbnNbdGFyZ2V0TmFtZV0gPSBwZXJtaXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VmFsaWRhdGVkUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgIHJldHVybiBwZXJtaXNzaW9ucztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBzcGVjaWZpZWQgcGVybWlzc2lvbiBieTpcbiAgICAgKiAtIEVuc3VyaW5nIHRoYXQgaXRzIGBjYXZlYXRzYCBwcm9wZXJ0eSBpcyBlaXRoZXIgYG51bGxgIG9yIGEgbm9uLWVtcHR5IGFycmF5LlxuICAgICAqIC0gRW5zdXJpbmcgdGhhdCBpdCBvbmx5IGluY2x1ZGVzIGNhdmVhdHMgYWxsb3dlZCBieSBpdHMgc3BlY2lmaWNhdGlvbi5cbiAgICAgKiAtIEVuc3VyaW5nIHRoYXQgaXQgaW5jbHVkZXMgbm8gZHVwbGljYXRlIGNhdmVhdHMgKGJ5IGNhdmVhdCB0eXBlKS5cbiAgICAgKiAtIFZhbGlkYXRpbmcgZWFjaCBjYXZlYXQgb2JqZWN0LCBpZiBgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb25gIGlzIGB0cnVlYC5cbiAgICAgKiAtIENhbGxpbmcgdGhlIHZhbGlkYXRvciBvZiBpdHMgc3BlY2lmaWNhdGlvbiwgaWYgb25lIGV4aXN0cyBhbmQgYGludm9rZVBlcm1pc3Npb25WYWxpZGF0b3JgIGlzIGB0cnVlYC5cbiAgICAgKlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNwZWNpZmljYXRpb24gLSBUaGUgc3BlY2lmaWNhdGlvbiBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbiAtIFRoZSBwZXJtaXNzaW9uIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIGFzc29jaWF0ZWQgd2l0aCB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0TmFtZSAtIFRoZSB0YXJnZXQgbmFtZSBvZiB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcGFyYW0gdmFsaWRhdGlvbk9wdGlvbnMgLSBWYWxpZGF0aW9uIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIHZhbGlkYXRpb25PcHRpb25zLmludm9rZVBlcm1pc3Npb25WYWxpZGF0b3IgLSBXaGV0aGVyIHRvIGludm9rZSB0aGVcbiAgICAgKiBwZXJtaXNzaW9uJ3MgY29uc3VtZXItc3BlY2lmaWVkIHZhbGlkYXRvciBmdW5jdGlvbiwgaWYgYW55LlxuICAgICAqIEBwYXJhbSB2YWxpZGF0aW9uT3B0aW9ucy5wZXJmb3JtQ2F2ZWF0VmFsaWRhdGlvbiAtIFdoZXRoZXIgdG8gaW52b2tlXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnZhbGlkYXRlQ2F2ZWF0fSBvbiBlYWNoIG9mIHRoZSBwZXJtaXNzaW9uJ3NcbiAgICAgKiBjYXZlYXRzLlxuICAgICAqL1xuICAgIHZhbGlkYXRlUGVybWlzc2lvbihzcGVjaWZpY2F0aW9uLCBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUsIHsgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvciwgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb24gfSA9IHtcbiAgICAgICAgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcjogdHJ1ZSxcbiAgICAgICAgcGVyZm9ybUNhdmVhdFZhbGlkYXRpb246IHRydWUsXG4gICAgfSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRDYXZlYXRzLCB2YWxpZGF0b3IgfSA9IHNwZWNpZmljYXRpb247XG4gICAgICAgIGlmICgoMCwgdXRpbF8xLmhhc1Byb3BlcnR5KShwZXJtaXNzaW9uLCAnY2F2ZWF0cycpKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhdmVhdHMgfSA9IHBlcm1pc3Npb247XG4gICAgICAgICAgICBpZiAoY2F2ZWF0cyAhPT0gbnVsbCAmJiAhKEFycmF5LmlzQXJyYXkoY2F2ZWF0cykgJiYgY2F2ZWF0cy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3Iob3JpZ2luLCB0YXJnZXROYW1lLCBjYXZlYXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlZW5DYXZlYXRUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGNhdmVhdHMgPT09IG51bGwgfHwgY2F2ZWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F2ZWF0cy5mb3JFYWNoKChjYXZlYXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocGVyZm9ybUNhdmVhdFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNhdmVhdChjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKGFsbG93ZWRDYXZlYXRzID09PSBudWxsIHx8IGFsbG93ZWRDYXZlYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbGxvd2VkQ2F2ZWF0cy5pbmNsdWRlcyhjYXZlYXQudHlwZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5Gb3JiaWRkZW5DYXZlYXRFcnJvcihjYXZlYXQudHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNlZW5DYXZlYXRUeXBlcy5oYXMoY2F2ZWF0LnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5EdXBsaWNhdGVDYXZlYXRFcnJvcihjYXZlYXQudHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VlbkNhdmVhdFR5cGVzLmFkZChjYXZlYXQudHlwZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW52b2tlUGVybWlzc2lvblZhbGlkYXRvciAmJiB2YWxpZGF0b3IpIHtcbiAgICAgICAgICAgIHZhbGlkYXRvcihwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgdGhlIHNwZWNpZmllZCBwZXJtaXNzaW9ucyB0byB0aGUgc3ViamVjdCB3aXRoIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICogT3ZlcndyaXRlcyBhbGwgZXhpc3RpbmcgcGVybWlzc2lvbnMsIGFuZCBjcmVhdGVzIGEgc3ViamVjdCBlbnRyeSBpZiBpdFxuICAgICAqIGRvZXNuJ3QgYWxyZWFkeSBleGlzdC5cbiAgICAgKlxuICAgICAqIEFUVE46IEFzc3VtZXMgdGhhdCB0aGUgbmV3IHBlcm1pc3Npb25zIGhhdmUgYmVlbiB2YWxpZGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZ3JhbnRlZSBzdWJqZWN0LlxuICAgICAqIEBwYXJhbSBwZXJtaXNzaW9ucyAtIFRoZSBuZXcgcGVybWlzc2lvbnMgZm9yIHRoZSBncmFudGVlIHN1YmplY3QuXG4gICAgICovXG4gICAgc2V0VmFsaWRhdGVkUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucykge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl0pIHtcbiAgICAgICAgICAgICAgICBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl0gPSB7IG9yaWdpbiwgcGVybWlzc2lvbnM6IHt9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkcmFmdFN0YXRlLnN1YmplY3RzW29yaWdpbl0ucGVybWlzc2lvbnMgPSAoMCwgaW1tZXJfMS5jYXN0RHJhZnQpKHBlcm1pc3Npb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgcmVxdWVzdGVkIGNhdmVhdHMgZm9yIHRoZSBwZXJtaXNzaW9uIG9mIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBzdWJqZWN0IG9yaWdpbiBhbmQgdGFyZ2V0IG5hbWUgYW5kIHJldHVybnMgdGhlIHZhbGlkYXRlZCBjYXZlYXQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBwZXJtaXNzaW9uIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSBwZXJtaXNzaW9uIHRhcmdldCBuYW1lLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0ZWRDYXZlYXRzIC0gVGhlIHJlcXVlc3RlZCBjYXZlYXRzIHRvIGNvbnN0cnVjdC5cbiAgICAgKiBAcmV0dXJucyBUaGUgY29uc3RydWN0ZWQgY2F2ZWF0cy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RDYXZlYXRzKG9yaWdpbiwgdGFyZ2V0LCByZXF1ZXN0ZWRDYXZlYXRzKSB7XG4gICAgICAgIGNvbnN0IGNhdmVhdEFycmF5ID0gcmVxdWVzdGVkQ2F2ZWF0cyA9PT0gbnVsbCB8fCByZXF1ZXN0ZWRDYXZlYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXF1ZXN0ZWRDYXZlYXRzLm1hcCgocmVxdWVzdGVkQ2F2ZWF0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ2F2ZWF0KHJlcXVlc3RlZENhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICAgICAgLy8gUmVhc3NpZ24gc28gdGhhdCB3ZSBoYXZlIGEgZnJlc2ggb2JqZWN0LlxuICAgICAgICAgICAgY29uc3QgeyB0eXBlLCB2YWx1ZSB9ID0gcmVxdWVzdGVkQ2F2ZWF0O1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZSwgdmFsdWUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjYXZlYXRBcnJheSAmJiAoMCwgdXRpbF8xLmlzTm9uRW1wdHlBcnJheSkoY2F2ZWF0QXJyYXkpXG4gICAgICAgICAgICA/IGNhdmVhdEFycmF5XG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2RzIHZhbGlkYXRlcyB0aGF0IHRoZSBzcGVjaWZpZWQgY2F2ZWF0IGlzIGFuIG9iamVjdCB3aXRoIHRoZVxuICAgICAqIGV4cGVjdGVkIHByb3BlcnRpZXMgYW5kIHR5cGVzLiBJdCBhbHNvIGVuc3VyZXMgdGhhdCBhIGNhdmVhdCBzcGVjaWZpY2F0aW9uXG4gICAgICogZXhpc3RzIGZvciB0aGUgcmVxdWVzdGVkIGNhdmVhdCB0eXBlLCBhbmQgY2FsbHMgdGhlIHNwZWNpZmljYXRpb25cbiAgICAgKiB2YWxpZGF0b3IsIGlmIGl0IGV4aXN0cywgb24gdGhlIGNhdmVhdCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaHJvd3MgYW4gZXJyb3IgaWYgdmFsaWRhdGlvbiBmYWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYXZlYXQgLSBUaGUgY2F2ZWF0IG9iamVjdCB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBhc3NvY2lhdGVkIHdpdGggdGhlIHN1YmplY3Qgb2YgdGhlIHBhcmVudFxuICAgICAqIHBlcm1pc3Npb24uXG4gICAgICogQHBhcmFtIHRhcmdldCAtIFRoZSB0YXJnZXQgbmFtZSBhc3NvY2lhdGVkIHdpdGggdGhlIHBhcmVudCBwZXJtaXNzaW9uLlxuICAgICAqL1xuICAgIHZhbGlkYXRlQ2F2ZWF0KGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoISgwLCB1dGlsXzEuaXNQbGFpbk9iamVjdCkoY2F2ZWF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRDYXZlYXRFcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoY2F2ZWF0KS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjYXZlYXQudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkQ2F2ZWF0VHlwZUVycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwZWNpZmljYXRpb24gPSB0aGlzLmdldENhdmVhdFNwZWNpZmljYXRpb24oY2F2ZWF0LnR5cGUpO1xuICAgICAgICBpZiAoIXNwZWNpZmljYXRpb24pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnJlY29nbml6ZWRDYXZlYXRUeXBlRXJyb3IoY2F2ZWF0LnR5cGUsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCB1dGlsXzEuaGFzUHJvcGVydHkpKGNhdmVhdCwgJ3ZhbHVlJykgfHwgY2F2ZWF0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXRNaXNzaW5nVmFsdWVFcnJvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCB1dGlsXzEuaXNWYWxpZEpzb24pKGNhdmVhdC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5DYXZlYXRJbnZhbGlkSnNvbkVycm9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR5cGVjYXN0OiBUeXBlU2NyaXB0IHN0aWxsIGJlbGlldmVzIHRoYXQgdGhlIGNhdmVhdCBpcyBhIFBsYWluT2JqZWN0LlxuICAgICAgICAoX2EgPSBzcGVjaWZpY2F0aW9uLnZhbGlkYXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoc3BlY2lmaWNhdGlvbiwgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlcyBhIHBlcm1pc3Npb24gcmVxdWVzdCB0aGF0IHJlcXVpcmVzIHVzZXIgYXBwcm92YWwuIFRoaXMgc2hvdWxkXG4gICAgICogYWx3YXlzIGJlIHVzZWQgdG8gZ3JhbnQgYWRkaXRpb25hbCBwZXJtaXNzaW9ucyB0byBhIHN1YmplY3QsIHVubGVzcyB1c2VyXG4gICAgICogYXBwcm92YWwgaGFzIGJlZW4gb2J0YWluZWQgdGhyb3VnaCBzb21lIG90aGVyIG1lYW5zLlxuICAgICAqXG4gICAgICogUGVybWlzc2lvbnMgYXJlIHZhbGlkYXRlZCBhdCBldmVyeSBzdGVwIG9mIHRoZSBhcHByb3ZhbCBwcm9jZXNzLCBhbmQgdGhpc1xuICAgICAqIG1ldGhvZCB3aWxsIHJlamVjdCBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgQXBwcm92YWxDb250cm9sbGVyfSBGb3IgdGhlIHVzZXIgYXBwcm92YWwgbG9naWMuXG4gICAgICogQHNlZSB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuYWNjZXB0UGVybWlzc2lvbnNSZXF1ZXN0fSBGb3IgdGhlIG1ldGhvZFxuICAgICAqIHRoYXQgX2FjY2VwdHNfIHRoZSByZXF1ZXN0IGFuZCByZXNvbHZlcyB0aGUgdXNlciBhcHByb3ZhbCBwcm9taXNlLlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlamVjdFBlcm1pc3Npb25zUmVxdWVzdH0gRm9yIHRoZSBtZXRob2RcbiAgICAgKiB0aGF0IF9yZWplY3RzXyB0aGUgcmVxdWVzdCBhbmQgdGhlIHVzZXIgYXBwcm92YWwgcHJvbWlzZS5cbiAgICAgKiBAcGFyYW0gc3ViamVjdCAtIFRoZSBncmFudGVlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZFBlcm1pc3Npb25zIC0gVGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pZCAtIFRoZSBpZCBvZiB0aGUgcGVybWlzc2lvbnMgcmVxdWVzdC4gRGVmYXVsdHMgdG8gYSB1bmlxdWVcbiAgICAgKiBpZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5wcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgLSBXaGV0aGVyIHRvIHByZXNlcnZlIHRoZVxuICAgICAqIHN1YmplY3QncyBleGlzdGluZyBwZXJtaXNzaW9ucy4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgICAqIEByZXR1cm5zIFRoZSBncmFudGVkIHBlcm1pc3Npb25zIGFuZCByZXF1ZXN0IG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHJlcXVlc3RQZXJtaXNzaW9ucyhzdWJqZWN0LCByZXF1ZXN0ZWRQZXJtaXNzaW9ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gc3ViamVjdDtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgPSAoMCwgbmFub2lkXzEubmFub2lkKSgpLCBwcmVzZXJ2ZUV4aXN0aW5nUGVybWlzc2lvbnMgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZVJlcXVlc3RlZFBlcm1pc3Npb25zKG9yaWdpbiwgcmVxdWVzdGVkUGVybWlzc2lvbnMpO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zUmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVxdWVzdGVkUGVybWlzc2lvbnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgX2EgPSB5aWVsZCB0aGlzLnJlcXVlc3RVc2VyQXBwcm92YWwocGVybWlzc2lvbnNSZXF1ZXN0KSwgeyBwZXJtaXNzaW9uczogYXBwcm92ZWRQZXJtaXNzaW9ucyB9ID0gX2EsIHJlcXVlc3REYXRhID0gX19yZXN0KF9hLCBbXCJwZXJtaXNzaW9uc1wiXSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JhbnRQZXJtaXNzaW9ucyh7XG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3QsXG4gICAgICAgICAgICAgICAgICAgIGFwcHJvdmVkUGVybWlzc2lvbnMsXG4gICAgICAgICAgICAgICAgICAgIHByZXNlcnZlRXhpc3RpbmdQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdERhdGEsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbWV0YWRhdGEsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy4gVGhyb3dzIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBlbnN1cmVzIHRoYXQgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBhcmUgYSBwcm9wZXJseVxuICAgICAqIGZvcm1hdHRlZCB7QGxpbmsgUmVxdWVzdGVkUGVybWlzc2lvbnN9IG9iamVjdCwgYW5kIHBlcmZvcm1zIHRoZSBzYW1lXG4gICAgICogdmFsaWRhdGlvbiBhcyB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuZ3JhbnRQZXJtaXNzaW9uc30sIGV4Y2VwdCB0aGF0XG4gICAgICogY29uc3VtZXItc3BlY2lmaWVkIHBlcm1pc3Npb24gdmFsaWRhdG9yIGZ1bmN0aW9ucyBhcmUgbm90IGNhbGxlZCwgc2luY2VcbiAgICAgKiB0aGV5IGFyZSBvbmx5IGNhbGxlZCBvbiBmdWxseSBjb25zdHJ1Y3RlZCwgYXBwcm92ZWQgcGVybWlzc2lvbnMgdGhhdCBhcmVcbiAgICAgKiBvdGhlcndpc2UgY29tcGxldGVseSB2YWxpZC5cbiAgICAgKlxuICAgICAqIFVucmVjb2duemllZCBwcm9wZXJ0aWVzIG9uIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBncmFudGVlIHN1YmplY3QuXG4gICAgICogQHBhcmFtIHJlcXVlc3RlZFBlcm1pc3Npb25zIC0gVGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucy5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZVJlcXVlc3RlZFBlcm1pc3Npb25zKG9yaWdpbiwgcmVxdWVzdGVkUGVybWlzc2lvbnMpIHtcbiAgICAgICAgaWYgKCEoMCwgdXRpbF8xLmlzUGxhaW5PYmplY3QpKHJlcXVlc3RlZFBlcm1pc3Npb25zKSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLmludmFsaWRQYXJhbXMpKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVxdWVzdGVkIHBlcm1pc3Npb25zIGZvciBvcmlnaW4gXCIke29yaWdpbn1cIiBpcyBub3QgYSBwbGFpbiBvYmplY3QuYCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7IG9yaWdpbiwgcmVxdWVzdGVkUGVybWlzc2lvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQZXJtaXNzaW9ucykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JzXzEuaW52YWxpZFBhcmFtcykoe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBQZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBvcmlnaW4gXCIke29yaWdpbn1cIiBjb250YWlucyBubyBwZXJtaXNzaW9ucy5gLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdGVkUGVybWlzc2lvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0TmFtZSBvZiBPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQZXJtaXNzaW9ucykpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb24gPSByZXF1ZXN0ZWRQZXJtaXNzaW9uc1t0YXJnZXROYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRoaXMuZ2V0VGFyZ2V0S2V5KHRhcmdldE5hbWUpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRLZXkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JzXzEubWV0aG9kTm90Rm91bmQpKHRhcmdldE5hbWUsIHsgb3JpZ2luLCByZXF1ZXN0ZWRQZXJtaXNzaW9ucyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKDAsIHV0aWxfMS5pc1BsYWluT2JqZWN0KShwZXJtaXNzaW9uKSB8fFxuICAgICAgICAgICAgICAgIChwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXROYW1lICE9PSBwZXJtaXNzaW9uLnBhcmVudENhcGFiaWxpdHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLmludmFsaWRQYXJhbXMpKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIG9yaWdpbiBcIiR7b3JpZ2lufVwiIGNvbnRhaW5zIGludmFsaWQgcmVxdWVzdGVkIHBlcm1pc3Npb24ocykuYCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogeyBvcmlnaW4sIHJlcXVlc3RlZFBlcm1pc3Npb25zIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIZXJlIHdlIHZhbGlkYXRlIHRoZSBwZXJtaXNzaW9uIHdpdGhvdXQgaW52b2tpbmcgaXRzIHZhbGlkYXRvciwgaWYgYW55LlxuICAgICAgICAgICAgLy8gVGhlIHZhbGlkYXRvciB3aWxsIGJlIGludm9rZWQgYWZ0ZXIgdGhlIHBlcm1pc3Npb24gaGFzIGJlZW4gYXBwcm92ZWQuXG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUGVybWlzc2lvbih0aGlzLmdldFBlcm1pc3Npb25TcGVjaWZpY2F0aW9uKHRhcmdldEtleSksIFxuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IFRoZSBwZXJtaXNzaW9uIGlzIHN0aWxsIGEgXCJQbGFpbk9iamVjdFwiIGhlcmUuXG4gICAgICAgICAgICBwZXJtaXNzaW9uLCBvcmlnaW4sIHRhcmdldE5hbWUsIHsgaW52b2tlUGVybWlzc2lvblZhbGlkYXRvcjogZmFsc2UsIHBlcmZvcm1DYXZlYXRWYWxpZGF0aW9uOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSByZXF1ZXN0IHRvIHRoZSB7QGxpbmsgQXBwcm92YWxDb250cm9sbGVyfSB1c2luZyB0aGVcbiAgICAgKiB7QGxpbmsgQWRkQXBwcm92YWxSZXF1ZXN0fSBhY3Rpb24uIEFsc28gdmFsaWRhdGVzIHRoZSByZXN1bHRpbmcgYXBwcm92ZWRcbiAgICAgKiBwZXJtaXNzaW9ucyByZXF1ZXN0LCBhbmQgdGhyb3dzIGFuIGVycm9yIGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGVybWlzc2lvbnNSZXF1ZXN0IC0gVGhlIHBlcm1pc3Npb25zIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIFRoZSBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IG9iamVjdC5cbiAgICAgKi9cbiAgICByZXF1ZXN0VXNlckFwcHJvdmFsKHBlcm1pc3Npb25zUmVxdWVzdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBvcmlnaW4sIGlkIH0gPSBwZXJtaXNzaW9uc1JlcXVlc3QubWV0YWRhdGE7XG4gICAgICAgICAgICBjb25zdCBhcHByb3ZlZFJlcXVlc3QgPSB5aWVsZCB0aGlzLm1lc3NhZ2luZ1N5c3RlbS5jYWxsKCdBcHByb3ZhbENvbnRyb2xsZXI6YWRkUmVxdWVzdCcsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgcmVxdWVzdERhdGE6IHBlcm1pc3Npb25zUmVxdWVzdCxcbiAgICAgICAgICAgICAgICB0eXBlOiB1dGlsc18xLk1ldGhvZE5hbWVzLnJlcXVlc3RQZXJtaXNzaW9ucyxcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFwcHJvdmVkUGVybWlzc2lvbnMoYXBwcm92ZWRSZXF1ZXN0LCB7IGlkLCBvcmlnaW4gfSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwcm92ZWRSZXF1ZXN0O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIGFuIGFwcHJvdmVkIHtAbGluayBQZXJtaXNzaW9uc1JlcXVlc3R9IG9iamVjdC4gVGhlIGFwcHJvdmVkXG4gICAgICogcmVxdWVzdCBtdXN0IGhhdmUgdGhlIHJlcXVpcmVkIGBtZXRhZGF0YWAgYW5kIGBwZXJtaXNzaW9uc2AgcHJvcGVydGllcyxcbiAgICAgKiB0aGUgYGlkYCBhbmQgYG9yaWdpbmAgb2YgdGhlIGBtZXRhZGF0YWAgbXVzdCBtYXRjaCB0aGUgb3JpZ2luYWwgcmVxdWVzdFxuICAgICAqIG1ldGFkYXRhLCBhbmQgdGhlIHJlcXVlc3RlZCBwZXJtaXNzaW9ucyBtdXN0IGJlIHZhbGlkIHBlclxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci52YWxpZGF0ZVJlcXVlc3RlZFBlcm1pc3Npb25zfS4gQW55IGV4dHJhXG4gICAgICogbWV0YWRhdGEgcHJvcGVydGllcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEFuIGVycm9yIGlzIHRocm93biBpZiB2YWxpZGF0aW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFwcHJvdmVkUmVxdWVzdCAtIFRoZSBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxNZXRhZGF0YSAtIFRoZSBvcmlnaW5hbCByZXF1ZXN0IG1ldGFkYXRhLlxuICAgICAqL1xuICAgIHZhbGlkYXRlQXBwcm92ZWRQZXJtaXNzaW9ucyhhcHByb3ZlZFJlcXVlc3QsIG9yaWdpbmFsTWV0YWRhdGEpIHtcbiAgICAgICAgY29uc3QgeyBpZCwgb3JpZ2luIH0gPSBvcmlnaW5hbE1ldGFkYXRhO1xuICAgICAgICBpZiAoISgwLCB1dGlsXzEuaXNQbGFpbk9iamVjdCkoYXBwcm92ZWRSZXF1ZXN0KSB8fFxuICAgICAgICAgICAgISgwLCB1dGlsXzEuaXNQbGFpbk9iamVjdCkoYXBwcm92ZWRSZXF1ZXN0Lm1ldGFkYXRhKSkge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLmludGVybmFsRXJyb3IpKGBBcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBzdWJqZWN0IFwiJHtvcmlnaW59XCIgaXMgaW52YWxpZC5gLCB7IGRhdGE6IHsgYXBwcm92ZWRSZXF1ZXN0IH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBtZXRhZGF0YTogeyBpZDogbmV3SWQsIG9yaWdpbjogbmV3T3JpZ2luIH0sIHBlcm1pc3Npb25zLCB9ID0gYXBwcm92ZWRSZXF1ZXN0O1xuICAgICAgICBpZiAobmV3SWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcikoYEFwcHJvdmVkIHBlcm1pc3Npb25zIHJlcXVlc3QgZm9yIHN1YmplY3QgXCIke29yaWdpbn1cIiBtdXRhdGVkIGl0cyBpZC5gLCB7IG9yaWdpbmFsSWQ6IGlkLCBtdXRhdGVkSWQ6IG5ld0lkIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdPcmlnaW4gIT09IG9yaWdpbikge1xuICAgICAgICAgICAgdGhyb3cgKDAsIGVycm9yc18xLmludGVybmFsRXJyb3IpKGBBcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0IGZvciBzdWJqZWN0IFwiJHtvcmlnaW59XCIgbXV0YXRlZCBpdHMgb3JpZ2luLmAsIHsgb3JpZ2luYWxPcmlnaW46IG9yaWdpbiwgbXV0YXRlZE9yaWdpbjogbmV3T3JpZ2luIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWVzdGVkUGVybWlzc2lvbnMob3JpZ2luLCBwZXJtaXNzaW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBldGhfcnBjX2Vycm9yc18xLkV0aGVyZXVtUnBjRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyBhcyBhbiBpbnRlcm5hbCBlcnJvcjsgd2Ugc2hvdWxkIG5ldmVyIHJlY2VpdmUgaW52YWxpZCBhcHByb3ZlZFxuICAgICAgICAgICAgICAgIC8vIHBlcm1pc3Npb25zLlxuICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcnNfMS5pbnRlcm5hbEVycm9yKShgSW52YWxpZCBhcHByb3ZlZCBwZXJtaXNzaW9ucyByZXF1ZXN0OiAke2Vycm9yLm1lc3NhZ2V9YCwgZXJyb3IuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JzXzEuaW50ZXJuYWxFcnJvcikoJ1VucmVjb2duaXplZCBlcnJvciB0eXBlJywgeyBlcnJvciB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBY2NlcHRzIGEgcGVybWlzc2lvbnMgcmVxdWVzdCBjcmVhdGVkIGJ5XG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlcXVlc3RQZXJtaXNzaW9uc30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0LlxuICAgICAqL1xuICAgIGFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSByZXF1ZXN0Lm1ldGFkYXRhO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0FwcHJvdmFsUmVxdWVzdCh7IGlkIH0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlcXVlc3QucGVybWlzc2lvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgKDAsIGVycm9yc18xLmludmFsaWRQYXJhbXMpKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogJ011c3QgcmVxdWVzdCBhdCBsZWFzdCBvbmUgcGVybWlzc2lvbi4nLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnaW5nU3lzdGVtLmNhbGwoJ0FwcHJvdmFsQ29udHJvbGxlcjphY2NlcHRSZXF1ZXN0JywgaWQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYWNjZXB0aW5nIHVuZXhwZWN0ZWRseSBmYWlscywgcmVqZWN0IHRoZSByZXF1ZXN0IGFuZCByZS10aHJvdyB0aGVcbiAgICAgICAgICAgICAgICAvLyBlcnJvclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVqZWN0cyBhIHBlcm1pc3Npb25zIHJlcXVlc3QgY3JlYXRlZCBieVxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZXF1ZXN0UGVybWlzc2lvbnN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIC0gVGhlIGlkIG9mIHRoZSByZXF1ZXN0IHRvIGJlIHJlamVjdGVkLlxuICAgICAqL1xuICAgIHJlamVjdFBlcm1pc3Npb25zUmVxdWVzdChpZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0FwcHJvdmFsUmVxdWVzdCh7IGlkIH0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkLCAoMCwgZXJyb3JzXzEudXNlclJlamVjdGVkUmVxdWVzdCkoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUge0BsaW5rIEFwcHJvdmFsQ29udHJvbGxlcn0gaGFzIGEgcGFydGljdWxhciBwZXJtaXNzaW9uc1xuICAgICAqIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5hY2NlcHRQZXJtaXNzaW9uc1JlcXVlc3R9IGFuZFxuICAgICAqIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlci5yZWplY3RQZXJtaXNzaW9uc1JlcXVlc3R9IGZvciB1c2FnZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSB7QGxpbmsgSGFzQXBwcm92YWxSZXF1ZXN0fSBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmlkIC0gVGhlIGlkIG9mIHRoZSBhcHByb3ZhbCByZXF1ZXN0IHRvIGNoZWNrIGZvci5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBzcGVjaWZpZWQgcmVxdWVzdCBleGlzdHMuXG4gICAgICovXG4gICAgaGFzQXBwcm92YWxSZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnaW5nU3lzdGVtLmNhbGwoJ0FwcHJvdmFsQ29udHJvbGxlcjpoYXNSZXF1ZXN0JywgXG4gICAgICAgIC8vIFR5cGVjYXN0OiBGb3Igc29tZSByZWFzb24sIHRoZSB0eXBlIGhlcmUgZXhwZWN0cyBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAgICAgIC8vIEhhc0FwcHJvdmFsUmVxdWVzdCBvcHRpb25zIHRvIGJlIHNwZWNpZmllZCwgd2hlbiB0aGV5J3JlIGFjdHVhbGx5IGFsbFxuICAgICAgICAvLyBvcHRpb25hbC4gUGFzc2luZyBqdXN0IHRoZSBpZCBpcyBkZWZpbml0ZWx5IHZhbGlkLCBzbyB3ZSBqdXN0IGNhc3QgaXQuXG4gICAgICAgIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWplY3RzIHRoZSBwZXJtaXNzaW9ucyByZXF1ZXN0IHdpdGggdGhlIHNwZWNpZmllZCBpZCwgd2l0aCB0aGUgc3BlY2lmaWVkXG4gICAgICogZXJyb3IgYXMgdGhlIHJlYXNvbi4gVGhpcyBtZXRob2QgaXMgZWZmZWN0aXZlbHkgYSB3cmFwcGVyIGFyb3VuZCBhXG4gICAgICogbWVzc2VuZ2VyIGNhbGwgZm9yIHRoZSBgQXBwcm92YWxDb250cm9sbGVyOnJlamVjdFJlcXVlc3RgIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmFjY2VwdFBlcm1pc3Npb25zUmVxdWVzdH0gYW5kXG4gICAgICoge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLnJlamVjdFBlcm1pc3Npb25zUmVxdWVzdH0gZm9yIHVzYWdlLlxuICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgcmVxdWVzdCB0byByZWplY3QuXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVqZWN0aW9uLlxuICAgICAqIEByZXR1cm5zIE5vdGhpbmdcbiAgICAgKi9cbiAgICBfcmVqZWN0UGVybWlzc2lvbnNSZXF1ZXN0KGlkLCBlcnJvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdpbmdTeXN0ZW0uY2FsbCgnQXBwcm92YWxDb250cm9sbGVyOnJlamVjdFJlcXVlc3QnLCBpZCwgZXJyb3IpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdWJqZWN0J3MgZW5kb3dtZW50cyBwZXIgdGhlIHNwZWNpZmllZCBlbmRvd21lbnQgcGVybWlzc2lvbi5cbiAgICAgKiBUaHJvd3MgaWYgdGhlIHN1YmplY3QgZG9lcyBub3QgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbiBvciBpZiB0aGVcbiAgICAgKiBwZXJtaXNzaW9uIGlzIG5vdCBhbiBlbmRvd21lbnQgcGVybWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBzdWJqZWN0IHdob3NlIGVuZG93bWVudHMgdG8gcmV0cmlldmUuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZW5kb3dtZW50IHBlcm1pc3Npb24uIFRoaXMgbXVzdCBiZSBhXG4gICAgICogdmFsaWQgcGVybWlzc2lvbiB0YXJnZXQgbmFtZS5cbiAgICAgKiBAcGFyYW0gcmVxdWVzdERhdGEgLSBBZGRpdGlvbmFsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSByZXF1ZXN0LCBpZiBhbnkuXG4gICAgICogRm9yd2FyZGVkIHRvIHRoZSBlbmRvd21lbnQgZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgcGVybWlzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgZW5kb3dtZW50cywgaWYgYW55LlxuICAgICAqL1xuICAgIGdldEVuZG93bWVudHMob3JpZ2luLCB0YXJnZXROYW1lLCByZXF1ZXN0RGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb24ob3JpZ2luLCB0YXJnZXROYW1lKSkge1xuICAgICAgICAgICAgICAgIHRocm93ICgwLCBlcnJvcnNfMS51bmF1dGhvcml6ZWQpKHsgZGF0YTogeyBvcmlnaW4sIHRhcmdldE5hbWUgfSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVkUGVybWlzc2lvblNwZWNpZmljYXRpb24oUGVybWlzc2lvbl8xLlBlcm1pc3Npb25UeXBlLkVuZG93bWVudCwgdGFyZ2V0TmFtZSwgb3JpZ2luKS5lbmRvd21lbnRHZXR0ZXIoeyBvcmlnaW4sIHJlcXVlc3REYXRhIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgYSByZXN0cmljdGVkIG1ldGhvZCBhcyB0aGUgc3ViamVjdCB3aXRoIHRoZSBnaXZlbiBvcmlnaW4uXG4gICAgICogVGhlIHNwZWNpZmllZCBwYXJhbXMsIGlmIGFueSwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIG1ldGhvZCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEFUVE46IEdyZWF0IGNhdXRpb24gc2hvdWxkIGJlIGV4ZXJjaXNlZCBpbiB0aGUgdXNlIG9mIHRoaXMgbWV0aG9kLlxuICAgICAqIE1ldGhvZHMgdGhhdCBjYXVzZSBzaWRlIGVmZmVjdHMgb3IgYWZmZWN0IGFwcGxpY2F0aW9uIHN0YXRlIHNob3VsZFxuICAgICAqIGJlIGF2b2lkZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGZpcnN0IGF0dGVtcHQgdG8gcmV0cmlldmUgdGhlIHJlcXVlc3RlZCByZXN0cmljdGVkIG1ldGhvZFxuICAgICAqIGltcGxlbWVudGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2VzIG5vdCBleGlzdC4gVGhlIG1ldGhvZCB3aWxsIHRoZW4gYmVcbiAgICAgKiBpbnZva2VkIGFzIHRob3VnaCB0aGUgc3ViamVjdCB3aXRoIHRoZSBzcGVjaWZpZWQgb3JpZ2luIGhhZCBpbnZva2VkIGl0IHdpdGhcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuIFRoaXMgbWVhbnMgdGhhdCBhbnkgZXhpc3RpbmcgY2F2ZWF0cyB3aWxsIGJlXG4gICAgICogYXBwbGllZCB0byB0aGUgcmVzdHJpY3RlZCBtZXRob2QsIGFuZCB0aGlzIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZVxuICAgICAqIHJlc3RyaWN0ZWQgbWV0aG9kIG9yIGl0cyBjYXZlYXQgZGVjb3JhdG9ycyB0aHJvdy5cbiAgICAgKlxuICAgICAqIEluIGFkZGl0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIHRocm93IGlmIHRoZSBzdWJqZWN0IGRvZXMgbm90IGhhdmUgYVxuICAgICAqIHBlcm1pc3Npb24gZm9yIHRoZSBzcGVjaWZpZWQgcmVzdHJpY3RlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgc3ViamVjdCB0byBleGVjdXRlIHRoZSBtZXRob2Qgb24gYmVoYWxmXG4gICAgICogb2YuXG4gICAgICogQHBhcmFtIHRhcmdldE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRvIGV4ZWN1dGUuIFRoaXMgbXVzdCBiZSBhIHZhbGlkXG4gICAgICogcGVybWlzc2lvbiB0YXJnZXQgbmFtZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgbWV0aG9kIGltcGxlbWVudGF0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGV4ZWN1dGVkIG1ldGhvZC5cbiAgICAgKi9cbiAgICBleGVjdXRlUmVzdHJpY3RlZE1ldGhvZChvcmlnaW4sIHRhcmdldE5hbWUsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gVGhyb3dzIGlmIHRoZSBtZXRob2QgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZEltcGxlbWVudGF0aW9uID0gdGhpcy5nZXRSZXN0cmljdGVkTWV0aG9kKHRhcmdldE5hbWUsIG9yaWdpbik7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZChtZXRob2RJbXBsZW1lbnRhdGlvbiwgeyBvcmlnaW4gfSwgdGFyZ2V0TmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgcmVxdWVzdCBmb3IgbWV0aG9kIFwiJHt0YXJnZXROYW1lfVwiIGFzIG9yaWdpbiBcIiR7b3JpZ2lufVwiIHJldHVybmVkIG5vIHJlc3VsdC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbnRlcm5hbCBtZXRob2QgdXNlZCBpbiB0aGUgY29udHJvbGxlcidzIGBqc29uLXJwYy1lbmdpbmVgIG1pZGRsZXdhcmVcbiAgICAgKiBhbmQge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kfS4gQ2FsbHMgdGhlXG4gICAgICogc3BlY2lmaWVkIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uIGFmdGVyIGRlY29yYXRpbmcgaXQgd2l0aCB0aGVcbiAgICAgKiBjYXZlYXRzIG9mIGl0cyBwZXJtaXNzaW9uLiBUaHJvd3MgaWYgdGhlIHN1YmplY3QgZG9lcyBub3QgaGF2ZSB0aGVcbiAgICAgKiByZXF1aXNpdGUgcGVybWlzc2lvbi5cbiAgICAgKlxuICAgICAqIEFUVE46IFBhcmFtZXRlciB2YWxpZGF0aW9uIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgY2FsbGVyLCBvclxuICAgICAqIHRoZSByZXN0cmljdGVkIG1ldGhvZCBpbXBsZW1lbnRhdGlvbiBpbiB0aGUgY2FzZSBvZiBgcGFyYW1zYC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kfSBhbmRcbiAgICAgKiB7QGxpbmsgUGVybWlzc2lvbkNvbnRyb2xsZXIuY3JlYXRlUGVybWlzc2lvbk1pZGRsZXdhcmV9IGZvciB1c2FnZS5cbiAgICAgKiBAcGFyYW0gbWV0aG9kSW1wbGVtZW50YXRpb24gLSBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIG1ldGhvZCB0byBjYWxsLlxuICAgICAqIEBwYXJhbSBzdWJqZWN0IC0gTWV0YWRhdGEgYWJvdXQgdGhlIHN1YmplY3QgdGhhdCBtYWRlIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBtZXRob2QgLSBUaGUgbWV0aG9kIG5hbWVcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1zIG5lZWRlZCBmb3IgZXhlY3V0aW5nIHRoZSByZXN0cmljdGVkIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIHJlc3RyaWN0ZWQgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gICAgICovXG4gICAgX2V4ZWN1dGVSZXN0cmljdGVkTWV0aG9kKG1ldGhvZEltcGxlbWVudGF0aW9uLCBzdWJqZWN0LCBtZXRob2QsIHBhcmFtcyA9IFtdKSB7XG4gICAgICAgIGNvbnN0IHsgb3JpZ2luIH0gPSBzdWJqZWN0O1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9uID0gdGhpcy5nZXRQZXJtaXNzaW9uKG9yaWdpbiwgbWV0aG9kKTtcbiAgICAgICAgaWYgKCFwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgZXJyb3JzXzEudW5hdXRob3JpemVkKSh7IGRhdGE6IHsgb3JpZ2luLCBtZXRob2QgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIENhdmVhdF8xLmRlY29yYXRlV2l0aENhdmVhdHMpKG1ldGhvZEltcGxlbWVudGF0aW9uLCBwZXJtaXNzaW9uLCB0aGlzLl9jYXZlYXRTcGVjaWZpY2F0aW9ucykoeyBtZXRob2QsIHBhcmFtcywgY29udGV4dDogeyBvcmlnaW4gfSB9KTtcbiAgICB9XG59XG5leHBvcnRzLlBlcm1pc3Npb25Db250cm9sbGVyID0gUGVybWlzc2lvbkNvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJtaXNzaW9uQ29udHJvbGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IGV4cG9ydHMuRHVwbGljYXRlQ2F2ZWF0RXJyb3IgPSBleHBvcnRzLkZvcmJpZGRlbkNhdmVhdEVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IgPSBleHBvcnRzLkNhdmVhdEludmFsaWRKc29uRXJyb3IgPSBleHBvcnRzLkNhdmVhdE1pc3NpbmdWYWx1ZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0VHlwZUVycm9yID0gZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RXJyb3IgPSBleHBvcnRzLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvciA9IGV4cG9ydHMuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3IgPSBleHBvcnRzLkludmFsaWRDYXZlYXRzUHJvcGVydHlFcnJvciA9IGV4cG9ydHMuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yID0gZXhwb3J0cy5FbmRvd21lbnRQZXJtaXNzaW9uRG9lc05vdEV4aXN0RXJyb3IgPSBleHBvcnRzLlBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvciA9IGV4cG9ydHMuSW52YWxpZEFwcHJvdmVkUGVybWlzc2lvbkVycm9yID0gZXhwb3J0cy5VbnJlY29nbml6ZWRTdWJqZWN0RXJyb3IgPSBleHBvcnRzLkludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yID0gZXhwb3J0cy5pbnRlcm5hbEVycm9yID0gZXhwb3J0cy51c2VyUmVqZWN0ZWRSZXF1ZXN0ID0gZXhwb3J0cy5pbnZhbGlkUGFyYW1zID0gZXhwb3J0cy5tZXRob2ROb3RGb3VuZCA9IGV4cG9ydHMudW5hdXRob3JpemVkID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgYW4gXCJ1bmF1dGhvcml6ZWRcIiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gb3B0cyAtIE9wdGlvbmFsIGFyZ3VtZW50cyB0aGF0IGFkZCBleHRyYSBjb250ZXh0XG4gKiBAcmV0dXJucyBUaGUgYnVpbHQgZXJyb3JcbiAqL1xuZnVuY3Rpb24gdW5hdXRob3JpemVkKG9wdHMpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudW5hdXRob3JpemVkKHtcbiAgICAgICAgbWVzc2FnZTogJ1VuYXV0aG9yaXplZCB0byBwZXJmb3JtIGFjdGlvbi4gVHJ5IHJlcXVlc3RpbmcgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb24ocykgZmlyc3QuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWU6IGh0dHBzOi8vZG9jcy5tZXRhbWFzay5pby9ndWlkZS9ycGMtYXBpLmh0bWwjcGVybWlzc2lvbnMnLFxuICAgICAgICBkYXRhOiBvcHRzLmRhdGEsXG4gICAgfSk7XG59XG5leHBvcnRzLnVuYXV0aG9yaXplZCA9IHVuYXV0aG9yaXplZDtcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgYSBcIm1ldGhvZCBub3QgZm91bmRcIiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG1ldGhvZCBpbiBxdWVzdGlvbi5cbiAqIEBwYXJhbSBkYXRhIC0gT3B0aW9uYWwgZGF0YSBmb3IgY29udGV4dC5cbiAqIEByZXR1cm5zIFRoZSBidWlsdCBlcnJvclxuICovXG5mdW5jdGlvbiBtZXRob2ROb3RGb3VuZChtZXRob2QsIGRhdGEpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFRoZSBtZXRob2QgXCIke21ldGhvZH1cIiBkb2VzIG5vdCBleGlzdCAvIGlzIG5vdCBhdmFpbGFibGUuYDtcbiAgICBjb25zdCBvcHRzID0geyBtZXNzYWdlIH07XG4gICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKG9wdHMpO1xufVxuZXhwb3J0cy5tZXRob2ROb3RGb3VuZCA9IG1ldGhvZE5vdEZvdW5kO1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBidWlsZGluZyBhbiBcImludmFsaWQgcGFyYW1zXCIgZXJyb3IuXG4gKlxuICogQHBhcmFtIG9wdHMgLSBPcHRpb25hbCBhcmd1bWVudHMgdGhhdCBhZGQgZXh0cmEgY29udGV4dFxuICogQHJldHVybnMgVGhlIGJ1aWx0IGVycm9yXG4gKi9cbmZ1bmN0aW9uIGludmFsaWRQYXJhbXMob3B0cykge1xuICAgIHJldHVybiBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyh7XG4gICAgICAgIGRhdGE6IG9wdHMuZGF0YSxcbiAgICAgICAgbWVzc2FnZTogb3B0cy5tZXNzYWdlLFxuICAgIH0pO1xufVxuZXhwb3J0cy5pbnZhbGlkUGFyYW1zID0gaW52YWxpZFBhcmFtcztcbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYnVpbGRpbmcgYW4gXCJ1c2VyIHJlamVjdGVkIHJlcXVlc3RcIiBlcnJvci5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gYWRkIGV4dHJhIGNvbnRleHRcbiAqIEByZXR1cm5zIFRoZSBidWlsdCBlcnJvclxuICovXG5mdW5jdGlvbiB1c2VyUmVqZWN0ZWRSZXF1ZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCh7IGRhdGEgfSk7XG59XG5leHBvcnRzLnVzZXJSZWplY3RlZFJlcXVlc3QgPSB1c2VyUmVqZWN0ZWRSZXF1ZXN0O1xuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBidWlsZGluZyBhbiBpbnRlcm5hbCBlcnJvci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0gZGF0YSAtIE9wdGlvbmFsIGRhdGEgdG8gYWRkIGV4dHJhIGNvbnRleHRcbiAqIEByZXR1cm5zIFRoZSBidWlsdCBlcnJvclxuICovXG5mdW5jdGlvbiBpbnRlcm5hbEVycm9yKG1lc3NhZ2UsIGRhdGEpIHtcbiAgICByZXR1cm4gZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZSwgZGF0YSB9KTtcbn1cbmV4cG9ydHMuaW50ZXJuYWxFcnJvciA9IGludGVybmFsRXJyb3I7XG5jbGFzcyBJbnZhbGlkU3ViamVjdElkZW50aWZpZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4pIHtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgc3ViamVjdCBpZGVudGlmaWVyOiBcIiR7dHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycgPyBvcmlnaW4gOiB0eXBlb2Ygb3JpZ2lufVwiYCk7XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU3ViamVjdElkZW50aWZpZXJFcnJvciA9IEludmFsaWRTdWJqZWN0SWRlbnRpZmllckVycm9yO1xuY2xhc3MgVW5yZWNvZ25pemVkU3ViamVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbikge1xuICAgICAgICBzdXBlcihgVW5yZWNvZ25pemVkIHN1YmplY3Q6IFwiJHtvcmlnaW59XCIgaGFzIG5vIHBlcm1pc3Npb25zLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5yZWNvZ25pemVkU3ViamVjdEVycm9yID0gVW5yZWNvZ25pemVkU3ViamVjdEVycm9yO1xuY2xhc3MgSW52YWxpZEFwcHJvdmVkUGVybWlzc2lvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0LCBhcHByb3ZlZFBlcm1pc3Npb24pIHtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgYXBwcm92ZWQgcGVybWlzc2lvbiBmb3Igb3JpZ2luIFwiJHtvcmlnaW59XCIgYW5kIHRhcmdldCBcIiR7dGFyZ2V0fVwiLmApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IG9yaWdpbiwgdGFyZ2V0LCBhcHByb3ZlZFBlcm1pc3Npb24gfTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRBcHByb3ZlZFBlcm1pc3Npb25FcnJvciA9IEludmFsaWRBcHByb3ZlZFBlcm1pc3Npb25FcnJvcjtcbmNsYXNzIFBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgU3ViamVjdCBcIiR7b3JpZ2lufVwiIGhhcyBubyBwZXJtaXNzaW9uIGZvciBcIiR7dGFyZ2V0fVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yID0gUGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yO1xuY2xhc3MgRW5kb3dtZW50UGVybWlzc2lvbkRvZXNOb3RFeGlzdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3JpZ2luKSB7XG4gICAgICAgIHN1cGVyKGBTdWJqZWN0IFwiJHtvcmlnaW59XCIgaGFzIG5vIHBlcm1pc3Npb24gZm9yIFwiJHt0YXJnZXR9XCIuYCk7XG4gICAgICAgIGlmIChvcmlnaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHsgb3JpZ2luIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVuZG93bWVudFBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvciA9IEVuZG93bWVudFBlcm1pc3Npb25Eb2VzTm90RXhpc3RFcnJvcjtcbmNsYXNzIFVucmVjb2duaXplZENhdmVhdFR5cGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgVW5yZWNvZ25pemVkIGNhdmVhdCB0eXBlOiBcIiR7Y2F2ZWF0VHlwZX1cImApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUgfTtcbiAgICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yID0gVW5yZWNvZ25pemVkQ2F2ZWF0VHlwZUVycm9yO1xuY2xhc3MgSW52YWxpZENhdmVhdHNQcm9wZXJ0eUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbiwgdGFyZ2V0LCBjYXZlYXRzUHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoYFRoZSBcImNhdmVhdHNcIiBwcm9wZXJ0eSBvZiBwZXJtaXNzaW9uIGZvciBcIiR7dGFyZ2V0fVwiIG9mIHN1YmplY3QgXCIke29yaWdpbn1cIiBpcyBpbnZhbGlkLiBJdCBtdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5IGlmIHNwZWNpZmllZC5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBvcmlnaW4sIHRhcmdldCwgY2F2ZWF0c1Byb3BlcnR5IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3IgPSBJbnZhbGlkQ2F2ZWF0c1Byb3BlcnR5RXJyb3I7XG5jbGFzcyBDYXZlYXREb2VzTm90RXhpc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIiBvZiBzdWJqZWN0IFwiJHtvcmlnaW59XCIgaGFzIG5vIGNhdmVhdCBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0RG9lc05vdEV4aXN0RXJyb3IgPSBDYXZlYXREb2VzTm90RXhpc3RFcnJvcjtcbmNsYXNzIENhdmVhdEFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW4sIHRhcmdldCwgY2F2ZWF0VHlwZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbiBmb3IgXCIke3RhcmdldH1cIiBvZiBzdWJqZWN0IFwiJHtvcmlnaW59XCIgYWxyZWFkeSBoYXMgYSBjYXZlYXQgb2YgdHlwZSBcIiR7Y2F2ZWF0VHlwZX1cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLkNhdmVhdEFscmVhZHlFeGlzdHNFcnJvciA9IENhdmVhdEFscmVhZHlFeGlzdHNFcnJvcjtcbmNsYXNzIEludmFsaWRDYXZlYXRFcnJvciBleHRlbmRzIGV0aF9ycGNfZXJyb3JzXzEuRXRoZXJldW1ScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVjZWl2ZWRDYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGV0aF9ycGNfZXJyb3JzXzEuZXJyb3JDb2Rlcy5ycGMuaW52YWxpZFBhcmFtcywgYEludmFsaWQgY2F2ZWF0LiBDYXZlYXRzIG11c3QgYmUgcGxhaW4gb2JqZWN0cy5gLCB7IHJlY2VpdmVkQ2F2ZWF0IH0pO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IG9yaWdpbiwgdGFyZ2V0IH07XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkQ2F2ZWF0RXJyb3IgPSBJbnZhbGlkQ2F2ZWF0RXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0VHlwZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIoYENhdmVhdCB0eXBlcyBtdXN0IGJlIHN0cmluZ3MuIFJlY2VpdmVkOiBcIiR7dHlwZW9mIGNhdmVhdC50eXBlfVwiYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZENhdmVhdFR5cGVFcnJvciA9IEludmFsaWRDYXZlYXRUeXBlRXJyb3I7XG5jbGFzcyBDYXZlYXRNaXNzaW5nVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjYXZlYXQsIG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgICAgIHN1cGVyKGBDYXZlYXQgaXMgbWlzc2luZyBcInZhbHVlXCIgZmllbGQuYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0TWlzc2luZ1ZhbHVlRXJyb3IgPSBDYXZlYXRNaXNzaW5nVmFsdWVFcnJvcjtcbmNsYXNzIENhdmVhdEludmFsaWRKc29uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IFwidmFsdWVcIiBpcyBpbnZhbGlkIEpTT04uYCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHsgY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCB9O1xuICAgIH1cbn1cbmV4cG9ydHMuQ2F2ZWF0SW52YWxpZEpzb25FcnJvciA9IENhdmVhdEludmFsaWRKc29uRXJyb3I7XG5jbGFzcyBJbnZhbGlkQ2F2ZWF0RmllbGRzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0LCBvcmlnaW4sIHRhcmdldCkge1xuICAgICAgICBzdXBlcihgQ2F2ZWF0IGhhcyB1bmV4cGVjdGVkIG51bWJlciBvZiBmaWVsZHM6IFwiJHtPYmplY3Qua2V5cyhjYXZlYXQpLmxlbmd0aH1cImApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdCwgb3JpZ2luLCB0YXJnZXQgfTtcbiAgICB9XG59XG5leHBvcnRzLkludmFsaWRDYXZlYXRGaWVsZHNFcnJvciA9IEludmFsaWRDYXZlYXRGaWVsZHNFcnJvcjtcbmNsYXNzIEZvcmJpZGRlbkNhdmVhdEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0TmFtZSkge1xuICAgICAgICBzdXBlcihgUGVybWlzc2lvbnMgZm9yIHRhcmdldCBcIiR7dGFyZ2V0TmFtZX1cIiBtYXkgbm90IGhhdmUgY2F2ZWF0cyBvZiB0eXBlIFwiJHtjYXZlYXRUeXBlfVwiLmApO1xuICAgICAgICB0aGlzLmRhdGEgPSB7IGNhdmVhdFR5cGUsIG9yaWdpbiwgdGFyZ2V0OiB0YXJnZXROYW1lIH07XG4gICAgfVxufVxuZXhwb3J0cy5Gb3JiaWRkZW5DYXZlYXRFcnJvciA9IEZvcmJpZGRlbkNhdmVhdEVycm9yO1xuY2xhc3MgRHVwbGljYXRlQ2F2ZWF0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoY2F2ZWF0VHlwZSwgb3JpZ2luLCB0YXJnZXROYW1lKSB7XG4gICAgICAgIHN1cGVyKGBQZXJtaXNzaW9ucyBmb3IgdGFyZ2V0IFwiJHt0YXJnZXROYW1lfVwiIGNvbnRhaW5zIG11bHRpcGxlIGNhdmVhdHMgb2YgdHlwZSBcIiR7Y2F2ZWF0VHlwZX1cIi5gKTtcbiAgICAgICAgdGhpcy5kYXRhID0geyBjYXZlYXRUeXBlLCBvcmlnaW4sIHRhcmdldDogdGFyZ2V0TmFtZSB9O1xuICAgIH1cbn1cbmV4cG9ydHMuRHVwbGljYXRlQ2F2ZWF0RXJyb3IgPSBEdXBsaWNhdGVDYXZlYXRFcnJvcjtcbmNsYXNzIFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoaWQpIHtcbiAgICAgICAgc3VwZXIoYFBlcm1pc3Npb25zIHJlcXVlc3Qgd2l0aCBpZCBcIiR7aWR9XCIgbm90IGZvdW5kLmApO1xuICAgIH1cbn1cbmV4cG9ydHMuUGVybWlzc2lvbnNSZXF1ZXN0Tm90Rm91bmRFcnJvciA9IFBlcm1pc3Npb25zUmVxdWVzdE5vdEZvdW5kRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBlcm1pc3Npb25ScGNNZXRob2RzID0gdm9pZCAwO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NhdmVhdFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGVybWlzc2lvblwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUGVybWlzc2lvbkNvbnRyb2xsZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpLCBleHBvcnRzKTtcbmV4cG9ydHMucGVybWlzc2lvblJwY01ldGhvZHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcnBjLW1ldGhvZHNcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5ID0gdm9pZCAwO1xuY29uc3QganNvbl9ycGNfZW5naW5lXzEgPSByZXF1aXJlKFwianNvbi1ycGMtZW5naW5lXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG4vKipcbiAqIENyZWF0ZXMgYSBwZXJtaXNzaW9uIG1pZGRsZXdhcmUgZnVuY3Rpb24gZmFjdG9yeS4gSW50ZW5kZWQgZm9yIGludGVybmFsIHVzZVxuICogaW4gdGhlIHtAbGluayBQZXJtaXNzaW9uQ29udHJvbGxlcn0uIExpa2UgYW55IHtAbGluayBKc29uUnBjRW5naW5lfVxuICogbWlkZGxld2FyZSwgZWFjaCBtaWRkbGV3YXJlIHdpbGwgb25seSByZWNlaXZlIHJlcXVlc3RzIGZyb20gYSBwYXJ0aWN1bGFyXG4gKiBzdWJqZWN0IC8gb3JpZ2luLiBIb3dldmVyLCBlYWNoIG1pZGRsZXdhcmUgYWxzbyByZXF1aXJlcyBhY2Nlc3MgdG8gc29tZVxuICogYFBlcm1pc3Npb25Db250cm9sbGVyYCBpbnRlcm5hbHMsIHdoaWNoIGlzIHdoeSB0aGlzIFwiZmFjdG9yeSBmYWN0b3J5XCIgZXhpc3RzLlxuICpcbiAqIFRoZSBtaWRkbGV3YXJlcyByZXR1cm5lZCBieSB0aGUgZmFjdG9yeSB3aWxsIHBhc3MgdGhyb3VnaCByZXF1ZXN0cyBmb3JcbiAqIHVucmVzdHJpY3RlZCBtZXRob2RzLCBhbmQgYXR0ZW1wdCB0byBleGVjdXRlIHJlc3RyaWN0ZWQgbWV0aG9kcy4gSWYgYSBtZXRob2RcbiAqIGlzIG5laXRoZXIgcmVzdHJpY3RlZCBub3IgdW5yZXN0cmljdGVkLCBhIFwibWV0aG9kIG5vdCBmb3VuZFwiIGVycm9yIHdpbGwgYmVcbiAqIHJldHVybmVkLlxuICogSWYgYSBtZXRob2QgaXMgcmVzdHJpY3RlZCwgdGhlIG1pZGRsZXdhcmUgd2lsbCBmaXJzdCBhdHRlbXB0IHRvIHJldHJpZXZlIHRoZVxuICogc3ViamVjdCdzIHBlcm1pc3Npb24gZm9yIHRoYXQgbWV0aG9kLiBJZiB0aGUgcGVybWlzc2lvbiBpcyBmb3VuZCwgdGhlIG1ldGhvZFxuICogd2lsbCBiZSBleGVjdXRlZC4gT3RoZXJ3aXNlLCBhbiBcInVuYXV0aG9yaXplZFwiIGVycm9yIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIGJhZy5cbiAqIEBwYXJhbSBvcHRpb25zLmV4ZWN1dGVSZXN0cmljdGVkTWV0aG9kIC0ge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLl9leGVjdXRlUmVzdHJpY3RlZE1ldGhvZH0uXG4gKiBAcGFyYW0gb3B0aW9ucy5nZXRSZXN0cmljdGVkTWV0aG9kIC0ge0BsaW5rIFBlcm1pc3Npb25Db250cm9sbGVyLmdldFJlc3RyaWN0ZWRNZXRob2R9LlxuICogQHBhcmFtIG9wdGlvbnMuaXNVbnJlc3RyaWN0ZWRNZXRob2QgLSBBIGZ1bmN0aW9uIHRoYXQgY2hlY2tzIHdoZXRoZXIgYVxuICogcGFydGljdWxhciBtZXRob2QgaXMgdW5yZXN0cmljdGVkLlxuICogQHJldHVybnMgQSBwZXJtaXNzaW9uIG1pZGRsZXdhcmUgZmFjdG9yeSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5KHsgZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QsIGdldFJlc3RyaWN0ZWRNZXRob2QsIGlzVW5yZXN0cmljdGVkTWV0aG9kLCB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVBlcm1pc3Npb25NaWRkbGV3YXJlKHN1YmplY3QpIHtcbiAgICAgICAgY29uc3QgeyBvcmlnaW4gfSA9IHN1YmplY3Q7XG4gICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luICE9PSAnc3RyaW5nJyB8fCAhb3JpZ2luKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBzdWJqZWN0IFwib3JpZ2luXCIgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnNNaWRkbGV3YXJlID0gKHJlcSwgcmVzLCBuZXh0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IG1ldGhvZCwgcGFyYW1zIH0gPSByZXE7XG4gICAgICAgICAgICAvLyBTa2lwIHJlZ2lzdGVyZWQgdW5yZXN0cmljdGVkIG1ldGhvZHMuXG4gICAgICAgICAgICBpZiAoaXNVbnJlc3RyaWN0ZWRNZXRob2QobWV0aG9kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgbm8gcmVzdHJpY3RlZCBtZXRob2QgaW1wbGVtZW50YXRpb24gaXMgZm91bmQuXG4gICAgICAgICAgICBjb25zdCBtZXRob2RJbXBsZW1lbnRhdGlvbiA9IGdldFJlc3RyaWN0ZWRNZXRob2QobWV0aG9kLCBvcmlnaW4pO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHRoZSBwZXJtaXNzaW9uIGRvZXMgbm90IGV4aXN0LlxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgZXhlY3V0ZVJlc3RyaWN0ZWRNZXRob2QobWV0aG9kSW1wbGVtZW50YXRpb24sIHN1YmplY3QsIG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcy5lcnJvciA9ICgwLCBlcnJvcnNfMS5pbnRlcm5hbEVycm9yKShgUmVxdWVzdCBmb3IgbWV0aG9kIFwiJHtyZXEubWV0aG9kfVwiIHJldHVybmVkIHVuZGVmaW5lZCByZXN1bHQuYCwgeyByZXF1ZXN0OiByZXEgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBqc29uX3JwY19lbmdpbmVfMS5jcmVhdGVBc3luY01pZGRsZXdhcmUpKHBlcm1pc3Npb25zTWlkZGxld2FyZSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5ID0gZ2V0UGVybWlzc2lvbk1pZGRsZXdhcmVGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGVybWlzc2lvbi1taWRkbGV3YXJlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldFBlcm1pc3Npb25zSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5leHBvcnRzLmdldFBlcm1pc3Npb25zSGFuZGxlciA9IHtcbiAgICBtZXRob2ROYW1lczogW3V0aWxzXzEuTWV0aG9kTmFtZXMuZ2V0UGVybWlzc2lvbnNdLFxuICAgIGltcGxlbWVudGF0aW9uOiBnZXRQZXJtaXNzaW9uc0ltcGxlbWVudGF0aW9uLFxuICAgIGhvb2tOYW1lczoge1xuICAgICAgICBnZXRQZXJtaXNzaW9uc0Zvck9yaWdpbjogdHJ1ZSxcbiAgICB9LFxufTtcbi8qKlxuICogR2V0IFBlcm1pc3Npb25zIGltcGxlbWVudGF0aW9uIHRvIGJlIHVzZWQgaW4gSnNvblJwY0VuZ2luZSBtaWRkbGV3YXJlLlxuICpcbiAqIEBwYXJhbSBfcmVxIC0gVGhlIEpzb25ScGNFbmdpbmUgcmVxdWVzdCAtIHVudXNlZFxuICogQHBhcmFtIHJlcyAtIFRoZSBKc29uUnBjRW5naW5lIHJlc3VsdCBvYmplY3RcbiAqIEBwYXJhbSBfbmV4dCAtIEpzb25ScGNFbmdpbmUgbmV4dCgpIGNhbGxiYWNrIC0gdW51c2VkXG4gKiBAcGFyYW0gZW5kIC0gSnNvblJwY0VuZ2luZSBlbmQoKSBjYWxsYmFja1xuICogQHBhcmFtIG9wdGlvbnMgLSBNZXRob2QgaG9va3MgcGFzc2VkIHRvIHRoZSBtZXRob2QgaW1wbGVtZW50YXRpb25cbiAqIEBwYXJhbSBvcHRpb25zLmdldFBlcm1pc3Npb25zRm9yT3JpZ2luIC0gVGhlIHNwZWNpZmljIG1ldGhvZCBob29rIG5lZWRlZCBmb3IgdGhpcyBtZXRob2QgaW1wbGVtZW50YXRpb25cbiAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIG5vdGhpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0UGVybWlzc2lvbnNJbXBsZW1lbnRhdGlvbihfcmVxLCByZXMsIF9uZXh0LCBlbmQsIHsgZ2V0UGVybWlzc2lvbnNGb3JPcmlnaW4gfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJlcy5yZXN1bHQgPSBPYmplY3QudmFsdWVzKGdldFBlcm1pc3Npb25zRm9yT3JpZ2luKCkgfHwge30pO1xuICAgICAgICByZXR1cm4gZW5kKCk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRQZXJtaXNzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFuZGxlcnMgPSB2b2lkIDA7XG5jb25zdCByZXF1ZXN0UGVybWlzc2lvbnNfMSA9IHJlcXVpcmUoXCIuL3JlcXVlc3RQZXJtaXNzaW9uc1wiKTtcbmNvbnN0IGdldFBlcm1pc3Npb25zXzEgPSByZXF1aXJlKFwiLi9nZXRQZXJtaXNzaW9uc1wiKTtcbmV4cG9ydHMuaGFuZGxlcnMgPSBbcmVxdWVzdFBlcm1pc3Npb25zXzEucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciwgZ2V0UGVybWlzc2lvbnNfMS5nZXRQZXJtaXNzaW9uc0hhbmRsZXJdO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVxdWVzdFBlcm1pc3Npb25zSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGV0aF9ycGNfZXJyb3JzXzEgPSByZXF1aXJlKFwiZXRoLXJwYy1lcnJvcnNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG5leHBvcnRzLnJlcXVlc3RQZXJtaXNzaW9uc0hhbmRsZXIgPSB7XG4gICAgbWV0aG9kTmFtZXM6IFt1dGlsc18xLk1ldGhvZE5hbWVzLnJlcXVlc3RQZXJtaXNzaW9uc10sXG4gICAgaW1wbGVtZW50YXRpb246IHJlcXVlc3RQZXJtaXNzaW9uc0ltcGxlbWVudGF0aW9uLFxuICAgIGhvb2tOYW1lczoge1xuICAgICAgICByZXF1ZXN0UGVybWlzc2lvbnNGb3JPcmlnaW46IHRydWUsXG4gICAgfSxcbn07XG4vKipcbiAqIFJlcXVlc3QgUGVybWlzc2lvbnMgaW1wbGVtZW50YXRpb24gdG8gYmUgdXNlZCBpbiBKc29uUnBjRW5naW5lIG1pZGRsZXdhcmUuXG4gKlxuICogQHBhcmFtIHJlcSAtIFRoZSBKc29uUnBjRW5naW5lIHJlcXVlc3RcbiAqIEBwYXJhbSByZXMgLSBUaGUgSnNvblJwY0VuZ2luZSByZXN1bHQgb2JqZWN0XG4gKiBAcGFyYW0gX25leHQgLSBKc29uUnBjRW5naW5lIG5leHQoKSBjYWxsYmFjayAtIHVudXNlZFxuICogQHBhcmFtIGVuZCAtIEpzb25ScGNFbmdpbmUgZW5kKCkgY2FsbGJhY2tcbiAqIEBwYXJhbSBvcHRpb25zIC0gTWV0aG9kIGhvb2tzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gb3B0aW9ucy5yZXF1ZXN0UGVybWlzc2lvbnNGb3JPcmlnaW4gLSBUaGUgc3BlY2lmaWMgbWV0aG9kIGhvb2sgbmVlZGVkIGZvciB0aGlzIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gbm90aGluZ1xuICovXG5mdW5jdGlvbiByZXF1ZXN0UGVybWlzc2lvbnNJbXBsZW1lbnRhdGlvbihyZXEsIHJlcywgX25leHQsIGVuZCwgeyByZXF1ZXN0UGVybWlzc2lvbnNGb3JPcmlnaW4gfSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHsgaWQsIHBhcmFtcyB9ID0gcmVxO1xuICAgICAgICBpZiAoKHR5cGVvZiBpZCAhPT0gJ251bWJlcicgJiYgdHlwZW9mIGlkICE9PSAnc3RyaW5nJykgfHxcbiAgICAgICAgICAgICh0eXBlb2YgaWQgPT09ICdzdHJpbmcnICYmICFpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBlbmQoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiAnSW52YWxpZCByZXF1ZXN0OiBNdXN0IHNwZWNpZnkgYSB2YWxpZCBpZC4nLFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgcmVxdWVzdDogcmVxIH0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcykgfHwgISgwLCB1dGlsXzEuaXNQbGFpbk9iamVjdCkocGFyYW1zWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVuZCgoMCwgZXJyb3JzXzEuaW52YWxpZFBhcmFtcykoeyBkYXRhOiB7IHJlcXVlc3Q6IHJlcSB9IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbcmVxdWVzdGVkUGVybWlzc2lvbnNdID0gcGFyYW1zO1xuICAgICAgICBjb25zdCBbZ3JhbnRlZFBlcm1pc3Npb25zXSA9IHlpZWxkIHJlcXVlc3RQZXJtaXNzaW9uc0Zvck9yaWdpbihyZXF1ZXN0ZWRQZXJtaXNzaW9ucywgU3RyaW5nKGlkKSk7XG4gICAgICAgIC8vIGB3YWxsZXRfcmVxdWVzdFBlcm1pc3Npb25gIGlzIHNwZWNpZmllZCB0byByZXR1cm4gYW4gYXJyYXkuXG4gICAgICAgIHJlcy5yZXN1bHQgPSBPYmplY3QudmFsdWVzKGdyYW50ZWRQZXJtaXNzaW9ucyk7XG4gICAgICAgIHJldHVybiBlbmQoKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlcXVlc3RQZXJtaXNzaW9ucy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWV0aG9kTmFtZXMgPSB2b2lkIDA7XG52YXIgTWV0aG9kTmFtZXM7XG4oZnVuY3Rpb24gKE1ldGhvZE5hbWVzKSB7XG4gICAgTWV0aG9kTmFtZXNbXCJyZXF1ZXN0UGVybWlzc2lvbnNcIl0gPSBcIndhbGxldF9yZXF1ZXN0UGVybWlzc2lvbnNcIjtcbiAgICBNZXRob2ROYW1lc1tcImdldFBlcm1pc3Npb25zXCJdID0gXCJ3YWxsZXRfZ2V0UGVybWlzc2lvbnNcIjtcbn0pKE1ldGhvZE5hbWVzID0gZXhwb3J0cy5NZXRob2ROYW1lcyB8fCAoZXhwb3J0cy5NZXRob2ROYW1lcyA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SYXRlTGltaXRDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyVjJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclYyXCIpO1xuY29uc3QgbmFtZSA9ICdSYXRlTGltaXRDb250cm9sbGVyJztcbmNvbnN0IG1ldGFkYXRhID0ge1xuICAgIHJlcXVlc3RzOiB7IHBlcnNpc3Q6IGZhbHNlLCBhbm9ueW1vdXM6IGZhbHNlIH0sXG59O1xuLyoqXG4gKiBDb250cm9sbGVyIHdpdGggbG9naWMgZm9yIHJhdGUtbGltaXRpbmcgQVBJIGVuZHBvaW50cyBwZXIgcmVxdWVzdGluZyBvcmlnaW4uXG4gKi9cbmNsYXNzIFJhdGVMaW1pdENvbnRyb2xsZXIgZXh0ZW5kcyBCYXNlQ29udHJvbGxlclYyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBSYXRlTGltaXRDb250cm9sbGVyIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBDb25zdHJ1Y3RvciBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLm1lc3NlbmdlciAtIEEgcmVmZXJlbmNlIHRvIHRoZSBtZXNzYWdpbmcgc3lzdGVtLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLnN0YXRlIC0gSW5pdGlhbCBzdGF0ZSB0byBzZXQgb24gdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBvcHRpb25zLmltcGxlbWVudGF0aW9ucyAtIE1hcHBpbmcgZnJvbSBBUEkgdHlwZSB0byBBUEkgaW1wbGVtZW50YXRpb24uXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmF0ZUxpbWl0VGltZW91dCAtIFRoZSB0aW1lIHdpbmRvdyBpbiB3aGljaCB0aGUgcmF0ZSBsaW1pdCBpcyBhcHBsaWVkIChpbiBtcykuXG4gICAgICogQHBhcmFtIG9wdGlvbnMucmF0ZUxpbWl0Q291bnQgLSBUaGUgYW1vdW50IG9mIGNhbGxzIGFuIG9yaWdpbiBjYW4gbWFrZSBpbiB0aGUgcmF0ZSBsaW1pdCB0aW1lIHdpbmRvdy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IHJhdGVMaW1pdFRpbWVvdXQgPSA1MDAwLCByYXRlTGltaXRDb3VudCA9IDEsIG1lc3Nlbmdlciwgc3RhdGUsIGltcGxlbWVudGF0aW9ucywgfSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICByZXF1ZXN0czogT2JqZWN0LmtleXMoaW1wbGVtZW50YXRpb25zKS5yZWR1Y2UoKGFjYywga2V5KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhY2MpLCB7IFtrZXldOiB7fSB9KSksIHt9KSxcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgbWVzc2VuZ2VyLFxuICAgICAgICAgICAgc3RhdGU6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFN0YXRlKSwgc3RhdGUpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbXBsZW1lbnRhdGlvbnMgPSBpbXBsZW1lbnRhdGlvbnM7XG4gICAgICAgIHRoaXMucmF0ZUxpbWl0VGltZW91dCA9IHJhdGVMaW1pdFRpbWVvdXQ7XG4gICAgICAgIHRoaXMucmF0ZUxpbWl0Q291bnQgPSByYXRlTGltaXRDb3VudDtcbiAgICAgICAgdGhpcy5tZXNzYWdpbmdTeXN0ZW0ucmVnaXN0ZXJBY3Rpb25IYW5kbGVyKGAke25hbWV9OmNhbGxgLCAoKG9yaWdpbiwgdHlwZSwgLi4uYXJncykgPT4gdGhpcy5jYWxsKG9yaWdpbiwgdHlwZSwgLi4uYXJncykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYW4gQVBJIGlmIHRoZSByZXF1ZXN0aW5nIG9yaWdpbiBpcyBub3QgcmF0ZS1saW1pdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSByZXF1ZXN0aW5nIG9yaWdpbi5cbiAgICAgKiBAcGFyYW0gdHlwZSAtIFRoZSB0eXBlIG9mIEFQSSBjYWxsIHRvIG1ha2UuXG4gICAgICogQHBhcmFtIGFyZ3MgLSBBcmd1bWVudHMgZm9yIHRoZSBBUEkgY2FsbC5cbiAgICAgKiBAcmV0dXJucyBgZmFsc2VgIGlmIHJhdGUtbGltaXRlZCwgYW5kIGB0cnVlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgY2FsbChvcmlnaW4sIHR5cGUsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUmF0ZUxpbWl0ZWQodHlwZSwgb3JpZ2luKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5saW1pdEV4Y2VlZGVkKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFwiJHt0eXBlfVwiIGlzIGN1cnJlbnRseSByYXRlLWxpbWl0ZWQuIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuYCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVjb3JkUmVxdWVzdCh0eXBlLCBvcmlnaW4pO1xuICAgICAgICAgICAgY29uc3QgaW1wbGVtZW50YXRpb24gPSB0aGlzLmltcGxlbWVudGF0aW9uc1t0eXBlXTtcbiAgICAgICAgICAgIGlmICghaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXBpIHR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbXBsZW1lbnRhdGlvbiguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIG9yaWdpbiBpcyByYXRlIGxpbWl0ZWQgZm9yIHRoZSBhIHNwZWNpZmljIEFQSS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcGkgLSBUaGUgQVBJIHRoZSBvcmlnaW4gaXMgdHJ5aW5nIHRvIGFjY2Vzcy5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB0cnlpbmcgdG8gYWNjZXNzIHRoZSBBUEkuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHJhdGUtbGltaXRlZCwgYW5kIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGlzUmF0ZUxpbWl0ZWQoYXBpLCBvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucmVxdWVzdHNbYXBpXVtvcmlnaW5dID49IHRoaXMucmF0ZUxpbWl0Q291bnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlY29yZHMgdGhhdCBhbiBvcmlnaW4gaGFzIG1hZGUgYSByZXF1ZXN0IHRvIGNhbGwgYW4gQVBJLCBmb3IgcmF0ZS1saW1pdGluZyBwdXJwb3Nlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcGkgLSBUaGUgQVBJIHRoZSBvcmlnaW4gaXMgdHJ5aW5nIHRvIGFjY2Vzcy5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB0cnlpbmcgdG8gYWNjZXNzIHRoZSBBUEkuXG4gICAgICovXG4gICAgcmVjb3JkUmVxdWVzdChhcGksIG9yaWdpbikge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzID0gKF9hID0gc3RhdGUucmVxdWVzdHNbYXBpXVtvcmlnaW5dKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICAgICAgc3RhdGUucmVxdWVzdHNbYXBpXVtvcmlnaW5dID0gcHJldmlvdXMgKyAxO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnJlc2V0UmVxdWVzdENvdW50KGFwaSwgb3JpZ2luKSwgdGhpcy5yYXRlTGltaXRUaW1lb3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcmVxdWVzdCBjb3VudCBmb3IgYSBnaXZlbiBvcmlnaW4gYW5kIEFQSSBjb21iaW5hdGlvbiwgZm9yIHJhdGUtbGltaXRpbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXBpIC0gVGhlIEFQSSBpbiBxdWVzdGlvbi5cbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiBpbiBxdWVzdGlvbi5cbiAgICAgKi9cbiAgICByZXNldFJlcXVlc3RDb3VudChhcGksIG9yaWdpbikge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoc3RhdGUpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnJlcXVlc3RzW2FwaV1bb3JpZ2luXSA9IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUmF0ZUxpbWl0Q29udHJvbGxlciA9IFJhdGVMaW1pdENvbnRyb2xsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SYXRlTGltaXRDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gdm9pZCAwO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJWMl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyVjJcIik7XG5jb25zdCBjb250cm9sbGVyTmFtZSA9ICdTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyJztcbmNvbnN0IHN0YXRlTWV0YWRhdGEgPSB7XG4gICAgc3ViamVjdE1ldGFkYXRhOiB7IHBlcnNpc3Q6IHRydWUsIGFub255bW91czogZmFsc2UgfSxcbn07XG5jb25zdCBkZWZhdWx0U3RhdGUgPSB7XG4gICAgc3ViamVjdE1ldGFkYXRhOiB7fSxcbn07XG4vKipcbiAqIEEgY29udHJvbGxlciBmb3Igc3RvcmluZyBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggcGVybWlzc2lvbiBzdWJqZWN0cy4gTW9yZVxuICogb3IgbGVzcywgYSBjYWNoZS5cbiAqL1xuY2xhc3MgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyVjJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgY29uc3RydWN0b3IoeyBtZXNzZW5nZXIsIHN1YmplY3RDYWNoZUxpbWl0LCBzdGF0ZSA9IHt9LCB9KSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzdWJqZWN0Q2FjaGVMaW1pdCkgfHwgc3ViamVjdENhY2hlTGltaXQgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN1YmplY3RDYWNoZUxpbWl0IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiBSZWNlaXZlZDogXCIke3N1YmplY3RDYWNoZUxpbWl0fVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzUGVybWlzc2lvbnMgPSAob3JpZ2luKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2VuZ2VyLmNhbGwoJ1Blcm1pc3Npb25Db250cm9sbGVyOmhhc1Blcm1pc3Npb25zJywgb3JpZ2luKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgbmFtZTogY29udHJvbGxlck5hbWUsXG4gICAgICAgICAgICBtZXRhZGF0YTogc3RhdGVNZXRhZGF0YSxcbiAgICAgICAgICAgIG1lc3NlbmdlcixcbiAgICAgICAgICAgIHN0YXRlOiBPYmplY3QuYXNzaWduKHt9LCBTdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyLmdldFRyaW1tZWRTdGF0ZShzdGF0ZSwgaGFzUGVybWlzc2lvbnMpKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3ViamVjdEhhc1Blcm1pc3Npb25zID0gaGFzUGVybWlzc2lvbnM7XG4gICAgICAgIHRoaXMuc3ViamVjdENhY2hlTGltaXQgPSBzdWJqZWN0Q2FjaGVMaW1pdDtcbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc3RhdGUgb2YgdGhpcyBjb250cm9sbGVyLiBBbHNvIHJlc2V0cyB0aGUgY2FjaGUgb2Ygc3ViamVjdHNcbiAgICAgKiBlbmNvdW50ZXJlZCBzaW5jZSBzdGFydHVwLCBzbyBhcyB0byBub3QgcHJlbWF0dXJlbHkgcmVhY2ggdGhlIGNhY2hlIGxpbWl0LlxuICAgICAqL1xuICAgIGNsZWFyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudXBkYXRlKChfZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRTdGF0ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9yZXMgZG9tYWluIG1ldGFkYXRhIGZvciB0aGUgZ2l2ZW4gb3JpZ2luIChzdWJqZWN0KS4gRGVsZXRlcyBtZXRhZGF0YSBmb3JcbiAgICAgKiBzdWJqZWN0cyB3aXRob3V0IHBlcm1pc3Npb25zIGluIGEgRklGTyBtYW5uZXIgb25jZSBtb3JlIHRoYW5cbiAgICAgKiB7QGxpbmsgU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlci5zdWJqZWN0Q2FjaGVMaW1pdH0gZGlzdGluY3Qgb3JpZ2lucyBoYXZlXG4gICAgICogYmVlbiBhZGRlZCBzaW5jZSBib290LlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgdG8gcHJldmVudCBhIGRlZ3JhZGVkIHVzZXIgZXhwZXJpZW5jZSxcbiAgICAgKiBtZXRhZGF0YSBpcyBuZXZlciBkZWxldGVkIGZvciBzdWJqZWN0cyB3aXRoIHBlcm1pc3Npb25zLCBzaW5jZSBtZXRhZGF0YVxuICAgICAqIGNhbm5vdCB5ZXQgYmUgcmVxdWVzdGVkIG9uIGRlbWFuZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBtZXRhZGF0YSAtIFRoZSBzdWJqZWN0IG1ldGFkYXRhIHRvIHN0b3JlLlxuICAgICAqL1xuICAgIGFkZFN1YmplY3RNZXRhZGF0YShtZXRhZGF0YSkge1xuICAgICAgICBjb25zdCB7IG9yaWdpbiB9ID0gbWV0YWRhdGE7XG4gICAgICAgIGNvbnN0IG5ld01ldGFkYXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZXRhZGF0YSksIHsgZXh0ZW5zaW9uSWQ6IG1ldGFkYXRhLmV4dGVuc2lvbklkIHx8IG51bGwsIGljb25Vcmw6IG1ldGFkYXRhLmljb25VcmwgfHwgbnVsbCwgbmFtZTogbWV0YWRhdGEubmFtZSB8fCBudWxsIH0pO1xuICAgICAgICBsZXQgb3JpZ2luVG9Gb3JnZXQgPSBudWxsO1xuICAgICAgICAvLyBXZSBvbmx5IGRlbGV0ZSB0aGUgb2xkZXN0IGVuY291bnRlcmVkIHN1YmplY3QgZnJvbSB0aGUgY2FjaGUsIGFnYWluIHRvXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSB1c2VyJ3MgZXhwZXJpZW5jZSBpc24ndCBkZWdyYWRlZCBieSBtaXNzaW5nIGljb25zIGV0Yy5cbiAgICAgICAgaWYgKHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLnNpemUgPj1cbiAgICAgICAgICAgIHRoaXMuc3ViamVjdENhY2hlTGltaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZE9yaWdpbiA9IHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwXG4gICAgICAgICAgICAgICAgLnZhbHVlcygpXG4gICAgICAgICAgICAgICAgLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdHNXaXRob3V0UGVybWlzc2lvbnNFY291bnRlcmVkU2luY2VTdGFydHVwLmRlbGV0ZShjYWNoZWRPcmlnaW4pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN1YmplY3RIYXNQZXJtaXNzaW9ucyhjYWNoZWRPcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luVG9Gb3JnZXQgPSBjYWNoZWRPcmlnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJqZWN0c1dpdGhvdXRQZXJtaXNzaW9uc0Vjb3VudGVyZWRTaW5jZVN0YXJ0dXAuYWRkKG9yaWdpbik7XG4gICAgICAgIHRoaXMudXBkYXRlKChkcmFmdFN0YXRlKSA9PiB7XG4gICAgICAgICAgICAvLyBUeXBlY2FzdDogdHMoMjU4OSlcbiAgICAgICAgICAgIGRyYWZ0U3RhdGUuc3ViamVjdE1ldGFkYXRhW29yaWdpbl0gPSBuZXdNZXRhZGF0YTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luVG9Gb3JnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRyYWZ0U3RhdGUuc3ViamVjdE1ldGFkYXRhW29yaWdpblRvRm9yZ2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYWxsIHN1YmplY3RzIHdpdGhvdXQgcGVybWlzc2lvbnMgZnJvbSB0aGUgY29udHJvbGxlcidzIHN0YXRlLlxuICAgICAqL1xuICAgIHRyaW1NZXRhZGF0YVN0YXRlKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgoZHJhZnRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuZ2V0VHJpbW1lZFN0YXRlKFxuICAgICAgICAgICAgLy8gVHlwZWNhc3Q6IHRzKDI1ODkpXG4gICAgICAgICAgICBkcmFmdFN0YXRlLCB0aGlzLnN1YmplY3RIYXNQZXJtaXNzaW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IHN0YXRlIG9iamVjdCB0aGF0IG9ubHkgaW5jbHVkZXMgc3ViamVjdHMgd2l0aCBwZXJtaXNzaW9ucy5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBzdGF0aWMgYmVjYXVzZSB3ZSB3YW50IHRvIGNhbGwgaXQgaW4gdGhlIGNvbnN0cnVjdG9yLCBiZWZvcmVcbiAgICAgKiB0aGUgY29udHJvbGxlcidzIHN0YXRlIGlzIGluaXRpYWxpemVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIC0gVGhlIHN0YXRlIG9iamVjdCB0byB0cmltLlxuICAgICAqIEBwYXJhbSBoYXNQZXJtaXNzaW9ucyAtIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nXG4gICAgICogd2hldGhlciBhIHBhcnRpY3VsYXIgc3ViamVjdCAoaWRlbnRpZmllZCBieSBpdHMgb3JpZ2luKSBoYXMgYW55XG4gICAgICogcGVybWlzc2lvbnMuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBzdGF0ZSBvYmplY3QuIElmIHRoZSBzcGVjaWZpZWQgYHN0YXRlYCBvYmplY3QgaGFzIG5vXG4gICAgICogc3ViamVjdCBtZXRhZGF0YSwgdGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdGhlIGRlZmF1bHRcbiAgICAgKiBzdGF0ZSBvZiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgc3RhdGljIGdldFRyaW1tZWRTdGF0ZShzdGF0ZSwgaGFzUGVybWlzc2lvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzdWJqZWN0TWV0YWRhdGEgPSB7fSB9ID0gc3RhdGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJqZWN0TWV0YWRhdGE6IE9iamVjdC5rZXlzKHN1YmplY3RNZXRhZGF0YSkucmVkdWNlKChuZXdTdWJqZWN0TWV0YWRhdGEsIG9yaWdpbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChoYXNQZXJtaXNzaW9ucyhvcmlnaW4pKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1N1YmplY3RNZXRhZGF0YVtvcmlnaW5dID0gc3ViamVjdE1ldGFkYXRhW29yaWdpbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTdWJqZWN0TWV0YWRhdGE7XG4gICAgICAgICAgICB9LCB7fSksXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0cy5TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyID0gU3ViamVjdE1ldGFkYXRhQ29udHJvbGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1YmplY3RNZXRhZGF0YUNvbnRyb2xsZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdWJqZWN0TWV0YWRhdGFDb250cm9sbGVyXCIpLCBleHBvcnRzKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBoaXNoaW5nQ29udHJvbGxlciA9IHZvaWQgMDtcbmNvbnN0IHB1bnljb2RlXzEgPSByZXF1aXJlKFwicHVueWNvZGUvXCIpO1xuY29uc3QgY29uZmlnX2pzb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXBoaXNoaW5nLWRldGVjdC9zcmMvY29uZmlnLmpzb25cIikpO1xuY29uc3QgZGV0ZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLXBoaXNoaW5nLWRldGVjdC9zcmMvZGV0ZWN0b3JcIikpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuLyoqXG4gKiBDb250cm9sbGVyIHRoYXQgcGFzc2l2ZWx5IHBvbGxzIG9uIGEgc2V0IGludGVydmFsIGZvciBhcHByb3ZlZCBhbmQgdW5hcHByb3ZlZCB3ZWJzaXRlIG9yaWdpbnNcbiAqL1xuY2xhc3MgUGhpc2hpbmdDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFBoaXNoaW5nQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICB0aGlzLmNvbmZpZ1VybE1ldGFNYXNrID0gJ2h0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9NZXRhTWFzay9ldGgtcGhpc2hpbmctZGV0ZWN0QG1hc3Rlci9zcmMvY29uZmlnLmpzb24nO1xuICAgICAgICB0aGlzLmNvbmZpZ1VybFBoaXNoRm9ydEhvdGxpc3QgPSBgaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3BoaXNoZm9ydC9waGlzaGZvcnQtbGlzdHNAbWFzdGVyL2JsYWNrbGlzdHMvaG90bGlzdC5qc29uYDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnUGhpc2hpbmdDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0geyBpbnRlcnZhbDogNjAgKiA2MCAqIDEwMDAgfTtcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7XG4gICAgICAgICAgICBwaGlzaGluZzogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dsaXN0OiBjb25maWdfanNvbl8xLmRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC53aGl0ZWxpc3QsXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrbGlzdDogY29uZmlnX2pzb25fMS5kZWZhdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAuYmxhY2tsaXN0LFxuICAgICAgICAgICAgICAgICAgICBmdXp6eWxpc3Q6IGNvbmZpZ19qc29uXzEuZGVmYXVsdFxuICAgICAgICAgICAgICAgICAgICAgICAgLmZ1enp5bGlzdCxcbiAgICAgICAgICAgICAgICAgICAgdG9sZXJhbmNlOiBjb25maWdfanNvbl8xLmRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgIC50b2xlcmFuY2UsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGBNZXRhTWFza2AsXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IGNvbmZpZ19qc29uXzEuZGVmYXVsdC52ZXJzaW9uLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgd2hpdGVsaXN0OiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kZXRlY3RvciA9IG5ldyBkZXRlY3Rvcl8xLmRlZmF1bHQodGhpcy5kZWZhdWx0U3RhdGUucGhpc2hpbmcpO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBhIG5ldyBwb2xsaW5nIGludGVydmFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIGludGVydmFsIC0gUG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyBhcHByb3ZhbCBsaXN0cy5cbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLnVwZGF0ZVBoaXNoaW5nTGlzdHMoKSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucG9sbCh0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgICAgICB9LCB0aGlzLmNvbmZpZy5pbnRlcnZhbCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gb3JpZ2luIGlzIHVuYXBwcm92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gRG9tYWluIG9yaWdpbiBvZiBhIHdlYnNpdGUuXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgb3JpZ2luIGlzIGFuIHVuYXBwcm92ZWQgb3JpZ2luLlxuICAgICAqL1xuICAgIHRlc3Qob3JpZ2luKSB7XG4gICAgICAgIGNvbnN0IHB1bnljb2RlT3JpZ2luID0gKDAsIHB1bnljb2RlXzEudG9BU0NJSSkob3JpZ2luKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUud2hpdGVsaXN0LmluZGV4T2YocHVueWNvZGVPcmlnaW4pICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgdHlwZTogJ2FsbCcgfTsgLy8gU2FtZSBhcyB3aGl0ZWxpc3RlZCBtYXRjaCByZXR1cm5lZCBieSBkZXRlY3Rvci5jaGVjayguLi4pLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRldGVjdG9yLmNoZWNrKHB1bnljb2RlT3JpZ2luKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVtcG9yYXJpbHkgbWFya3MgYSBnaXZlbiBvcmlnaW4gYXMgYXBwcm92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luIC0gVGhlIG9yaWdpbiB0byBtYXJrIGFzIGFwcHJvdmVkLlxuICAgICAqL1xuICAgIGJ5cGFzcyhvcmlnaW4pIHtcbiAgICAgICAgY29uc3QgcHVueWNvZGVPcmlnaW4gPSAoMCwgcHVueWNvZGVfMS50b0FTQ0lJKShvcmlnaW4pO1xuICAgICAgICBjb25zdCB7IHdoaXRlbGlzdCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHdoaXRlbGlzdC5pbmRleE9mKHB1bnljb2RlT3JpZ2luKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7IHdoaXRlbGlzdDogWy4uLndoaXRlbGlzdCwgcHVueWNvZGVPcmlnaW5dIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGxpc3RzIG9mIGFwcHJvdmVkIGFuZCB1bmFwcHJvdmVkIHdlYnNpdGUgb3JpZ2lucy5cbiAgICAgKi9cbiAgICB1cGRhdGVQaGlzaGluZ0xpc3RzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb25maWdzID0gW107XG4gICAgICAgICAgICBjb25zdCBbbWV0YW1hc2tDb25maWdMZWdhY3ksIHBoaXNoZm9ydEhvdGxpc3RdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucXVlcnlDb25maWcodGhpcy5jb25maWdVcmxNZXRhTWFzayksXG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5xdWVyeUNvbmZpZyh0aGlzLmNvbmZpZ1VybFBoaXNoRm9ydEhvdGxpc3QpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBDb3JyZWN0bHkgc2hhcGluZyBNZXRhTWFzayBjb25maWcuXG4gICAgICAgICAgICBjb25zdCBtZXRhbWFza0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBhbGxvd2xpc3Q6IG1ldGFtYXNrQ29uZmlnTGVnYWN5ID8gbWV0YW1hc2tDb25maWdMZWdhY3kud2hpdGVsaXN0IDogW10sXG4gICAgICAgICAgICAgICAgYmxvY2tsaXN0OiBtZXRhbWFza0NvbmZpZ0xlZ2FjeSA/IG1ldGFtYXNrQ29uZmlnTGVnYWN5LmJsYWNrbGlzdCA6IFtdLFxuICAgICAgICAgICAgICAgIGZ1enp5bGlzdDogbWV0YW1hc2tDb25maWdMZWdhY3kgPyBtZXRhbWFza0NvbmZpZ0xlZ2FjeS5mdXp6eWxpc3QgOiBbXSxcbiAgICAgICAgICAgICAgICB0b2xlcmFuY2U6IG1ldGFtYXNrQ29uZmlnTGVnYWN5ID8gbWV0YW1hc2tDb25maWdMZWdhY3kudG9sZXJhbmNlIDogMCxcbiAgICAgICAgICAgICAgICBuYW1lOiBgTWV0YU1hc2tgLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IG1ldGFtYXNrQ29uZmlnTGVnYWN5ID8gbWV0YW1hc2tDb25maWdMZWdhY3kudmVyc2lvbiA6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKG1ldGFtYXNrQ29uZmlnTGVnYWN5KSB7XG4gICAgICAgICAgICAgICAgY29uZmlncy5wdXNoKG1ldGFtYXNrQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcnJlY3RseSBzaGFwaW5nIFBoaXNoRm9ydCBjb25maWcuXG4gICAgICAgICAgICBjb25zdCBwaGlzaGZvcnRDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgYWxsb3dsaXN0OiBbXSxcbiAgICAgICAgICAgICAgICBibG9ja2xpc3Q6IChwaGlzaGZvcnRIb3RsaXN0IHx8IFtdKS5maWx0ZXIoKGkpID0+ICFtZXRhbWFza0NvbmZpZy5ibG9ja2xpc3QuaW5jbHVkZXMoaSkpLFxuICAgICAgICAgICAgICAgIGZ1enp5bGlzdDogW10sXG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlOiAwLFxuICAgICAgICAgICAgICAgIG5hbWU6IGBQaGlzaEZvcnRgLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHBoaXNoZm9ydEhvdGxpc3QpIHtcbiAgICAgICAgICAgICAgICBjb25maWdzLnB1c2gocGhpc2hmb3J0Q29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCB1cGRhdGUgaWYgYWxsIGNvbmZpZ3MgYXJlIHVuYXZhaWxhYmxlLlxuICAgICAgICAgICAgaWYgKCFjb25maWdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0b3IgPSBuZXcgZGV0ZWN0b3JfMS5kZWZhdWx0KGNvbmZpZ3MpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgIHBoaXNoaW5nOiBjb25maWdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBxdWVyeUNvbmZpZyhpbnB1dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChpbnB1dCwgeyBjYWNoZTogJ25vLWNhY2hlJyB9KTtcbiAgICAgICAgICAgIHN3aXRjaCAocmVzcG9uc2Uuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAyMDA6IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGhpc2hpbmdDb250cm9sbGVyID0gUGhpc2hpbmdDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGhpc2hpbmdDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGhpc2hpbmdDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlRyYW5zYWN0aW9uQ29udHJvbGxlciA9IGV4cG9ydHMuU1BFRURfVVBfUkFURSA9IGV4cG9ydHMuQ0FOQ0VMX1JBVEUgPSBleHBvcnRzLldhbGxldERldmljZSA9IGV4cG9ydHMuVHJhbnNhY3Rpb25TdGF0dXMgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBldGhlcmV1bWpzX3V0aWxfMSA9IHJlcXVpcmUoXCJldGhlcmV1bWpzLXV0aWxcIik7XG5jb25zdCBldGhfcnBjX2Vycm9yc18xID0gcmVxdWlyZShcImV0aC1ycGMtZXJyb3JzXCIpO1xuY29uc3QgZXRoX21ldGhvZF9yZWdpc3RyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtbWV0aG9kLXJlZ2lzdHJ5XCIpKTtcbmNvbnN0IGV0aF9xdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJldGgtcXVlcnlcIikpO1xuY29uc3QgY29tbW9uXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkBldGhlcmV1bWpzL2NvbW1vblwiKSk7XG5jb25zdCB0eF8xID0gcmVxdWlyZShcIkBldGhlcmV1bWpzL3R4XCIpO1xuY29uc3QgdXVpZF8xID0gcmVxdWlyZShcInV1aWRcIik7XG5jb25zdCBhc3luY19tdXRleF8xID0gcmVxdWlyZShcImFzeW5jLW11dGV4XCIpO1xuY29uc3QgQmFzZUNvbnRyb2xsZXJfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQ29udHJvbGxlclwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuY29uc3QgY29uc3RhbnRzXzEgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRzXCIpO1xuY29uc3QgSEFSREZPUksgPSAnbG9uZG9uJztcbi8qKlxuICogVGhlIHN0YXR1cyBvZiB0aGUgdHJhbnNhY3Rpb24uIEVhY2ggc3RhdHVzIHJlcHJlc2VudHMgdGhlIHN0YXRlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbnRlcm5hbGx5XG4gKiBpbiB0aGUgd2FsbGV0LiBTb21lIG9mIHRoZXNlIGNvcnJlc3BvbmQgd2l0aCB0aGUgc3RhdGUgb2YgdGhlIHRyYW5zYWN0aW9uIG9uIHRoZSBuZXR3b3JrLCBidXRcbiAqIHNvbWUgYXJlIHdhbGxldC1zcGVjaWZpYy5cbiAqL1xudmFyIFRyYW5zYWN0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiYXBwcm92ZWRcIl0gPSBcImFwcHJvdmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJjYW5jZWxsZWRcIl0gPSBcImNhbmNlbGxlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1wiY29uZmlybWVkXCJdID0gXCJjb25maXJtZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcImZhaWxlZFwiXSA9IFwiZmFpbGVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJyZWplY3RlZFwiXSA9IFwicmVqZWN0ZWRcIjtcbiAgICBUcmFuc2FjdGlvblN0YXR1c1tcInNpZ25lZFwiXSA9IFwic2lnbmVkXCI7XG4gICAgVHJhbnNhY3Rpb25TdGF0dXNbXCJzdWJtaXR0ZWRcIl0gPSBcInN1Ym1pdHRlZFwiO1xuICAgIFRyYW5zYWN0aW9uU3RhdHVzW1widW5hcHByb3ZlZFwiXSA9IFwidW5hcHByb3ZlZFwiO1xufSkoVHJhbnNhY3Rpb25TdGF0dXMgPSBleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzIHx8IChleHBvcnRzLlRyYW5zYWN0aW9uU3RhdHVzID0ge30pKTtcbi8qKlxuICogT3B0aW9ucyBmb3Igd2FsbGV0IGRldmljZS5cbiAqL1xudmFyIFdhbGxldERldmljZTtcbihmdW5jdGlvbiAoV2FsbGV0RGV2aWNlKSB7XG4gICAgV2FsbGV0RGV2aWNlW1wiTU1fTU9CSUxFXCJdID0gXCJtZXRhbWFza19tb2JpbGVcIjtcbiAgICBXYWxsZXREZXZpY2VbXCJNTV9FWFRFTlNJT05cIl0gPSBcIm1ldGFtYXNrX2V4dGVuc2lvblwiO1xuICAgIFdhbGxldERldmljZVtcIk9USEVSXCJdID0gXCJvdGhlcl9kZXZpY2VcIjtcbn0pKFdhbGxldERldmljZSA9IGV4cG9ydHMuV2FsbGV0RGV2aWNlIHx8IChleHBvcnRzLldhbGxldERldmljZSA9IHt9KSk7XG4vKipcbiAqIE11bHRpcGxpZXIgdXNlZCB0byBkZXRlcm1pbmUgYSB0cmFuc2FjdGlvbidzIGluY3JlYXNlZCBnYXMgZmVlIGR1cmluZyBjYW5jZWxsYXRpb25cbiAqL1xuZXhwb3J0cy5DQU5DRUxfUkFURSA9IDEuNTtcbi8qKlxuICogTXVsdGlwbGllciB1c2VkIHRvIGRldGVybWluZSBhIHRyYW5zYWN0aW9uJ3MgaW5jcmVhc2VkIGdhcyBmZWUgZHVyaW5nIHNwZWVkIHVwXG4gKi9cbmV4cG9ydHMuU1BFRURfVVBfUkFURSA9IDEuMTtcbi8qKlxuICogQ29udHJvbGxlciByZXNwb25zaWJsZSBmb3Igc3VibWl0dGluZyBhbmQgbWFuYWdpbmcgdHJhbnNhY3Rpb25zXG4gKi9cbmNsYXNzIFRyYW5zYWN0aW9uQ29udHJvbGxlciBleHRlbmRzIEJhc2VDb250cm9sbGVyXzEuQmFzZUNvbnRyb2xsZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBjb250cm9sbGVyIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMuZ2V0TmV0d29ya1N0YXRlIC0gR2V0cyB0aGUgc3RhdGUgb2YgdGhlIG5ldHdvcmsgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5vbk5ldHdvcmtTdGF0ZUNoYW5nZSAtIEFsbG93cyBzdWJzY3JpYmluZyB0byBuZXR3b3JrIGNvbnRyb2xsZXIgc3RhdGUgY2hhbmdlcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5nZXRQcm92aWRlciAtIFJldHVybnMgYSBwcm92aWRlciBmb3IgdGhlIGN1cnJlbnQgbmV0d29yay5cbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBnZXROZXR3b3JrU3RhdGUsIG9uTmV0d29ya1N0YXRlQ2hhbmdlLCBnZXRQcm92aWRlciwgfSwgY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5tdXRleCA9IG5ldyBhc3luY19tdXRleF8xLk11dGV4KCk7XG4gICAgICAgIHRoaXMubm9ybWFsaXplVG9rZW5UeCA9ICh0eE1ldGEsIGN1cnJlbnROZXR3b3JrSUQsIGN1cnJlbnRDaGFpbklkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gcGFyc2VJbnQodHhNZXRhLnRpbWVTdGFtcCwgMTApICogMTAwMDtcbiAgICAgICAgICAgIGNvbnN0IHsgdG8sIGZyb20sIGdhcywgZ2FzUHJpY2UsIGdhc1VzZWQsIGhhc2gsIGNvbnRyYWN0QWRkcmVzcywgdG9rZW5EZWNpbWFsLCB0b2tlblN5bWJvbCwgdmFsdWUsIH0gPSB0eE1ldGE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgdXVpZF8xLnYxKSh7IG1zZWNzOiB0aW1lIH0pLFxuICAgICAgICAgICAgICAgIGlzVHJhbnNmZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgbmV0d29ya0lEOiBjdXJyZW50TmV0d29ya0lELFxuICAgICAgICAgICAgICAgIGNoYWluSWQ6IGN1cnJlbnRDaGFpbklkLFxuICAgICAgICAgICAgICAgIHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkLFxuICAgICAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZDogMSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzVXNlZCxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgICAgIHRyYW5zZmVySW5mb3JtYXRpb246IHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3RBZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICBkZWNpbWFsczogTnVtYmVyKHRva2VuRGVjaW1hbCksXG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbDogdG9rZW5TeW1ib2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZXJpZmllZE9uQmxvY2tjaGFpbjogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnRFbWl0dGVyIGluc3RhbmNlIHVzZWQgdG8gbGlzdGVuIHRvIHNwZWNpZmljIHRyYW5zYWN0aW9uYWwgZXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmh1YiA9IG5ldyBldmVudHNfMS5FdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnVHJhbnNhY3Rpb25Db250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgaW50ZXJ2YWw6IDE1MDAwLFxuICAgICAgICAgICAgdHhIaXN0b3J5TGltaXQ6IDQwLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIG1ldGhvZERhdGE6IHt9LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBbXSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZ2V0UHJvdmlkZXIoKTtcbiAgICAgICAgdGhpcy5nZXROZXR3b3JrU3RhdGUgPSBnZXROZXR3b3JrU3RhdGU7XG4gICAgICAgIHRoaXMuZXRoUXVlcnkgPSBuZXcgZXRoX3F1ZXJ5XzEuZGVmYXVsdChwcm92aWRlcik7XG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSBuZXcgZXRoX21ldGhvZF9yZWdpc3RyeV8xLmRlZmF1bHQoeyBwcm92aWRlciB9KTtcbiAgICAgICAgb25OZXR3b3JrU3RhdGVDaGFuZ2UoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3UHJvdmlkZXIgPSBnZXRQcm92aWRlcigpO1xuICAgICAgICAgICAgdGhpcy5ldGhRdWVyeSA9IG5ldyBldGhfcXVlcnlfMS5kZWZhdWx0KG5ld1Byb3ZpZGVyKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0cnkgPSBuZXcgZXRoX21ldGhvZF9yZWdpc3RyeV8xLmRlZmF1bHQoeyBwcm92aWRlcjogbmV3UHJvdmlkZXIgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG4gICAgZmFpbFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbmV3VHJhbnNhY3Rpb25NZXRhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbk1ldGEpLCB7IGVycm9yLCBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbihuZXdUcmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICB0aGlzLmh1Yi5lbWl0KGAke3RyYW5zYWN0aW9uTWV0YS5pZH06ZmluaXNoZWRgLCBuZXdUcmFuc2FjdGlvbk1ldGEpO1xuICAgIH1cbiAgICByZWdpc3RyeUxvb2t1cChmb3VyQnl0ZVByZWZpeCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVnaXN0cnlNZXRob2QgPSB5aWVsZCB0aGlzLnJlZ2lzdHJ5Lmxvb2t1cChmb3VyQnl0ZVByZWZpeCk7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRSZWdpc3RyeU1ldGhvZCA9IHRoaXMucmVnaXN0cnkucGFyc2UocmVnaXN0cnlNZXRob2QpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVnaXN0cnlNZXRob2QsIHBhcnNlZFJlZ2lzdHJ5TWV0aG9kIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIHRoZSB0cmFuc2FjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGV0aGVyc2NhblxuICAgICAqIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGUgVHJhbnNhY3Rpb25NZXRhIGludGVyZmFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eE1ldGEgLSBUaGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIGN1cnJlbnROZXR3b3JrSUQgLSBUaGUgY3VycmVudCBuZXR3b3JrIElELlxuICAgICAqIEBwYXJhbSBjdXJyZW50Q2hhaW5JZCAtIFRoZSBjdXJyZW50IGNoYWluIElELlxuICAgICAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIG5vcm1hbGl6ZVR4KHR4TWV0YSwgY3VycmVudE5ldHdvcmtJRCwgY3VycmVudENoYWluSWQpIHtcbiAgICAgICAgY29uc3QgdGltZSA9IHBhcnNlSW50KHR4TWV0YS50aW1lU3RhbXAsIDEwKSAqIDEwMDA7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2FjdGlvbkJhc2UgPSB7XG4gICAgICAgICAgICBibG9ja051bWJlcjogdHhNZXRhLmJsb2NrTnVtYmVyLFxuICAgICAgICAgICAgaWQ6ICgwLCB1dWlkXzEudjEpKHsgbXNlY3M6IHRpbWUgfSksXG4gICAgICAgICAgICBuZXR3b3JrSUQ6IGN1cnJlbnROZXR3b3JrSUQsXG4gICAgICAgICAgICBjaGFpbklkOiBjdXJyZW50Q2hhaW5JZCxcbiAgICAgICAgICAgIHRpbWUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgIGRhdGE6IHR4TWV0YS5pbnB1dCxcbiAgICAgICAgICAgICAgICBmcm9tOiB0eE1ldGEuZnJvbSxcbiAgICAgICAgICAgICAgICBnYXM6ICgwLCB1dGlsXzEuQk5Ub0hleCkobmV3IGV0aGVyZXVtanNfdXRpbF8xLkJOKHR4TWV0YS5nYXMpKSxcbiAgICAgICAgICAgICAgICBnYXNQcmljZTogKDAsIHV0aWxfMS5CTlRvSGV4KShuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLmdhc1ByaWNlKSksXG4gICAgICAgICAgICAgICAgZ2FzVXNlZDogKDAsIHV0aWxfMS5CTlRvSGV4KShuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLmdhc1VzZWQpKSxcbiAgICAgICAgICAgICAgICBub25jZTogKDAsIHV0aWxfMS5CTlRvSGV4KShuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLm5vbmNlKSksXG4gICAgICAgICAgICAgICAgdG86IHR4TWV0YS50byxcbiAgICAgICAgICAgICAgICB2YWx1ZTogKDAsIHV0aWxfMS5CTlRvSGV4KShuZXcgZXRoZXJldW1qc191dGlsXzEuQk4odHhNZXRhLnZhbHVlKSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eE1ldGEuaGFzaCxcbiAgICAgICAgICAgIHZlcmlmaWVkT25CbG9ja2NoYWluOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKHR4TWV0YS5pc0Vycm9yID09PSAnMCcpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbkJhc2UpLCB7IHN0YXR1czogVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbkJhc2UpLCB7IGVycm9yOiBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZCcpLCBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGEgbmV3IHBvbGxpbmcgaW50ZXJ2YWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW50ZXJ2YWwgLSBUaGUgcG9sbGluZyBpbnRlcnZhbCB1c2VkIHRvIGZldGNoIG5ldyB0cmFuc2FjdGlvbiBzdGF0dXNlcy5cbiAgICAgKi9cbiAgICBwb2xsKGludGVydmFsKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpbnRlcnZhbCAmJiB0aGlzLmNvbmZpZ3VyZSh7IGludGVydmFsIH0sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSAmJiBjbGVhclRpbWVvdXQodGhpcy5oYW5kbGUpO1xuICAgICAgICAgICAgeWllbGQgKDAsIHV0aWxfMS5zYWZlbHlFeGVjdXRlKSgoKSA9PiB0aGlzLnF1ZXJ5VHJhbnNhY3Rpb25TdGF0dXNlcygpKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb2xsKHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgICAgIH0sIHRoaXMuY29uZmlnLmludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBuZXcgbWV0aG9kIGRhdGEgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3VyQnl0ZVByZWZpeCAtIFRoZSBtZXRob2QgcHJlZml4LlxuICAgICAqIEByZXR1cm5zIFRoZSBtZXRob2QgZGF0YSBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gc2lnbmF0dXJlIHByZWZpeC5cbiAgICAgKi9cbiAgICBoYW5kbGVNZXRob2REYXRhKGZvdXJCeXRlUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1ldGhvZERhdGEgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3Qga25vd25NZXRob2QgPSBPYmplY3Qua2V5cyhtZXRob2REYXRhKS5maW5kKChrbm93bkZvdXJCeXRlUHJlZml4KSA9PiBmb3VyQnl0ZVByZWZpeCA9PT0ga25vd25Gb3VyQnl0ZVByZWZpeCk7XG4gICAgICAgICAgICAgICAgaWYgKGtub3duTWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXRob2REYXRhW2ZvdXJCeXRlUHJlZml4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnaXN0cnkgPSB5aWVsZCB0aGlzLnJlZ2lzdHJ5TG9va3VwKGZvdXJCeXRlUHJlZml4KTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZERhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWV0aG9kRGF0YSksIHsgW2ZvdXJCeXRlUHJlZml4XTogcmVnaXN0cnkgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uIHRvIHN0YXRlLiBQYXJhbWV0ZXJzIHdpbGwgYmUgdmFsaWRhdGVkLCBhXG4gICAgICogdW5pcXVlIHRyYW5zYWN0aW9uIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLCBhbmQgZ2FzIGFuZCBnYXNQcmljZSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAgICAgKiBpZiBub3QgcHJvdmlkZWQuIElmIEEgYDx0eC5pZD46dW5hcHByb3ZlZGAgaHViIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBvbmNlIGFkZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCB0byBhZGQuXG4gICAgICogQHBhcmFtIG9yaWdpbiAtIFRoZSBkb21haW4gb3JpZ2luIHRvIGFwcGVuZCB0byB0aGUgZ2VuZXJhdGVkIFRyYW5zYWN0aW9uTWV0YS5cbiAgICAgKiBAcGFyYW0gZGV2aWNlQ29uZmlybWVkT24gLSBBbiBlbnVtIHRvIGluZGljYXRlIHdoYXQgZGV2aWNlIHRoZSB0cmFuc2FjdGlvbiB3YXMgY29uZmlybWVkIHRvIGFwcGVuZCB0byB0aGUgZ2VuZXJhdGVkIFRyYW5zYWN0aW9uTWV0YS5cbiAgICAgKiBAcmV0dXJucyBPYmplY3QgY29udGFpbmluZyBhIHByb21pc2UgcmVzb2x2aW5nIHRvIHRoZSB0cmFuc2FjdGlvbiBoYXNoIGlmIGFwcHJvdmVkLlxuICAgICAqL1xuICAgIGFkZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBvcmlnaW4sIGRldmljZUNvbmZpcm1lZE9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByb3ZpZGVyLCBuZXR3b3JrIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbiA9ICgwLCB1dGlsXzEubm9ybWFsaXplVHJhbnNhY3Rpb24pKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVUcmFuc2FjdGlvbikodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25NZXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoMCwgdXVpZF8xLnYxKSgpLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtJRDogbmV0d29yayxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBwcm92aWRlci5jaGFpbklkLFxuICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFRyYW5zYWN0aW9uU3RhdHVzLnVuYXBwcm92ZWQsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBkZXZpY2VDb25maXJtZWRPbixcbiAgICAgICAgICAgICAgICB2ZXJpZmllZE9uQmxvY2tjaGFpbjogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGdhcyB9ID0geWllbGQgdGhpcy5lc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZ2FzID0gZ2FzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmh1Yi5vbmNlKGAke3RyYW5zYWN0aW9uTWV0YS5pZH06ZmluaXNoZWRgLCAobWV0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1ldGEuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShtZXRhLnRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLnJlamVjdGVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCgnVXNlciByZWplY3RlZCB0aGUgdHJhbnNhY3Rpb24nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLmNhbmNlbGxlZDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCgnVXNlciBjYW5jZWxsZWQgdGhlIHRyYW5zYWN0aW9uJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblN0YXR1cy5mYWlsZWQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW50ZXJuYWwobWV0YS5lcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnRlcm5hbChgTWV0YU1hc2sgVHggU2lnbmF0dXJlOiBVbmtub3duIHByb2JsZW06ICR7SlNPTi5zdHJpbmdpZnkobWV0YSl9YCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSB9KTtcbiAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYHVuYXBwcm92ZWRUcmFuc2FjdGlvbmAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQsIHRyYW5zYWN0aW9uTWV0YSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlcGFyZVVuc2lnbmVkRXRoVHgodHhQYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHR4XzEuVHJhbnNhY3Rpb25GYWN0b3J5LmZyb21UeERhdGEodHhQYXJhbXMsIHtcbiAgICAgICAgICAgIGNvbW1vbjogdGhpcy5nZXRDb21tb25Db25maWd1cmF0aW9uKCksXG4gICAgICAgICAgICBmcmVlemU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYEBldGhlcmV1bWpzL3R4YCB1c2VzIGBAZXRoZXJldW1qcy9jb21tb25gIGFzIGEgY29uZmlndXJhdGlvbiB0b29sIGZvclxuICAgICAqIHNwZWNpZnlpbmcgd2hpY2ggY2hhaW4sIG5ldHdvcmssIGhhcmRmb3JrIGFuZCBFSVBzIHRvIHN1cHBvcnQgZm9yXG4gICAgICogYSB0cmFuc2FjdGlvbi4gQnkgcmVmZXJlbmNpbmcgdGhpcyBjb25maWd1cmF0aW9uLCBhbmQgYW5hbHl6aW5nIHRoZSBmaWVsZHNcbiAgICAgKiBzcGVjaWZpZWQgaW4gdHhQYXJhbXMsIEBldGhlcmV1bWpzL3R4IGlzIGFibGUgdG8gZGV0ZXJtaW5lIHdoaWNoIEVJUC0yNzE4XG4gICAgICogdHJhbnNhY3Rpb24gdHlwZSB0byB1c2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q29tbW9ufSBjb21tb24gY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBnZXRDb21tb25Db25maWd1cmF0aW9uKCkge1xuICAgICAgICBjb25zdCB7IG5ldHdvcms6IG5ldHdvcmtJZCwgcHJvdmlkZXI6IHsgdHlwZTogY2hhaW4sIGNoYWluSWQsIG5pY2tuYW1lOiBuYW1lIH0sIH0gPSB0aGlzLmdldE5ldHdvcmtTdGF0ZSgpO1xuICAgICAgICBpZiAoY2hhaW4gIT09IGNvbnN0YW50c18xLlJQQykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjb21tb25fMS5kZWZhdWx0KHsgY2hhaW4sIGhhcmRmb3JrOiBIQVJERk9SSyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXN0b21DaGFpblBhcmFtcyA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBjaGFpbklkOiBwYXJzZUludChjaGFpbklkLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgbmV0d29ya0lkOiBwYXJzZUludChuZXR3b3JrSWQsIHVuZGVmaW5lZCksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5kZWZhdWx0LmZvckN1c3RvbUNoYWluKGNvbnN0YW50c18xLk1BSU5ORVQsIGN1c3RvbUNoYWluUGFyYW1zLCBIQVJERk9SSyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcHJvdmVzIGEgdHJhbnNhY3Rpb24gYW5kIHVwZGF0ZXMgaXQncyBzdGF0dXMgaW4gc3RhdGUuIElmIHRoaXMgaXMgbm90IGFcbiAgICAgKiByZXRyeSB0cmFuc2FjdGlvbiwgYSBub25jZSB3aWxsIGJlIGdlbmVyYXRlZC4gVGhlIHRyYW5zYWN0aW9uIGlzIHNpZ25lZFxuICAgICAqIHVzaW5nIHRoZSBzaWduIGNvbmZpZ3VyYXRpb24gcHJvcGVydHksIHRoZW4gcHVibGlzaGVkIHRvIHRoZSBibG9ja2NoYWluLlxuICAgICAqIEEgYDx0eC5pZD46ZmluaXNoZWRgIGh1YiBldmVudCBpcyBmaXJlZCBhZnRlciBzdWNjZXNzIG9yIGZhaWx1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25JRCAtIFRoZSBJRCBvZiB0aGUgdHJhbnNhY3Rpb24gdG8gYXBwcm92ZS5cbiAgICAgKi9cbiAgICBhcHByb3ZlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCByZWxlYXNlTG9jayA9IHlpZWxkIHRoaXMubXV0ZXguYWNxdWlyZSgpO1xuICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0cmFuc2FjdGlvbnMuZmluZEluZGV4KCh7IGlkIH0pID0+IHRyYW5zYWN0aW9uSUQgPT09IGlkKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRyYW5zYWN0aW9uc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCB7IG5vbmNlIH0gPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFpbFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uTWV0YSwgbmV3IEVycm9yKCdObyBzaWduIG1ldGhvZCBkZWZpbmVkLicpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY3VycmVudENoYWluSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhLCBuZXcgRXJyb3IoJ05vIGNoYWluSWQgZGVmaW5lZC4nKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5JZCA9IHBhcnNlSW50KGN1cnJlbnRDaGFpbklkLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXBwcm92ZWQ6IHN0YXR1cyB9ID0gVHJhbnNhY3Rpb25TdGF0dXM7XG4gICAgICAgICAgICAgICAgY29uc3QgdHhOb25jZSA9IG5vbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgICh5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25Db3VudCcsIFtmcm9tLCAncGVuZGluZyddKSk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25NZXRhLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubm9uY2UgPSB0eE5vbmNlO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHhQYXJhbXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsIGNoYWluSWQsIG5vbmNlOiB0eE5vbmNlLCBzdGF0dXMgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNFSVAxNTU5ID0gKDAsIHV0aWxfMS5pc0VJUDE1NTlUcmFuc2FjdGlvbikodHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eFBhcmFtcyA9IGlzRUlQMTU1OVxuICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYmFzZVR4UGFyYW1zKSwgeyBtYXhGZWVQZXJHYXM6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMsIGVzdGltYXRlZEJhc2VGZWU6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5lc3RpbWF0ZWRCYXNlRmVlLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZnkgdHlwZSAyIGlmIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgYXJlIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogMiB9KSA6IGJhc2VUeFBhcmFtcztcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgZ2FzUHJpY2UgaWYgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBhcmUgc2V0XG4gICAgICAgICAgICAgICAgaWYgKGlzRUlQMTU1OSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHhQYXJhbXMuZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXRoVHggPSB0aGlzLnByZXBhcmVVbnNpZ25lZEV0aFR4KHR4UGFyYW1zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnbih1bnNpZ25lZEV0aFR4LCBmcm9tKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuc2lnbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5idWZmZXJUb0hleCkoc2lnbmVkVHguc2VyaWFsaXplKCkpO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS5yYXdUcmFuc2FjdGlvbiA9IHJhd1RyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnc2VuZFJhd1RyYW5zYWN0aW9uJywgW1xuICAgICAgICAgICAgICAgICAgICByYXdUcmFuc2FjdGlvbixcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb25IYXNoID0gdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uTWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5zdWJtaXR0ZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuaHViLmVtaXQoYCR7dHJhbnNhY3Rpb25NZXRhLmlkfTpmaW5pc2hlZGAsIHRyYW5zYWN0aW9uTWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk1ldGEsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2VMb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgdHJhbnNhY3Rpb24gYmFzZWQgb24gaXRzIElEIGJ5IHNldHRpbmcgaXRzIHN0YXR1cyB0byBcInJlamVjdGVkXCJcbiAgICAgKiBhbmQgZW1pdHRpbmcgYSBgPHR4LmlkPjpmaW5pc2hlZGAgaHViIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uSUQgLSBUaGUgSUQgb2YgdGhlIHRyYW5zYWN0aW9uIHRvIGNhbmNlbC5cbiAgICAgKi9cbiAgICBjYW5jZWxUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICBpZiAoIXRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zYWN0aW9uTWV0YS5zdGF0dXMgPSBUcmFuc2FjdGlvblN0YXR1cy5yZWplY3RlZDtcbiAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25zID0gdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMuZmlsdGVyKCh7IGlkIH0pID0+IGlkICE9PSB0cmFuc2FjdGlvbklEKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIGNhbmNlbCBhIHRyYW5zYWN0aW9uIGJhc2VkIG9uIGl0cyBJRCBieSBzZXR0aW5nIGl0cyBzdGF0dXMgdG8gXCJyZWplY3RlZFwiXG4gICAgICogYW5kIGVtaXR0aW5nIGEgYDx0eC5pZD46ZmluaXNoZWRgIGh1YiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbklEIC0gVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBjYW5jZWwuXG4gICAgICogQHBhcmFtIGdhc1ZhbHVlcyAtIFRoZSBnYXMgdmFsdWVzIHRvIHVzZSBmb3IgdGhlIGNhbmNlbGxhdGlvbiB0cmFuc2F0aW9uLlxuICAgICAqL1xuICAgIHN0b3BUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklELCBnYXNWYWx1ZXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChnYXNWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLnZhbGlkYXRlR2FzVmFsdWVzKShnYXNWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25NZXRhID0gdGhpcy5zdGF0ZS50cmFuc2FjdGlvbnMuZmluZCgoeyBpZCB9KSA9PiBpZCA9PT0gdHJhbnNhY3Rpb25JRCk7XG4gICAgICAgICAgICBpZiAoIXRyYW5zYWN0aW9uTWV0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduIG1ldGhvZCBkZWZpbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2FzUHJpY2UgKGxlZ2FjeSBub24gRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IG1pbkdhc1ByaWNlID0gKDAsIHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZykodHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhc1ByaWNlLCBleHBvcnRzLkNBTkNFTF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IGdhc1ByaWNlRnJvbVZhbHVlcyA9ICgwLCB1dGlsXzEuaXNHYXNQcmljZVZhbHVlKShnYXNWYWx1ZXMpICYmIGdhc1ZhbHVlcy5nYXNQcmljZTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0dhc1ByaWNlID0gKGdhc1ByaWNlRnJvbVZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UpKGdhc1ByaWNlRnJvbVZhbHVlcywgbWluR2FzUHJpY2UpKSB8fFxuICAgICAgICAgICAgICAgIG1pbkdhc1ByaWNlO1xuICAgICAgICAgICAgLy8gbWF4RmVlUGVyR2FzIChFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdNYXhGZWVQZXJHYXMgPSAoX2EgPSB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICBjb25zdCBtaW5NYXhGZWVQZXJHYXMgPSAoMCwgdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKShleGlzdGluZ01heEZlZVBlckdhcywgZXhwb3J0cy5DQU5DRUxfUkFURSk7XG4gICAgICAgICAgICBjb25zdCBtYXhGZWVQZXJHYXNWYWx1ZXMgPSAoMCwgdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcykoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4RmVlUGVyR2FzID0gKG1heEZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UpKG1heEZlZVBlckdhc1ZhbHVlcywgbWluTWF4RmVlUGVyR2FzKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdNYXhGZWVQZXJHYXMgJiYgbWluTWF4RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIC8vIG1heFByaW9yaXR5RmVlUGVyR2FzIChFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcyA9IChfYiA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAoMCwgdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKShleGlzdGluZ01heFByaW9yaXR5RmVlUGVyR2FzLCBleHBvcnRzLkNBTkNFTF9SQVRFKTtcbiAgICAgICAgICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzID0gKDAsIHV0aWxfMS5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMpKGdhc1ZhbHVlcykgJiYgZ2FzVmFsdWVzLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAobWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKShtYXhQcmlvcml0eUZlZVBlckdhc1ZhbHVlcywgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMpKSB8fFxuICAgICAgICAgICAgICAgIChleGlzdGluZ01heFByaW9yaXR5RmVlUGVyR2FzICYmIG1pbk1heFByaW9yaXR5RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIGNvbnN0IHR4UGFyYW1zID0gbmV3TWF4RmVlUGVyR2FzICYmIG5ld01heFByaW9yaXR5RmVlUGVyR2FzXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgICAgICAgICAgICAgICBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcyxcbiAgICAgICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzOiBuZXdNYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBuZXdNYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJzB4MCcsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgZ2FzTGltaXQ6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5nYXMsXG4gICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBuZXdHYXNQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5mcm9tLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogJzB4MCcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHVuc2lnbmVkRXRoVHggPSB0aGlzLnByZXBhcmVVbnNpZ25lZEV0aFR4KHR4UGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFR4ID0geWllbGQgdGhpcy5zaWduKHVuc2lnbmVkRXRoVHgsIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1RyYW5zYWN0aW9uID0gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmJ1ZmZlclRvSGV4KShzaWduZWRUeC5zZXJpYWxpemUoKSk7XG4gICAgICAgICAgICB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnc2VuZFJhd1RyYW5zYWN0aW9uJywgW3Jhd1RyYW5zYWN0aW9uXSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbk1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuY2FuY2VsbGVkO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OmZpbmlzaGVkYCwgdHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGVtcHRzIHRvIHNwZWVkIHVwIGEgdHJhbnNhY3Rpb24gaW5jcmVhc2luZyB0cmFuc2FjdGlvbiBnYXNQcmljZSBieSB0ZW4gcGVyY2VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbklEIC0gVGhlIElEIG9mIHRoZSB0cmFuc2FjdGlvbiB0byBzcGVlZCB1cC5cbiAgICAgKiBAcGFyYW0gZ2FzVmFsdWVzIC0gVGhlIGdhcyB2YWx1ZXMgdG8gdXNlIGZvciB0aGUgc3BlZWQgdXAgdHJhbnNhdGlvbi5cbiAgICAgKi9cbiAgICBzcGVlZFVwVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRCwgZ2FzVmFsdWVzKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZ2FzVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgKDAsIHV0aWxfMS52YWxpZGF0ZUdhc1ZhbHVlcykoZ2FzVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uTWV0YSA9IHRoaXMuc3RhdGUudHJhbnNhY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IHRyYW5zYWN0aW9uSUQpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdHJhbnNhY3Rpb25NZXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5zaWduKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduIG1ldGhvZCBkZWZpbmVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2FjdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAvLyBnYXNQcmljZSAobGVnYWN5IG5vbiBFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgbWluR2FzUHJpY2UgPSAoMCwgdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKSh0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24uZ2FzUHJpY2UsIGV4cG9ydHMuU1BFRURfVVBfUkFURSk7XG4gICAgICAgICAgICBjb25zdCBnYXNQcmljZUZyb21WYWx1ZXMgPSAoMCwgdXRpbF8xLmlzR2FzUHJpY2VWYWx1ZSkoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMuZ2FzUHJpY2U7XG4gICAgICAgICAgICBjb25zdCBuZXdHYXNQcmljZSA9IChnYXNQcmljZUZyb21WYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAoMCwgdXRpbF8xLnZhbGlkYXRlTWluaW11bUluY3JlYXNlKShnYXNQcmljZUZyb21WYWx1ZXMsIG1pbkdhc1ByaWNlKSkgfHxcbiAgICAgICAgICAgICAgICBtaW5HYXNQcmljZTtcbiAgICAgICAgICAgIC8vIG1heEZlZVBlckdhcyAoRUlQMTU1OSlcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nTWF4RmVlUGVyR2FzID0gKF9hID0gdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4RmVlUGVyR2FzID0gKDAsIHV0aWxfMS5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZykoZXhpc3RpbmdNYXhGZWVQZXJHYXMsIGV4cG9ydHMuU1BFRURfVVBfUkFURSk7XG4gICAgICAgICAgICBjb25zdCBtYXhGZWVQZXJHYXNWYWx1ZXMgPSAoMCwgdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcykoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbmV3TWF4RmVlUGVyR2FzID0gKG1heEZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UpKG1heEZlZVBlckdhc1ZhbHVlcywgbWluTWF4RmVlUGVyR2FzKSkgfHxcbiAgICAgICAgICAgICAgICAoZXhpc3RpbmdNYXhGZWVQZXJHYXMgJiYgbWluTWF4RmVlUGVyR2FzKTtcbiAgICAgICAgICAgIC8vIG1heFByaW9yaXR5RmVlUGVyR2FzIChFSVAxNTU5KVxuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdNYXhQcmlvcml0eUZlZVBlckdhcyA9IChfYiA9IHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heFByaW9yaXR5RmVlUGVyR2FzO1xuICAgICAgICAgICAgY29uc3QgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMgPSAoMCwgdXRpbF8xLmdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nKShleGlzdGluZ01heFByaW9yaXR5RmVlUGVyR2FzLCBleHBvcnRzLlNQRUVEX1VQX1JBVEUpO1xuICAgICAgICAgICAgY29uc3QgbWF4UHJpb3JpdHlGZWVQZXJHYXNWYWx1ZXMgPSAoMCwgdXRpbF8xLmlzRmVlTWFya2V0RUlQMTU1OVZhbHVlcykoZ2FzVmFsdWVzKSAmJiBnYXNWYWx1ZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgICAgICBjb25zdCBuZXdNYXhQcmlvcml0eUZlZVBlckdhcyA9IChtYXhQcmlvcml0eUZlZVBlckdhc1ZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICgwLCB1dGlsXzEudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UpKG1heFByaW9yaXR5RmVlUGVyR2FzVmFsdWVzLCBtaW5NYXhQcmlvcml0eUZlZVBlckdhcykpIHx8XG4gICAgICAgICAgICAgICAgKGV4aXN0aW5nTWF4UHJpb3JpdHlGZWVQZXJHYXMgJiYgbWluTWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgY29uc3QgdHhQYXJhbXMgPSBuZXdNYXhGZWVQZXJHYXMgJiYgbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXNcbiAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgbWF4RmVlUGVyR2FzOiBuZXdNYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzOiBuZXdNYXhQcmlvcml0eUZlZVBlckdhcywgdHlwZTogMiB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uKSwgeyBnYXNMaW1pdDogdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmdhcywgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlIH0pO1xuICAgICAgICAgICAgY29uc3QgdW5zaWduZWRFdGhUeCA9IHRoaXMucHJlcGFyZVVuc2lnbmVkRXRoVHgodHhQYXJhbXMpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHggPSB5aWVsZCB0aGlzLnNpZ24odW5zaWduZWRFdGhUeCwgdHJhbnNhY3Rpb25NZXRhLnRyYW5zYWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgcmF3VHJhbnNhY3Rpb24gPSAoMCwgZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgpKHNpZ25lZFR4LnNlcmlhbGl6ZSgpKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSGFzaCA9IHlpZWxkICgwLCB1dGlsXzEucXVlcnkpKHRoaXMuZXRoUXVlcnksICdzZW5kUmF3VHJhbnNhY3Rpb24nLCBbXG4gICAgICAgICAgICAgICAgcmF3VHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGNvbnN0IGJhc2VUcmFuc2FjdGlvbk1ldGEgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YSksIHsgaWQ6ICgwLCB1dWlkXzEudjEpKCksIHRpbWU6IERhdGUubm93KCksIHRyYW5zYWN0aW9uSGFzaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RyYW5zYWN0aW9uTWV0YSA9IG5ld01heEZlZVBlckdhcyAmJiBuZXdNYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBiYXNlVHJhbnNhY3Rpb25NZXRhKSwgeyB0cmFuc2FjdGlvbjogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pLCB7IG1heEZlZVBlckdhczogbmV3TWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhczogbmV3TWF4UHJpb3JpdHlGZWVQZXJHYXMgfSkgfSkgOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGJhc2VUcmFuc2FjdGlvbk1ldGEpLCB7IHRyYW5zYWN0aW9uOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbiksIHsgZ2FzUHJpY2U6IG5ld0dhc1ByaWNlIH0pIH0pO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25zLnB1c2gobmV3VHJhbnNhY3Rpb25NZXRhKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKHsgdHJhbnNhY3Rpb25zOiB0aGlzLnRyaW1UcmFuc2FjdGlvbnNGb3JTdGF0ZSh0cmFuc2FjdGlvbnMpIH0pO1xuICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHt0cmFuc2FjdGlvbk1ldGEuaWR9OnNwZWVkdXBgLCBuZXdUcmFuc2FjdGlvbk1ldGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXN0aW1hdGVzIHJlcXVpcmVkIGdhcyBmb3IgYSBnaXZlbiB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRoZSB0cmFuc2FjdGlvbiB0byBlc3RpbWF0ZSBnYXMgZm9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBnYXMgYW5kIGdhcyBwcmljZS5cbiAgICAgKi9cbiAgICBlc3RpbWF0ZUdhcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVkVHJhbnNhY3Rpb24gPSBPYmplY3QuYXNzaWduKHt9LCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGdhcywgZ2FzUHJpY2U6IHByb3ZpZGVkR2FzUHJpY2UsIHRvLCB2YWx1ZSwgZGF0YSwgfSA9IGVzdGltYXRlZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB0eXBlb2YgcHJvdmlkZWRHYXNQcmljZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHlpZWxkICgwLCB1dGlsXzEucXVlcnkpKHRoaXMuZXRoUXVlcnksICdnYXNQcmljZScpXG4gICAgICAgICAgICAgICAgOiBwcm92aWRlZEdhc1ByaWNlO1xuICAgICAgICAgICAgY29uc3QgeyBpc0N1c3RvbU5ldHdvcmsgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgICAgICAvLyAxLiBJZiBnYXMgaXMgYWxyZWFkeSBkZWZpbmVkIG9uIHRoZSB0cmFuc2FjdGlvbiwgdXNlIGl0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBnYXMsIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGdhc0xpbWl0IH0gPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0QmxvY2tCeU51bWJlcicsIFtcbiAgICAgICAgICAgICAgICAnbGF0ZXN0JyxcbiAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gMi4gSWYgdG8gaXMgbm90IGRlZmluZWQgb3IgdGhpcyBpcyBub3QgYSBjb250cmFjdCBhZGRyZXNzLCBhbmQgdGhlcmUgaXMgbm8gZGF0YSB1c2UgMHg1MjA4IC8gMjEwMDAuXG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV3dHdvcmsgaXMgYSBjdXN0b20gbmV0d29yayB0aGVuIGJ5cGFzcyB0aGlzIGNoZWNrIGFuZCBmZXRjaCAnZXN0aW1hdGVHYXMnLlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB0byA/IHlpZWxkICgwLCB1dGlsXzEucXVlcnkpKHRoaXMuZXRoUXVlcnksICdnZXRDb2RlJywgW3RvXSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKCFpc0N1c3RvbU5ldHdvcmsgJiZcbiAgICAgICAgICAgICAgICAoIXRvIHx8ICh0byAmJiAhZGF0YSAmJiAoIWNvZGUgfHwgY29kZSA9PT0gJzB4JykpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogJzB4NTIwOCcsIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBkYXRhLCBzaG91bGQgYmUgaGV4IHN0cmluZyBmb3JtYXRcbiAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLmRhdGEgPSAhZGF0YVxuICAgICAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgICAgIDogLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkoZGF0YSk7XG4gICAgICAgICAgICAvLyAzLiBJZiB0aGlzIGlzIGEgY29udHJhY3QgYWRkcmVzcywgc2FmZWx5IGVzdGltYXRlIGdhcyB1c2luZyBSUENcbiAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLnZhbHVlID1cbiAgICAgICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJzB4MCcgOiAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGdhc0xpbWl0Qk4gPSAoMCwgdXRpbF8xLmhleFRvQk4pKGdhc0xpbWl0KTtcbiAgICAgICAgICAgIGVzdGltYXRlZFRyYW5zYWN0aW9uLmdhcyA9ICgwLCB1dGlsXzEuQk5Ub0hleCkoKDAsIHV0aWxfMS5mcmFjdGlvbkJOKShnYXNMaW1pdEJOLCAxOSwgMjApKTtcbiAgICAgICAgICAgIGNvbnN0IGdhc0hleCA9IHlpZWxkICgwLCB1dGlsXzEucXVlcnkpKHRoaXMuZXRoUXVlcnksICdlc3RpbWF0ZUdhcycsIFtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZWRUcmFuc2FjdGlvbixcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgLy8gNC4gUGFkIGVzdGltYXRlZCBnYXMgd2l0aG91dCBleGNlZWRpbmcgdGhlIG1vc3QgcmVjZW50IGJsb2NrIGdhc0xpbWl0LiBJZiB0aGUgbmV0d29yayBpcyBhXG4gICAgICAgICAgICAvLyBhIGN1c3RvbSBuZXR3b3JrIHRoZW4gcmV0dXJuIHRoZSBldGhfZXN0aW1hdGVHYXMgdmFsdWUuXG4gICAgICAgICAgICBjb25zdCBnYXNCTiA9ICgwLCB1dGlsXzEuaGV4VG9CTikoZ2FzSGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG1heEdhc0JOID0gZ2FzTGltaXRCTi5tdWxuKDAuOSk7XG4gICAgICAgICAgICBjb25zdCBwYWRkZWRHYXNCTiA9IGdhc0JOLm11bG4oMS41KTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoZ2FzQk4uZ3QobWF4R2FzQk4pIHx8IGlzQ3VzdG9tTmV0d29yaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGdhczogKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkoZ2FzSGV4KSwgZ2FzUHJpY2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAocGFkZGVkR2FzQk4ubHQobWF4R2FzQk4pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZ2FzOiAoMCwgZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KSgoMCwgdXRpbF8xLkJOVG9IZXgpKHBhZGRlZEdhc0JOKSksIGdhc1ByaWNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBnYXM6ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgpKCgwLCB1dGlsXzEuQk5Ub0hleCkobWF4R2FzQk4pKSwgZ2FzUHJpY2UgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoZSBzdGF0dXMgb2Ygc3VibWl0dGVkIHRyYW5zYWN0aW9ucyBvbiB0aGUgbmV0d29yayB0byBkZXRlcm1pbmUgd2hldGhlciB0aGV5IGhhdmVcbiAgICAgKiBiZWVuIGluY2x1ZGVkIGluIGEgYmxvY2suIEFueSB0aGF0IGhhdmUgYmVlbiBpbmNsdWRlZCBpbiBhIGJsb2NrIGFyZSBtYXJrZWQgYXMgY29uZmlybWVkLlxuICAgICAqL1xuICAgIHF1ZXJ5VHJhbnNhY3Rpb25TdGF0dXNlcygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgbmV0d29yazogY3VycmVudE5ldHdvcmtJRCB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICAgICAgbGV0IGdvdFVwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIHlpZWxkICgwLCB1dGlsXzEuc2FmZWx5RXhlY3V0ZSkoKCkgPT4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zLm1hcCgobWV0YSwgaW5kZXgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2luZyBmYWxsYmFjayB0byBuZXR3b3JrSUQgb25seSB3aGVuIHRoZXJlIGlzIG5vIGNoYWluSWQgcHJlc2VudC5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG5ldHdvcmtJRCBpcyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgICAgICAgICAgY29uc3QgdHhCZWxvbmdzVG9DdXJyZW50Q2hhaW4gPSBtZXRhLmNoYWluSWQgPT09IGN1cnJlbnRDaGFpbklkIHx8XG4gICAgICAgICAgICAgICAgICAgICghbWV0YS5jaGFpbklkICYmIG1ldGEubmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1ldGEudmVyaWZpZWRPbkJsb2NrY2hhaW4gJiYgdHhCZWxvbmdzVG9DdXJyZW50Q2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3JlY29uY2lsZWRUeCwgdXBkYXRlUmVxdWlyZWRdID0geWllbGQgdGhpcy5ibG9ja2NoYWluVHJhbnNhY3Rpb25TdGF0ZVJlY29uY2lsZXIobWV0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1cGRhdGVSZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zW2luZGV4XSA9IHJlY29uY2lsZWRUeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdvdFVwZGF0ZXMgPSB1cGRhdGVSZXF1aXJlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKSkpO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChnb3RVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucyksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGFuIGV4aXN0aW5nIHRyYW5zYWN0aW9uIGluIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uTWV0YSAtIFRoZSBuZXcgdHJhbnNhY3Rpb24gdG8gc3RvcmUgaW4gc3RhdGUuXG4gICAgICovXG4gICAgdXBkYXRlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25NZXRhKSB7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICB0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24gPSAoMCwgdXRpbF8xLm5vcm1hbGl6ZVRyYW5zYWN0aW9uKSh0cmFuc2FjdGlvbk1ldGEudHJhbnNhY3Rpb24pO1xuICAgICAgICAoMCwgdXRpbF8xLnZhbGlkYXRlVHJhbnNhY3Rpb24pKHRyYW5zYWN0aW9uTWV0YS50cmFuc2FjdGlvbik7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdHJhbnNhY3Rpb25zLmZpbmRJbmRleCgoeyBpZCB9KSA9PiB0cmFuc2FjdGlvbk1ldGEuaWQgPT09IGlkKTtcbiAgICAgICAgdHJhbnNhY3Rpb25zW2luZGV4XSA9IHRyYW5zYWN0aW9uTWV0YTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKHRyYW5zYWN0aW9ucykgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIHRyYW5zYWN0aW9ucyBmcm9tIHN0YXRlLCBvcHRpb25hbGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50IG5ldHdvcmsuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWdub3JlTmV0d29yayAtIERldGVybWluZXMgd2hldGhlciB0byB3aXBlIGFsbCB0cmFuc2FjdGlvbnMsIG9yIGp1c3QgdGhvc2Ugb24gdGhlXG4gICAgICogY3VycmVudCBuZXR3b3JrLiBJZiBgdHJ1ZWAsIGFsbCB0cmFuc2FjdGlvbnMgYXJlIHdpcGVkLlxuICAgICAqL1xuICAgIHdpcGVUcmFuc2FjdGlvbnMoaWdub3JlTmV0d29yaykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICBpZiAoaWdub3JlTmV0d29yaykge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IFtdIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcHJvdmlkZXIsIG5ldHdvcms6IGN1cnJlbnROZXR3b3JrSUQgfSA9IHRoaXMuZ2V0TmV0d29ya1N0YXRlKCk7XG4gICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQgfSA9IHByb3ZpZGVyO1xuICAgICAgICBjb25zdCBuZXdUcmFuc2FjdGlvbnMgPSB0aGlzLnN0YXRlLnRyYW5zYWN0aW9ucy5maWx0ZXIoKHsgbmV0d29ya0lELCBjaGFpbklkIH0pID0+IHtcbiAgICAgICAgICAgIC8vIFVzaW5nIGZhbGxiYWNrIHRvIG5ldHdvcmtJRCBvbmx5IHdoZW4gdGhlcmUgaXMgbm8gY2hhaW5JZCBwcmVzZW50LiBTaG91bGQgYmUgcmVtb3ZlZCB3aGVuIG5ldHdvcmtJRCBpcyBjb21wbGV0ZWx5IHJlbW92ZWQuXG4gICAgICAgICAgICBjb25zdCBpc0N1cnJlbnROZXR3b3JrID0gY2hhaW5JZCA9PT0gY3VycmVudENoYWluSWQgfHxcbiAgICAgICAgICAgICAgICAoIWNoYWluSWQgJiYgbmV0d29ya0lEID09PSBjdXJyZW50TmV0d29ya0lEKTtcbiAgICAgICAgICAgIHJldHVybiAhaXNDdXJyZW50TmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uczogdGhpcy50cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUobmV3VHJhbnNhY3Rpb25zKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0cmFuc2FjdGlvbnMgZnJvbSBFdGhlcnNjYW4gZm9yIHRoZSBnaXZlbiBhZGRyZXNzLiBCeSBkZWZhdWx0IGFsbCB0cmFuc2FjdGlvbnMgYXJlXG4gICAgICogcmV0dXJuZWQsIGJ1dCB0aGUgYGZyb21CbG9ja2Agb3B0aW9uIGNhbiBiZSBnaXZlbiB0byBmaWx0ZXIganVzdCBmb3IgdHJhbnNhY3Rpb25zIGZyb20gYVxuICAgICAqIHNwZWNpZmljIGJsb2NrIG9ud2FyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gZmV0Y2ggdGhlIHRyYW5zYWN0aW9ucyBmb3IuXG4gICAgICogQHBhcmFtIG9wdCAtIE9iamVjdCBjb250YWluaW5nIG9wdGlvbmFsIGRhdGEsIGZyb21CbG9jayBhbmQgRXRoZXJzY2FuIEFQSSBrZXkuXG4gICAgICogQHJldHVybnMgVGhlIGJsb2NrIG51bWJlciBvZiB0aGUgbGF0ZXN0IGluY29taW5nIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGZldGNoQWxsKGFkZHJlc3MsIG9wdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwcm92aWRlciwgbmV0d29yazogY3VycmVudE5ldHdvcmtJRCB9ID0gdGhpcy5nZXROZXR3b3JrU3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2hhaW5JZDogY3VycmVudENoYWluSWQsIHR5cGU6IG5ldHdvcmtUeXBlIH0gPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkTmV0d29ya0lkcyA9IFsnMScsICczJywgJzQnLCAnNDInXTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkTmV0d29ya0lkcy5pbmRleE9mKGN1cnJlbnROZXR3b3JrSUQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZXRoZXJzY2FuVHhSZXNwb25zZSwgZXRoZXJzY2FuVG9rZW5SZXNwb25zZV0gPSB5aWVsZCAoMCwgdXRpbF8xLmhhbmRsZVRyYW5zYWN0aW9uRmV0Y2gpKG5ldHdvcmtUeXBlLCBhZGRyZXNzLCB0aGlzLmNvbmZpZy50eEhpc3RvcnlMaW1pdCwgb3B0KTtcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRUeHMgPSBldGhlcnNjYW5UeFJlc3BvbnNlLnJlc3VsdC5tYXAoKHR4KSA9PiB0aGlzLm5vcm1hbGl6ZVR4KHR4LCBjdXJyZW50TmV0d29ya0lELCBjdXJyZW50Q2hhaW5JZCkpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZFRva2VuVHhzID0gZXRoZXJzY2FuVG9rZW5SZXNwb25zZS5yZXN1bHQubWFwKCh0eCkgPT4gdGhpcy5ub3JtYWxpemVUb2tlblR4KHR4LCBjdXJyZW50TmV0d29ya0lELCBjdXJyZW50Q2hhaW5JZCkpO1xuICAgICAgICAgICAgY29uc3QgW3VwZGF0ZVJlcXVpcmVkLCBhbGxUeHNdID0gdGhpcy5ldGhlcnNjYW5UcmFuc2FjdGlvblN0YXRlUmVjb25jaWxlcihbLi4ubm9ybWFsaXplZFR4cywgLi4ubm9ybWFsaXplZFRva2VuVHhzXSwgdHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIGFsbFR4cy5zb3J0KChhLCBiKSA9PiAoYS50aW1lIDwgYi50aW1lID8gLTEgOiAxKSk7XG4gICAgICAgICAgICBsZXQgbGF0ZXN0SW5jb21pbmdUeEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgYWxsVHhzLmZvckVhY2goKHR4KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gVXNpbmcgZmFsbGJhY2sgdG8gbmV0d29ya0lEIG9ubHkgd2hlbiB0aGVyZSBpcyBubyBjaGFpbklkIHByZXNlbnQuIFNob3VsZCBiZSByZW1vdmVkIHdoZW4gbmV0d29ya0lEIGlzIGNvbXBsZXRlbHkgcmVtb3ZlZC5cbiAgICAgICAgICAgICAgICAodHguY2hhaW5JZCA9PT0gY3VycmVudENoYWluSWQgfHxcbiAgICAgICAgICAgICAgICAgICAgKCF0eC5jaGFpbklkICYmIHR4Lm5ldHdvcmtJRCA9PT0gY3VycmVudE5ldHdvcmtJRCkpICYmXG4gICAgICAgICAgICAgICAgICAgIHR4LnRyYW5zYWN0aW9uLnRvICYmXG4gICAgICAgICAgICAgICAgICAgIHR4LnRyYW5zYWN0aW9uLnRvLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHguYmxvY2tOdW1iZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICghbGF0ZXN0SW5jb21pbmdUeEJsb2NrTnVtYmVyIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VJbnQobGF0ZXN0SW5jb21pbmdUeEJsb2NrTnVtYmVyLCAxMCkgPFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludCh0eC5ibG9ja051bWJlciwgMTApKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF0ZXN0SW5jb21pbmdUeEJsb2NrTnVtYmVyID0gdHguYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAodHgudG9TbWFydENvbnRyYWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm90IGB0b2AgaXMgYSBjb250cmFjdCBkZXBsb3ksIGlmIG5vdCBgZGF0YWAgaXMgc2VuZCBldGhcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4LnRyYW5zYWN0aW9uLnRvICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIXR4LnRyYW5zYWN0aW9uLmRhdGEgfHwgdHgudHJhbnNhY3Rpb24uZGF0YSAhPT0gJzB4JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0Q29kZScsIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC50cmFuc2FjdGlvbi50byxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgudG9TbWFydENvbnRyYWN0ID0gKDAsIHV0aWxfMS5pc1NtYXJ0Q29udHJhY3RDb2RlKShjb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LnRvU21hcnRDb250cmFjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlIG9ubHkgaWYgbmV3IHRyYW5zYWN0aW9ucyB3ZXJlIGZldGNoZWQgb3JcbiAgICAgICAgICAgIC8vIHRoZSBzdGF0dXMgb3IgZ2FzIGRhdGEgb2YgYSB0cmFuc2FjdGlvbiBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKHVwZGF0ZVJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoeyB0cmFuc2FjdGlvbnM6IHRoaXMudHJpbVRyYW5zYWN0aW9uc0ZvclN0YXRlKGFsbFR4cykgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0SW5jb21pbmdUeEJsb2NrTnVtYmVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJpbSB0aGUgYW1vdW50IG9mIHRyYW5zYWN0aW9ucyB0aGF0IGFyZSBzZXQgb24gdGhlIHN0YXRlLiBDaGVja3NcbiAgICAgKiBpZiB0aGUgbGVuZ3RoIG9mIHRoZSB0eCBoaXN0b3J5IGlzIGxvbmdlciB0aGVuIGRlc2lyZWQgcGVyc2lzdGVuY2VcbiAgICAgKiBsaW1pdCBhbmQgdGhlbiBpZiBpdCBpcyByZW1vdmVzIHRoZSBvbGRlc3QgY29uZmlybWVkIG9yIHJlamVjdGVkIHR4LlxuICAgICAqIFBlbmRpbmcgb3IgdW5hcHByb3ZlZCB0cmFuc2FjdGlvbnMgd2lsbCBub3QgYmUgcmVtb3ZlZCBieSB0aGlzXG4gICAgICogb3BlcmF0aW9uLiBGb3Igc2FmZXR5IG9mIHByZXNlbnRpbmcgYSBmdWxseSBmdW5jdGlvbmFsIHRyYW5zYWN0aW9uIFVJXG4gICAgICogcmVwcmVzZW50YXRpb24sIHRoaXMgZnVuY3Rpb24gd2lsbCBub3QgYnJlYWsgYXBhcnQgdHJhbnNhY3Rpb25zIHdpdGggdGhlXG4gICAgICogc2FtZSBub25jZSwgY3JlYXRlZCBvbiB0aGUgc2FtZSBkYXksIHBlciBuZXR3b3JrLiBOb3QgYWNjb3VudGluZyBmb3IgdHJhbnNhY3Rpb25zIG9mIHRoZSBzYW1lXG4gICAgICogbm9uY2UsIHNhbWUgZGF5IGFuZCBuZXR3b3JrIGNvbWJvIGNhbiByZXN1bHQgaW4gY29uZnVzaW5nIG9yIGJyb2tlbiBleHBlcmllbmNlc1xuICAgICAqIGluIHRoZSBVSS4gVGhlIHRyYW5zYWN0aW9ucyBhcmUgdGhlbiB1cGRhdGVkIHVzaW5nIHRoZSBCYXNlQ29udHJvbGxlciB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIC0gVGhlIHRyYW5zYWN0aW9ucyB0byBiZSBhcHBsaWVkIHRvIHRoZSBzdGF0ZS5cbiAgICAgKiBAcmV0dXJucyBUaGUgdHJpbW1lZCBsaXN0IG9mIHRyYW5zYWN0aW9ucy5cbiAgICAgKi9cbiAgICB0cmltVHJhbnNhY3Rpb25zRm9yU3RhdGUodHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIGNvbnN0IG5vbmNlTmV0d29ya1NldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgdHhzVG9LZWVwID0gdHJhbnNhY3Rpb25zLnJldmVyc2UoKS5maWx0ZXIoKHR4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGNoYWluSWQsIG5ldHdvcmtJRCwgc3RhdHVzLCB0cmFuc2FjdGlvbiwgdGltZSB9ID0gdHg7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgJHt0cmFuc2FjdGlvbi5ub25jZX0tJHtjaGFpbklkICE9PSBudWxsICYmIGNoYWluSWQgIT09IHZvaWQgMCA/IGNoYWluSWQgOiBuZXR3b3JrSUR9LSR7bmV3IERhdGUodGltZSkudG9EYXRlU3RyaW5nKCl9YDtcbiAgICAgICAgICAgICAgICBpZiAobm9uY2VOZXR3b3JrU2V0LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChub25jZU5ldHdvcmtTZXQuc2l6ZSA8IHRoaXMuY29uZmlnLnR4SGlzdG9yeUxpbWl0IHx8XG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmlzRmluYWxTdGF0ZShzdGF0dXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbmNlTmV0d29ya1NldC5hZGQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdHhzVG9LZWVwLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIHR4c1RvS2VlcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgaW4gYSBmaW5hbCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0dXMgLSBUaGUgdHJhbnNhY3Rpb24gc3RhdHVzLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGlzIGluIGEgZmluYWwgc3RhdGUuXG4gICAgICovXG4gICAgaXNGaW5hbFN0YXRlKHN0YXR1cykge1xuICAgICAgICByZXR1cm4gKHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMucmVqZWN0ZWQgfHxcbiAgICAgICAgICAgIHN0YXR1cyA9PT0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkIHx8XG4gICAgICAgICAgICBzdGF0dXMgPT09IFRyYW5zYWN0aW9uU3RhdHVzLmZhaWxlZCB8fFxuICAgICAgICAgICAgc3RhdHVzID09PSBUcmFuc2FjdGlvblN0YXR1cy5jYW5jZWxsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdmVyaWZ5IHRoZSBzdGF0ZSBvZiBhIHRyYW5zYWN0aW9uIHVzaW5nIHRoZSBCbG9ja2NoYWluIGFzIGEgc291cmNlIG9mIHRydXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIG1ldGEgLSBUaGUgbG9jYWwgdHJhbnNhY3Rpb24gdG8gdmVyaWZ5IG9uIHRoZSBibG9ja2NoYWluLlxuICAgICAqIEByZXR1cm5zIEEgdHVwbGUgY29udGFpbmluZyB0aGUgdXBkYXRlZCB0cmFuc2FjdGlvbiwgYW5kIHdoZXRoZXIgb3Igbm90IGFuIHVwZGF0ZSB3YXMgcmVxdWlyZWQuXG4gICAgICovXG4gICAgYmxvY2tjaGFpblRyYW5zYWN0aW9uU3RhdGVSZWNvbmNpbGVyKG1ldGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzLCB0cmFuc2FjdGlvbkhhc2ggfSA9IG1ldGE7XG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIGNhc2UgVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkOlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eFJlY2VpcHQgPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JywgW1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoLFxuICAgICAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0eFJlY2VpcHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG1ldGEudmVyaWZpZWRPbkJsb2NrY2hhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtZXRhLnRyYW5zYWN0aW9uLmdhc1VzZWQgPSB0eFJlY2VpcHQuZ2FzVXNlZDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIHRoZSBXZWIzIGRvY3M6XG4gICAgICAgICAgICAgICAgICAgIC8vIFRSVUUgaWYgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsLCBGQUxTRSBpZiB0aGUgRVZNIHJldmVydGVkIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKE51bWJlcih0eFJlY2VpcHQuc3RhdHVzKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZhaWxlZC4gVGhlIHRyYW5zYWN0aW9uIHdhcyByZXZlcnNlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24obWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uU3RhdHVzLnN1Ym1pdHRlZDpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHhPYmogPSB5aWVsZCAoMCwgdXRpbF8xLnF1ZXJ5KSh0aGlzLmV0aFF1ZXJ5LCAnZ2V0VHJhbnNhY3Rpb25CeUhhc2gnLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2gsXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXR4T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNlaXB0U2hvd3NGYWlsZWRTdGF0dXMgPSB5aWVsZCB0aGlzLmNoZWNrVHhSZWNlaXB0U3RhdHVzSXNGYWlsZWQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhc2UgdGhlIHR4T2JqIGlzIGV2YWx1YXRlZCBhcyBmYWxzZSwgYSBzZWNvbmQgY2hlY2sgd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIGlmIHRoZSB0eCBmYWlsZWQgb3IgaXQgaXMgcGVuZGluZyBvciBjb25maXJtZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0U2hvd3NGYWlsZWRTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmFpbGVkLiBUaGUgdHJhbnNhY3Rpb24gd2FzIGRyb3BwZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXcgb25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsVHJhbnNhY3Rpb24obWV0YSwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eE9iaiA9PT0gbnVsbCB8fCB0eE9iaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHhPYmouYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGEuc3RhdHVzID0gVHJhbnNhY3Rpb25TdGF0dXMuY29uZmlybWVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5odWIuZW1pdChgJHttZXRhLmlkfTpjb25maXJtZWRgLCBtZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbbWV0YSwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFttZXRhLCBmYWxzZV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gY2hlY2sgaWYgYSB0eCBoYXMgZmFpbGVkIGFjY29yZGluZyB0byB0aGVpciByZWNlaXB0XG4gICAgICogQWNjb3JkaW5nIHRvIHRoZSBXZWIzIGRvY3M6XG4gICAgICogVFJVRSBpZiB0aGUgdHJhbnNhY3Rpb24gd2FzIHN1Y2Nlc3NmdWwsIEZBTFNFIGlmIHRoZSBFVk0gcmV2ZXJ0ZWQgdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIFRoZSByZWNlaXB0IGlzIG5vdCBhdmFpbGFibGUgZm9yIHBlbmRpbmcgdHJhbnNhY3Rpb25zIGFuZCByZXR1cm5zIG51bGwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHhIYXNoIC0gVGhlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICogQHJldHVybnMgV2hldGhlciB0aGUgdHJhbnNhY3Rpb24gaGFzIGZhaWxlZC5cbiAgICAgKi9cbiAgICBjaGVja1R4UmVjZWlwdFN0YXR1c0lzRmFpbGVkKHR4SGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdHhSZWNlaXB0ID0geWllbGQgKDAsIHV0aWxfMS5xdWVyeSkodGhpcy5ldGhRdWVyeSwgJ2dldFRyYW5zYWN0aW9uUmVjZWlwdCcsIFtcbiAgICAgICAgICAgICAgICB0eEhhc2gsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICghdHhSZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgLy8gVHJhbnNhY3Rpb24gaXMgcGVuZGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodHhSZWNlaXB0LnN0YXR1cykgPT09IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gdmVyaWZ5IHRoZSBzdGF0ZSBvZiB0cmFuc2FjdGlvbnMgdXNpbmcgRXRoZXJzY2FuIGFzIGEgc291cmNlIG9mIHRydXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZVR4cyAtIFRyYW5zYWN0aW9ucyB0byByZWNvbmNpbGUgdGhhdCBhcmUgZnJvbSBhIHJlbW90ZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIGxvY2FsVHhzIC0gVHJhbnNhY3Rpb25zIHRvIHJlY29uY2lsZSB0aGF0IGFyZSBsb2NhbC5cbiAgICAgKiBAcmV0dXJucyBBIHR1cGxlIGNvbnRhaW5pbmcgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvciBub3QgYW4gdXBkYXRlIHdhcyByZXF1aXJlZCwgYW5kIHRoZSB1cGRhdGVkIHRyYW5zYWN0aW9uLlxuICAgICAqL1xuICAgIGV0aGVyc2NhblRyYW5zYWN0aW9uU3RhdGVSZWNvbmNpbGVyKHJlbW90ZVR4cywgbG9jYWxUeHMpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFR4cyA9IHRoaXMuZ2V0VXBkYXRlZFRyYW5zYWN0aW9ucyhyZW1vdGVUeHMsIGxvY2FsVHhzKTtcbiAgICAgICAgY29uc3QgbmV3VHhzID0gdGhpcy5nZXROZXdUcmFuc2FjdGlvbnMocmVtb3RlVHhzLCBsb2NhbFR4cyk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRMb2NhbFR4cyA9IGxvY2FsVHhzLm1hcCgodHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR4SWR4ID0gdXBkYXRlZFR4cy5maW5kSW5kZXgoKHsgdHJhbnNhY3Rpb25IYXNoIH0pID0+IHRyYW5zYWN0aW9uSGFzaCA9PT0gdHgudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIHJldHVybiB0eElkeCA9PT0gLTEgPyB0eCA6IHVwZGF0ZWRUeHNbdHhJZHhdO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdXBkYXRlUmVxdWlyZWQgPSBuZXdUeHMubGVuZ3RoID4gMCB8fCB1cGRhdGVkTG9jYWxUeHMubGVuZ3RoID4gMDtcbiAgICAgICAgcmV0dXJuIFt1cGRhdGVSZXF1aXJlZCwgWy4uLm5ld1R4cywgLi4udXBkYXRlZExvY2FsVHhzXV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgdHJhbnNhY3Rpb25zIHRoYXQgYXJlIGluIHRoZSByZW1vdGUgdHJhbnNhY3Rpb25zIGFycmF5XG4gICAgICogYnV0IG5vdCBpbiB0aGUgbG9jYWwgdHJhbnNhY3Rpb25zIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZVR4cyAtIEFycmF5IG9mIHRyYW5zYWN0aW9ucyBmcm9tIHJlbW90ZSBzb3VyY2UuXG4gICAgICogQHBhcmFtIGxvY2FsVHhzIC0gQXJyYXkgb2YgdHJhbnNhY3Rpb25zIHN0b3JlZCBsb2NhbGx5LlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldE5ld1RyYW5zYWN0aW9ucyhyZW1vdGVUeHMsIGxvY2FsVHhzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVUeHMuZmlsdGVyKCh0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxyZWFkeUluVHJhbnNhY3Rpb25zID0gbG9jYWxUeHMuZmluZCgoeyB0cmFuc2FjdGlvbkhhc2ggfSkgPT4gdHJhbnNhY3Rpb25IYXNoID09PSB0eC50cmFuc2FjdGlvbkhhc2gpO1xuICAgICAgICAgICAgcmV0dXJuICFhbHJlYWR5SW5UcmFuc2FjdGlvbnM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHRoZSB0cmFuc2FjdGlvbnMgdGhhdCBhcmUgbG9jYWxseSBvdXRkYXRlZCB3aXRoIHJlc3BlY3RcbiAgICAgKiB0byBhIHJlbW90ZSBzb3VyY2UgKGV0aGVyc2NhbiBvciBibG9ja2NoYWluKS4gVGhlIHJldHVybmVkIGFycmF5XG4gICAgICogY29udGFpbnMgdGhlIHRyYW5zYWN0aW9ucyB3aXRoIHRoZSB1cGRhdGVkIGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVtb3RlVHhzIC0gQXJyYXkgb2YgdHJhbnNhY3Rpb25zIGZyb20gcmVtb3RlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0gbG9jYWxUeHMgLSBBcnJheSBvZiB0cmFuc2FjdGlvbnMgc3RvcmVkIGxvY2FsbHkuXG4gICAgICogQHJldHVybnMgVGhlIHVwZGF0ZWQgdHJhbnNhY3Rpb25zLlxuICAgICAqL1xuICAgIGdldFVwZGF0ZWRUcmFuc2FjdGlvbnMocmVtb3RlVHhzLCBsb2NhbFR4cykge1xuICAgICAgICByZXR1cm4gcmVtb3RlVHhzLmZpbHRlcigocmVtb3RlVHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzVHhPdXRkYXRlZCA9IGxvY2FsVHhzLmZpbmQoKGxvY2FsVHgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlbW90ZVR4LnRyYW5zYWN0aW9uSGFzaCA9PT0gbG9jYWxUeC50cmFuc2FjdGlvbkhhc2ggJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1RyYW5zYWN0aW9uT3V0ZGF0ZWQocmVtb3RlVHgsIGxvY2FsVHgpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGlzVHhPdXRkYXRlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIGlmIGEgbG9jYWwgdHJhbnNhY3Rpb24gaXMgb3V0ZGF0ZWQgd2l0aCByZXNwZWN0IHRvIHRoZSByZW1vdGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVtb3RlVHggLSBUaGUgcmVtb3RlIHRyYW5zYWN0aW9uIGZyb20gRXRoZXJzY2FuLlxuICAgICAqIEBwYXJhbSBsb2NhbFR4IC0gVGhlIGxvY2FsIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGlzIG91dGRhdGVkLlxuICAgICAqL1xuICAgIGlzVHJhbnNhY3Rpb25PdXRkYXRlZChyZW1vdGVUeCwgbG9jYWxUeCkge1xuICAgICAgICBjb25zdCBzdGF0dXNPdXRkYXRlZCA9IHRoaXMuaXNTdGF0dXNPdXRkYXRlZChyZW1vdGVUeC50cmFuc2FjdGlvbkhhc2gsIGxvY2FsVHgudHJhbnNhY3Rpb25IYXNoLCByZW1vdGVUeC5zdGF0dXMsIGxvY2FsVHguc3RhdHVzKTtcbiAgICAgICAgY29uc3QgZ2FzRGF0YU91dGRhdGVkID0gdGhpcy5pc0dhc0RhdGFPdXRkYXRlZChyZW1vdGVUeC50cmFuc2FjdGlvbi5nYXNVc2VkLCBsb2NhbFR4LnRyYW5zYWN0aW9uLmdhc1VzZWQpO1xuICAgICAgICByZXR1cm4gc3RhdHVzT3V0ZGF0ZWQgfHwgZ2FzRGF0YU91dGRhdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgc3RhdHVzIG9mIGEgbG9jYWwgdHJhbnNhY3Rpb24gaXMgb3V0ZGF0ZWQgd2l0aCByZXNwZWN0IHRvIHRoZSByZW1vdGUgdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVtb3RlVHhIYXNoIC0gUmVtb3RlIHRyYW5zYWN0aW9uIGhhc2guXG4gICAgICogQHBhcmFtIGxvY2FsVHhIYXNoIC0gTG9jYWwgdHJhbnNhY3Rpb24gaGFzaC5cbiAgICAgKiBAcGFyYW0gcmVtb3RlVHhTdGF0dXMgLSBSZW1vdGUgdHJhbnNhY3Rpb24gc3RhdHVzLlxuICAgICAqIEBwYXJhbSBsb2NhbFR4U3RhdHVzIC0gTG9jYWwgdHJhbnNhY3Rpb24gc3RhdHVzLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHN0YXR1cyBpcyBvdXRkYXRlZC5cbiAgICAgKi9cbiAgICBpc1N0YXR1c091dGRhdGVkKHJlbW90ZVR4SGFzaCwgbG9jYWxUeEhhc2gsIHJlbW90ZVR4U3RhdHVzLCBsb2NhbFR4U3RhdHVzKSB7XG4gICAgICAgIHJldHVybiByZW1vdGVUeEhhc2ggPT09IGxvY2FsVHhIYXNoICYmIHJlbW90ZVR4U3RhdHVzICE9PSBsb2NhbFR4U3RhdHVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBpZiB0aGUgZ2FzIGRhdGEgb2YgYSBsb2NhbCB0cmFuc2FjdGlvbiBpcyBvdXRkYXRlZCB3aXRoIHJlc3BlY3QgdG8gdGhlIHJlbW90ZSB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZW1vdGVHYXNVc2VkIC0gUmVtb3RlIGdhcyB1c2VkIGluIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgKiBAcGFyYW0gbG9jYWxHYXNVc2VkIC0gTG9jYWwgZ2FzIHVzZWQgaW4gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGdhcyBkYXRhIGlzIG91dGRhdGVkLlxuICAgICAqL1xuICAgIGlzR2FzRGF0YU91dGRhdGVkKHJlbW90ZUdhc1VzZWQsIGxvY2FsR2FzVXNlZCkge1xuICAgICAgICByZXR1cm4gcmVtb3RlR2FzVXNlZCAhPT0gbG9jYWxHYXNVc2VkO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNhY3Rpb25Db250cm9sbGVyID0gVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNhY3Rpb25Db250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25Db250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGRyZXNzQm9va0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbmNvbnN0IEJhc2VDb250cm9sbGVyXzEgPSByZXF1aXJlKFwiLi4vQmFzZUNvbnRyb2xsZXJcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBtYW5hZ2VzIGEgbGlzdCBvZiByZWNpcGllbnQgYWRkcmVzc2VzIGFzc29jaWF0ZWQgd2l0aCBuaWNrbmFtZXNcbiAqL1xuY2xhc3MgQWRkcmVzc0Jvb2tDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBBZGRyZXNzQm9va0NvbnRyb2xsZXIgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gSW5pdGlhbCBvcHRpb25zIHVzZWQgdG8gY29uZmlndXJlIHRoaXMgY29udHJvbGxlci5cbiAgICAgKiBAcGFyYW0gc3RhdGUgLSBJbml0aWFsIHN0YXRlIHRvIHNldCBvbiB0aGlzIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcihjb25maWcsIHN0YXRlKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5hbWUgb2YgdGhpcyBjb250cm9sbGVyIHVzZWQgZHVyaW5nIGNvbXBvc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hbWUgPSAnQWRkcmVzc0Jvb2tDb250cm9sbGVyJztcbiAgICAgICAgdGhpcy5kZWZhdWx0U3RhdGUgPSB7IGFkZHJlc3NCb29rOiB7fSB9O1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFsbCBjb250cmFjdCBlbnRyaWVzLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFkZHJlc3NCb29rOiB7fSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgY29udHJhY3QgZW50cnkgYnkgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW4gaWQgaWRlbnRpZmllcyB0aGUgY3VycmVudCBjaGFpbi5cbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIFJlY2lwaWVudCBhZGRyZXNzIHRvIGRlbGV0ZS5cbiAgICAgKiBAcmV0dXJucyBXaGV0aGVyIHRoZSBlbnRyeSB3YXMgZGVsZXRlZC5cbiAgICAgKi9cbiAgICBkZWxldGUoY2hhaW5JZCwgYWRkcmVzcykge1xuICAgICAgICBhZGRyZXNzID0gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcyk7XG4gICAgICAgIGlmICghKDAsIHV0aWxfMS5pc1ZhbGlkSGV4QWRkcmVzcykoYWRkcmVzcykgfHxcbiAgICAgICAgICAgICF0aGlzLnN0YXRlLmFkZHJlc3NCb29rW2NoYWluSWRdIHx8XG4gICAgICAgICAgICAhdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXVthZGRyZXNzXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFkZHJlc3NCb29rID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5hZGRyZXNzQm9vayk7XG4gICAgICAgIGRlbGV0ZSBhZGRyZXNzQm9va1tjaGFpbklkXVthZGRyZXNzXTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGFkZHJlc3NCb29rW2NoYWluSWRdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSBhZGRyZXNzQm9va1tjaGFpbklkXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7IGFkZHJlc3NCb29rIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIG9yIHVwZGF0ZSBhIGNvbnRhY3QgZW50cnkgYnkgYWRkcmVzcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIC0gUmVjaXBpZW50IGFkZHJlc3MgdG8gYWRkIG9yIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAtIE5pY2tuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIHRoaXMgYWRkcmVzcy5cbiAgICAgKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluIGlkIGlkZW50aWZpZXMgdGhlIGN1cnJlbnQgY2hhaW4uXG4gICAgICogQHBhcmFtIG1lbW8gLSBVc2VyJ3Mgbm90ZSBhYm91dCBhZGRyZXNzLlxuICAgICAqIEByZXR1cm5zIEJvb2xlYW4gaW5kaWNhdGluZyBpZiB0aGUgYWRkcmVzcyB3YXMgc3VjY2Vzc2Z1bGx5IHNldC5cbiAgICAgKi9cbiAgICBzZXQoYWRkcmVzcywgbmFtZSwgY2hhaW5JZCA9ICcxJywgbWVtbyA9ICcnKSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgaWYgKCEoMCwgdXRpbF8xLmlzVmFsaWRIZXhBZGRyZXNzKShhZGRyZXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJ5ID0ge1xuICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICBpc0VuczogZmFsc2UsXG4gICAgICAgICAgICBtZW1vLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW5zTmFtZSA9ICgwLCB1dGlsXzEubm9ybWFsaXplRW5zTmFtZSkobmFtZSk7XG4gICAgICAgIGlmIChlbnNOYW1lKSB7XG4gICAgICAgICAgICBlbnRyeS5uYW1lID0gZW5zTmFtZTtcbiAgICAgICAgICAgIGVudHJ5LmlzRW5zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZSh7XG4gICAgICAgICAgICBhZGRyZXNzQm9vazogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnN0YXRlLmFkZHJlc3NCb29rKSwgeyBbY2hhaW5JZF06IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zdGF0ZS5hZGRyZXNzQm9va1tjaGFpbklkXSksIHsgW2FkZHJlc3NdOiBlbnRyeSB9KSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRkcmVzc0Jvb2tDb250cm9sbGVyID0gQWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gQWRkcmVzc0Jvb2tDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWRkcmVzc0Jvb2tDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QcmVmZXJlbmNlc0NvbnRyb2xsZXIgPSB2b2lkIDA7XG5jb25zdCBCYXNlQ29udHJvbGxlcl8xID0gcmVxdWlyZShcIi4uL0Jhc2VDb250cm9sbGVyXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG4vKipcbiAqIENvbnRyb2xsZXIgdGhhdCBzdG9yZXMgc2hhcmVkIHNldHRpbmdzIGFuZCBleHBvc2VzIGNvbnZlbmllbmNlIG1ldGhvZHNcbiAqL1xuY2xhc3MgUHJlZmVyZW5jZXNDb250cm9sbGVyIGV4dGVuZHMgQmFzZUNvbnRyb2xsZXJfMS5CYXNlQ29udHJvbGxlciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByZWZlcmVuY2VzQ29udHJvbGxlciBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maWcgLSBJbml0aWFsIG9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhpcyBjb250cm9sbGVyLlxuICAgICAqIEBwYXJhbSBzdGF0ZSAtIEluaXRpYWwgc3RhdGUgdG8gc2V0IG9uIHRoaXMgY29udHJvbGxlci5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25maWcsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZywgc3RhdGUpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTmFtZSBvZiB0aGlzIGNvbnRyb2xsZXIgdXNlZCBkdXJpbmcgY29tcG9zaXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubmFtZSA9ICdQcmVmZXJlbmNlc0NvbnRyb2xsZXInO1xuICAgICAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIGZlYXR1cmVGbGFnczoge30sXG4gICAgICAgICAgICBmcmVxdWVudFJwY0xpc3Q6IFtdLFxuICAgICAgICAgICAgaWRlbnRpdGllczoge30sXG4gICAgICAgICAgICBpcGZzR2F0ZXdheTogJ2h0dHBzOi8vaXBmcy5pby9pcGZzLycsXG4gICAgICAgICAgICBsb3N0SWRlbnRpdGllczoge30sXG4gICAgICAgICAgICBzZWxlY3RlZEFkZHJlc3M6ICcnLFxuICAgICAgICAgICAgdXNlVG9rZW5EZXRlY3Rpb246IHRydWUsXG4gICAgICAgICAgICB1c2VDb2xsZWN0aWJsZURldGVjdGlvbjogZmFsc2UsXG4gICAgICAgICAgICBvcGVuU2VhRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGlkZW50aXRpZXMgdG8gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzc2VzIC0gTGlzdCBvZiBhZGRyZXNzZXMgdG8gdXNlIHRvIGdlbmVyYXRlIG5ldyBpZGVudGl0aWVzLlxuICAgICAqL1xuICAgIGFkZElkZW50aXRpZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpdGllcyB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgYWRkcmVzc2VzLmZvckVhY2goKGFkZHJlc3MpID0+IHtcbiAgICAgICAgICAgIGFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChpZGVudGl0aWVzW2FkZHJlc3NdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWRlbnRpdHlDb3VudCA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmxlbmd0aDtcbiAgICAgICAgICAgIGlkZW50aXRpZXNbYWRkcmVzc10gPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogYEFjY291bnQgJHtpZGVudGl0eUNvdW50ICsgMX1gLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgaW1wb3J0VGltZTogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IGlkZW50aXRpZXM6IE9iamVjdC5hc3NpZ24oe30sIGlkZW50aXRpZXMpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGlkZW50aXR5IGZyb20gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyAtIEFkZHJlc3Mgb2YgdGhlIGlkZW50aXR5IHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICByZW1vdmVJZGVudGl0eShhZGRyZXNzKSB7XG4gICAgICAgIGFkZHJlc3MgPSAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShhZGRyZXNzKTtcbiAgICAgICAgY29uc3QgeyBpZGVudGl0aWVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIWlkZW50aXRpZXNbYWRkcmVzc10pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaWRlbnRpdGllc1thZGRyZXNzXTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSB9KTtcbiAgICAgICAgaWYgKGFkZHJlc3MgPT09IHRoaXMuc3RhdGUuc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHNlbGVjdGVkQWRkcmVzczogT2JqZWN0LmtleXMoaWRlbnRpdGllcylbMF0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlcyBhIG5ldyBsYWJlbCB3aXRoIGFuIGlkZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIG9mIHRoZSBpZGVudGl0eSB0byBhc3NvY2lhdGUuXG4gICAgICogQHBhcmFtIGxhYmVsIC0gTmV3IGxhYmVsIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBzZXRBY2NvdW50TGFiZWwoYWRkcmVzcywgbGFiZWwpIHtcbiAgICAgICAgYWRkcmVzcyA9ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpO1xuICAgICAgICBjb25zdCB7IGlkZW50aXRpZXMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlkZW50aXRpZXNbYWRkcmVzc10gPSBpZGVudGl0aWVzW2FkZHJlc3NdIHx8IHt9O1xuICAgICAgICBpZGVudGl0aWVzW2FkZHJlc3NdLm5hbWUgPSBsYWJlbDtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBpZGVudGl0aWVzOiBPYmplY3QuYXNzaWduKHt9LCBpZGVudGl0aWVzKSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBzcGVjaWZpYyBmZWF0dXJlIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZmVhdHVyZSAtIEZlYXR1cmUgdG8gdG9nZ2xlLlxuICAgICAqIEBwYXJhbSBhY3RpdmF0ZWQgLSBWYWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgc2V0RmVhdHVyZUZsYWcoZmVhdHVyZSwgYWN0aXZhdGVkKSB7XG4gICAgICAgIGNvbnN0IG9sZEZlYXR1cmVGbGFncyA9IHRoaXMuc3RhdGUuZmVhdHVyZUZsYWdzO1xuICAgICAgICBjb25zdCBmZWF0dXJlRmxhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZEZlYXR1cmVGbGFncyksIHsgW2ZlYXR1cmVdOiBhY3RpdmF0ZWQgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgZmVhdHVyZUZsYWdzOiBPYmplY3QuYXNzaWduKHt9LCBmZWF0dXJlRmxhZ3MpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZXMgdGhlIGN1cnJlbnQgaWRlbnRpdHkgbGlzdCB3aXRoIG5ldyBpZGVudGl0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIExpc3Qgb2YgYWRkcmVzc2VzIGNvcnJlc3BvbmRpbmcgdG8gaWRlbnRpdGllcyB0byBzeW5jLlxuICAgICAqIEByZXR1cm5zIE5ld2x5LXNlbGVjdGVkIGFkZHJlc3MgYWZ0ZXIgc3luY2luZy5cbiAgICAgKi9cbiAgICBzeW5jSWRlbnRpdGllcyhhZGRyZXNzZXMpIHtcbiAgICAgICAgYWRkcmVzc2VzID0gYWRkcmVzc2VzLm1hcCgoYWRkcmVzcykgPT4gKDAsIHV0aWxfMS50b0NoZWNrc3VtSGV4QWRkcmVzcykoYWRkcmVzcykpO1xuICAgICAgICBjb25zdCB7IGlkZW50aXRpZXMsIGxvc3RJZGVudGl0aWVzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCBuZXdseUxvc3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpZGVudGl0eSBpbiBpZGVudGl0aWVzKSB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc2VzLmluZGV4T2YoaWRlbnRpdHkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG5ld2x5TG9zdFtpZGVudGl0eV0gPSBpZGVudGl0aWVzW2lkZW50aXR5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgaWRlbnRpdGllc1tpZGVudGl0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG5ld2x5TG9zdCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbmV3bHlMb3N0KSB7XG4gICAgICAgICAgICAgICAgbG9zdElkZW50aXRpZXNba2V5XSA9IG5ld2x5TG9zdFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHtcbiAgICAgICAgICAgIGlkZW50aXRpZXM6IE9iamVjdC5hc3NpZ24oe30sIGlkZW50aXRpZXMpLFxuICAgICAgICAgICAgbG9zdElkZW50aXRpZXM6IE9iamVjdC5hc3NpZ24oe30sIGxvc3RJZGVudGl0aWVzKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkSWRlbnRpdGllcyhhZGRyZXNzZXMpO1xuICAgICAgICBpZiAoYWRkcmVzc2VzLmluZGV4T2YodGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3MpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoeyBzZWxlY3RlZEFkZHJlc3M6IGFkZHJlc3Nlc1swXSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5zZWxlY3RlZEFkZHJlc3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhbmQgc3RvcmVzIGEgbmV3IGxpc3Qgb2Ygc3RvcmVkIGlkZW50aXRpZXMgYmFzZWQgb24gYWRkcmVzcy4gSWYgdGhlIHNlbGVjdGVkIGFkZHJlc3NcbiAgICAgKiBpcyB1bnNldCwgb3IgaWYgaXQgcmVmZXJzIHRvIGFuIGlkZW50aXR5IHRoYXQgd2FzIHJlbW92ZWQsIGl0IHdpbGwgYmUgc2V0IHRvIHRoZSBmaXJzdFxuICAgICAqIGlkZW50aXR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyAtIExpc3Qgb2YgYWRkcmVzc2VzIHRvIHVzZSBhcyBhIGJhc2lzIGZvciBlYWNoIGlkZW50aXR5LlxuICAgICAqL1xuICAgIHVwZGF0ZUlkZW50aXRpZXMoYWRkcmVzc2VzKSB7XG4gICAgICAgIGFkZHJlc3NlcyA9IGFkZHJlc3Nlcy5tYXAoKGFkZHJlc3MpID0+ICgwLCB1dGlsXzEudG9DaGVja3N1bUhleEFkZHJlc3MpKGFkZHJlc3MpKTtcbiAgICAgICAgY29uc3Qgb2xkSWRlbnRpdGllcyA9IHRoaXMuc3RhdGUuaWRlbnRpdGllcztcbiAgICAgICAgY29uc3QgaWRlbnRpdGllcyA9IGFkZHJlc3Nlcy5yZWR1Y2UoKGlkcywgYWRkcmVzcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlkc1thZGRyZXNzXSA9IG9sZElkZW50aXRpZXNbYWRkcmVzc10gfHwge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgbmFtZTogYEFjY291bnQgJHtpbmRleCArIDF9YCxcbiAgICAgICAgICAgICAgICBpbXBvcnRUaW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBpZHM7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgbGV0IHsgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKGlkZW50aXRpZXMpLmluY2x1ZGVzKHNlbGVjdGVkQWRkcmVzcykpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzcyA9IE9iamVjdC5rZXlzKGlkZW50aXRpZXMpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaWRlbnRpdGllczogT2JqZWN0LmFzc2lnbih7fSwgaWRlbnRpdGllcyksIHNlbGVjdGVkQWRkcmVzcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBjdXN0b20gUlBDIFVSTCB0byBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgLSBUaGUgY3VzdG9tIFJQQyBVUkwuXG4gICAgICogQHBhcmFtIGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgb2YgdGhlIG5ldHdvcmssIGFzIHBlciBFSVAtMTU1LlxuICAgICAqIEBwYXJhbSB0aWNrZXIgLSBDdXJyZW5jeSB0aWNrZXIuXG4gICAgICogQHBhcmFtIG5pY2tuYW1lIC0gUGVyc29uYWxpemVkIG5ldHdvcmsgbmFtZS5cbiAgICAgKiBAcGFyYW0gcnBjUHJlZnMgLSBQZXJzb25hbGl6ZWQgcHJlZmVyZW5jZXMuXG4gICAgICovXG4gICAgYWRkVG9GcmVxdWVudFJwY0xpc3QodXJsLCBjaGFpbklkLCB0aWNrZXIsIG5pY2tuYW1lLCBycGNQcmVmcykge1xuICAgICAgICBjb25zdCB7IGZyZXF1ZW50UnBjTGlzdCB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBmcmVxdWVudFJwY0xpc3QuZmluZEluZGV4KCh7IHJwY1VybCB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcnBjVXJsID09PSB1cmw7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBmcmVxdWVudFJwY0xpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdGcmVxdWVzdFJwYyA9IHtcbiAgICAgICAgICAgIHJwY1VybDogdXJsLFxuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIHRpY2tlcixcbiAgICAgICAgICAgIG5pY2tuYW1lLFxuICAgICAgICAgICAgcnBjUHJlZnMsXG4gICAgICAgIH07XG4gICAgICAgIGZyZXF1ZW50UnBjTGlzdC5wdXNoKG5ld0ZyZXF1ZXN0UnBjKTtcbiAgICAgICAgdGhpcy51cGRhdGUoeyBmcmVxdWVudFJwY0xpc3Q6IFsuLi5mcmVxdWVudFJwY0xpc3RdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGN1c3RvbSBSUEMgVVJMIGZyb20gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIC0gQ3VzdG9tIFJQQyBVUkwuXG4gICAgICovXG4gICAgcmVtb3ZlRnJvbUZyZXF1ZW50UnBjTGlzdCh1cmwpIHtcbiAgICAgICAgY29uc3QgeyBmcmVxdWVudFJwY0xpc3QgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZnJlcXVlbnRScGNMaXN0LmZpbmRJbmRleCgoeyBycGNVcmwgfSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJwY1VybCA9PT0gdXJsO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgZnJlcXVlbnRScGNMaXN0LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyBmcmVxdWVudFJwY0xpc3Q6IFsuLi5mcmVxdWVudFJwY0xpc3RdIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHNlbGVjdGVkIGFkZHJlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VsZWN0ZWRBZGRyZXNzIC0gRXRoZXJldW0gYWRkcmVzcy5cbiAgICAgKi9cbiAgICBzZXRTZWxlY3RlZEFkZHJlc3Moc2VsZWN0ZWRBZGRyZXNzKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgc2VsZWN0ZWRBZGRyZXNzOiAoMCwgdXRpbF8xLnRvQ2hlY2tzdW1IZXhBZGRyZXNzKShzZWxlY3RlZEFkZHJlc3MpIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIG5ldyBJUEZTIGdhdGV3YXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXBmc0dhdGV3YXkgLSBJUEZTIGdhdGV3YXkgc3RyaW5nLlxuICAgICAqL1xuICAgIHNldElwZnNHYXRld2F5KGlwZnNHYXRld2F5KSB7XG4gICAgICAgIHRoaXMudXBkYXRlKHsgaXBmc0dhdGV3YXkgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgdG9rZW4gZGV0ZWN0aW9uIHNldHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXNlVG9rZW5EZXRlY3Rpb24gLSBCb29sZWFuIGluZGljYXRpbmcgdXNlciBwcmVmZXJlbmNlIG9uIHRva2VuIGRldGVjdGlvbi5cbiAgICAgKi9cbiAgICBzZXRVc2VUb2tlbkRldGVjdGlvbih1c2VUb2tlbkRldGVjdGlvbikge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IHVzZVRva2VuRGV0ZWN0aW9uIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIGNvbGxlY3RpYmxlIGRldGVjdGlvbiBzZXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uIC0gQm9vbGVhbiBpbmRpY2F0aW5nIHVzZXIgcHJlZmVyZW5jZSBvbiBjb2xsZWN0aWJsZSBkZXRlY3Rpb24uXG4gICAgICovXG4gICAgc2V0VXNlQ29sbGVjdGlibGVEZXRlY3Rpb24odXNlQ29sbGVjdGlibGVEZXRlY3Rpb24pIHtcbiAgICAgICAgaWYgKHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uICYmICF0aGlzLnN0YXRlLm9wZW5TZWFFbmFibGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uIGNhbm5vdCBiZSBlbmFibGVkIGlmIG9wZW5TZWFFbmFibGVkIGlzIGZhbHNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGUoeyB1c2VDb2xsZWN0aWJsZURldGVjdGlvbiB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlIHRoZSBvcGVuc2VhIGVuYWJsZWQgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcGVuU2VhRW5hYmxlZCAtIEJvb2xlYW4gaW5kaWNhdGluZyB1c2VyIHByZWZlcmVuY2Ugb24gdXNpbmcgT3BlblNlYSdzIEFQSS5cbiAgICAgKi9cbiAgICBzZXRPcGVuU2VhRW5hYmxlZChvcGVuU2VhRW5hYmxlZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSh7IG9wZW5TZWFFbmFibGVkIH0pO1xuICAgICAgICBpZiAoIW9wZW5TZWFFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSh7IHVzZUNvbGxlY3RpYmxlRGV0ZWN0aW9uOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJlZmVyZW5jZXNDb250cm9sbGVyID0gUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJlZmVyZW5jZXNDb250cm9sbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJlZmVyZW5jZXNDb250cm9sbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzVG9rZW5MaXN0U3VwcG9ydGVkRm9yTmV0d29yayA9IGV4cG9ydHMuaXNUb2tlbkRldGVjdGlvblN1cHBvcnRlZEZvck5ldHdvcmsgPSBleHBvcnRzLlN1cHBvcnRlZFRva2VuRGV0ZWN0aW9uTmV0d29ya3MgPSBleHBvcnRzLmlzVmFsaWRKc29uID0gZXhwb3J0cy5pc05vbkVtcHR5QXJyYXkgPSBleHBvcnRzLmhhc1Byb3BlcnR5ID0gZXhwb3J0cy5pc1BsYWluT2JqZWN0ID0gZXhwb3J0cy5nZXRGb3JtYXR0ZWRJcGZzVXJsID0gZXhwb3J0cy5hZGRVcmxQcm90b2NvbFByZWZpeCA9IGV4cG9ydHMuZ2V0SXBmc0NJRHYxQW5kUGF0aCA9IGV4cG9ydHMucmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4ID0gZXhwb3J0cy52YWxpZGF0ZU1pbmltdW1JbmNyZWFzZSA9IGV4cG9ydHMuaXNHYXNQcmljZVZhbHVlID0gZXhwb3J0cy5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMgPSBleHBvcnRzLnZhbGlkYXRlR2FzVmFsdWVzID0gZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9IGV4cG9ydHMuZ2V0SW5jcmVhc2VkUHJpY2VIZXggPSBleHBvcnRzLmNvbnZlcnRIZXhUb0RlY2ltYWwgPSBleHBvcnRzLmlzRUlQMTU1OVRyYW5zYWN0aW9uID0gZXhwb3J0cy5xdWVyeSA9IGV4cG9ydHMubm9ybWFsaXplRW5zTmFtZSA9IGV4cG9ydHMudGltZW91dEZldGNoID0gZXhwb3J0cy5mZXRjaFdpdGhFcnJvckhhbmRsaW5nID0gZXhwb3J0cy5oYW5kbGVGZXRjaCA9IGV4cG9ydHMuc3VjY2Vzc2Z1bEZldGNoID0gZXhwb3J0cy5pc1NtYXJ0Q29udHJhY3RDb2RlID0gZXhwb3J0cy52YWxpZGF0ZVRva2VuVG9XYXRjaCA9IGV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzID0gZXhwb3J0cy52YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjEgPSBleHBvcnRzLnZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhID0gZXhwb3J0cy5ub3JtYWxpemVNZXNzYWdlRGF0YSA9IGV4cG9ydHMudmFsaWRhdGVUcmFuc2FjdGlvbiA9IGV4cG9ydHMuaXNWYWxpZEhleEFkZHJlc3MgPSBleHBvcnRzLnRvQ2hlY2tzdW1IZXhBZGRyZXNzID0gZXhwb3J0cy5zYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQgPSBleHBvcnRzLnNhZmVseUV4ZWN1dGUgPSBleHBvcnRzLm5vcm1hbGl6ZVRyYW5zYWN0aW9uID0gZXhwb3J0cy50b0hleCA9IGV4cG9ydHMuZnJvbUhleCA9IGV4cG9ydHMuaGV4VG9UZXh0ID0gZXhwb3J0cy5oZXhUb0JOID0gZXhwb3J0cy5oYW5kbGVUcmFuc2FjdGlvbkZldGNoID0gZXhwb3J0cy5nZXRFdGhlcnNjYW5BcGlVcmwgPSBleHBvcnRzLmdldEJ1eVVSTCA9IGV4cG9ydHMud2VpSGV4VG9Hd2VpRGVjID0gZXhwb3J0cy5nd2VpRGVjVG9XRUlCTiA9IGV4cG9ydHMuZnJhY3Rpb25CTiA9IGV4cG9ydHMuQk5Ub0hleCA9IHZvaWQgMDtcbmNvbnN0IGV0aGVyZXVtanNfdXRpbF8xID0gcmVxdWlyZShcImV0aGVyZXVtanMtdXRpbFwiKTtcbmNvbnN0IGV0aGpzX3VuaXRfMSA9IHJlcXVpcmUoXCJldGhqcy11bml0XCIpO1xuY29uc3QgZXRoX3JwY19lcnJvcnNfMSA9IHJlcXVpcmUoXCJldGgtcnBjLWVycm9yc1wiKTtcbmNvbnN0IGV0aF9lbnNfbmFtZWhhc2hfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZXRoLWVucy1uYW1laGFzaFwiKSk7XG5jb25zdCBldGhfc2lnX3V0aWxfMSA9IHJlcXVpcmUoXCJldGgtc2lnLXV0aWxcIik7XG5jb25zdCBqc29uc2NoZW1hXzEgPSByZXF1aXJlKFwianNvbnNjaGVtYVwiKTtcbmNvbnN0IGNpZF8xID0gcmVxdWlyZShcIm11bHRpZm9ybWF0cy9jaWRcIik7XG5jb25zdCBmYXN0X2RlZXBfZXF1YWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZmFzdC1kZWVwLWVxdWFsXCIpKTtcbmNvbnN0IGNvbnN0YW50c18xID0gcmVxdWlyZShcIi4vY29uc3RhbnRzXCIpO1xuY29uc3QgVElNRU9VVF9FUlJPUiA9IG5ldyBFcnJvcigndGltZW91dCcpO1xuY29uc3QgaGV4UmUgPSAvXlswLTlBLUZhLWZdKyQvZ3U7XG5jb25zdCBOT1JNQUxJWkVSUyA9IHtcbiAgICBkYXRhOiAoZGF0YSkgPT4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkoZGF0YSksXG4gICAgZnJvbTogKGZyb20pID0+ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgpKGZyb20pLnRvTG93ZXJDYXNlKCksXG4gICAgZ2FzOiAoZ2FzKSA9PiAoMCwgZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KShnYXMpLFxuICAgIGdhc1ByaWNlOiAoZ2FzUHJpY2UpID0+ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgpKGdhc1ByaWNlKSxcbiAgICBub25jZTogKG5vbmNlKSA9PiAoMCwgZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KShub25jZSksXG4gICAgdG86ICh0bykgPT4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkodG8pLnRvTG93ZXJDYXNlKCksXG4gICAgdmFsdWU6ICh2YWx1ZSkgPT4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkodmFsdWUpLFxuICAgIG1heEZlZVBlckdhczogKG1heEZlZVBlckdhcykgPT4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkobWF4RmVlUGVyR2FzKSxcbiAgICBtYXhQcmlvcml0eUZlZVBlckdhczogKG1heFByaW9yaXR5RmVlUGVyR2FzKSA9PiAoMCwgZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KShtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgZXN0aW1hdGVkQmFzZUZlZTogKG1heFByaW9yaXR5RmVlUGVyR2FzKSA9PiAoMCwgZXRoZXJldW1qc191dGlsXzEuYWRkSGV4UHJlZml4KShtYXhQcmlvcml0eUZlZVBlckdhcyksXG59O1xuLyoqXG4gKiBDb252ZXJ0cyBhIEJOIG9iamVjdCB0byBhIGhleCBzdHJpbmcgd2l0aCBhICcweCcgcHJlZml4LlxuICpcbiAqIEBwYXJhbSBpbnB1dEJuIC0gQk4gaW5zdGFuY2UgdG8gY29udmVydCB0byBhIGhleCBzdHJpbmcuXG4gKiBAcmV0dXJucyBBICcweCctcHJlZml4ZWQgaGV4IHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gQk5Ub0hleChpbnB1dEJuKSB7XG4gICAgcmV0dXJuICgwLCBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgpKGlucHV0Qm4udG9TdHJpbmcoMTYpKTtcbn1cbmV4cG9ydHMuQk5Ub0hleCA9IEJOVG9IZXg7XG4vKipcbiAqIFVzZWQgdG8gbXVsdGlwbHkgYSBCTiBieSBhIGZyYWN0aW9uLlxuICpcbiAqIEBwYXJhbSB0YXJnZXRCTiAtIE51bWJlciB0byBtdWx0aXBseSBieSBhIGZyYWN0aW9uLlxuICogQHBhcmFtIG51bWVyYXRvciAtIE51bWVyYXRvciBvZiB0aGUgZnJhY3Rpb24gbXVsdGlwbGllci5cbiAqIEBwYXJhbSBkZW5vbWluYXRvciAtIERlbm9taW5hdG9yIG9mIHRoZSBmcmFjdGlvbiBtdWx0aXBsaWVyLlxuICogQHJldHVybnMgUHJvZHVjdCBvZiB0aGUgbXVsdGlwbGljYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGZyYWN0aW9uQk4odGFyZ2V0Qk4sIG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICBjb25zdCBudW1CTiA9IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihudW1lcmF0b3IpO1xuICAgIGNvbnN0IGRlbm9tQk4gPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oZGVub21pbmF0b3IpO1xuICAgIHJldHVybiB0YXJnZXRCTi5tdWwobnVtQk4pLmRpdihkZW5vbUJOKTtcbn1cbmV4cG9ydHMuZnJhY3Rpb25CTiA9IGZyYWN0aW9uQk47XG4vKipcbiAqIFVzZWQgdG8gY29udmVydCBhIGJhc2UtMTAgbnVtYmVyIGZyb20gR1dFSSB0byBXRUkuIENhbiBoYW5kbGUgbnVtYmVycyB3aXRoIGRlY2ltYWwgcGFydHMuXG4gKlxuICogQHBhcmFtIG4gLSBUaGUgYmFzZSAxMCBudW1iZXIgdG8gY29udmVydCB0byBXRUkuXG4gKiBAcmV0dXJucyBUaGUgbnVtYmVyIGluIFdFSSwgYXMgYSBCTi5cbiAqL1xuZnVuY3Rpb24gZ3dlaURlY1RvV0VJQk4obikge1xuICAgIGlmIChOdW1iZXIuaXNOYU4obikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTigwKTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBuLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICBjb25zdCB3aG9sZVBhcnQgPSBwYXJ0c1swXSB8fCAnMCc7XG4gICAgbGV0IGRlY2ltYWxQYXJ0ID0gcGFydHNbMV0gfHwgJyc7XG4gICAgaWYgKCFkZWNpbWFsUGFydCkge1xuICAgICAgICByZXR1cm4gKDAsIGV0aGpzX3VuaXRfMS50b1dlaSkod2hvbGVQYXJ0LCAnZ3dlaScpO1xuICAgIH1cbiAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoIDw9IDkpIHtcbiAgICAgICAgcmV0dXJuICgwLCBldGhqc191bml0XzEudG9XZWkpKGAke3dob2xlUGFydH0uJHtkZWNpbWFsUGFydH1gLCAnZ3dlaScpO1xuICAgIH1cbiAgICBjb25zdCBkZWNpbWFsUGFydFRvUmVtb3ZlID0gZGVjaW1hbFBhcnQuc2xpY2UoOSk7XG4gICAgY29uc3QgZGVjaW1hbFJvdW5kaW5nRGlnaXQgPSBkZWNpbWFsUGFydFRvUmVtb3ZlWzBdO1xuICAgIGRlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQuc2xpY2UoMCwgOSk7XG4gICAgbGV0IHdlaSA9ICgwLCBldGhqc191bml0XzEudG9XZWkpKGAke3dob2xlUGFydH0uJHtkZWNpbWFsUGFydH1gLCAnZ3dlaScpO1xuICAgIGlmIChOdW1iZXIoZGVjaW1hbFJvdW5kaW5nRGlnaXQpID49IDUpIHtcbiAgICAgICAgd2VpID0gd2VpLmFkZChuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oMSkpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpO1xufVxuZXhwb3J0cy5nd2VpRGVjVG9XRUlCTiA9IGd3ZWlEZWNUb1dFSUJOO1xuLyoqXG4gKiBVc2VkIHRvIGNvbnZlcnQgdmFsdWVzIGZyb20gd2VpIGhleCBmb3JtYXQgdG8gZGVjIGd3ZWkgZm9ybWF0LlxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUgdmFsdWUgaW4gaGV4IHdlaS5cbiAqIEByZXR1cm5zIFRoZSB2YWx1ZSBpbiBkZWMgZ3dlaSBhcyBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHdlaUhleFRvR3dlaURlYyhoZXgpIHtcbiAgICBjb25zdCBoZXhXZWkgPSBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oKDAsIGV0aGVyZXVtanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KShoZXgpLCAxNik7XG4gICAgcmV0dXJuICgwLCBldGhqc191bml0XzEuZnJvbVdlaSkoaGV4V2VpLCAnZ3dlaScpLnRvU3RyaW5nKDEwKTtcbn1cbmV4cG9ydHMud2VpSGV4VG9Hd2VpRGVjID0gd2VpSGV4VG9Hd2VpRGVjO1xuLyoqXG4gKiBSZXR1cm4gYSBVUkwgdGhhdCBjYW4gYmUgdXNlZCB0byBvYnRhaW4gRVRIIGZvciBhIGdpdmVuIG5ldHdvcmsuXG4gKlxuICogQHBhcmFtIG5ldHdvcmtDb2RlIC0gTmV0d29yayBjb2RlIG9mIGRlc2lyZWQgbmV0d29yay5cbiAqIEBwYXJhbSBhZGRyZXNzIC0gQWRkcmVzcyB0byBkZXBvc2l0IG9idGFpbmVkIEVUSC5cbiAqIEBwYXJhbSBhbW91bnQgLSBIb3cgbXVjaCBFVEggaXMgZGVzaXJlZC5cbiAqIEByZXR1cm5zIFVSTCB0byBidXkgRVRIIGJhc2VkIG9uIG5ldHdvcmsuXG4gKi9cbmZ1bmN0aW9uIGdldEJ1eVVSTChuZXR3b3JrQ29kZSA9ICcxJywgYWRkcmVzcywgYW1vdW50ID0gNSkge1xuICAgIHN3aXRjaCAobmV0d29ya0NvZGUpIHtcbiAgICAgICAgY2FzZSAnMSc6XG4gICAgICAgICAgICByZXR1cm4gYGh0dHBzOi8vYnV5LmNvaW5iYXNlLmNvbS8/Y29kZT05ZWM1NmQwMS03ZTgxLTUwMTctOTMwYy01MTNkYWEyN2JiNmEmYW1vdW50PSR7YW1vdW50fSZhZGRyZXNzPSR7YWRkcmVzc30mY3J5cHRvX2N1cnJlbmN5PUVUSGA7XG4gICAgICAgIGNhc2UgJzMnOlxuICAgICAgICAgICAgcmV0dXJuICdodHRwczovL2ZhdWNldC5tZXRhbWFzay5pby8nO1xuICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly93d3cucmlua2VieS5pby8nO1xuICAgICAgICBjYXNlICc1JzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly9nb2VybGktZmF1Y2V0LnNsb2NrLml0Lyc7XG4gICAgICAgIGNhc2UgJzQyJzpcbiAgICAgICAgICAgIHJldHVybiAnaHR0cHM6Ly9naXRodWIuY29tL2tvdmFuLXRlc3RuZXQvZmF1Y2V0JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5nZXRCdXlVUkwgPSBnZXRCdXlVUkw7XG4vKipcbiAqIFJldHVybiBhIFVSTCB0aGF0IGNhbiBiZSB1c2VkIHRvIGZldGNoIEVUSCB0cmFuc2FjdGlvbnMuXG4gKlxuICogQHBhcmFtIG5ldHdvcmtUeXBlIC0gTmV0d29yayB0eXBlIG9mIGRlc2lyZWQgbmV0d29yay5cbiAqIEBwYXJhbSB1cmxQYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgVVJMLlxuICogQHJldHVybnMgVVJMIHRvIGZldGNoIHRoZSBhY2Nlc3MgdGhlIGVuZHBvaW50LlxuICovXG5mdW5jdGlvbiBnZXRFdGhlcnNjYW5BcGlVcmwobmV0d29ya1R5cGUsIHVybFBhcmFtcykge1xuICAgIGxldCBldGhlcnNjYW5TdWJkb21haW4gPSAnYXBpJztcbiAgICBpZiAobmV0d29ya1R5cGUgIT09IGNvbnN0YW50c18xLk1BSU5ORVQpIHtcbiAgICAgICAgZXRoZXJzY2FuU3ViZG9tYWluID0gYGFwaS0ke25ldHdvcmtUeXBlfWA7XG4gICAgfVxuICAgIGNvbnN0IGFwaVVybCA9IGBodHRwczovLyR7ZXRoZXJzY2FuU3ViZG9tYWlufS5ldGhlcnNjYW4uaW9gO1xuICAgIGxldCB1cmwgPSBgJHthcGlVcmx9L2FwaT9gO1xuICAgIGZvciAoY29uc3QgcGFyYW1LZXkgaW4gdXJsUGFyYW1zKSB7XG4gICAgICAgIGlmICh1cmxQYXJhbXNbcGFyYW1LZXldKSB7XG4gICAgICAgICAgICB1cmwgKz0gYCR7cGFyYW1LZXl9PSR7dXJsUGFyYW1zW3BhcmFtS2V5XX0mYDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cmwgKz0gJ3RhZz1sYXRlc3QmcGFnZT0xJztcbiAgICByZXR1cm4gdXJsO1xufVxuZXhwb3J0cy5nZXRFdGhlcnNjYW5BcGlVcmwgPSBnZXRFdGhlcnNjYW5BcGlVcmw7XG4vKipcbiAqIEhhbmRsZXMgdGhlIGZldGNoIG9mIGluY29taW5nIHRyYW5zYWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gbmV0d29ya1R5cGUgLSBOZXR3b3JrIHR5cGUgb2YgZGVzaXJlZCBuZXR3b3JrLlxuICogQHBhcmFtIGFkZHJlc3MgLSBBZGRyZXNzIHRvIGdldCB0aGUgdHJhbnNhY3Rpb25zIGZyb20uXG4gKiBAcGFyYW0gdHhIaXN0b3J5TGltaXQgLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgdHJhbnNhY3Rpb25zIHRvIGZldGNoLlxuICogQHBhcmFtIG9wdCAtIE9iamVjdCB0aGF0IGNhbiBjb250YWluIGZyb21CbG9jayBhbmQgRXRoZXJzY2FuIHNlcnZpY2UgQVBJIGtleS5cbiAqIEByZXR1cm5zIFJlc3BvbnNlcyBmb3IgYm90aCBFVEggYW5kIEVSQzIwIHRva2VuIHRyYW5zYWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVHJhbnNhY3Rpb25GZXRjaChuZXR3b3JrVHlwZSwgYWRkcmVzcywgdHhIaXN0b3J5TGltaXQsIG9wdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIHRyYW5zYWN0aW9uc1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSB7XG4gICAgICAgICAgICBtb2R1bGU6ICdhY2NvdW50JyxcbiAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBzdGFydEJsb2NrOiBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuZnJvbUJsb2NrLFxuICAgICAgICAgICAgYXBpa2V5OiBvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuZXRoZXJzY2FuQXBpS2V5LFxuICAgICAgICAgICAgb2Zmc2V0OiB0eEhpc3RvcnlMaW1pdC50b1N0cmluZygpLFxuICAgICAgICAgICAgb3JkZXI6ICdkZXNjJyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVHhVcmwgPSBnZXRFdGhlcnNjYW5BcGlVcmwobmV0d29ya1R5cGUsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdXJsUGFyYW1zKSwgeyBhY3Rpb246ICd0eGxpc3QnIH0pKTtcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVHhSZXNwb25zZVByb21pc2UgPSBoYW5kbGVGZXRjaChldGhlcnNjYW5UeFVybCk7XG4gICAgICAgIC8vIHRva2Vuc1xuICAgICAgICBjb25zdCBldGhlcnNjYW5Ub2tlblVybCA9IGdldEV0aGVyc2NhbkFwaVVybChuZXR3b3JrVHlwZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1cmxQYXJhbXMpLCB7IGFjdGlvbjogJ3Rva2VudHgnIH0pKTtcbiAgICAgICAgY29uc3QgZXRoZXJzY2FuVG9rZW5SZXNwb25zZVByb21pc2UgPSBoYW5kbGVGZXRjaChldGhlcnNjYW5Ub2tlblVybCk7XG4gICAgICAgIGxldCBbZXRoZXJzY2FuVHhSZXNwb25zZSwgZXRoZXJzY2FuVG9rZW5SZXNwb25zZV0gPSB5aWVsZCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBldGhlcnNjYW5UeFJlc3BvbnNlUHJvbWlzZSxcbiAgICAgICAgICAgIGV0aGVyc2NhblRva2VuUmVzcG9uc2VQcm9taXNlLFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKGV0aGVyc2NhblR4UmVzcG9uc2Uuc3RhdHVzID09PSAnMCcgfHxcbiAgICAgICAgICAgIGV0aGVyc2NhblR4UmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICBldGhlcnNjYW5UeFJlc3BvbnNlID0geyBzdGF0dXM6IGV0aGVyc2NhblR4UmVzcG9uc2Uuc3RhdHVzLCByZXN1bHQ6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV0aGVyc2NhblRva2VuUmVzcG9uc2Uuc3RhdHVzID09PSAnMCcgfHxcbiAgICAgICAgICAgIGV0aGVyc2NhblRva2VuUmVzcG9uc2UucmVzdWx0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICBldGhlcnNjYW5Ub2tlblJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogZXRoZXJzY2FuVG9rZW5SZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtldGhlcnNjYW5UeFJlc3BvbnNlLCBldGhlcnNjYW5Ub2tlblJlc3BvbnNlXTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFuZGxlVHJhbnNhY3Rpb25GZXRjaCA9IGhhbmRsZVRyYW5zYWN0aW9uRmV0Y2g7XG4vKipcbiAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIEJOIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gaW5wdXRIZXggLSBOdW1iZXIgcmVwcmVzZW50ZWQgYXMgYSBoZXggc3RyaW5nLlxuICogQHJldHVybnMgQSBCTiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGV4VG9CTihpbnB1dEhleCkge1xuICAgIHJldHVybiBuZXcgZXRoZXJldW1qc191dGlsXzEuQk4oKDAsIGV0aGVyZXVtanNfdXRpbF8xLnN0cmlwSGV4UHJlZml4KShpbnB1dEhleCksIDE2KTtcbn1cbmV4cG9ydHMuaGV4VG9CTiA9IGhleFRvQk47XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRoYXQgY29udmVydHMgaGV4IGRhdGEgdG8gaHVtYW4gcmVhZGFibGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSBoZXggLSBUaGUgaGV4IHN0cmluZyB0byBjb252ZXJ0IHRvIHN0cmluZy5cbiAqIEByZXR1cm5zIEEgaHVtYW4gcmVhZGFibGUgc3RyaW5nIGNvbnZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGhleFRvVGV4dChoZXgpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzdHJpcHBlZCA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5zdHJpcEhleFByZWZpeCkoaGV4KTtcbiAgICAgICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKHN0cmlwcGVkLCAnaGV4Jyk7XG4gICAgICAgIHJldHVybiBidWZmLnRvU3RyaW5nKCd1dGY4Jyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgfVxufVxuZXhwb3J0cy5oZXhUb1RleHQgPSBoZXhUb1RleHQ7XG4vKipcbiAqIFBhcnNlcyBhIGhleCBzdHJpbmcgYW5kIGNvbnZlcnRzIGl0IGludG8gYSBudW1iZXIgdGhhdCBjYW4gYmUgb3BlcmF0ZWQgb24gaW4gYSBiaWdudW0tc2FmZSxcbiAqIGJhc2UtMTAgd2F5LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEEgYmFzZS0xNiBudW1iZXIgZW5jb2RlZCBhcyBhIHN0cmluZy5cbiAqIEByZXR1cm5zIFRoZSBudW1iZXIgYXMgYSBCTiBvYmplY3QgaW4gYmFzZS0xNiBtb2RlLlxuICovXG5mdW5jdGlvbiBmcm9tSGV4KHZhbHVlKSB7XG4gICAgaWYgKGV0aGVyZXVtanNfdXRpbF8xLkJOLmlzQk4odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTihoZXhUb0JOKHZhbHVlKS50b1N0cmluZygxMCkpO1xufVxuZXhwb3J0cy5mcm9tSGV4ID0gZnJvbUhleDtcbi8qKlxuICogQ29udmVydHMgYW4gaW50ZWdlciB0byBhIGhleGFkZWNpbWFsIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIEFuIGludGVnZXIsIGFuIGludGVnZXIgZW5jb2RlZCBhcyBhIGJhc2UtMTAgc3RyaW5nLCBvciBhIEJOLlxuICogQHJldHVybnMgVGhlIGludGVnZXIgZW5jb2RlZCBhcyBhIGhleCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgKDAsIGV0aGVyZXVtanNfdXRpbF8xLmlzSGV4U3RyaW5nKSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBoZXhTdHJpbmcgPSBldGhlcmV1bWpzX3V0aWxfMS5CTi5pc0JOKHZhbHVlKVxuICAgICAgICA/IHZhbHVlLnRvU3RyaW5nKDE2KVxuICAgICAgICA6IG5ldyBldGhlcmV1bWpzX3V0aWxfMS5CTih2YWx1ZS50b1N0cmluZygpLCAxMCkudG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBgMHgke2hleFN0cmluZ31gO1xufVxuZXhwb3J0cy50b0hleCA9IHRvSGV4O1xuLyoqXG4gKiBOb3JtYWxpemVzIHByb3BlcnRpZXMgb24gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRyYW5zYWN0aW9uIC0gVHJhbnNhY3Rpb24gb2JqZWN0IHRvIG5vcm1hbGl6ZS5cbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUcmFuc2FjdGlvbiA9IHsgZnJvbTogJycgfTtcbiAgICBsZXQga2V5O1xuICAgIGZvciAoa2V5IGluIE5PUk1BTElaRVJTKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkVHJhbnNhY3Rpb25ba2V5XSA9IE5PUk1BTElaRVJTW2tleV0odHJhbnNhY3Rpb25ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vcm1hbGl6ZWRUcmFuc2FjdGlvbjtcbn1cbmV4cG9ydHMubm9ybWFsaXplVHJhbnNhY3Rpb24gPSBub3JtYWxpemVUcmFuc2FjdGlvbjtcbi8qKlxuICogRXhlY3V0ZSBhbmQgcmV0dXJuIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24gd2l0aG91dCB0aHJvd2luZyBlcnJvcnMuXG4gKlxuICogQHBhcmFtIG9wZXJhdGlvbiAtIEZ1bmN0aW9uIHJldHVybmluZyBhIFByb21pc2UuXG4gKiBAcGFyYW0gbG9nRXJyb3IgLSBEZXRlcm1pbmVzIGlmIHRoZSBlcnJvciBzaG91bGQgYmUgbG9nZ2VkLlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3VsdCBvZiB0aGUgYXN5bmMgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBzYWZlbHlFeGVjdXRlKG9wZXJhdGlvbiwgbG9nRXJyb3IgPSBmYWxzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgb3BlcmF0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGxvZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNhZmVseUV4ZWN1dGUgPSBzYWZlbHlFeGVjdXRlO1xuLyoqXG4gKiBFeGVjdXRlIGFuZCByZXR1cm4gYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aXRoIGEgdGltZW91dC5cbiAqXG4gKiBAcGFyYW0gb3BlcmF0aW9uIC0gRnVuY3Rpb24gcmV0dXJuaW5nIGEgUHJvbWlzZS5cbiAqIEBwYXJhbSBsb2dFcnJvciAtIERldGVybWluZXMgaWYgdGhlIGVycm9yIHNob3VsZCBiZSBsb2dnZWQuXG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQgdG8gZmFpbCB0aGUgb3BlcmF0aW9uLlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdG8gdGhlIHJlc3VsdCBvZiB0aGUgYXN5bmMgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBzYWZlbHlFeGVjdXRlV2l0aFRpbWVvdXQob3BlcmF0aW9uLCBsb2dFcnJvciA9IGZhbHNlLCB0aW1lb3V0ID0gNTAwKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbigpLFxuICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoVElNRU9VVF9FUlJPUik7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCkpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGxvZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnNhZmVseUV4ZWN1dGVXaXRoVGltZW91dCA9IHNhZmVseUV4ZWN1dGVXaXRoVGltZW91dDtcbi8qKlxuICogQ29udmVydCBhbiBhZGRyZXNzIHRvIGEgY2hlY2tzdW1tZWQgaGV4aWRlY2ltYWwgYWRkcmVzcy5cbiAqXG4gKiBAcGFyYW0gYWRkcmVzcyAtIFRoZSBhZGRyZXNzIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIDB4LXByZWZpeGVkIGhleGlkZWNpbWFsIGNoZWNrc3VtbWVkIGFkZHJlc3MuXG4gKi9cbmZ1bmN0aW9uIHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBjb25zdCBoZXhQcmVmaXhlZCA9ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgpKGFkZHJlc3MpO1xuICAgIGlmICghKDAsIGV0aGVyZXVtanNfdXRpbF8xLmlzSGV4U3RyaW5nKShoZXhQcmVmaXhlZCkpIHtcbiAgICAgICAgLy8gVmVyc2lvbiA1LjEgb2YgZXRoZXJldW1qcy11dGlscyB3b3VsZCBoYXZlIHJldHVybmVkICcweFknIGZvciBpbnB1dCAneSdcbiAgICAgICAgLy8gYnV0IHdlIHNob3VsZG4ndCB3YXN0ZSBlZmZvcnQgdHJ5aW5nIHRvIGNoYW5nZSBjYXNlIG9uIGEgY2xlYXJseSBpbnZhbGlkXG4gICAgICAgIC8vIHN0cmluZy4gSW5zdGVhZCBqdXN0IHJldHVybiB0aGUgaGV4IHByZWZpeGVkIG9yaWdpbmFsIHN0cmluZyB3aGljaCBtb3N0XG4gICAgICAgIC8vIGNsb3NlbHkgbWltaWNzIHRoZSBvcmlnaW5hbCBiZWhhdmlvci5cbiAgICAgICAgcmV0dXJuIGhleFByZWZpeGVkO1xuICAgIH1cbiAgICByZXR1cm4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLnRvQ2hlY2tzdW1BZGRyZXNzKShoZXhQcmVmaXhlZCk7XG59XG5leHBvcnRzLnRvQ2hlY2tzdW1IZXhBZGRyZXNzID0gdG9DaGVja3N1bUhleEFkZHJlc3M7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbnB1dCBpcyBhIGhleCBhZGRyZXNzLiBUaGlzIHV0aWxpdHkgbWV0aG9kIGlzIGEgdGhpblxuICogd3JhcHBlciBhcm91bmQgZXRoZXJldW1qcy11dGlsLmlzVmFsaWRBZGRyZXNzLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpdFxuICogZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBwcm92aWRlZCB2YWx1ZXMgdGhhdCBhcmUgbm90IGhleCBzdHJpbmdzLiBJblxuICogYWRkaXRpb24sIGFuZCBieSBkZWZhdWx0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0cnVlIGZvciBoZXggc3RyaW5ncyB0aGF0XG4gKiBtZWV0IHRoZSBsZW5ndGggcmVxdWlyZW1lbnQgb2YgYSBoZXggYWRkcmVzcywgYnV0IGFyZSBub3QgcHJlZml4ZWQgd2l0aCBgMHhgXG4gKiBGaW5hbGx5LCBpZiB0aGUgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gZmxhZyBpcyB0cnVlIGFuZCBhIG1peGVkIGNhc2Ugc3RyaW5nIGlzXG4gKiBwcm92aWRlZCB0aGlzIG1ldGhvZCB3aWxsIHZhbGlkYXRlIGl0IGhhcyB0aGUgcHJvcGVyIGNoZWNrc3VtIGZvcm1hdHRpbmcuXG4gKlxuICogQHBhcmFtIHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgdmFsaWRhdGlvbiBvcHRpb25zLlxuICogQHBhcmFtIG9wdGlvbnMuYWxsb3dOb25QcmVmaXhlZCAtIElmIHRydWUgd2lsbCBmaXJzdCBlbnN1cmUgJzB4JyBpcyBwcmVwZW5kZWQgdG8gdGhlIHN0cmluZy5cbiAqIEByZXR1cm5zIFdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzcyhwb3NzaWJsZUFkZHJlc3MsIHsgYWxsb3dOb25QcmVmaXhlZCA9IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgYWRkcmVzc1RvQ2hlY2sgPSBhbGxvd05vblByZWZpeGVkXG4gICAgICAgID8gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkocG9zc2libGVBZGRyZXNzKVxuICAgICAgICA6IHBvc3NpYmxlQWRkcmVzcztcbiAgICBpZiAoISgwLCBldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZykoYWRkcmVzc1RvQ2hlY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBldGhlcmV1bWpzX3V0aWxfMS5pc1ZhbGlkQWRkcmVzcykoYWRkcmVzc1RvQ2hlY2spO1xufVxuZXhwb3J0cy5pc1ZhbGlkSGV4QWRkcmVzcyA9IGlzVmFsaWRIZXhBZGRyZXNzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBUcmFuc2FjdGlvbiBvYmplY3QgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yLlxuICpcbiAqIEBwYXJhbSB0cmFuc2FjdGlvbiAtIFRyYW5zYWN0aW9uIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIGlmICghdHJhbnNhY3Rpb24uZnJvbSB8fFxuICAgICAgICB0eXBlb2YgdHJhbnNhY3Rpb24uZnJvbSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIWlzVmFsaWRIZXhBZGRyZXNzKHRyYW5zYWN0aW9uLmZyb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImZyb21cIiBhZGRyZXNzOiAke3RyYW5zYWN0aW9uLmZyb219IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICh0cmFuc2FjdGlvbi50byA9PT0gJzB4JyB8fCB0cmFuc2FjdGlvbi50byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5kYXRhKSB7XG4gICAgICAgICAgICBkZWxldGUgdHJhbnNhY3Rpb24udG87XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ0b1wiIGFkZHJlc3M6ICR7dHJhbnNhY3Rpb24udG99IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNhY3Rpb24udG8gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAhaXNWYWxpZEhleEFkZHJlc3ModHJhbnNhY3Rpb24udG8pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInRvXCIgYWRkcmVzczogJHt0cmFuc2FjdGlvbi50b30gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKHRyYW5zYWN0aW9uLnZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0cmFuc2FjdGlvbi52YWx1ZS50b1N0cmluZygpO1xuICAgICAgICBpZiAodmFsdWUuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFwidmFsdWVcIjogJHt2YWx1ZX0gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyLmApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnLicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJ2YWx1ZVwiOiAke3ZhbHVlfSBudW1iZXIgbXVzdCBiZSBkZW5vbWluYXRlZCBpbiB3ZWkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW50VmFsdWUgPSBwYXJzZUludCh0cmFuc2FjdGlvbi52YWx1ZSwgMTApO1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gTnVtYmVyLmlzRmluaXRlKGludFZhbHVlKSAmJlxuICAgICAgICAgICAgIU51bWJlci5pc05hTihpbnRWYWx1ZSkgJiZcbiAgICAgICAgICAgICFpc05hTihOdW1iZXIodmFsdWUpKSAmJlxuICAgICAgICAgICAgTnVtYmVyLmlzU2FmZUludGVnZXIoaW50VmFsdWUpO1xuICAgICAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcInZhbHVlXCI6ICR7dmFsdWV9IG51bWJlciBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyLmApO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVRyYW5zYWN0aW9uID0gdmFsaWRhdGVUcmFuc2FjdGlvbjtcbi8qKlxuICogQSBoZWxwZXIgZnVuY3Rpb24gdGhhdCBjb252ZXJ0cyByYXdtZXNzYWdlRGF0YSBidWZmZXIgZGF0YSB0byBhIGhleCwgb3IganVzdCByZXR1cm5zIHRoZSBkYXRhIGlmXG4gKiBpdCBpcyBhbHJlYWR5IGZvcm1hdHRlZCBhcyBhIGhleC5cbiAqXG4gKiBAcGFyYW0gZGF0YSAtIFRoZSBidWZmZXIgZGF0YSB0byBjb252ZXJ0IHRvIGEgaGV4LlxuICogQHJldHVybnMgQSBoZXggc3RyaW5nIGNvbnZlcnNpb24gb2YgdGhlIGJ1ZmZlciBkYXRhLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVNZXNzYWdlRGF0YShkYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3RyaXBwZWQgPSAoMCwgZXRoZXJldW1qc191dGlsXzEuc3RyaXBIZXhQcmVmaXgpKGRhdGEpO1xuICAgICAgICBpZiAoc3RyaXBwZWQubWF0Y2goaGV4UmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGV0aGVyZXVtanNfdXRpbF8xLmFkZEhleFByZWZpeCkoc3RyaXBwZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgfVxuICAgIHJldHVybiAoMCwgZXRoZXJldW1qc191dGlsXzEuYnVmZmVyVG9IZXgpKEJ1ZmZlci5mcm9tKGRhdGEsICd1dGY4JykpO1xufVxuZXhwb3J0cy5ub3JtYWxpemVNZXNzYWdlRGF0YSA9IG5vcm1hbGl6ZU1lc3NhZ2VEYXRhO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBQZXJzb25hbE1lc3NhZ2VQYXJhbXMgYW5kIE1lc3NhZ2VQYXJhbXMgb2JqZWN0cyBmb3IgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgdGhyb3dzIGluXG4gKiB0aGUgZXZlbnQgb2YgYW55IHZhbGlkYXRpb24gZXJyb3IuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2VEYXRhIC0gUGVyc29uYWxNZXNzYWdlUGFyYW1zIG9iamVjdCB0byB2YWxpZGF0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTaWduTWVzc2FnZURhdGEobWVzc2FnZURhdGEpIHtcbiAgICBjb25zdCB7IGZyb20sIGRhdGEgfSA9IG1lc3NhZ2VEYXRhO1xuICAgIGlmICghZnJvbSB8fCB0eXBlb2YgZnJvbSAhPT0gJ3N0cmluZycgfHwgIWlzVmFsaWRIZXhBZGRyZXNzKGZyb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImZyb21cIiBhZGRyZXNzOiAke2Zyb219IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICghZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgXCJkYXRhXCI6ICR7ZGF0YX0gbXVzdCBiZSBhIHZhbGlkIHN0cmluZy5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlU2lnbk1lc3NhZ2VEYXRhID0gdmFsaWRhdGVTaWduTWVzc2FnZURhdGE7XG4vKipcbiAqIFZhbGlkYXRlcyBhIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgZm9yIHJlcXVpcmVkIHByb3BlcnRpZXMgYW5kIHRocm93cyBpblxuICogdGhlIGV2ZW50IG9mIGFueSB2YWxpZGF0aW9uIGVycm9yIGZvciBldGhfc2lnblR5cGVkTWVzc2FnZV9WMS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZURhdGEgLSBUeXBlZE1lc3NhZ2VQYXJhbXMgb2JqZWN0IHRvIHZhbGlkYXRlLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVkU2lnbk1lc3NhZ2VEYXRhVjEobWVzc2FnZURhdGEpIHtcbiAgICBpZiAoIW1lc3NhZ2VEYXRhLmZyb20gfHxcbiAgICAgICAgdHlwZW9mIG1lc3NhZ2VEYXRhLmZyb20gIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFpc1ZhbGlkSGV4QWRkcmVzcyhtZXNzYWdlRGF0YS5mcm9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgXCJmcm9tXCIgYWRkcmVzczogJHttZXNzYWdlRGF0YS5mcm9tfSBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nLmApO1xuICAgIH1cbiAgICBpZiAoIW1lc3NhZ2VEYXRhLmRhdGEgfHwgIUFycmF5LmlzQXJyYXkobWVzc2FnZURhdGEuZGF0YSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgXCJkYXRhXCI6ICR7bWVzc2FnZURhdGEuZGF0YX0gbXVzdCBiZSBhIHZhbGlkIGFycmF5LmApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB0eXBlZFNpZ25hdHVyZUhhc2ggd2lsbCB0aHJvdyBpZiB0aGUgZGF0YSBpcyBpbnZhbGlkLlxuICAgICAgICAoMCwgZXRoX3NpZ191dGlsXzEudHlwZWRTaWduYXR1cmVIYXNoKShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBFSVA3MTIgdHlwZWQgZGF0YS5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMSA9IHZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMTtcbi8qKlxuICogVmFsaWRhdGVzIGEgVHlwZWRNZXNzYWdlUGFyYW1zIG9iamVjdCBmb3IgcmVxdWlyZWQgcHJvcGVydGllcyBhbmQgdGhyb3dzIGluXG4gKiB0aGUgZXZlbnQgb2YgYW55IHZhbGlkYXRpb24gZXJyb3IgZm9yIGV0aF9zaWduVHlwZWRNZXNzYWdlX1YzLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlRGF0YSAtIFR5cGVkTWVzc2FnZVBhcmFtcyBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZWRTaWduTWVzc2FnZURhdGFWMyhtZXNzYWdlRGF0YSkge1xuICAgIGlmICghbWVzc2FnZURhdGEuZnJvbSB8fFxuICAgICAgICB0eXBlb2YgbWVzc2FnZURhdGEuZnJvbSAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIWlzVmFsaWRIZXhBZGRyZXNzKG1lc3NhZ2VEYXRhLmZyb20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcImZyb21cIiBhZGRyZXNzOiAke21lc3NhZ2VEYXRhLmZyb219IG11c3QgYmUgYSB2YWxpZCBzdHJpbmcuYCk7XG4gICAgfVxuICAgIGlmICghbWVzc2FnZURhdGEuZGF0YSB8fCB0eXBlb2YgbWVzc2FnZURhdGEuZGF0YSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG1lc3NhZ2UgXCJkYXRhXCI6ICR7bWVzc2FnZURhdGEuZGF0YX0gbXVzdCBiZSBhIHZhbGlkIGFycmF5LmApO1xuICAgIH1cbiAgICBsZXQgZGF0YTtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShtZXNzYWdlRGF0YS5kYXRhKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgYmUgcGFzc2VkIGFzIGEgdmFsaWQgSlNPTiBzdHJpbmcuJyk7XG4gICAgfVxuICAgIGNvbnN0IHZhbGlkYXRpb24gPSAoMCwganNvbnNjaGVtYV8xLnZhbGlkYXRlKShkYXRhLCBldGhfc2lnX3V0aWxfMS5UWVBFRF9NRVNTQUdFX1NDSEVNQSk7XG4gICAgaWYgKHZhbGlkYXRpb24uZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIG11c3QgY29uZm9ybSB0byBFSVAtNzEyIHNjaGVtYS4gU2VlIGh0dHBzOi8vZ2l0LmlvL2ZOdGN4LicpO1xuICAgIH1cbn1cbmV4cG9ydHMudmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzID0gdmFsaWRhdGVUeXBlZFNpZ25NZXNzYWdlRGF0YVYzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgYSBFUkMyMCB0b2tlbiB0byBiZSBhZGRlZCB3aXRoIEVJUDc0Ny5cbiAqXG4gKiBAcGFyYW0gdG9rZW4gLSBUb2tlbiBvYmplY3QgdG8gdmFsaWRhdGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5Ub1dhdGNoKHRva2VuKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBzeW1ib2wsIGRlY2ltYWxzIH0gPSB0b2tlbjtcbiAgICBpZiAoIWFkZHJlc3MgfHwgIXN5bWJvbCB8fCB0eXBlb2YgZGVjaW1hbHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IGV0aF9ycGNfZXJyb3JzXzEuZXRoRXJyb3JzLnJwYy5pbnZhbGlkUGFyYW1zKGBNdXN0IHNwZWNpZnkgYWRkcmVzcywgc3ltYm9sLCBhbmQgZGVjaW1hbHMuYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3ltYm9sICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBzeW1ib2w6IG5vdCBhIHN0cmluZy5gKTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC5sZW5ndGggPiAxMSkge1xuICAgICAgICB0aHJvdyBldGhfcnBjX2Vycm9yc18xLmV0aEVycm9ycy5ycGMuaW52YWxpZFBhcmFtcyhgSW52YWxpZCBzeW1ib2wgXCIke3N5bWJvbH1cIjogbG9uZ2VyIHRoYW4gMTEgY2hhcmFjdGVycy5gKTtcbiAgICB9XG4gICAgY29uc3QgbnVtRGVjaW1hbHMgPSBwYXJzZUludChkZWNpbWFscywgMTApO1xuICAgIGlmIChpc05hTihudW1EZWNpbWFscykgfHwgbnVtRGVjaW1hbHMgPiAzNiB8fCBudW1EZWNpbWFscyA8IDApIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgZGVjaW1hbHMgXCIke2RlY2ltYWxzfVwiOiBtdXN0IGJlIDAgPD0gMzYuYCk7XG4gICAgfVxuICAgIGlmICghaXNWYWxpZEhleEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgdGhyb3cgZXRoX3JwY19lcnJvcnNfMS5ldGhFcnJvcnMucnBjLmludmFsaWRQYXJhbXMoYEludmFsaWQgYWRkcmVzcyBcIiR7YWRkcmVzc31cIi5gKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVG9rZW5Ub1dhdGNoID0gdmFsaWRhdGVUb2tlblRvV2F0Y2g7XG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBjb3JyZXNwb25kcyB0byBhIHNtYXJ0IGNvbnRyYWN0LlxuICpcbiAqIEBwYXJhbSBjb2RlIC0gVGhlIHBvdGVudGlhbCBzbWFydCBjb250cmFjdCBjb2RlLlxuICogQHJldHVybnMgV2hldGhlciB0aGUgY29kZSB3YXMgc21hcnQgY29udHJhY3QgY29kZSBvciBub3QuXG4gKi9cbmZ1bmN0aW9uIGlzU21hcnRDb250cmFjdENvZGUoY29kZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY29kZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEdldGggd2lsbCByZXR1cm4gJzB4JywgYW5kIGdhbmFjaGUtY29yZSB2Mi4yLjEgd2lsbCByZXR1cm4gJzB4MCdcbiAgICBjb25zdCBzbWFydENvbnRyYWN0Q29kZSA9IGNvZGUgIT09ICcweCcgJiYgY29kZSAhPT0gJzB4MCc7XG4gICAgcmV0dXJuIHNtYXJ0Q29udHJhY3RDb2RlO1xufVxuZXhwb3J0cy5pc1NtYXJ0Q29udHJhY3RDb2RlID0gaXNTbWFydENvbnRyYWN0Q29kZTtcbi8qKlxuICogRXhlY3V0ZSBmZXRjaCBhbmQgdmVyaWZ5IHRoYXQgdGhlIHJlc3BvbnNlIHdhcyBzdWNjZXNzZnVsLlxuICpcbiAqIEBwYXJhbSByZXF1ZXN0IC0gUmVxdWVzdCBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSBvcHRpb25zIC0gRmV0Y2ggb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBmZXRjaCByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc3VjY2Vzc2Z1bEZldGNoKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHJlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZldGNoIGZhaWxlZCB3aXRoIHN0YXR1cyAnJHtyZXNwb25zZS5zdGF0dXN9JyBmb3IgcmVxdWVzdCAnJHtyZXF1ZXN0fSdgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5leHBvcnRzLnN1Y2Nlc3NmdWxGZXRjaCA9IHN1Y2Nlc3NmdWxGZXRjaDtcbi8qKlxuICogRXhlY3V0ZSBmZXRjaCBhbmQgcmV0dXJuIG9iamVjdCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIFRoZSByZXF1ZXN0IGluZm9ybWF0aW9uLlxuICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgZmV0Y2ggb3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBmZXRjaCByZXNwb25zZSBKU09OIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZUZldGNoKHJlcXVlc3QsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHN1Y2Nlc3NmdWxGZXRjaChyZXF1ZXN0LCBvcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0geWllbGQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xufVxuZXhwb3J0cy5oYW5kbGVGZXRjaCA9IGhhbmRsZUZldGNoO1xuLyoqXG4gKiBFeGVjdXRlIGZldGNoIGFuZCByZXR1cm4gb2JqZWN0IHJlc3BvbnNlLCBsb2cgaWYga25vd24gZXJyb3IgdGhyb3duLCBvdGhlcndpc2UgcmV0aHJvdyBlcnJvci5cbiAqXG4gKiBAcGFyYW0gcmVxdWVzdCAtIHRoZSByZXF1ZXN0IG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0gcmVxdWVzdC51cmwgLSBUaGUgcmVxdWVzdCB1cmwgdG8gcXVlcnkuXG4gKiBAcGFyYW0gcmVxdWVzdC5vcHRpb25zIC0gVGhlIGZldGNoIG9wdGlvbnMuXG4gKiBAcGFyYW0gcmVxdWVzdC50aW1lb3V0IC0gVGltZW91dCB0byBmYWlsIHJlcXVlc3RcbiAqIEBwYXJhbSByZXF1ZXN0LmVycm9yQ29kZXNUb0NhdGNoIC0gYXJyYXkgb2YgZXJyb3IgY29kZXMgZm9yIGVycm9ycyB3ZSB3YW50IHRvIGNhdGNoIGluIGEgcGFydGljdWxhciBjb250ZXh0XG4gKiBAcmV0dXJucyBUaGUgZmV0Y2ggcmVzcG9uc2UgSlNPTiBkYXRhIG9yIHVuZGVmaW5lZCAoaWYgZXJyb3Igb2NjdXJzKS5cbiAqL1xuZnVuY3Rpb24gZmV0Y2hXaXRoRXJyb3JIYW5kbGluZyh7IHVybCwgb3B0aW9ucywgdGltZW91dCwgZXJyb3JDb2Rlc1RvQ2F0Y2gsIH0pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBoYW5kbGVGZXRjaCh1cmwsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZSgoXywgcmVqZWN0KSA9PiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChUSU1FT1VUX0VSUk9SKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCkpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0geWllbGQgaGFuZGxlRmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nT3JSZXRocm93RXJyb3IoZSwgZXJyb3JDb2Rlc1RvQ2F0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG59XG5leHBvcnRzLmZldGNoV2l0aEVycm9ySGFuZGxpbmcgPSBmZXRjaFdpdGhFcnJvckhhbmRsaW5nO1xuLyoqXG4gKiBGZXRjaCB0aGF0IGZhaWxzIGFmdGVyIHRpbWVvdXQuXG4gKlxuICogQHBhcmFtIHVybCAtIFVybCB0byBmZXRjaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZW5kIHdpdGggdGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0gdGltZW91dCAtIFRpbWVvdXQgdG8gZmFpbCByZXF1ZXN0LlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdGhlIHJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIHRpbWVvdXRGZXRjaCh1cmwsIG9wdGlvbnMsIHRpbWVvdXQgPSA1MDApIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWxGZXRjaCh1cmwsIG9wdGlvbnMpLFxuICAgICAgICAgICAgbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KFRJTUVPVVRfRVJST1IpO1xuICAgICAgICAgICAgfSwgdGltZW91dCkpLFxuICAgICAgICBdKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudGltZW91dEZldGNoID0gdGltZW91dEZldGNoO1xuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBFTlMgbmFtZS5cbiAqXG4gKiBAcGFyYW0gZW5zTmFtZSAtIFRoZSBFTlMgbmFtZS5cbiAqIEByZXR1cm5zIFRoZSBub3JtYWxpemVkIEVOUyBuYW1lIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplRW5zTmFtZShlbnNOYW1lKSB7XG4gICAgaWYgKGVuc05hbWUgJiYgdHlwZW9mIGVuc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBub3JtYWxpemVkID0gZXRoX2Vuc19uYW1laGFzaF8xLmRlZmF1bHQubm9ybWFsaXplKGVuc05hbWUudHJpbSgpKTtcbiAgICAgICAgICAgIC8vIHRoaXMgcmVnZXggaXMgb25seSBzdWZmaWNpZW50IHdpdGggdGhlIGFib3ZlIGNhbGwgdG8gZW5zTmFtZWhhc2gubm9ybWFsaXplXG4gICAgICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgNyBpbiByZWdleCB0byAzIHdoZW4gc2hvcnRlciBFTlMgZG9tYWlucyBhcmUgbGl2ZVxuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWQubWF0Y2goL14oKFtcXHdcXGQtXSspXFwuKSpbXFx3XFxkLV17Nyx9XFwuKGV0aHx0ZXN0KSQvdSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5ub3JtYWxpemVFbnNOYW1lID0gbm9ybWFsaXplRW5zTmFtZTtcbi8qKlxuICogV3JhcHBlciBtZXRob2QgdG8gaGFuZGxlIEV0aFF1ZXJ5IHJlcXVlc3RzLlxuICpcbiAqIEBwYXJhbSBldGhRdWVyeSAtIEV0aFF1ZXJ5IG9iamVjdCBpbml0aWFsaXplZCB3aXRoIGEgcHJvdmlkZXIuXG4gKiBAcGFyYW0gbWV0aG9kIC0gTWV0aG9kIHRvIHJlcXVlc3QuXG4gKiBAcGFyYW0gYXJncyAtIEFyZ3VtZW50cyB0byBzZW5kLlxuICogQHJldHVybnMgUHJvbWlzZSByZXNvbHZpbmcgdGhlIHJlcXVlc3QuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5KGV0aFF1ZXJ5LCBtZXRob2QsIGFyZ3MgPSBbXSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGNiID0gKGVycm9yLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGV0aFF1ZXJ5W21ldGhvZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGV0aFF1ZXJ5W21ldGhvZF0oLi4uYXJncywgY2IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXRoUXVlcnkuc2VuZEFzeW5jKHsgbWV0aG9kLCBwYXJhbXM6IGFyZ3MgfSwgY2IpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnF1ZXJ5ID0gcXVlcnk7XG4vKipcbiAqIENoZWNrcyBpZiBhIHRyYW5zYWN0aW9uIGlzIEVJUC0xNTU5IGJ5IGNoZWNraW5nIGZvciB0aGUgZXhpc3RlbmNlIG9mXG4gKiBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIHdpdGhpbiBpdHMgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb24gLSBUcmFuc2FjdGlvbiBvYmplY3QgdG8gYWRkLlxuICogQHJldHVybnMgQm9vbGVhbiB0aGF0IGlzIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGlzIEVJUC0xNTU5IChoYXMgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxuICovXG5jb25zdCBpc0VJUDE1NTlUcmFuc2FjdGlvbiA9ICh0cmFuc2FjdGlvbikgPT4ge1xuICAgIGNvbnN0IGhhc093blByb3AgPSAob2JqLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgcmV0dXJuIChoYXNPd25Qcm9wKHRyYW5zYWN0aW9uLCAnbWF4RmVlUGVyR2FzJykgJiZcbiAgICAgICAgaGFzT3duUHJvcCh0cmFuc2FjdGlvbiwgJ21heFByaW9yaXR5RmVlUGVyR2FzJykpO1xufTtcbmV4cG9ydHMuaXNFSVAxNTU5VHJhbnNhY3Rpb24gPSBpc0VJUDE1NTlUcmFuc2FjdGlvbjtcbi8qKlxuICogQ29udmVydHMgdmFsaWQgaGV4IHN0cmluZ3MgdG8gZGVjaW1hbCBudW1iZXJzLCBhbmQgaGFuZGxlcyB1bmV4cGVjdGVkIGFyZyB0eXBlcy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBhIHN0cmluZyB0aGF0IGlzIGVpdGhlciBhIGhleGFkZWNpbWFsIHdpdGggYDB4YCBwcmVmaXggb3IgYSBkZWNpbWFsIHN0cmluZy5cbiAqIEByZXR1cm5zIGEgZGVjaW1hbCBudW1iZXIuXG4gKi9cbmNvbnN0IGNvbnZlcnRIZXhUb0RlY2ltYWwgPSAodmFsdWUgPSAnMHgwJykgPT4ge1xuICAgIGlmICgoMCwgZXRoZXJldW1qc191dGlsXzEuaXNIZXhTdHJpbmcpKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPyBOdW1iZXIodmFsdWUpIDogMDtcbn07XG5leHBvcnRzLmNvbnZlcnRIZXhUb0RlY2ltYWwgPSBjb252ZXJ0SGV4VG9EZWNpbWFsO1xuY29uc3QgZ2V0SW5jcmVhc2VkUHJpY2VIZXggPSAodmFsdWUsIHJhdGUpID0+ICgwLCBldGhlcmV1bWpzX3V0aWxfMS5hZGRIZXhQcmVmaXgpKGAke3BhcnNlSW50KGAke3ZhbHVlICogcmF0ZX1gLCAxMCkudG9TdHJpbmcoMTYpfWApO1xuZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUhleCA9IGdldEluY3JlYXNlZFByaWNlSGV4O1xuY29uc3QgZ2V0SW5jcmVhc2VkUHJpY2VGcm9tRXhpc3RpbmcgPSAodmFsdWUsIHJhdGUpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0SW5jcmVhc2VkUHJpY2VIZXgpKCgwLCBleHBvcnRzLmNvbnZlcnRIZXhUb0RlY2ltYWwpKHZhbHVlKSwgcmF0ZSk7XG59O1xuZXhwb3J0cy5nZXRJbmNyZWFzZWRQcmljZUZyb21FeGlzdGluZyA9IGdldEluY3JlYXNlZFByaWNlRnJvbUV4aXN0aW5nO1xuY29uc3QgdmFsaWRhdGVHYXNWYWx1ZXMgPSAoZ2FzVmFsdWVzKSA9PiB7XG4gICAgT2JqZWN0LmtleXMoZ2FzVmFsdWVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBnYXNWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgISgwLCBldGhlcmV1bWpzX3V0aWxfMS5pc0hleFN0cmluZykodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCBoZXggc3RyaW5nIGZvciAke2tleX0gYnV0IHJlY2VpdmVkOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy52YWxpZGF0ZUdhc1ZhbHVlcyA9IHZhbGlkYXRlR2FzVmFsdWVzO1xuY29uc3QgaXNGZWVNYXJrZXRFSVAxNTU5VmFsdWVzID0gKGdhc1ZhbHVlcykgPT4gKGdhc1ZhbHVlcyA9PT0gbnVsbCB8fCBnYXNWYWx1ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdhc1ZhbHVlcy5tYXhGZWVQZXJHYXMpICE9PSB1bmRlZmluZWQgfHxcbiAgICAoZ2FzVmFsdWVzID09PSBudWxsIHx8IGdhc1ZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2FzVmFsdWVzLm1heFByaW9yaXR5RmVlUGVyR2FzKSAhPT0gdW5kZWZpbmVkO1xuZXhwb3J0cy5pc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXMgPSBpc0ZlZU1hcmtldEVJUDE1NTlWYWx1ZXM7XG5jb25zdCBpc0dhc1ByaWNlVmFsdWUgPSAoZ2FzVmFsdWVzKSA9PiAoZ2FzVmFsdWVzID09PSBudWxsIHx8IGdhc1ZhbHVlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2FzVmFsdWVzLmdhc1ByaWNlKSAhPT0gdW5kZWZpbmVkO1xuZXhwb3J0cy5pc0dhc1ByaWNlVmFsdWUgPSBpc0dhc1ByaWNlVmFsdWU7XG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBwcm9wb3NlZCB2YWx1ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG1pbmltdW0gdmFsdWUuXG4gKlxuICogQHBhcmFtIHByb3Bvc2VkIC0gVGhlIHByb3Bvc2VkIHZhbHVlLlxuICogQHBhcmFtIG1pbiAtIFRoZSBtaW5pbXVtIHZhbHVlLlxuICogQHJldHVybnMgVGhlIHByb3Bvc2VkIHZhbHVlLlxuICogQHRocm93cyBXaWxsIHRocm93IGlmIHRoZSBwcm9wb3NlZCB2YWx1ZSBpcyB0b28gbG93LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1pbmltdW1JbmNyZWFzZShwcm9wb3NlZCwgbWluKSB7XG4gICAgY29uc3QgcHJvcG9zZWREZWNpbWFsID0gKDAsIGV4cG9ydHMuY29udmVydEhleFRvRGVjaW1hbCkocHJvcG9zZWQpO1xuICAgIGNvbnN0IG1pbkRlY2ltYWwgPSAoMCwgZXhwb3J0cy5jb252ZXJ0SGV4VG9EZWNpbWFsKShtaW4pO1xuICAgIGlmIChwcm9wb3NlZERlY2ltYWwgPj0gbWluRGVjaW1hbCkge1xuICAgICAgICByZXR1cm4gcHJvcG9zZWQ7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTXNnID0gYFRoZSBwcm9wb3NlZCB2YWx1ZTogJHtwcm9wb3NlZERlY2ltYWx9IHNob3VsZCBtZWV0IG9yIGV4Y2VlZCB0aGUgbWluaW11bSB2YWx1ZTogJHttaW5EZWNpbWFsfWA7XG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVNaW5pbXVtSW5jcmVhc2UgPSB2YWxpZGF0ZU1pbmltdW1JbmNyZWFzZTtcbi8qKlxuICogUmVtb3ZlcyBJUEZTIHByb3RvY29sIHByZWZpeCBmcm9tIGlucHV0IHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gaXBmc1VybCAtIEFuIElQRlMgdXJsIChlLmcuIGlwZnM6Ly97Y29udGVudCBpZH0pXG4gKiBAcmV0dXJucyBJUEZTIGNvbnRlbnQgaWRlbnRpZmllciBhbmQgKHBvc3NpYmx5KSBwYXRoIGluIGEgc3RyaW5nXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIHVybCBwYXNzZWQgaXMgbm90IElQRlMuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUlwZnNQcm90b2NvbFByZWZpeChpcGZzVXJsKSB7XG4gICAgaWYgKGlwZnNVcmwuc3RhcnRzV2l0aCgnaXBmczovL2lwZnMvJykpIHtcbiAgICAgICAgcmV0dXJuIGlwZnNVcmwucmVwbGFjZSgnaXBmczovL2lwZnMvJywgJycpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpcGZzVXJsLnN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSkge1xuICAgICAgICByZXR1cm4gaXBmc1VybC5yZXBsYWNlKCdpcGZzOi8vJywgJycpO1xuICAgIH1cbiAgICAvLyB0aGlzIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQgd2l0aCBub24taXBmcyB1cmxzIChpLmUuIHN0YXJ0c1dpdGgoJ2lwZnM6Ly8nKSA9PT0gdHJ1ZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RoaXMgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZCB3aXRoIG5vbiBpcGZzIHVybHMnKTtcbn1cbmV4cG9ydHMucmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4ID0gcmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4O1xuLyoqXG4gKiBFeHRyYWN0cyBjb250ZW50IGlkZW50aWZpZXIgYW5kIHBhdGggZnJvbSBhbiBpbnB1dCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIGlwZnNVcmwgLSBBbiBJUEZTIFVSTCBtaW51cyB0aGUgSVBGUyBwcm90b2NvbCBwcmVmaXhcbiAqIEByZXR1cm5zIElGUFMgY29udGVudCBpZGVudGlmaWVyIChjaWQpIGFuZCBzdWIgcGF0aCBhcyBzdHJpbmcuXG4gKiBAdGhyb3dzIFdpbGwgdGhyb3cgaWYgdGhlIHVybCBwYXNzZWQgaXMgbm90IGlwZnMuXG4gKi9cbmZ1bmN0aW9uIGdldElwZnNDSUR2MUFuZFBhdGgoaXBmc1VybCkge1xuICAgIGNvbnN0IHVybCA9IHJlbW92ZUlwZnNQcm90b2NvbFByZWZpeChpcGZzVXJsKTtcbiAgICAvLyBjaGVjayBpZiB0aGVyZSBpcyBhIHBhdGhcbiAgICAvLyAoQ0lEIGlzIGV2ZXJ5dGhpbmcgcHJlY2VkaW5nIGZpcnN0IGZvcndhcmQgc2xhc2gsIHBhdGggaXMgZXZlcnl0aGluZyBhZnRlcilcbiAgICBjb25zdCBpbmRleCA9IHVybC5pbmRleE9mKCcvJyk7XG4gICAgY29uc3QgY2lkID0gaW5kZXggIT09IC0xID8gdXJsLnN1YnN0cmluZygwLCBpbmRleCkgOiB1cmw7XG4gICAgY29uc3QgcGF0aCA9IGluZGV4ICE9PSAtMSA/IHVybC5zdWJzdHJpbmcoaW5kZXgpIDogdW5kZWZpbmVkO1xuICAgIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgdGhlIENJRCBpcyB2MSAoaHR0cHM6Ly9kb2NzLmlwZnMuaW8vY29uY2VwdHMvY29udGVudC1hZGRyZXNzaW5nLyNpZGVudGlmaWVyLWZvcm1hdHMpXG4gICAgLy8gYmVjYXVzZSBtb3N0IGNpZCB2MHMgYXBwZWFyIHRvIGJlIGluY29tcGF0aWJsZSB3aXRoIElQRlMgc3ViZG9tYWluc1xuICAgIHJldHVybiB7XG4gICAgICAgIGNpZDogY2lkXzEuQ0lELnBhcnNlKGNpZCkudG9WMSgpLnRvU3RyaW5nKCksXG4gICAgICAgIHBhdGgsXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0SXBmc0NJRHYxQW5kUGF0aCA9IGdldElwZnNDSUR2MUFuZFBhdGg7XG4vKipcbiAqIEFkZHMgVVJMIHByb3RvY29sIHByZWZpeCB0byBpbnB1dCBVUkwgc3RyaW5nIGlmIG1pc3NpbmcuXG4gKlxuICogQHBhcmFtIHVybFN0cmluZyAtIEFuIElQRlMgVVJMLlxuICogQHJldHVybnMgQSBVUkwgd2l0aCBhIGh0dHBzOi8vIHByZXBlbmRlZC5cbiAqL1xuZnVuY3Rpb24gYWRkVXJsUHJvdG9jb2xQcmVmaXgodXJsU3RyaW5nKSB7XG4gICAgaWYgKCF1cmxTdHJpbmcubWF0Y2goLyheaHR0cDpcXC9cXC8pfCheaHR0cHM6XFwvXFwvKS91KSkge1xuICAgICAgICByZXR1cm4gYGh0dHBzOi8vJHt1cmxTdHJpbmd9YDtcbiAgICB9XG4gICAgcmV0dXJuIHVybFN0cmluZztcbn1cbmV4cG9ydHMuYWRkVXJsUHJvdG9jb2xQcmVmaXggPSBhZGRVcmxQcm90b2NvbFByZWZpeDtcbi8qKlxuICogRm9ybWF0cyBVUkwgY29ycmVjdGx5IGZvciB1c2UgcmV0cmlldmluZyBhc3NldHMgaG9zdGVkIG9uIElQRlMuXG4gKlxuICogQHBhcmFtIGlwZnNHYXRld2F5IC0gVGhlIHVzZXJzIHByZWZlcnJlZCBJUEZTIGdhdGV3YXkgKGZ1bGwgVVJMIG9yIGp1c3QgaG9zdCkuXG4gKiBAcGFyYW0gaXBmc1VybCAtIFRoZSBJRlBTIFVSTCBwb2ludGVkIGF0IHRoZSBhc3NldC5cbiAqIEBwYXJhbSBzdWJkb21haW5TdXBwb3J0ZWQgLSBCb29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgVVJMIHNob3VsZCBiZSBmb3JtYXR0ZWQgd2l0aCBzdWJkb21haW5zIG9yIG5vdC5cbiAqIEByZXR1cm5zIEEgZm9ybWF0dGVkIFVSTCwgd2l0aCB0aGUgdXNlcidzIHByZWZlcnJlZCBJUEZTIGdhdGV3YXkgYW5kIGZvcm1hdCAoc3ViZG9tYWluIG9yIG5vdCksIHBvaW50aW5nIHRvIGFuIGFzc2V0IGhvc3RlZCBvbiBJUEZTLlxuICovXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRJcGZzVXJsKGlwZnNHYXRld2F5LCBpcGZzVXJsLCBzdWJkb21haW5TdXBwb3J0ZWQpIHtcbiAgICBjb25zdCB7IGhvc3QsIHByb3RvY29sLCBvcmlnaW4gfSA9IG5ldyBVUkwoYWRkVXJsUHJvdG9jb2xQcmVmaXgoaXBmc0dhdGV3YXkpKTtcbiAgICBpZiAoc3ViZG9tYWluU3VwcG9ydGVkKSB7XG4gICAgICAgIGNvbnN0IHsgY2lkLCBwYXRoIH0gPSBnZXRJcGZzQ0lEdjFBbmRQYXRoKGlwZnNVcmwpO1xuICAgICAgICByZXR1cm4gYCR7cHJvdG9jb2x9Ly8ke2NpZH0uaXBmcy4ke2hvc3R9JHtwYXRoICE9PSBudWxsICYmIHBhdGggIT09IHZvaWQgMCA/IHBhdGggOiAnJ31gO1xuICAgIH1cbiAgICBjb25zdCBjaWRBbmRQYXRoID0gcmVtb3ZlSXBmc1Byb3RvY29sUHJlZml4KGlwZnNVcmwpO1xuICAgIHJldHVybiBgJHtvcmlnaW59L2lwZnMvJHtjaWRBbmRQYXRofWA7XG59XG5leHBvcnRzLmdldEZvcm1hdHRlZElwZnNVcmwgPSBnZXRGb3JtYXR0ZWRJcGZzVXJsO1xuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSB2YWx1ZSBpcyBhIFwicGxhaW5cIiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gQSB2YWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgcGFzc2VkIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbih2YWx1ZSkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5leHBvcnRzLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuY29uc3QgaGFzUHJvcGVydHkgPSAob2JqZWN0LCBrZXkpID0+IFJlZmxlY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG5leHBvcnRzLmhhc1Byb3BlcnR5ID0gaGFzUHJvcGVydHk7XG4vKipcbiAqIFR5cGUgZ3VhcmQgZm9yIHtAbGluayBOb25FbXB0eUFycmF5fS5cbiAqXG4gKiBAdGVtcGxhdGUgVCAtIFRoZSBub24tZW1wdHkgYXJyYXkgbWVtYmVyIHR5cGUuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyBXaGV0aGVyIHRoZSB2YWx1ZSBpcyBhIG5vbi1lbXB0eSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gaXNOb25FbXB0eUFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA+IDA7XG59XG5leHBvcnRzLmlzTm9uRW1wdHlBcnJheSA9IGlzTm9uRW1wdHlBcnJheTtcbi8qKlxuICogVHlwZSBndWFyZCBmb3Ige0BsaW5rIEpzb259LlxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIHZhbHVlIGlzIHZhbGlkIEpTT04uXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRKc29uKHZhbHVlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuICgwLCBmYXN0X2RlZXBfZXF1YWxfMS5kZWZhdWx0KSh2YWx1ZSwgSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpKTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNWYWxpZEpzb24gPSBpc1ZhbGlkSnNvbjtcbi8qKlxuICogTmV0d29ya3Mgd2hlcmUgdG9rZW4gZGV0ZWN0aW9uIGlzIHN1cHBvcnRlZCAtIFZhbHVlcyBhcmUgaW4gZGVjaW1hbCBmb3JtYXRcbiAqL1xudmFyIFN1cHBvcnRlZFRva2VuRGV0ZWN0aW9uTmV0d29ya3M7XG4oZnVuY3Rpb24gKFN1cHBvcnRlZFRva2VuRGV0ZWN0aW9uTmV0d29ya3MpIHtcbiAgICBTdXBwb3J0ZWRUb2tlbkRldGVjdGlvbk5ldHdvcmtzW1wibWFpbm5ldFwiXSA9IFwiMVwiO1xuICAgIFN1cHBvcnRlZFRva2VuRGV0ZWN0aW9uTmV0d29ya3NbXCJic2NcIl0gPSBcIjU2XCI7XG4gICAgU3VwcG9ydGVkVG9rZW5EZXRlY3Rpb25OZXR3b3Jrc1tcInBvbHlnb25cIl0gPSBcIjEzN1wiO1xuICAgIFN1cHBvcnRlZFRva2VuRGV0ZWN0aW9uTmV0d29ya3NbXCJhdmF4XCJdID0gXCI0MzExNFwiO1xufSkoU3VwcG9ydGVkVG9rZW5EZXRlY3Rpb25OZXR3b3JrcyA9IGV4cG9ydHMuU3VwcG9ydGVkVG9rZW5EZXRlY3Rpb25OZXR3b3JrcyB8fCAoZXhwb3J0cy5TdXBwb3J0ZWRUb2tlbkRldGVjdGlvbk5ldHdvcmtzID0ge30pKTtcbi8qKlxuICogQ2hlY2sgaWYgdG9rZW4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIGNlcnRhaW4gbmV0d29ya3MuXG4gKlxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbklEIG9mIG5ldHdvcmtcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGN1cnJlbnQgbmV0d29yayBzdXBwb3J0cyB0b2tlbiBkZXRlY3Rpb25cbiAqL1xuZnVuY3Rpb24gaXNUb2tlbkRldGVjdGlvblN1cHBvcnRlZEZvck5ldHdvcmsoY2hhaW5JZCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKFN1cHBvcnRlZFRva2VuRGV0ZWN0aW9uTmV0d29ya3MpLmluY2x1ZGVzKGNoYWluSWQpO1xufVxuZXhwb3J0cy5pc1Rva2VuRGV0ZWN0aW9uU3VwcG9ydGVkRm9yTmV0d29yayA9IGlzVG9rZW5EZXRlY3Rpb25TdXBwb3J0ZWRGb3JOZXR3b3JrO1xuLyoqXG4gKiBDaGVjayBpZiB0b2tlbiBsaXN0IHBvbGxpbmcgaXMgZW5hYmxlZCBmb3IgYSBnaXZlbiBuZXR3b3JrLlxuICogQ3VycmVudGx5IHRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc3VwcG9ydCBlMmUgdGVzdGluZyBmb3IgY29uc3VtZXJzIG9mIHRoaXMgcGFja2FnZS5cbiAqXG4gKiBAcGFyYW0gY2hhaW5JZCAtIENoYWluSUQgb2YgbmV0d29ya1xuICogQHJldHVybnMgV2hldGhlciB0aGUgY3VycmVudCBuZXR3b3JrIHN1cHBvcnRzIHRva2VubGlzdHNcbiAqL1xuZnVuY3Rpb24gaXNUb2tlbkxpc3RTdXBwb3J0ZWRGb3JOZXR3b3JrKGNoYWluSWQpIHtcbiAgICBjb25zdCBjaGFpbklkRGVjaW1hbCA9ICgwLCBleHBvcnRzLmNvbnZlcnRIZXhUb0RlY2ltYWwpKGNoYWluSWQpLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIChpc1Rva2VuRGV0ZWN0aW9uU3VwcG9ydGVkRm9yTmV0d29yayhjaGFpbklkRGVjaW1hbCkgfHxcbiAgICAgICAgY2hhaW5JZERlY2ltYWwgPT09IGNvbnN0YW50c18xLkdBTkFDSEVfQ0hBSU5fSUQpO1xufVxuZXhwb3J0cy5pc1Rva2VuTGlzdFN1cHBvcnRlZEZvck5ldHdvcmsgPSBpc1Rva2VuTGlzdFN1cHBvcnRlZEZvck5ldHdvcms7XG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGxvZyBpZiBlcnJvciBpcyBhIGNvbW1vbiBmZXRjaCBlcnJvciBhbmQgb3RoZXJ3aXNlIHJldGhyb3cgaXQuXG4gKlxuICogQHBhcmFtIGVycm9yIC0gQ2F1Z2h0IGVycm9yIHRoYXQgd2Ugc2hvdWxkIGVpdGhlciByZXRocm93IG9yIGxvZyB0byBjb25zb2xlXG4gKiBAcGFyYW0gY29kZXNUb0NhdGNoIC0gYXJyYXkgb2YgZXJyb3IgY29kZXMgZm9yIGVycm9ycyB3ZSB3YW50IHRvIGNhdGNoIGFuZCBsb2cgaW4gYSBwYXJ0aWN1bGFyIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gbG9nT3JSZXRocm93RXJyb3IoZXJyb3IsIGNvZGVzVG9DYXRjaCA9IFtdKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmNsdWRlc0Vycm9yQ29kZVRvQ2F0Y2ggPSBjb2Rlc1RvQ2F0Y2guc29tZSgoY29kZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBlcnJvci5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoYEZldGNoIGZhaWxlZCB3aXRoIHN0YXR1cyAnJHtjb2RlfSdgKTsgfSk7XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiZcbiAgICAgICAgKGluY2x1ZGVzRXJyb3JDb2RlVG9DYXRjaCB8fFxuICAgICAgICAgICAgKChfYSA9IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmNsdWRlcygnRmFpbGVkIHRvIGZldGNoJykpIHx8XG4gICAgICAgICAgICBlcnJvciA9PT0gVElNRU9VVF9FUlJPUikpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAifQ==
